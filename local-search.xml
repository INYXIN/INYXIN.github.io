<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>21.合并两个有序链表</title>
    <link href="/post/87f453c3-c442-4726-a077-dc248516c603/"/>
    <url>/post/87f453c3-c442-4726-a077-dc248516c603/</url>
    
    <content type="html"><![CDATA[<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(list1.val &lt; list2.val)&#123;<br>            list1.next = mergeTwoLists(list1.next,list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            list2.next = mergeTwoLists(list2.next,list1);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.盛最多水的容器</title>
    <link href="/post/0b95425c-86c8-43f6-bec0-8dc6fee1f81d/"/>
    <url>/post/0b95425c-86c8-43f6-bec0-8dc6fee1f81d/</url>
    
    <content type="html"><![CDATA[<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>已解答</p><p>中等</p><p>相关标签</p><p>相关企业</p><p>提示</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[left],height[right]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> right - left; <br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> w * h;<br>            maxArea = Math.max( area , maxArea );<br>            <span class="hljs-keyword">if</span>(height[left] &gt; height[right])&#123;<br>                right --;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>中等</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283.移动零</title>
    <link href="/post/b84f669b-c519-4d45-8c66-79b36535b924/"/>
    <url>/post/b84f669b-c519-4d45-8c66-79b36535b924/</url>
    
    <content type="html"><![CDATA[<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p><p>简单</p><p>相关标签</p><p>相关企业</p><p>提示</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java敏感词过滤</title>
    <link href="/post/3285f0d6-d3c2-459a-9463-117ce411ad8a/"/>
    <url>/post/3285f0d6-d3c2-459a-9463-117ce411ad8a/</url>
    
    <content type="html"><![CDATA[<h3 id="Java敏感词过滤"><a href="#Java敏感词过滤" class="headerlink" title="Java敏感词过滤"></a>Java敏感词过滤</h3><p><code>hexo template generate by typora plugin templater</code></p><p><a href="https://github.com/houbb/sensitive-word?tab=readme-ov-file">houbb&#x2F;sensitive-word: 👮‍♂️The sensitive word tool for java.(敏感词&#x2F;违禁词&#x2F;违法词&#x2F;脏词。基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。请勿发布涉及政治、广告、营销、翻墙、违反国家法律法规等内容。高性能敏感词检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。) (github.com)</a></p><h1 id="sensitive-word"><a href="#sensitive-word" class="headerlink" title="sensitive-word"></a>sensitive-word</h1><p><a href="https://github.com/houbb/sensitive-word">sensitive-word</a> 基于 DFA 算法实现的高性能敏感词工具。</p><blockquote><p><a href="https://houbb.github.io/opensource/sensitive-word">在线体验</a></p></blockquote><p>如果有一些疑难杂症，可以加入：<a href="https://mp.weixin.qq.com/s/rkSvXxiiLGjl3S-ZOZCr0Q">技术交流群</a></p><p><a href="https://github.com/houbb/sensitive-word-admin">sensitive-word-admin</a> 是对应的控台的应用，目前功能处于初期开发中，MVP 版本可用。</p><h2 id="创作目的"><a href="#创作目的" class="headerlink" title="创作目的"></a>创作目的</h2><p>实现一款好用敏感词工具。</p><p>基于 DFA 算法实现，目前敏感词库内容收录 6W+（源文件 18W+，经过一次删减）。</p><p>后期将进行持续优化和补充敏感词库，并进一步提升算法的性能。</p><p>希望可以细化敏感词的分类，感觉工作量比较大，暂时没有进行。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>6W+ 词库，且不断优化更新</li><li>基于 fluent-api 实现，使用优雅简洁</li><li><a href="https://github.com/houbb/sensitive-word#benchmark">基于 DFA 算法，性能为 7W+ QPS，应用无感</a></li><li><a href="https://github.com/houbb/sensitive-word#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">支持敏感词的判断、返回、脱敏等常见操作</a></li><li><a href="https://github.com/houbb/sensitive-word#%E6%9B%B4%E5%A4%9A%E7%89%B9%E6%80%A7">支持常见的格式转换</a></li></ul><p>全角半角互换、英文大小写互换、数字常见形式的互换、中文繁简体互换、英文常见形式的互换、忽略重复词等</p><ul><li><a href="https://github.com/houbb/sensitive-word#%E6%9B%B4%E5%A4%9A%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5">支持敏感词检测、邮箱检测、数字检测、网址检测、IPV4等</a></li><li><a href="https://github.com/houbb/sensitive-word#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5">支持自定义替换策略</a></li><li><a href="https://github.com/houbb/sensitive-word#%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8">支持用户自定义敏感词和白名单</a></li><li><a href="https://github.com/houbb/sensitive-word#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89">支持数据的数据动态更新（用户自定义），实时生效</a></li><li><a href="https://github.com/houbb/sensitive-word#%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A0%87%E7%AD%BE">支持敏感词的标签接口</a></li><li><a href="https://github.com/houbb/sensitive-word#%E5%BF%BD%E7%95%A5%E5%AD%97%E7%AC%A6">支持跳过一些特殊字符，让匹配更灵活</a></li></ul><h2 id="变更日志"><a href="#变更日志" class="headerlink" title="变更日志"></a>变更日志</h2><p><a href="https://github.com/houbb/sensitive-word/blob/master/CHANGE_LOG.md">CHANGE_LOG.md</a></p><h3 id="V0-17-0"><a href="#V0-17-0" class="headerlink" title="V0.17.0"></a>V0.17.0</h3><ul><li>支持 ipv4</li></ul><h3 id="V0-18-0"><a href="#V0-18-0" class="headerlink" title="V0.18.0"></a>V0.18.0</h3><ul><li>优化 URL 检测，降低误判率</li></ul><h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><h3 id="敏感词控台"><a href="#敏感词控台" class="headerlink" title="敏感词控台"></a>敏感词控台</h3><p>有时候敏感词有一个控台，配置起来会更加灵活方便。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rQo75cfMU_OEbTJa0JGMGg">java 如何实现开箱即用的敏感词控台服务？</a></p></blockquote><h3 id="敏感词标签文件"><a href="#敏感词标签文件" class="headerlink" title="敏感词标签文件"></a>敏感词标签文件</h3><p>梳理了大量的敏感词标签文件，可以让我们的敏感词更加方便。</p><p>这两个资料阅读可在下方文章获取：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/m40ZnR6YF6WgPrArUSZ_0g">v0.11.0-敏感词新特性及对应标签文件</a></p></blockquote><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>JDK1.8+</li><li>Maven 3.x+</li></ul><h2 id="Maven-引入"><a href="#Maven-引入" class="headerlink" title="Maven 引入"></a>Maven 引入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.houbb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sensitive-word<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.18.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p><code>SensitiveWordHelper</code> 作为敏感词的工具类，核心方法如下：</p><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>contains(String)</td><td>待验证的字符串</td><td>布尔值</td><td>验证字符串是否包含敏感词</td></tr><tr><td>replace(String, ISensitiveWordReplace)</td><td>使用指定的替换策略替换敏感词</td><td>字符串</td><td>返回脱敏后的字符串</td></tr><tr><td>replace(String, char)</td><td>使用指定的 char 替换敏感词</td><td>字符串</td><td>返回脱敏后的字符串</td></tr><tr><td>replace(String)</td><td>使用 <code>*</code> 替换敏感词</td><td>字符串</td><td>返回脱敏后的字符串</td></tr><tr><td>findAll(String)</td><td>待验证的字符串</td><td>字符串列表</td><td>返回字符串中所有敏感词</td></tr><tr><td>findFirst(String)</td><td>待验证的字符串</td><td>字符串</td><td>返回字符串中第一个敏感词</td></tr><tr><td>findAll(String, IWordResultHandler)</td><td>IWordResultHandler 结果处理类</td><td>字符串列表</td><td>返回字符串中所有敏感词</td></tr><tr><td>findFirst(String, IWordResultHandler)</td><td>IWordResultHandler 结果处理类</td><td>字符串</td><td>返回字符串中第一个敏感词</td></tr><tr><td>tags(String)</td><td>获取敏感词的标签</td><td>敏感词字符串</td><td>返回敏感词的标签列表</td></tr></tbody></table><h3 id="判断是否包含敏感词"><a href="#判断是否包含敏感词" class="headerlink" title="判断是否包含敏感词"></a>判断是否包含敏感词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br>Assert.assertTrue(SensitiveWordHelper.contains(text));<br></code></pre></td></tr></table></figure><h3 id="返回第一个敏感词"><a href="#返回第一个敏感词" class="headerlink" title="返回第一个敏感词"></a>返回第一个敏感词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> SensitiveWordHelper.findFirst(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;五星红旗&quot;</span>, word);<br></code></pre></td></tr></table></figure><p>SensitiveWordHelper.findFirst(text) 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> SensitiveWordHelper.findFirst(text, WordResultHandlers.word());<br></code></pre></td></tr></table></figure><h3 id="返回所有敏感词"><a href="#返回所有敏感词" class="headerlink" title="返回所有敏感词"></a>返回所有敏感词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordHelper.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[五星红旗, 毛主席, 天安门]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><p>返回所有敏感词用法上类似于 SensitiveWordHelper.findFirst()，同样也支持指定结果处理类。</p><p>SensitiveWordHelper.findAll(text) 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; wordList = SensitiveWordHelper.findAll(text, WordResultHandlers.word());<br></code></pre></td></tr></table></figure><p>WordResultHandlers.raw() 可以保留对应的下标信息、类别信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br><span class="hljs-comment">// 默认敏感词标签为空</span><br>List&lt;WordTagsDto&gt; wordList1 = SensitiveWordHelper.findAll(text, WordResultHandlers.wordTags());<br>Assert.assertEquals(<span class="hljs-string">&quot;[WordTagsDto&#123;word=&#x27;五星红旗&#x27;, tags=[]&#125;, WordTagsDto&#123;word=&#x27;毛主席&#x27;, tags=[]&#125;, WordTagsDto&#123;word=&#x27;天安门&#x27;, tags=[]&#125;]&quot;</span>, wordList1.toString());<br></code></pre></td></tr></table></figure><h3 id="默认的替换策略"><a href="#默认的替换策略" class="headerlink" title="默认的替换策略"></a>默认的替换策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> SensitiveWordHelper.replace(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;****迎风飘扬，***的画像屹立在***前。&quot;</span>, result);<br></code></pre></td></tr></table></figure><h3 id="指定替换的内容"><a href="#指定替换的内容" class="headerlink" title="指定替换的内容"></a>指定替换的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> SensitiveWordHelper.replace(text, <span class="hljs-string">&#x27;0&#x27;</span>);<br>Assert.assertEquals(<span class="hljs-string">&quot;0000迎风飘扬，000的画像屹立在000前。&quot;</span>, result);<br></code></pre></td></tr></table></figure><h3 id="自定义替换策略"><a href="#自定义替换策略" class="headerlink" title="自定义替换策略"></a>自定义替换策略</h3><p>V0.2.0 支持该特性。</p><p>场景说明：有时候我们希望不同的敏感词有不同的替换结果。比如【游戏】替换为【电子竞技】，【失业】替换为【灵活就业】。</p><p>诚然，提前使用字符串的正则替换也可以，不过性能一般。</p><p>使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定替换策略</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.2.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defineReplaceTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br>    <span class="hljs-type">ISensitiveWordReplace</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySensitiveWordReplace</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> SensitiveWordHelper.replace(text, replace);<br><br>    Assert.assertEquals(<span class="hljs-string">&quot;国家旗帜迎风飘扬，教员的画像屹立在***前。&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>MySensitiveWordReplace</code> 是我们自定义的替换策略，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWordReplace</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IWordReplace</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replace</span><span class="hljs-params">(StringBuilder stringBuilder, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] rawChars, IWordResult wordResult, IWordContext wordContext)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sensitiveWord</span> <span class="hljs-operator">=</span> InnerWordCharUtils.getString(rawChars, wordResult);<br>        <span class="hljs-comment">// 自定义不同的敏感词替换策略，可以从数据库等地方读取</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;五星红旗&quot;</span>.equals(sensitiveWord)) &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;国家旗帜&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;毛主席&quot;</span>.equals(sensitiveWord)) &#123;<br>            stringBuilder.append(<span class="hljs-string">&quot;教员&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他默认使用 * 代替</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wordLength</span> <span class="hljs-operator">=</span> wordResult.endIndex() - wordResult.startIndex();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wordLength; i++) &#123;<br>                stringBuilder.append(<span class="hljs-string">&#x27;*&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们针对其中的部分词做固定映射处理，其他的默认转换为 <code>*</code>。</p><h2 id="IWordResultHandler-结果处理类"><a href="#IWordResultHandler-结果处理类" class="headerlink" title="IWordResultHandler 结果处理类"></a>IWordResultHandler 结果处理类</h2><p>IWordResultHandler 可以对敏感词的结果进行处理，允许用户自定义。</p><p>内置实现见 <code>WordResultHandlers</code> 工具类：</p><ul><li>WordResultHandlers.word()</li></ul><p>只保留敏感词单词本身。</p><ul><li>WordResultHandlers.raw()</li></ul><p>保留敏感词相关信息，包含敏感词的开始和结束下标。</p><ul><li>WordResultHandlers.wordTags()</li></ul><p>同时保留单词，和对应的词标签信息。</p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>所有测试案例参见 <a href="https://github.com/houbb/sensitive-word/blob/master/src/test/java/com/github/houbb/sensitive/word/core/SensitiveWordHelperTest.java">SensitiveWordHelperTest</a></p><p>1）基本例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordHelper.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[五星红旗, 毛主席, 天安门]&quot;</span>, wordList.toString());<br>List&lt;String&gt; wordList2 = SensitiveWordHelper.findAll(text, WordResultHandlers.word());<br>Assert.assertEquals(<span class="hljs-string">&quot;[五星红旗, 毛主席, 天安门]&quot;</span>, wordList2.toString());<br><br>List&lt;IWordResult&gt; wordList3 = SensitiveWordHelper.findAll(text, WordResultHandlers.raw());<br>Assert.assertEquals(<span class="hljs-string">&quot;[WordResult&#123;startIndex=0, endIndex=4&#125;, WordResult&#123;startIndex=9, endIndex=12&#125;, WordResult&#123;startIndex=18, endIndex=21&#125;]&quot;</span>, wordList3.toString());<br></code></pre></td></tr></table></figure><ol><li>wordTags 例子</li></ol><p>我们在 <code>dict_tag_test.txt</code> 文件中指定对应词的标签信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br><br><span class="hljs-comment">// 默认敏感词标签为空</span><br>List&lt;WordTagsDto&gt; wordList1 = SensitiveWordHelper.findAll(text, WordResultHandlers.wordTags());<br>Assert.assertEquals(<span class="hljs-string">&quot;[WordTagsDto&#123;word=&#x27;五星红旗&#x27;, tags=[]&#125;, WordTagsDto&#123;word=&#x27;毛主席&#x27;, tags=[]&#125;, WordTagsDto&#123;word=&#x27;天安门&#x27;, tags=[]&#125;]&quot;</span>, wordList1.toString());<br><br>List&lt;WordTagsDto&gt; wordList2 = SensitiveWordBs.newInstance()<br>        .wordTag(WordTags.file(<span class="hljs-string">&quot;dict_tag_test.txt&quot;</span>))<br>        .init()<br>        .findAll(text, WordResultHandlers.wordTags());<br>Assert.assertEquals(<span class="hljs-string">&quot;[WordTagsDto&#123;word=&#x27;五星红旗&#x27;, tags=[政治, 国家]&#125;, WordTagsDto&#123;word=&#x27;毛主席&#x27;, tags=[政治, 伟人, 国家]&#125;, WordTagsDto&#123;word=&#x27;天安门&#x27;, tags=[政治, 国家, 地址]&#125;]&quot;</span>, wordList2.toString());<br></code></pre></td></tr></table></figure><h1 id="更多特性"><a href="#更多特性" class="headerlink" title="更多特性"></a>更多特性</h1><p>后续的诸多特性，主要是针对各种针对各种情况的处理，尽可能的提升敏感词命中率。</p><p>这是一场漫长的攻防之战。</p><h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fuCK the bad words.&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> SensitiveWordHelper.findFirst(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;fuCK&quot;</span>, word);<br></code></pre></td></tr></table></figure><h3 id="忽略半角圆角"><a href="#忽略半角圆角" class="headerlink" title="忽略半角圆角"></a>忽略半角圆角</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ｆｕｃｋ the bad words.&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> SensitiveWordHelper.findFirst(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;ｆｕｃｋ&quot;</span>, word);<br></code></pre></td></tr></table></figure><h3 id="忽略数字的写法"><a href="#忽略数字的写法" class="headerlink" title="忽略数字的写法"></a>忽略数字的写法</h3><p>这里实现了数字常见形式的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这个是我的微信：9⓿二肆⁹₈③⑸⒋➃㈤㊄&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance().enableNumCheck(<span class="hljs-literal">true</span>).init().findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[9⓿二肆⁹₈③⑸⒋➃㈤㊄]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h3 id="忽略繁简体"><a href="#忽略繁简体" class="headerlink" title="忽略繁简体"></a>忽略繁简体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;我爱我的祖国和五星紅旗。&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordHelper.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[五星紅旗]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h3 id="忽略英文的书写格式"><a href="#忽略英文的书写格式" class="headerlink" title="忽略英文的书写格式"></a>忽略英文的书写格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ⓕⓤc⒦ the bad words&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordHelper.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[Ⓕⓤc⒦]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h3 id="忽略重复词"><a href="#忽略重复词" class="headerlink" title="忽略重复词"></a>忽略重复词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ⒻⒻⒻfⓤuⓤ⒰cⓒ⒦ the bad words&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance()<br>        .ignoreRepeat(<span class="hljs-literal">true</span>)<br>        .init()<br>        .findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[ⒻⒻⒻfⓤuⓤ⒰cⓒ⒦]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h2 id="更多检测策略"><a href="#更多检测策略" class="headerlink" title="更多检测策略"></a>更多检测策略</h2><h3 id="邮箱检测"><a href="#邮箱检测" class="headerlink" title="邮箱检测"></a>邮箱检测</h3><p>邮箱等个人信息，默认未启用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;楼主好人，邮箱 sensitiveword@xx.com&quot;</span>;<br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance().enableEmailCheck(<span class="hljs-literal">true</span>).init().findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[sensitiveword@xx.com]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h3 id="连续数字检测"><a href="#连续数字检测" class="headerlink" title="连续数字检测"></a>连续数字检测</h3><p>一般用于过滤手机号&#x2F;QQ等广告信息，默认未启用。</p><p>V0.2.1 之后，支持通过 <code>numCheckLen(长度)</code> 自定义检测的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你懂得：12345678&quot;</span>;<br><br><span class="hljs-comment">// 默认检测 8 位</span><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance()<br>.enableNumCheck(<span class="hljs-literal">true</span>)<br>.init().findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[12345678]&quot;</span>, wordList.toString());<br><br><span class="hljs-comment">// 指定数字的长度，避免误杀</span><br>List&lt;String&gt; wordList2 = SensitiveWordBs.newInstance()<br>.enableNumCheck(<span class="hljs-literal">true</span>)<br>.numCheckLen(<span class="hljs-number">9</span>)<br>.init()<br>.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[]&quot;</span>, wordList2.toString());<br>```java<br><br><br><br>### 网址检测<br><br><br><br>用于过滤常见的网址信息，默认未启用。<br><br>v0<span class="hljs-number">.18</span><span class="hljs-number">.0</span> 优化 URL 检测，更加严格，降低误判率<br><br>```java<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;点击链接 https://www.baidu.com 查看答案&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">sensitiveWordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance().enableUrlCheck(<span class="hljs-literal">true</span>).init();<br>List&lt;String&gt; wordList = sensitiveWordBs.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[https://www.baidu.com]&quot;</span>, wordList.toString());<br>Assert.assertEquals(<span class="hljs-string">&quot;点击链接 ********************* 查看答案&quot;</span>, sensitiveWordBs.replace(text));<br></code></pre></td></tr></table></figure><h3 id="IPV4-检测"><a href="#IPV4-检测" class="headerlink" title="IPV4 检测"></a>IPV4 检测</h3><p>v0.17.0 支持</p><p>避免用户通过 ip 绕过网址检测等，默认未启用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;个人网站，如果网址打不开可以访问 127.0.0.1。&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">sensitiveWordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance().enableIpv4Check(<span class="hljs-literal">true</span>).init();<br>List&lt;String&gt; wordList = sensitiveWordBs.findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[127.0.0.1]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><h1 id="引导类特性配置"><a href="#引导类特性配置" class="headerlink" title="引导类特性配置"></a>引导类特性配置</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上面的特性默认都是开启的，有时业务需要灵活定义相关的配置特性。</p><p>所以 v0.0.14 开放了属性配置。</p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>为了让使用更加优雅，统一使用 fluent-api 的方式定义。</p><p>用户可以使用 <code>SensitiveWordBs</code> 进行如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">wordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>        .ignoreCase(<span class="hljs-literal">true</span>)<br>        .ignoreWidth(<span class="hljs-literal">true</span>)<br>        .ignoreNumStyle(<span class="hljs-literal">true</span>)<br>        .ignoreChineseStyle(<span class="hljs-literal">true</span>)<br>        .ignoreEnglishStyle(<span class="hljs-literal">true</span>)<br>        .ignoreRepeat(<span class="hljs-literal">false</span>)<br>        .enableNumCheck(<span class="hljs-literal">false</span>)<br>        .enableEmailCheck(<span class="hljs-literal">false</span>)<br>        .enableUrlCheck(<span class="hljs-literal">false</span>)<br>        .enableIpv4Check(<span class="hljs-literal">false</span>)<br>        .enableWordCheck(<span class="hljs-literal">true</span>)<br>        .numCheckLen(<span class="hljs-number">8</span>)<br>        .wordTag(WordTags.none())<br>        .charIgnore(SensitiveWordCharIgnores.defaults())<br>        .wordResultCondition(WordResultConditions.alwaysTrue())<br>        .init();<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br>Assert.assertTrue(wordBs.contains(text));<br></code></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p>其中各项配置的说明如下：</p><table><thead><tr><th>序号</th><th>方法</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>1</td><td>ignoreCase</td><td>忽略大小写</td><td>true</td></tr><tr><td>2</td><td>ignoreWidth</td><td>忽略半角圆角</td><td>true</td></tr><tr><td>3</td><td>ignoreNumStyle</td><td>忽略数字的写法</td><td>true</td></tr><tr><td>4</td><td>ignoreChineseStyle</td><td>忽略中文的书写格式</td><td>true</td></tr><tr><td>5</td><td>ignoreEnglishStyle</td><td>忽略英文的书写格式</td><td>true</td></tr><tr><td>6</td><td>ignoreRepeat</td><td>忽略重复词</td><td>false</td></tr><tr><td>7</td><td>enableNumCheck</td><td>是否启用数字检测。</td><td>false</td></tr><tr><td>8</td><td>enableEmailCheck</td><td>是有启用邮箱检测</td><td>false</td></tr><tr><td>9</td><td>enableUrlCheck</td><td>是否启用链接检测</td><td>false</td></tr><tr><td>10</td><td>enableIpv4Check</td><td>是否启用IPv4检测</td><td>false</td></tr><tr><td>11</td><td>enableWordCheck</td><td>是否启用敏感单词检测</td><td>true</td></tr><tr><td>12</td><td>numCheckLen</td><td>数字检测，自定义指定长度。</td><td>8</td></tr><tr><td>13</td><td>wordTag</td><td>词对应的标签</td><td>none</td></tr><tr><td>14</td><td>charIgnore</td><td>忽略的字符</td><td>none</td></tr><tr><td>15</td><td>wordResultCondition</td><td>针对匹配的敏感词额外加工，比如可以限制英文单词必须全匹配</td><td>恒为真</td></tr></tbody></table><h2 id="内存资源的释放"><a href="#内存资源的释放" class="headerlink" title="内存资源的释放"></a>内存资源的释放</h2><p>v0.16.1 开始支持，有时候我们需要释放内存，可以如下：</p><blockquote><p><a href="https://github.com/houbb/sensitive-word/issues/53">关于内存回收问题</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">wordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>                .init();<br><span class="hljs-comment">// 后续因为一些原因移除了对应信息，希望释放内存。</span><br>wordBs.destroy();<br></code></pre></td></tr></table></figure><h1 id="wordResultCondition-针对匹配词进一步判断"><a href="#wordResultCondition-针对匹配词进一步判断" class="headerlink" title="wordResultCondition-针对匹配词进一步判断"></a>wordResultCondition-针对匹配词进一步判断</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>支持版本：v0.13.0</p><p>有时候我们可能希望对匹配的敏感词进一步限制，比如虽然我们定义了【av】作为敏感词，但是不希望【have】被匹配。</p><p>就可以自定义实现 wordResultCondition 接口，实现自己的策略。</p><p>系统内置的策略在 <code>WordResultConditions#alwaysTrue()</code> 恒为真，<code>WordResultConditions#englishWordMatch()</code> 则要求英文必须全词匹配。</p><h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><p>原始的默认情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I have a nice day。&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance()<br>        .wordDeny(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IWordDeny</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">deny</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-string">&quot;av&quot;</span>);<br>            &#125;<br>        &#125;)<br>        .wordResultCondition(WordResultConditions.alwaysTrue())<br>        .init()<br>        .findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[av]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><p>我们可以指定为英文必须全词匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I have a nice day。&quot;</span>;<br><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance()<br>        .wordDeny(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IWordDeny</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">deny</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-string">&quot;av&quot;</span>);<br>            &#125;<br>        &#125;)<br>        .wordResultCondition(WordResultConditions.englishWordMatch())<br>        .init()<br>        .findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[]&quot;</span>, wordList.toString());<br></code></pre></td></tr></table></figure><p>当然可以根据需要实现更加复杂的策略。</p><h1 id="忽略字符"><a href="#忽略字符" class="headerlink" title="忽略字符"></a>忽略字符</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>我们的敏感词一般都是比较连续的，比如【傻帽】</p><p>那就有大聪明发现，可以在中间加一些字符，比如【傻!@#$帽】跳过检测，但是骂人等攻击力不减。</p><p>那么，如何应对这些类似的场景呢？</p><p>我们可以指定特殊字符的跳过集合，忽略掉这些无意义的字符即可。</p><p>v0.11.0 开始支持</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>其中 charIgnore 对应的字符策略，用户可以自行灵活定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;傻@冒，狗+东西&quot;</span>;<br><br><span class="hljs-comment">//默认因为有特殊字符分割，无法识别</span><br>List&lt;String&gt; wordList = SensitiveWordBs.newInstance().init().findAll(text);<br>Assert.assertEquals(<span class="hljs-string">&quot;[]&quot;</span>, wordList.toString());<br><br><span class="hljs-comment">// 指定忽略的字符策略，可自行实现。</span><br>List&lt;String&gt; wordList2 = SensitiveWordBs.newInstance()<br>        .charIgnore(SensitiveWordCharIgnores.specialChars())<br>        .init()<br>        .findAll(text);<br><br>Assert.assertEquals(<span class="hljs-string">&quot;[傻@冒, 狗+东西]&quot;</span>, wordList2.toString());<br></code></pre></td></tr></table></figure><h1 id="敏感词标签"><a href="#敏感词标签" class="headerlink" title="敏感词标签"></a>敏感词标签</h1><h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><p>有时候我们希望对敏感词加一个分类标签：比如社情、暴&#x2F;力等等。</p><p>这样后续可以按照标签等进行更多特性操作，比如只处理某一类的标签。</p><p>支持版本：v0.10.0</p><h2 id="入门例子-1"><a href="#入门例子-1" class="headerlink" title="入门例子"></a>入门例子</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>这里只是一个抽象的接口，用户可以自行定义实现。比如从数据库查询等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWordTag</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询标签列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> word 脏词</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 结果</span><br><span class="hljs-comment">     */</span><br>    Set&lt;String&gt; <span class="hljs-title function_">getTag</span><span class="hljs-params">(String word)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>我们可以自定义 dict 标签文件，通过 WordTags.file() 创建一个 WordTag 实现。</p><ul><li>dict_tag_test.txt</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">五星红旗 政治,国家<br></code></pre></td></tr></table></figure><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">敏感词 tag1,tag2<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>具体的效果如下，在引导类设置一下即可。</p><p>默认的 wordTag 是空的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dict_tag_test.txt&quot;</span>;<br><span class="hljs-type">IWordTag</span> <span class="hljs-variable">wordTag</span> <span class="hljs-operator">=</span> WordTags.file(filePath);<br><br><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">sensitiveWordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>        .wordTag(wordTag)<br>        .init();<br><br>Assert.assertEquals(<span class="hljs-string">&quot;[政治, 国家]&quot;</span>, sensitiveWordBs.tags(<span class="hljs-string">&quot;五星红旗&quot;</span>).toString());;<br></code></pre></td></tr></table></figure><p>后续会考虑引入一个内置的标签文件策略。</p><h3 id="敏感词标签文件-1"><a href="#敏感词标签文件-1" class="headerlink" title="敏感词标签文件"></a>敏感词标签文件</h3><p>梳理了大量的敏感词标签文件，可以让我们的敏感词更加方便。</p><p>这两个资料阅读可在下方文章获取：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/m40ZnR6YF6WgPrArUSZ_0g">v0.11.0-敏感词新特性及对应标签文件</a></p></blockquote><h1 id="动态加载（用户自定义）"><a href="#动态加载（用户自定义）" class="headerlink" title="动态加载（用户自定义）"></a>动态加载（用户自定义）</h1><h2 id="情景说明"><a href="#情景说明" class="headerlink" title="情景说明"></a>情景说明</h2><p>有时候我们希望将敏感词的加载设计成动态的，比如控台修改，然后可以实时生效。</p><p>v0.0.13 支持了这种特性。</p><h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>为了实现这个特性，并且兼容以前的功能，我们定义了两个接口。</p><h3 id="IWordDeny"><a href="#IWordDeny" class="headerlink" title="IWordDeny"></a>IWordDeny</h3><p>接口如下，可以自定义自己的实现。</p><p>返回的列表，表示这个词是一个敏感词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拒绝出现的数据-返回的内容被当做是敏感词</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> binbin.hou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.0.13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWordDeny</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 0.0.13</span><br><span class="hljs-comment">     */</span><br>    List&lt;String&gt; <span class="hljs-title function_">deny</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWordDeny</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IWordDeny</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">deny</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;我的自定义敏感词&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IWordAllow"><a href="#IWordAllow" class="headerlink" title="IWordAllow"></a>IWordAllow</h3><p>接口如下，可以自定义自己的实现。</p><p>返回的列表，表示这个词不是一个敏感词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许的内容-返回的内容不被当做敏感词</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> binbin.hou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.0.13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWordAllow</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 0.0.13</span><br><span class="hljs-comment">     */</span><br>    List&lt;String&gt; <span class="hljs-title function_">allow</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWordAllow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IWordAllow</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">allow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;五星红旗&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><p><strong>接口自定义之后，当然需要指定才能生效。</strong></p><p>为了让使用更加优雅，我们设计了引导类 <code>SensitiveWordBs</code>。</p><p>可以通过 wordDeny() 指定敏感词，wordAllow() 指定非敏感词，通过 init() 初始化敏感词字典。</p><h3 id="系统的默认配置"><a href="#系统的默认配置" class="headerlink" title="系统的默认配置"></a>系统的默认配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">wordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>        .wordDeny(WordDenys.defaults())<br>        .wordAllow(WordAllows.defaults())<br>        .init();<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;五星红旗迎风飘扬，毛主席的画像屹立在天安门前。&quot;</span>;<br>Assert.assertTrue(wordBs.contains(text));<br></code></pre></td></tr></table></figure><p>备注：init() 对于敏感词 DFA 的构建是比较耗时的，一般建议在应用初始化的时候<strong>只初始化一次</strong>。而不是重复初始化！</p><h3 id="指定自己的实现"><a href="#指定自己的实现" class="headerlink" title="指定自己的实现"></a>指定自己的实现</h3><p>我们可以测试一下自定义的实现，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这是一个测试，我的自定义敏感词。&quot;</span>;<br><br><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">wordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>        .wordDeny(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWordDeny</span>())<br>        .wordAllow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWordAllow</span>())<br>        .init();<br><br>Assert.assertEquals(<span class="hljs-string">&quot;[我的自定义敏感词]&quot;</span>, wordBs.findAll(text).toString());<br></code></pre></td></tr></table></figure><p>这里只有 <code>我的自定义敏感词</code> 是敏感词，而 <code>测试</code> 不是敏感词。</p><p>当然，这里是全部使用我们自定义的实现，一般建议使用系统的默认配置+自定义配置。</p><p>可以使用下面的方式。</p><h3 id="同时配置多个"><a href="#同时配置多个" class="headerlink" title="同时配置多个"></a>同时配置多个</h3><ul><li>多个敏感词</li></ul><p><code>WordDenys.chains()</code> 方法，将多个实现合并为同一个 IWordDeny。</p><ul><li>多个白名单</li></ul><p><code>WordAllows.chains()</code> 方法，将多个实现合并为同一个 IWordAllow。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这是一个测试。我的自定义敏感词。&quot;</span>;<br><br><span class="hljs-type">IWordDeny</span> <span class="hljs-variable">wordDeny</span> <span class="hljs-operator">=</span> WordDenys.chains(WordDenys.defaults(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWordDeny</span>());<br><span class="hljs-type">IWordAllow</span> <span class="hljs-variable">wordAllow</span> <span class="hljs-operator">=</span> WordAllows.chains(WordAllows.defaults(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWordAllow</span>());<br><br><span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">wordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>        .wordDeny(wordDeny)<br>        .wordAllow(wordAllow)<br>        .init();<br><br>Assert.assertEquals(<span class="hljs-string">&quot;[我的自定义敏感词]&quot;</span>, wordBs.findAll(text).toString());<br></code></pre></td></tr></table></figure><p>这里都是同时使用了系统默认配置，和自定义的配置。</p><p>注意：<strong>我们初始化了新的 wordBs，那么用新的 wordBs 去判断。而不是用以前的 <code>SensitiveWordHelper</code> 工具方法，工具方法配置是默认的！</strong></p><h1 id="spring-整合"><a href="#spring-整合" class="headerlink" title="spring 整合"></a>spring 整合</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实际使用中，比如可以在页面配置修改，然后实时生效。</p><p>数据存储在数据库中，下面是一个伪代码的例子，可以参考 <a href="https://github.com/houbb/sensitive-word/blob/master/src/test/java/com/github/houbb/sensitive/word/spring/SpringSensitiveWordConfig.java">SpringSensitiveWordConfig.java</a></p><p>要求，版本 v0.0.15 及其以上。</p><h2 id="自定义数据源"><a href="#自定义数据源" class="headerlink" title="自定义数据源"></a>自定义数据源</h2><p>简化伪代码如下，数据的源头为数据库。</p><p>MyDdWordAllow 和 MyDdWordDeny 是基于数据库为源头的自定义实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringSensitiveWordConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyDdWordAllow myDdWordAllow;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyDdWordDeny myDdWordDeny;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化引导类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 初始化引导类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.0.0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SensitiveWordBs <span class="hljs-title function_">sensitiveWordBs</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SensitiveWordBs</span> <span class="hljs-variable">sensitiveWordBs</span> <span class="hljs-operator">=</span> SensitiveWordBs.newInstance()<br>                .wordAllow(WordAllows.chains(WordAllows.defaults(), myDdWordAllow))<br>                .wordDeny(myDdWordDeny)<br>                <span class="hljs-comment">// 各种其他配置</span><br>                .init();<br><br>        <span class="hljs-keyword">return</span> sensitiveWordBs;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>敏感词库的初始化较为耗时，建议程序启动时做一次 init 初始化。</p><h2 id="动态变更"><a href="#动态变更" class="headerlink" title="动态变更"></a>动态变更</h2><p>为了保证敏感词修改可以实时生效且保证接口的尽可能简化，此处没有新增 add&#x2F;remove 的方法。</p><p>而是在调用 <code>sensitiveWordBs.init()</code> 的时候，根据 IWordDeny+IWordAllow 重新构建敏感词库。</p><p>因为初始化可能耗时较长（秒级别），所有优化为 init 未完成时<strong>不影响旧的词库功能，完成后以新的为准</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensitiveWordService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SensitiveWordBs sensitiveWordBs;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新词库</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 每次数据库的信息发生变化之后，首先调用更新数据库敏感词库的方法。</span><br><span class="hljs-comment">     * 如果需要生效，则调用这个方法。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 说明：重新初始化不影响旧的方法使用。初始化完成后，会以新的为准。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 每次数据库的信息发生变化之后，首先调用更新数据库敏感词库的方法，然后调用这个方法。</span><br>        sensitiveWordBs.init();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，你可以在数据库词库发生变更时，需要词库生效，主动触发一次初始化 <code>sensitiveWordBs.init();</code>。</p><p>其他使用保持不变，无需重启应用。</p><h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p>V0.6.0 以后，添加对应的 benchmark 测试。</p><blockquote><p><a href="https://github.com/houbb/sensitive-word/blob/master/src/test/java/com/github/houbb/sensitive/word/benchmark/BenchmarkTimesTest.java">BenchmarkTimesTest</a></p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>测试环境为普通的笔记本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">处理器12th Gen <span class="hljs-title function_">Intel</span><span class="hljs-params">(R)</span> Core(TM) i7-1260P   <span class="hljs-number">2.10</span> GHz<br>机带 RAM<span class="hljs-number">16.0</span> GB (<span class="hljs-number">15.7</span> GB 可用)<br>系统类型<span class="hljs-number">64</span> 位操作系统, 基于 x64 的处理器<br></code></pre></td></tr></table></figure><p>ps: 不同环境会有差异，但是比例基本稳定。</p><h2 id="测试效果记录"><a href="#测试效果记录" class="headerlink" title="测试效果记录"></a>测试效果记录</h2><p>测试数据：100+ 字符串，循环 10W 次。</p><table><thead><tr><th>序号</th><th>场景</th><th>耗时</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>只做敏感词，无任何格式转换</td><td>1470ms，约 7.2W QPS</td><td>追求极致性能，可以这样配置</td></tr><tr><td>2</td><td>只做敏感词，支持全部格式转换</td><td>2744ms，约 3.7W QPS</td><td>满足大部分场景</td></tr></tbody></table><h1 id="STAR"><a href="#STAR" class="headerlink" title="STAR"></a>STAR</h1><h1 id="后期-road-map"><a href="#后期-road-map" class="headerlink" title="后期 road-map"></a>后期 road-map</h1><ul><li>移除单个汉字的敏感词，在中国，要把词组当做一次词，降低误判率。</li><li>支持单个的敏感词变化？</li></ul><p>remove、add、edit?</p><ul><li>敏感词标签接口支持</li><li>敏感词处理时标签支持</li><li>wordData 的内存占用对比 + 优化</li><li>用户指定自定义的词组，同时允许指定词组的组合获取，更加灵活</li></ul><p>FormatCombine&#x2F;CheckCombine&#x2F;AllowDenyCombine 组合策略，允许用户自定义。</p><ul><li>word check 策略的优化，统一遍历+转换</li><li>添加 ThreadLocal 等性能优化</li></ul><h1 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h1><h1 id="敏感词系列"><a href="#敏感词系列" class="headerlink" title="敏感词系列"></a>敏感词系列</h1><p><a href="https://mp.weixin.qq.com/s/7wSy0PuJLTudEo9gTY5s5w">sensitive-word-admin 敏感词控台 v1.2.0 版本开源</a></p><p><a href="https://mp.weixin.qq.com/s/4wia8SlQQbLV5_OHplaWvg">sensitive-word-admin v1.3.0 发布 如何支持分布式部署？</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-00-overview">01-开源敏感词工具入门使用</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-01-intro">02-如何实现一个敏感词工具？违禁词实现思路梳理</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-02-stopword">03-敏感词之 StopWord 停止词优化与特殊符号</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-03-slim">04-敏感词之字典瘦身</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-04-dfa">05-敏感词之 DFA 算法(Trie Tree 算法)详解</a></p><p><a href="https://houbb.github.io/2020/01/07/sensitive-word-05-ignore-char">06-敏感词(脏词) 如何忽略无意义的字符？达到更好的过滤效果</a></p><p><a href="https://juejin.cn/post/7308782855941292058?searchId=20231209140414C082B3CCF1E7B2316EF9">v0.10.0-脏词分类标签初步支持</a></p><p><a href="https://mp.weixin.qq.com/s/m40ZnR6YF6WgPrArUSZ_0g">v0.11.0-敏感词新特性：忽略无意义的字符，词标签字典</a></p><p><a href="https://mp.weixin.qq.com/s/-wa-if7uAy2jWsZC13C0cQ">v0.12.0-敏感词&#x2F;脏词词标签能力进一步增强</a></p><p><a href="https://mp.weixin.qq.com/s/DXv5OUyOs0y2dAq8nFWJ9A">v0.13.0-敏感词特性版本发布 支持英文单词全词匹配</a></p><p><a href="https://mp.weixin.qq.com/s/zbeJR-OkWjxashtjiopnMA">v0.16.1-敏感词新特性之字典内存资源释放</a></p><h1 id="NLP-开源矩阵"><a href="#NLP-开源矩阵" class="headerlink" title="NLP 开源矩阵"></a>NLP 开源矩阵</h1><p><a href="https://github.com/houbb/pinyin">pinyin 汉字转拼音</a></p><p><a href="https://github.com/houbb/pinyin2hanzi">pinyin2hanzi 拼音转汉字</a></p><p><a href="https://github.com/houbb/segment">segment 高性能中文分词</a></p><p><a href="https://github.com/houbb/opencc4j">opencc4j 中文繁简体转换</a></p><p><a href="https://github.com/houbb/nlp-hanzi-similar">nlp-hanzi-similar 汉字相似度</a></p><p><a href="https://github.com/houbb/word-checker">word-checker 拼写检测</a></p><p><a href="https://github.com/houbb/sensitive-word">sensitive-word 敏感词</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 两数相加</title>
    <link href="/post/9eec8197-ca95-4af8-ac8b-ff12d282b4fe/"/>
    <url>/post/9eec8197-ca95-4af8-ac8b-ff12d282b4fe/</url>
    
    <content type="html"><![CDATA[<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></p><p>已解答</p><p>中等</p><p>相关标签</p><p>相关企业</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 !=<span class="hljs-literal">null</span> || l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> next;<br>            <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) bit += l2.val;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) bit += l1.val;<br>            <span class="hljs-keyword">else</span>  bit = bit+ l1.val + l2.val; <br><br>            <span class="hljs-keyword">if</span>( bit &gt;= <span class="hljs-number">10</span> )&#123;<br>                bit = bit - <span class="hljs-number">10</span>;<br>                next = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                next = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(node !=<span class="hljs-literal">null</span>)&#123;<br>                node.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(bit);<br>                node = node.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(bit);<br>                head = node;<br>            <br>            &#125;<br>            <span class="hljs-keyword">if</span>( l1!=<span class="hljs-literal">null</span>)l1 = l1.next;   <br>            <span class="hljs-keyword">if</span>( l2!=<span class="hljs-literal">null</span>)l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (next &gt; <span class="hljs-number">0</span>)&#123;<br>            node.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Hot100</tag>
      
      <tag>中等</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141. 环形链表</title>
    <link href="/post/710e0573-50b2-4c97-a15d-c9d03e13c213/"/>
    <url>/post/710e0573-50b2-4c97-a15d-c9d03e13c213/</url>
    
    <content type="html"><![CDATA[<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></p><p>已解答</p><p>简单</p><p>相关标签</p><p>相关企业</p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="circularlinkedlist_test3.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      HashSet&lt;ListNode&gt; nodes =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ListNode&gt;();<br>      <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(nodes.contains(head))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        nodes.add(head);<br>        head=head.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/post/eb57e18d-7299-48fe-bafd-1e5e7926831d/"/>
    <url>/post/eb57e18d-7299-48fe-bafd-1e5e7926831d/</url>
    
    <content type="html"><![CDATA[<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p><p>简单</p><p>相关标签</p><p>相关企业</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_example_1_1.png" alt="img"></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_example_2.png" alt="img"></a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_example_3.png" alt="img"></a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lengthA</span> <span class="hljs-operator">=</span> getLength(headA);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lengthB</span> <span class="hljs-operator">=</span> getLength(headB);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span>  lengthA - lengthB;<br>    <br>        <span class="hljs-keyword">if</span>(diff&gt;<span class="hljs-number">0</span>)&#123;<br>           headA = step(headA,diff);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>           headB = step(headB,-diff);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(headA!=<span class="hljs-literal">null</span> &amp;&amp; headB!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(headA == headB)&#123;<br>                <span class="hljs-keyword">return</span> headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                headA=headA.next;<br>                headB=headB.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <br>    &#125;<br>    <span class="hljs-comment">//计算链表长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-literal">null</span>)&#123;<br>            length++;<br>            node=node.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>    <span class="hljs-comment">//链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">step</span><span class="hljs-params">(ListNode node, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++)&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>            node=node.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
      <tag>Hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 两数之和</title>
    <link href="/post/7621490a-4678-4469-b294-dd6e080e1491/"/>
    <url>/post/7621490a-4678-4469-b294-dd6e080e1491/</url>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li><li><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a&lt;nums.length-<span class="hljs-number">1</span>;a++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>a+<span class="hljs-number">1</span> ;b&lt;nums.length;b++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[a] + nums[b] == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123; a, b &#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer,Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> target - nums[i]; <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(num);<br>            <span class="hljs-keyword">if</span> ( index != <span class="hljs-literal">null</span> )&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, index&#125;;<br>            &#125;<br>            map.put(nums[i] , i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
      <tag>Hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据库</title>
    <link href="/post/391f27be-4063-4463-8247-5a836059d100/"/>
    <url>/post/391f27be-4063-4463-8247-5a836059d100/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><p><code>hexo template generate by typora plugin templater</code></p><p><img src="po12HL4Gjl8QOIE.jpg" alt="点击查看源网页"></p><h1 id="Redis数据库-1"><a href="#Redis数据库-1" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><p><strong>灵魂拷问：</strong> 不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？</p><p>在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。</p><p>因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。</p><h2 id="NoSQL概论"><a href="#NoSQL概论" class="headerlink" title="NoSQL概论"></a>NoSQL概论</h2><p>NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它：</p><ul><li>不保证关系数据的ACID特性</li><li>并不遵循SQL标准</li><li>消除数据之间关联性</li></ul><p>乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势：</p><ul><li>远超传统关系型数据库的性能</li><li>非常易于扩展</li><li>数据模型更加灵活</li><li>高可用</li></ul><p>这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！</p><p>NoSQL数据库分为以下几种：</p><ul><li><strong>键值存储数据库：</strong> 所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。</li><li><strong>列存储数据库：</strong> 这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。</li><li><strong>文档型数据库：</strong> 它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。</li><li><strong>图形数据库：</strong> 利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。</li></ul><p>其中我们要学习的Redis数据库，就是一个开源的<strong>键值存储数据库</strong>，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。</p><p>实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。</p><h2 id="Redis安装和部署"><a href="#Redis安装和部署" class="headerlink" title="Redis安装和部署"></a>Redis安装和部署</h2><p>我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找：</p><ul><li>官网地址：<a href="https://redis.io/">https://redis.io</a></li><li>GitHub Windows版本维护地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></li></ul><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过<code>insert</code>语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据）</p><p>在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。</p><p>我们可以通过<code>select</code>语句进行切换：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 序号;<br></code></pre></td></tr></table></figure><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>我们来看看，如何向Redis数据库中添加数据：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 一次性多个</span><br>mset [<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>所有存入的数据默认会以<strong>字符串</strong>的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span>:info:用户ID:name lbw<br></code></pre></td></tr></table></figure><p>我们可以通过键值获取存入的值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> EX 秒<br><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> PX 毫秒<br></code></pre></td></tr></table></figure><p>当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expire <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 秒<br></code></pre></td></tr></table></figure><p>通过下面的命令来查询某个键值对的过期时间还剩多少：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">ttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 毫秒显示</span><br>pttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 转换为永久</span><br>persist <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>那么当我们想直接删除这个数据时呢？直接使用：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">del <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>删除命令可以同时拼接多个键值一起删除。</p><p>当我们想要查看数据库中所有的键值时：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">keys <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>也可以查询某个键是否存在：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exists</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>还可以随机拿一个键：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">randomkey<br></code></pre></td></tr></table></figure><p>我们可以将一个数据库中的内容移动到另一个数据库中：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">move <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 数据库序号<br></code></pre></td></tr></table></figure><p>修改一个键为另一个键：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">rename <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 下面这个会检查新的名称是否已经存在</span><br>renamex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>如果存放的数据是一个数字，我们还可以对其进行自增自减操作：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 等价于a = a + 1</span><br>incr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 等价于a = a + b</span><br>incrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> b<br><span class="hljs-comment">-- 等价于a = a - 1</span><br>decr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>最后就是查看值的数据类型：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">type <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。</p><h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><p>一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#Redis默认存String类似于这样：<br>Map&lt;String, String&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>#Redis存Hash类型的数据类似于这样：<br>Map&lt;String, Map&lt;String, String&gt;&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。</p><p>我们可以像这样来添加一个Hash类型的数据：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>值<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>我们可以直接获取：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">hget <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 如果想要一次性获取所有的字段和值</span><br>hgetall <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>同样的，我们也可以判断某个字段是否存在：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hexists <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>删除Hash中的某个字段：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hdel <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个<code>h</code>，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。</p><p>我们现在想要知道Hash中一共存了多少个键值对：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hlen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以一次性获取所有字段的值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。</p><p>我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向列表头部添加元素</span><br>lpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 向列表尾部添加元素</span><br>rpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 在指定元素前面/后面插入元素</span><br>linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span>指定元素<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>同样的，获取元素也非常简单：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据下标获取元素</span><br>lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>下标<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除头部元素</span><br>lpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除尾部元素</span><br>rpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取指定范围内的</span><br>lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）:</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 获取列表a中的全部元素</span><br>lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>没想到吧，push和pop还能连着用呢：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素</span><br>rpoplpush 当前数组 目标数组<br></code></pre></td></tr></table></figure><p>它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行</span><br>blpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>... timeout<br></code></pre></td></tr></table></figure><h3 id="Set和SortedSet"><a href="#Set和SortedSet" class="headerlink" title="Set和SortedSet"></a>Set和SortedSet</h3><p>Set集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。</p><p>向Set中添加一个或多个值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>查看Set集合中有多少个值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>判断集合中是否包含：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 是否包含指定值</span><br>sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 列出所有值</span><br>smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>集合之间的运算：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 集合之间的差集</span><br>sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 集合之间的交集</span><br>sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 求并集</span><br>sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 将集合之间的差集存到目标集合中</span><br>sdiffstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sinterstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sunionstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>移动指定值到另一个集合中：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">smove <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 目标 <span class="hljs-keyword">value</span> <br></code></pre></td></tr></table></figure><p>移除操作：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 随机移除一个幸运儿</span><br>spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除指定</span><br>srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。</p><p>我们可以添加一个带分数的值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">zadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>score<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>同样的：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询有多少个值</span><br>zcard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除</span><br>zrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 获取区间内的所有</span><br>zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>由于所有的值都有一个分数，我们也可以根据分数段来获取：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 通过分数段查看</span><br>zrangebyscore <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop [withscores] [limit]<br><span class="hljs-comment">-- 统计分数段内的数量</span><br>zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">start</span> stop<br><span class="hljs-comment">-- 根据分数获取指定值的排名</span><br>zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/32b9fe8c20e1">https://www.jianshu.com/p/32b9fe8c20e1</a></p><p>有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。</p><hr><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。</p><p>这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。</p><p>持久化的实现方式有两种方案：一种是直接保存当前<strong>已经存储的数据</strong>，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的<strong>所有过程</strong>，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">save<br><span class="hljs-comment">-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存</span><br>bgsave<br></code></pre></td></tr></table></figure><p>执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">shutdown<br></code></pre></td></tr></table></figure><p>重启后可以看到数据依然存在。</p><p><img src="VK3k7EAZDT1fjIo.jpg" alt="点击查看图片来源"></p><p>虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。</p><p>我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作：</p><p>​                              </p><p>​                复制代码      </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个写入<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # <span class="hljs-number">60</span>秒（<span class="hljs-number">1</span>分钟）内有<span class="hljs-number">10000</span>个写入<br></code></pre></td></tr></table></figure><p>配置的save使用的都是bgsave后台执行。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。</p><p>而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。</p><p><img src="JYiOHBdtT7jC98R.jpg" alt="rdb和aof区别"></p><p>但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：</p><ul><li>always：每次执行写操作都会保存一次</li><li>everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据</li><li>no：看系统心情保存</li></ul><p>可以在配置文件中配置：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 注意得改成也是<br>appendonly yes<br><br># appendfsync always<br>appendfsync everysec<br># appendfsync <span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><p>重启服务器后，可以看到服务器目录下多了一个<code>appendonly.aof</code>文件，存储的就是我们执行的命令。</p><p>AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。</p><p>Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句：</p><p>​                              </p><p>​                复制代码      </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">777</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>实际上用一条语句也可以实现：</p><p>​                              </p><p>​                复制代码      </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span> <span class="hljs-number">777</span> <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。</p><p>我们可以输入命令来手动执行重写操作：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">bgrewriteaof<br></code></pre></td></tr></table></figure><p>或是在配置文件中配置自动重写：</p><p>​                              </p><p>​                复制代码      </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 百分比计算，这里不多介绍</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># 当达到这个大小时，触发自动重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><p>至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结：</p><ul><li>AOF：<ul><li>优点：存储速度快、消耗资源少、支持实时存储</li><li>缺点：加载速度慢、数据体积大</li></ul></li><li>RDB：<ul><li>优点：加载速度快、数据体积小</li><li>缺点：存储速度慢大量消耗资源、会发生数据丢失</li></ul></li></ul><hr><h2 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h2><p>和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。</p><p>我们可以使用命令来直接开启事务：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">multi<br></code></pre></td></tr></table></figure><p>当我们输入完所有要执行的命令时，可以使用命令来立即执行事务：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exec</span><br></code></pre></td></tr></table></figure><p>我们也可以中途取消事务：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">discard<br></code></pre></td></tr></table></figure><p>实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</p><p>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？</p><ul><li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。</li><li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。</li></ul><p>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">watch<br></code></pre></td></tr></table></figure><p>我们可以开两个客户端进行测试。</p><p>取消监视可以使用：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unwatch<br></code></pre></td></tr></table></figure><p>至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。</p><hr><h2 id="使用Java与Redis交互"><a href="#使用Java与Redis交互" class="headerlink" title="使用Java与Redis交互"></a>使用Java与Redis交互</h2><p>既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？</p><p>这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖：</p><p>​                              </p><p>​        xml        复制代码      </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//创建Jedis对象</span><br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>  <br>  <span class="hljs-comment">//使用之后关闭连接</span><br>  jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//直接使用try-with-resouse，省去close</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//等同于 set test lbwnb 命令</span><br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test&quot;</span>));  <span class="hljs-comment">//等同于 get test 命令</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hash类型的数据也是这样：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;sxc&quot;</span>);   <span class="hljs-comment">//等同于 hset hhh name sxc</span><br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>);    <span class="hljs-comment">//等同于 hset hhh age 19</span><br>        jedis.hgetAll(<span class="hljs-string">&quot;hhh&quot;</span>).forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">&quot;: &quot;</span>+v));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看列表操作：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);  <span class="hljs-comment">//等同于 lpush mylist 111 222 333 命令</span><br>        jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>                .forEach(System.out::println);    <span class="hljs-comment">//等同于 lrange mylist 0 -1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。</p><h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce：</p><p>​                              </p><p>​        xml        复制代码      </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：</p><p>​                              </p><p>​        yaml        复制代码      </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>  <span class="hljs-comment">#Redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span><br>    <span class="hljs-comment">#端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#使用几号数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(</span><br><span class="hljs-meta">    proxyBeanMethods = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="hljs-meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfiguration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisAutoConfiguration</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>(redisConnectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何去使用这两个模板类呢？我们可以直接注入<code>StringRedisTemplate</code>来使用模板：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        ValueOperations&lt;String, String&gt; operations = template.opsForValue();<br>        operations.set(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);   <span class="hljs-comment">//设置值</span><br>        System.out.println(operations.get(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//获取值</span><br>      <br>        template.delete(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">//删除键</span><br>        System.out.println(template.hasKey(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//判断是否包含键</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上所有的值的操作都被封装到了<code>ValueOperations</code>对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。</p><p>我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意：</p><p>​                              </p><p>​        xml        复制代码      </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        template.setEnableTransactionSupport(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//需要开启事务</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//需要添加此注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        template.multi();<br>        template.opsForValue().set(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>        template.exec();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoad2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//注意Student需要实现序列化接口才能存入Redis</span><br>    template.opsForValue().set(<span class="hljs-string">&quot;student&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>    System.out.println(template.opsForValue().get(<span class="hljs-string">&quot;student&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="使用Redis做缓存"><a href="#使用Redis做缓存" class="headerlink" title="使用Redis做缓存"></a>使用Redis做缓存</h2><p>我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。</p><h3 id="Mybatis二级缓存"><a href="#Mybatis二级缓存" class="headerlink" title="Mybatis二级缓存"></a>Mybatis二级缓存</h3><p>还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。</p><p><img src="JKDHFTiCr2t5Oj9.jpg" alt="img"></p><p>我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Mybatis的Cache接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisMybatisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisTemplate&lt;Object, Object&gt; template;<br><br>   <span class="hljs-comment">//注意构造方法必须带一个String类型的参数接收id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisMybatisCache</span><span class="hljs-params">(String id)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>  <span class="hljs-comment">//初始化时通过配置类将RedisTemplate给过来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTemplate</span><span class="hljs-params">(RedisTemplate&lt;Object, Object&gt; template)</span> &#123;<br>        RedisMybatisCache.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object o, Object o1)</span> &#123;<br>      <span class="hljs-comment">//这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间</span><br>        template.opsForValue().set(o, o1, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object o)</span> &#123;<br>      <span class="hljs-comment">//这里根据Key直接从Redis数据库中获取值即可</span><br>        <span class="hljs-keyword">return</span> template.opsForValue().get(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object o)</span> &#123;<br>      <span class="hljs-comment">//根据Key删除</span><br>        <span class="hljs-keyword">return</span> template.delete(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//由于template中没封装清除操作，只能通过connection来执行</span><br>template.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;<br>          <span class="hljs-comment">//通过connection对象执行清空操作</span><br>            connection.flushDb();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//这里也是使用connection对象来获取当前的Key数量</span><br>        <span class="hljs-keyword">return</span> template.execute(RedisServerCommands::dbSize).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存类编写完成后，我们接着来编写配置类：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//把RedisTemplate给到RedisMybatisCache</span><br>        RedisMybatisCache.setTemplate(template);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在Mapper上启用此缓存即可：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只需要修改缓存实现类implementation为我们的RedisMybatisCache即可</span><br><span class="hljs-meta">@CacheNamespace(implementation = RedisMybatisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MainMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select name from student where sid = 1&quot;)</span><br>    String <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们提供一个测试用例来查看当前的二级缓存是否生效：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。</p><h3 id="Token持久化存储"><a href="#Token持久化存储" class="headerlink" title="Token持久化存储"></a>Token持久化存储</h3><p>我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现PersistentTokenRepository接口</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersistentTokenRepository</span> &#123;<br>  <span class="hljs-comment">//Key名称前缀，用于区分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">REMEMBER_ME_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring:security:rememberMe:&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span> &#123;<br>      <span class="hljs-comment">//这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除</span><br>        template.opsForValue().set(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), token.getSeries());<br>        template.expire(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>        <span class="hljs-built_in">this</span>.setToken(token);<br>    &#125;<br><br>  <span class="hljs-comment">//先获取，然后修改创建一个新的，再放入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateToken</span><span class="hljs-params">(String series, String tokenValue, Date lastUsed)</span> &#123;<br>        <span class="hljs-type">PersistentRememberMeToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getToken(series);<br>        <span class="hljs-keyword">if</span>(token != <span class="hljs-literal">null</span>)<br>           <span class="hljs-built_in">this</span>.setToken(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PersistentRememberMeToken</span>(token.getUsername(), series, tokenValue, lastUsed));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PersistentRememberMeToken <span class="hljs-title function_">getTokenForSeries</span><span class="hljs-params">(String seriesId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getToken(seriesId);<br>    &#125;<br><br>  <span class="hljs-comment">//通过username找seriesId直接删除这两个</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUserTokens</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">series</span> <span class="hljs-operator">=</span> (String) template.opsForValue().get(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>        template.delete(REMEMBER_ME_KEY+series);<br>        template.delete(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>    &#125;<br><br>  <br>  <span class="hljs-comment">//由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作</span><br>    <span class="hljs-keyword">private</span> PersistentRememberMeToken <span class="hljs-title function_">getToken</span><span class="hljs-params">(String series)</span>&#123;<br>        Map&lt;Object, Object&gt; map = template.opsForHash().entries(REMEMBER_ME_KEY+series);<br>        <span class="hljs-keyword">if</span>(map.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersistentRememberMeToken</span>(<br>                (String) map.get(<span class="hljs-string">&quot;username&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;series&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;tokenValue&quot;</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(Long.parseLong((String) map.get(<span class="hljs-string">&quot;date&quot;</span>))));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span>&#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, token.getUsername());<br>        map.put(<span class="hljs-string">&quot;series&quot;</span>, token.getSeries());<br>        map.put(<span class="hljs-string">&quot;tokenValue&quot;</span>, token.getTokenValue());<br>        map.put(<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;&quot;</span>+token.getDate().getTime());<br>        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);<br>        template.expire(REMEMBER_ME_KEY+token.getSeries(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着把验证Service实现了：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> mapper.getAccountByUsername(username);<br>        <span class="hljs-keyword">if</span>(account == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(username)<br>                .password(account.getPassword())<br>                .roles(account.getRole())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper也安排上：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>    String role;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheNamespace(implementation = MybatisRedisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    Account <span class="hljs-title function_">getAccountByUsername</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后配置文件配一波：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http<br>            .authorizeRequests()<br>            .anyRequest().authenticated()<br>            .and()<br>            .formLogin()<br>            .and()<br>            .rememberMe()<br>            .tokenRepository(repository);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，启动服务器验证一下吧。</p><hr><h2 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h2><p><strong>注意：</strong> 这部分内容作为选学内容。</p><p>虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="fSDgVrZj2ozKuPG.jpg" alt="img"></p><p>当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？</p><p>这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的）</p><p><img src="vWaLugBJMT3zIDC.jpg" alt="点击查看图片来源"></p><p>使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。</p><p>布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。</p><p>接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><img src="6ut3ClgQrWUfKy2.jpg" alt="img"></p><p>某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。</p><p>这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="BwncOXbRU4WFgkV.jpg" alt="img"></p><p>当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。</p><p>解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。</p><p>————————————————</p><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/jjlolj5igvttvyhv">https://www.itbaima.cn/document/jjlolj5igvttvyhv</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级</title>
    <link href="/post/bd155093-7287-4a33-ab3f-6f114eadc1bd/"/>
    <url>/post/bd155093-7287-4a33-ab3f-6f114eadc1bd/</url>
    
    <content type="html"><![CDATA[<h3 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h3><p><code>hexo template generate by typora plugin templater</code></p><h1 id="MySQL高级-1"><a href="#MySQL高级-1" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>在JavaWeb阶段，我们初步认识了MySQL数据库，包括一些基本操作，比如创建数据库、表、触发器，以及最基本的增删改查、事务等操作。而在此阶段，我们将继续深入学习MySQL，了解它的更多高级玩法，也相当于进行复习。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>其实函数我们在之前已经接触到一部分了，在JavaWeb阶段，我们了解了聚集函数，聚集函数一般用作统计，包括：</p><ul><li>count([distinct]*)    统计所有的行数（distinct表示去重再统计，下同）</li><li>count([distinct]列名)    统计某列的值总和</li><li>sum([distinct]列名)    求一列的和（注意必须是数字类型的）</li><li>avg([distinct]列名)    求一列的平均值（注意必须是数字类型）</li><li>max([distinct]列名)    求一列的最大值</li><li>min([distinct]列名)    求一列的最小值</li></ul><p>比如我们需要计算某个表一共有多少行：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>通过使用COUNT聚集函数，就可以快速统计并得到结果，比如我们想计算某一列上所有数字的和：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(sid) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>通过SUM聚集函数，就可以快速计算每一列的和，实际上这些函数都是由系统提供的函数，我们可以直接使用。</p><p>本版块我们会详细介绍各类系统函数以及如何编写自定义函数。</p><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>系统为我们提供的函数也是非常实用的，我们将会分为几个类型进行讲解。</p><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>处理字符串是一个比较重要的内容，我们可以使用字符串函数来帮助我们快速处理字符串，其中常用比如用于字符串分割的函数有：</p><ul><li>substring(字符串, 起始位置, 结束位置)     同Java中String类的substring一致，但是注意下标是从1开始，下同</li><li>left(字符串, 长度)     从最左边向右截取字符串</li><li>right(字符串, 长度)     从最右边向左截取字符串</li></ul><p>比如我们只想获取所有学生姓名的第二个字，那么可以像这样写：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(name, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>比如我们想获取所有学生姓名的第一个字，可以像这样写：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(name, <span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>我们还可以利用字符串函数来快速将所有的字母转换为大写字母或是快速转换为小写字母：</p><ul><li>upper(字符串)     字符串中的所有字母转换为大写字母</li><li>lower(字符串)     字符串中的所有字母转换为小写字母</li></ul><p>比如我们希望将一个字符串所有字符专为大写：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;abcdefg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们也可以像Java中那样直接对字符串中的内容进行替换：</p><ul><li>replace(字符串, 原文, 替换文)      同Java中String的replace效果</li></ul><p>比如现在我们希望将查询到的所有同学的名称中的<code>小</code>全部替换<code>大</code>：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> REPLACE(`name`, <span class="hljs-string">&#x27;小&#x27;</span>, <span class="hljs-string">&#x27;大&#x27;</span>) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>字符串也支持进行拼接，系统提供了字符串的拼接函数：</p><ul><li>concat(字符串1, 字符串2)   连接两个字符串</li></ul><p>比如我们希望将查询到的所有同学的名称最后都添加一个<code>子</code>字：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> concat(name, <span class="hljs-string">&#x27;子&#x27;</span>) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>最后就是计算字符串的长度：</p><ul><li>length(字符串)    获取字符串长度（注意如果使用的是UTF-8编码格式，那么一个汉字占3字节，数字和字母占一个字节）</li></ul><p>比如我们要获取所有人名字的长度：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> LENGTH(`name`) <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>MySQL提供的日期函数也非常实用，我们可以快速对日期进行操作，比如我们想要快速将日期添加N天，就可以使用：</p><ul><li>date_add(日期, interval 增量 单位)</li></ul><p>比如我们希望让2022-1-1向后5天：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_ADD(<span class="hljs-string">&#x27;2022-1-1&#x27;</span>,<span class="hljs-type">INTERVAL</span> <span class="hljs-number">5</span> <span class="hljs-keyword">day</span>)<br></code></pre></td></tr></table></figure><p>同理，向前1年：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_ADD(<span class="hljs-string">&#x27;2022-1-1&#x27;</span>,<span class="hljs-type">INTERVAL</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">year</span>)<br></code></pre></td></tr></table></figure><p>单位有：year（年）、month（月）、day（日）、hour（小时）、minute（分钟）、second（秒）</p><p>我们还可以快速计算日期的间隔天数：</p><ul><li>datediff(日期1, 日期2)</li></ul><p>比如我们想计算2022年的2月有多少天：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATEDIFF(<span class="hljs-string">&#x27;2022-3-1&#x27;</span>,<span class="hljs-string">&#x27;2022-2-1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果我们想快速获取当前时间的话，可以使用这些：</p><ul><li>curdate()     当前的日期</li><li>curtime()     当前的时间</li><li>now()    当前的日期+时间</li></ul><p>此函数之前我们在编写实战项目的时候已经使用过了，这里就不演示了。我们也可以单独获取时间中的某个值：</p><ul><li>day(日期)    获取日期是几号</li><li>month(日期)   获取日期是几月</li><li>year(日期)      获取日期是哪一年</li></ul><p>比如我们想获取今天是几号：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DAY</span>(NOW())<br></code></pre></td></tr></table></figure><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>数学函数比较常规，基本与Java的Math工具类一致，这里列出即可，各位可以自行尝试：</p><ul><li>abs(x)   求x的绝对值</li><li>ceiling(x)   x向上取整</li><li>floor(x)  x向下取整</li><li>round(x, 精度)  x取四舍五入，遵循小数点精度</li><li>exp(x)   e的x次方</li><li>rand()   0-1之间的随机数</li><li>log(x)    x的对数</li><li>pi()     π</li><li>power(x, n)    x的n次方</li><li>sqrt(x)     x的平方根</li><li>sin(x)  cos(x)   tan(x)     三角函数（貌似没有arctan这类反函数？）</li></ul><h4 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h4><p>MySQL的类型转换也分为隐式类型转换和显示类型转换，首先我们来看看隐式类型转换：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><p>虽然这句中既包含了数字和字符，但是字符串会被进行隐式转换（注意这里并不是按照字符的ASCII码转换，而是写的多少表示多少）所以最后得到的就是1+2的结果为3</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里因为需要传入字符串类型的数据，但是我们给的是1这个数字，因此这里也会发生隐式类型转换，1会被直接转换为字符串的’1’，所以这里得到的结果是’12’</p><p>在某些情况下，我们可能需要使用强制类型转换来将得到的数据转换成我们需要的数据类型，这时就需要用到类型转换函数了，MySQL提供了：</p><ul><li>cast(数据   as 数据类型)</li></ul><p>数据类型有以下几种：</p><ul><li>BINARY[(N)] ：二进制字符串，转换后长度小于N个字节</li><li>CHAR[(N)] ：字符串，转换后长度小于N个字符</li><li>DATE ：日期</li><li>DATETIME ：日期时间</li><li>DECIMAL[(M[,N])] ：浮点数，M为数字总位数(包括整数部分和小数部分)，N为小数点后的位数</li><li>SIGNED [INTEGER] ：有符号整数</li><li>TIME ：时间</li><li>UNSIGNED [INTEGER] ：无符号整数</li></ul><p>比如我们现在需要将一个浮点数转换为一个整数：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(pi() <span class="hljs-keyword">AS</span> SIGNED)<br></code></pre></td></tr></table></figure><p>我们还可以将字符串转换为数字，会自动进行扫描，值得注意的是一旦遇到非数字的字符，会停止扫描：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(<span class="hljs-string">&#x27;123abc456&#x27;</span> <span class="hljs-keyword">as</span> SIGNED)<br></code></pre></td></tr></table></figure><p>除了cast以外还有convert函数，功能比较相似，这里就不做讲解了。</p><h4 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h4><p>MySQL还为我们提供了很多的逻辑判断函数，比如：</p><ul><li>if(条件表达式, 结果1, 结果2)    与Java中的三目运算符一致 a &gt; b ? “AAA” : “BBB”</li><li>ifnull(值1, 值2)     如果值1为NULL则返回值2，否则返回值1</li><li>nullif(值1, 值2)     如果值1与值2相等，那么返回NULL</li><li>isnull(值)      判断值是否为NULL</li></ul><p>比如现在我们想判断：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> IF(<span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;lbwnb&#x27;</span>,<span class="hljs-string">&#x27;yyds&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过判断函数，我们就可以很方便地进行一些条件判断操作。</p><p>除了IF条件判断，我们还可以使用类似Switch一样的语句完成多分支结构：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-number">10</span><br><span class="hljs-keyword">ELSE</span><br><span class="hljs-number">5</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>我们也可以将自定义的判断条件放入When之后，它类似于else-if：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">CASE</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">5</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-number">10</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span><span class="hljs-operator">&lt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-number">11</span><br><span class="hljs-keyword">ELSE</span><br><span class="hljs-number">5</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>还有一个类似于Java中的Thread.sleep的函数，以秒为单位：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sleep(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>有关MySQL8.0新增的窗口函数这里暂时不做介绍。</p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>除了使用系统为我们提供的函数以外，我们也可以自定义函数，并使用我们自定义的函数进行数据处理，唯一比较麻烦的就是函数定义后不能修改，只能删了重新写。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>MySQL的函数与Java中的方法类似，也可以添加参数和返回值，可以通过<code>CREATE FUNCTION</code>创建函数：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> test() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-number">666</span>;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>定义函数的格式为：</p><ul><li>create function 函数名称([参数列表]) returns 返回值类型</li><li>begin 和 end 之间写函数的其他逻辑，begin和end就相当于Java中的花括号<code>&#123;  ...  &#125;</code></li><li>return后紧跟返回的结果</li></ul><p>添加参数也很简单，我们只需要在函数名称括号中添加即可，注意类型需要写在参数名称后面：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> test(i <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">RETURN</span> i <span class="hljs-operator">*</span> i;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>我们可以在BEGIN和RETURN之间编写一些其他的逻辑，比如我们想要定义一个局部变量，并为其赋值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">RETURN</span> i <span class="hljs-operator">*</span> i <span class="hljs-operator">*</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>定义局部变量的格式为：</p><ul><li>declare 变量名称 变量类型 [, …]</li><li>declare 变量名称 变量类型 default 默认值</li></ul><p>为变量赋值的格式为：</p><ul><li>set 变量名称 &#x3D; 值</li></ul><p>我们还可以在函数内部使用<code>select</code>语句，它可以直接从表中读取数据，并可以结合into关键字将查询结果赋值给变量：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span>;<br><span class="hljs-comment">-- select into from 语句</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> a <span class="hljs-keyword">FROM</span> student;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>接着我们来看一下如何使用流程控制语句，其中最关键的就是IF判断语句：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>;<br>IF a <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">ELSE</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>IF分支语句的格式为：</p><ul><li>if 判断条件 then  … else if 判断条件 then …. else … end if;</li></ul><p>我们可以结合<code>exists</code>关键字来判断是否为NULL：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">-- IF EXISTS(SELECT * FROM student WHERE sid = 100) THEN</span><br>IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sid <span class="hljs-operator">=</span> <span class="hljs-number">100</span>) <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>我们也可以在函数中使用switch语句：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">CASE</span> a<br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">ELSE</span><br><span class="hljs-keyword">RETURN</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>SWITCH分支语句的格式为：</p><ul><li>case 变量 when 具体值或是布尔表达式 then … when * then … else … end case;</li></ul><p>与Java不同的是，它支持使用布尔表达式：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">CASE</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">ELSE</span><br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>我们以类似于elseif的形式进行判断，其实和上面直接使用是一样的。</p><p>我们接着来看循环语句，MySQL提供了三种循环语句，其中第一种是WHILE语句：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>;<br>WHILE a <span class="hljs-operator">&lt;</span> <span class="hljs-number">11</span> DO<br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>格式为：</p><ul><li>while 循环条件 do …  end while;</li></ul><p>我们接着来看第二种循环语句，LOOP循环：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>;<br>lp1: LOOP<br>  <span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> a <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>IF a <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span><br>LEAVE lp1; <br><span class="hljs-keyword">END</span> IF; <br><span class="hljs-keyword">END</span> LOOP lp1;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>相比while语句，我们可以使用<code>LEAVE</code>精准控制结束哪个循环，有点类似于goto语句：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>lp1: LOOP<br>  lp2: LOOP<br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>IF a <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">THEN</span><br>LEAVE lp1; <br><span class="hljs-keyword">END</span> IF; <br><span class="hljs-keyword">END</span> LOOP lp2;<br><span class="hljs-keyword">END</span> LOOP lp1;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>类似于Java中的goto写法（在JavaSE阶段已经讲解过）：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    lp1: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        lp2: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            a++;<br>            <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span> lp1;<br>        &#125;<br>    &#125;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>它的语法格式如下：</p><ul><li>循环名称 loop …(可以插入leave语句结束) end loop 循环名称;</li></ul><p>接着我们来看最后一种循环语句，repeat语句：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>REPEAT<br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>UNTIL a <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span> REPEAT;<br><span class="hljs-keyword">RETURN</span> a;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>它类似于Java中的do-while循环语句，它会先去执行里面的内容，再进行判断，格式为：</p><ul><li>repeat … until 结束循环条件 end repeat;</li></ul><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>某些情况下，我们可以直接在一次会话中直接定义变量并使用，这时它并不是位于函数内的，这就是全局变量，它无需预先定义，直接使用即可：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>我们可以将全局变量作为参数传递给函数：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> test(<span class="hljs-variable">@x</span>);<br></code></pre></td></tr></table></figure><p>除了我们自己定义的全部变量以外，系统默认也有很多的变量，因此我们自己定义的变量称为用户变量，系统默认变量称为系统变量。查看系统变量的命令为：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES<br></code></pre></td></tr></table></figure><hr><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是一个包括多条SQL语句的集合，专用于特定表的特定操作，比如我们之前实战项目中的创建用户，那么我们就需要一次性为两张表添加数据，但是如果不使用Java，而是每次都去使用SQL命令来完成，就需要手动敲两次命令，非常麻烦，因此我们可以提前将这些操作定义好，预留出需要填写数据的位置，下次输入参数直接调用即可。</p><p>这里很容易与函数搞混淆，存储过程也是执行多条SQL语句，但是它们的出发点不一样，函数是专用于进行数据处理，并将结果返回给调用者，它更多情况下是一条SQL语句的参与者，无法直接运行，并且不涉及某个特定表：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> student;<br></code></pre></td></tr></table></figure><p>而存储过程是多条SQL语句的执行者，这是它们的本质区别。</p><p>定义存储过程与定义函数极为相似，它也可以包含参数，函数中使用的语句这里也能使用，但是它没有返回值：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> lbwnb(`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>), pwd <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>))<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users(username, `password`) <span class="hljs-keyword">VALUES</span>(`name`, pwd);<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>我们可以在存储过程中编写多条SQL语句，但是注意，MySQL的存储过程不具有原子性，当出现错误时，并不会回滚之前的操作，因此需要我们自己来编写事务保证原子性。</p><p>接着我们来看看如何执行存储过程：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> lbwnb(<span class="hljs-string">&#x27;111&#x27;</span>, <span class="hljs-string">&#x27;2222&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过使用<code>call</code>来执行一个存储过程，如果存储过程有参数，那么还需要填写参数。</p><p>比如现在我们想要实现查询用户表，如果包含用户<code>test</code>那么就删除用户，如果不包含，就添加用户：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `lbwnb`()<br><span class="hljs-keyword">BEGIN</span><br>IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users(username, `password`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>);<br><span class="hljs-keyword">ELSE</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span>;<br><span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>这里其实只需要一个简单的IF判断即可实现。</p><p>那么如果我们希望遍历一个SELECT语句查询的结果呢？我们可以使用游标来完成：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">DECLARE</span> `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">DECLARE</span> sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student;<br><span class="hljs-keyword">OPEN</span> cur;<br>WHILE <span class="hljs-literal">TRUE</span> DO<br><span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> id, `name`, sex;<br><span class="hljs-keyword">SELECT</span> id, `name`, sex;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">CLOSE</span> cur;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>游标的使用分为4个步骤：</p><ul><li>DECLARE 游标名称 CURSOR FOR 查询结果   -  定义游标</li><li>OPEN cur     -   开启游标</li><li>FETCH 游标名称 INTO 存储结果的变量    -    从顶部开始，每执行一次，向下移动，如果已经在最底部，则触发异常</li><li>CLOSE cur    -   关闭游标</li></ul><p>我们这里利用了一个while循环来多次通过游标获取查询结果，但是最后是因为出现异常才退出的，这样会导致之后的代码就无法继续正常运行了。</p><p>我们接着来看如何处理异常：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">DECLARE</span> `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">DECLARE</span> sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">DECLARE</span> score <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">DECLARE</span> a <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student;<br><span class="hljs-comment">-- 必须在游标定义之后编写</span><br><span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-number">1329</span> <span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">OPEN</span> cur;<br>WHILE a <span class="hljs-operator">=</span> <span class="hljs-number">0</span> DO<br><span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> id, `name`, sex, score;<br><span class="hljs-keyword">SELECT</span> id, `name`, sex, score;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">CLOSE</span> cur;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>我们可以声明一个异常处理器（句柄），格式如下：</p><ul><li>declear (continue&#x2F;exit) handler for 异常名称(ID) 做点什么</li></ul><p>我们还可以限定存储过程的参数传递，比如我们只希望用户给我们一个参数用于接收数据，而不是值传递，我们可以将其设定为OUT类型：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `lbwnb`(<span class="hljs-keyword">OUT</span> a <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">SELECT</span> a;<br><span class="hljs-keyword">SET</span> a <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>所有的参数默认为<code>IN</code>类型，也就是只能作为传入参数，无法为其赋值，而这里讲参数设定为<code>OUT</code>类型，那么参数无法将值传入，而只能被赋值。</p><p>如果我们既希望参数可以传入也可以被重新赋值，我们可以将其修改为<code>INOUT</code>类型。</p><hr><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎就像我们电脑中的CPU，它是整个MySQL最核心的部分，数据库中的数据如何存储，数据库能够支持哪些功能，我们的增删改查请求如何执行，都是由存储引擎来决定的。</p><p>我们可以大致了解一下以下三种存储引擎：</p><ul><li><strong>MyISAM：</strong> MySQL5.5之前的默认存储引擎，在插入和查询的情况下性能很高，但是它不支持事务，只能添加表级锁。</li><li><strong>InnoDB：</strong> MySQL5.5之后的默认存储引擎，它支持ACID事务、行级锁、外键，但是性能比不过MyISAM，更加消耗资源。</li><li><strong>Memory：</strong> 数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。</li></ul><p>我们可以使用下面的命令来查看MySQL支持的存储引擎：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> engines;<br></code></pre></td></tr></table></figure><p>在创建表时，我们也可以为表指定其存储引擎。</p><p>我们还可以在配置文件中修改默认的存储引擎，在Windows 11系统下，MySQL的配置文件默认放在<code>C:\ProgramData\MySQL\MySQL Server 5.7</code>中，注意ProgramData是个隐藏文件夹。</p><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>注意：</strong> 本小节会涉及<code>数据结构与算法</code>相关知识。</p><p>索引就好像我们书的目录，每本书都有一个目录用于我们快速定位我们想要的内容在哪一页，索引也是，通过建立索引，我们就可以根据索引来快速找到想要的一条记录，大大提高查询效率。</p><p>本版块我们会详细介绍索引的几种类型，以及索引的底层存储原理。</p><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引只针对于某一列数据创建索引，单列索引有以下几种类型：</p><ul><li><strong>NORMAL：</strong> 普通的索引类型，完完全全相当于一本书的目录。</li><li><strong>UNIQUE：</strong> 唯一索引，我们之前已经用过了，一旦建立唯一索引，那么整个列中将不允许出现重复数据。每个表的主键列，都有一个特殊的唯一索引，叫做Primary Key，它不仅仅要求不允许出现重复，还要求不能为NULL，它还可以自动递增。每张表可以有多个唯一索引，但是只能有一个Primary索引。</li><li><strong>SPATIAL：</strong> 空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON，不是很常用，这里不做介绍。</li><li><strong>FULLTEXT：</strong> 全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用<code>like %</code>更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</li></ul><p>我们来看看如何使用全文索引，首先创建一张用于测试全文索引的表：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> articles (<br>  id <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>  body TEXT,<br>  FULLTEXT (body));<br></code></pre></td></tr></table></figure><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> articles <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;MySQL Tutorial&#x27;</span>, <span class="hljs-string">&#x27;DBMS stands for DataBase ...&#x27;</span>),<br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;How To Use MySQL Efficiently&#x27;</span>, <span class="hljs-string">&#x27;After you went through a ...&#x27;</span>),<br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;Optimising MySQL&#x27;</span>,<span class="hljs-string">&#x27;In this tutorial we will show ...&#x27;</span>),<br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;1001 MySQL Tricks&#x27;</span>,<span class="hljs-string">&#x27;1. Never run mysqld as root. 2. ...&#x27;</span>),<br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;MySQL vs. YourSQL&#x27;</span>, <span class="hljs-string">&#x27;In the following database comparison ...&#x27;</span>),<br>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;MySQL Security&#x27;</span>, <span class="hljs-string">&#x27;When configured properly, MySQL ...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>最后我们使用全文索引进行模糊匹配：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> articles <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span> (body) AGAINST (<span class="hljs-string">&#x27;database&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意全文索引如何定义字段的，match中就必须是哪些字段，against中定义需要模糊匹配的字符串，我们用作查找的字符串实际上是被分词之后的结果，如果进行模糊匹配的不是一个词语，那么会查找失败，但是它的效率远高于以下这种写法：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> articles <span class="hljs-keyword">WHERE</span> body <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%database%&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>组合索引实际上就是将多行捆绑在一起，作为一个索引，它同样支持以上几种索引类型，我们可以在Navicat中进行演示。</p><p>注意组合索引在进行匹配时，遵循最左原则。</p><p>我们可以使用<code>explain</code>语句（它可以用于分析select语句的执行计划，也就是MySQL到底是如何在执行某条select语句的）来分析查询语句到底有没有通过索引进行匹配。</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小王&#x27;</span>;<br></code></pre></td></tr></table></figure><p>得到的结果如下：</p><ul><li>select_type：查询类型，上面的就是简单查询（SIMPLE）</li><li>table：查询的表</li><li>type：MySQL决定如何查找对应的记录，效率从高到低：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li><li>possible_keys：执行查询时可能会用到的索引</li><li>key：实际使用的索引</li><li>key_len：Mysql在索引里使用的字节数，字段的最大可能长度</li><li>rows：扫描的行数</li><li>extra：附加说明</li></ul><h3 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h3><p>在了解完了索引的类型之后，我们接着来看看索引是如何实现的。</p><p>既然我们要通过索引来快速查找内容，那么如何设计索引就是我们的重点内容，因为索引是存储在硬盘上的，跟我们之前使用的HashMap之类的不同，它们都是在内存中的，但是硬盘的读取速度远小于内存的速度，每一次IO操作都会耗费大量的时间，我们也不可能把整个磁盘上的索引全部导入内存，因此我们需要考虑尽可能多的减少IO次数，索引的实现可以依靠两种数据结构，一种是我们在JavaSE阶段已经学习过的Hash表，还有一种就是B-Tree。</p><p>我们首先来看看哈希表，实际上就是计算Hash值来快速定位：</p><p><img src="RLDXtxjmAhP5ZGY.jpg" alt="点击查看源网页"></p><p>通过对Key进行散列值计算，我们可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)，但是它也存在一定的缺陷：</p><ul><li>Hash索引仅仅能满足“&#x3D;”，“in”查询条件，不能使用范围查询。</li><li>Hash碰撞问题。</li><li>不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。</li></ul><p>那么，既然要解决这些问题，我们还有一种方案就是使用类似于二叉树那样的数据结构来存储索引，但是这样相比使用Hash索引，会牺牲一定的读取速度。</p><p>但是这里并没有使用二叉树，而是使用了BTree，它是专门为磁盘数据读取设计的一种度为n的查找树：</p><ul><li>树中每个结点最多含有m个孩子（m &gt;&#x3D; 2）</li><li>除根结点和叶子结点外，其它每个结点至少有[ceil(m &#x2F; 2)]个孩子。</li><li>若根结点不是叶子结点，则至少有2个孩子。</li><li>所有叶子结点都出现在同一层。</li><li>每个非终端结点中包含有n个键值信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中：<ol><li>Ki (i&#x3D;1…n)为键值，且键值按顺序升序排序K(i-1)&lt; Ki。</li><li>Pi为指向子树根的结点，且指针P(i)指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)。</li><li>键值的个数n必须满足： [ceil(m &#x2F; 2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。</li></ol></li></ul><p><img src="9o2vKsAf1pdSRQh.jpg" alt="img"></p><p>比如现在我们要对键值为<strong>10</strong>的记录进行查找，过程如下：</p><ol><li>读取根节点数据（目前进行了一次IO操作）</li><li>根据根节点数据进行判断得到10&lt;17，因为P1指向的子树中所有值都是小于17的，所以这时我们将P1指向的节点读取（目前进行了两次IO操作）</li><li>再次进行判断，得到8&lt;10&lt;12，因为P2指向的子树中所有的值都是小于12大于8的，所以这时读取P2指向的节点（目前进行了三次IO操作）</li><li>成功找到。</li></ol><p>我们接着来看，虽然BTree能够很好地利用二叉查找树的思想大幅度减少查找次数，但是它的查找效率还是很低，因此它的优化版本B+Tree诞生了，它拥有更稳定的查询效率和更低的IO读取次数：</p><p><img src="AmeW1GO8SpMjwPt.jpg" alt="img"></p><p>我们可以发现，它和BTree有一定的区别：</p><ul><li>有n棵子树的结点中含有n个键值，BTree只有n-1个。</li><li>所有的键值信息只在叶子节点中包含，非叶子节点仅仅保存子节点的最小（或最大）值，和指向叶子节点的指针，这样相比BTree每一个节点在硬盘中存放了更少的内容（没有键值信息了）</li><li>所有叶子节点都有一个根据大小顺序指向下一个叶子节点的指针Q，本质上数据就是一个链表。</li></ul><p>这样，读取IO的时间相比BTree就减少了很多，并且查询任何键值信息都需要完整地走到叶子节点，保证了查询的IO读取次数一致。因此MySQL默认选择B+Tree作为索引的存储数据结构。</p><p>这是MyISAM存储引擎下的B+Tree实现：</p><p><img src="q346VZgTy9EO5HF.jpg" alt="img"></p><p>这是InnoDB存储引擎下的B+Tree实现：</p><p><img src="p6BTltjD7YE1K9s.jpg" alt="img"></p><p><img src="Jpi1nPND3Wa4bHc.jpg" alt="img"></p><p>InnoDB与MyISAM实现的不同之处：</p><ul><li>数据本身就是索引的一部分（所以这里建议主键使用自增）</li><li>非主键索引的数据实际上存储的是对应记录的主键值（因此InnoDB必须有主键，若没有也会自动查找替代）</li></ul><hr><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>在JavaSE的学习中，我们在多线程板块首次用到了锁机制，当我们对某个方法或是某个代码块加锁后，除非锁的持有者释放当前的锁，否则其他线程无法进入此方法或是代码块，我们可以利用锁机制来保证多线程之间的安全性。</p><p>在MySQL中，就很容易出现多线程同时操作表中数据的情况，如果要避免潜在的并发问题，那么我们可以使用之前讲解的事务隔离级别来处理，而事务隔离中利用了锁机制。</p><ul><li>读未提交(Read Uncommitted)：能够读取到其他事务中未提交的内容，存在脏读问题。</li><li>读已提交(Read Committed RC)：只能读取其他事务已经提交的内容，存在不可重复读问题。</li><li>可重复读(Repeated Read RR)：在读取某行后不允许其他事务操作此行，直到事务结束，但是依然存在幻读问题。</li><li>串行读(Serializable)：一个事务的开始必须等待另一个事务的完成。</li></ul><p>我们可以切换隔离级别分别演示一下：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level read uncommitted;<br></code></pre></td></tr></table></figure><p>在RR级别下，MySQL在一定程度上解决了幻读问题：</p><ul><li>在快照读（不加锁）读情况下，mysql通过mvcc来避免幻读。</li><li>在当前读（加锁）读情况下，mysql通过next-key来避免幻读。</li></ul><blockquote><p>**<code>MVCC</code>**，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><h3 id="读锁和写锁"><a href="#读锁和写锁" class="headerlink" title="读锁和写锁"></a>读锁和写锁</h3><p>从对数据的操作类型上来说，锁分为读锁和写锁：</p><ul><li><strong>读锁：</strong> 也叫共享锁，当一个事务添加了读锁后，其他的事务也可以添加读锁或是读取数据，但是不能进行写操作，只能等到所有的读锁全部释放。</li><li><strong>写锁：</strong> 也叫排他锁，当一个事务添加了写锁后，其他事务不能读不能写也不能添加任何锁，只能等待当前事务释放锁。</li></ul><h3 id="全局锁、表锁和行锁"><a href="#全局锁、表锁和行锁" class="headerlink" title="全局锁、表锁和行锁"></a>全局锁、表锁和行锁</h3><p>从锁的作用范围上划分，分为全局锁、表锁和行锁：</p><ul><li><strong>全局锁：</strong> 锁作用于全局，整个数据库的所有操作全部受到锁限制。</li><li><strong>表锁：</strong> 锁作用于整个表，所有对表的操作都会收到锁限制。</li><li><strong>行锁：</strong> 锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持）</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>我们首先来看全局锁，它作用于整个数据库，我们可以使用以下命令来开启读全局锁：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock;<br></code></pre></td></tr></table></figure><p>开启后，整个数据库被上读锁，我们只能去读取数据，但是不允许进行写操作（包括更新、插入、删除等）一旦执行写操作，会被阻塞，直到锁被释放，我们可以使用以下命令来解锁：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><p>除了手动释放锁之外，当我们的会话结束后，锁也会被自动释放。</p><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁作用于某一张表，也是MyISAM和InnoDB存储引擎支持的方式，我们可以使用以下命令来为表添加锁：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock <span class="hljs-keyword">table</span> 表名称 read<span class="hljs-operator">/</span>write;<br></code></pre></td></tr></table></figure><p>在我们为表添加写锁后，我们发现其他地方是无法访问此表的，一律都被阻塞。</p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>表锁的作用范围太广了，如果我们仅仅只是对某一行进行操作，那么大可不必对整个表进行加锁，因此<code>InnoDB</code>支持了行锁，我们可以使用以下命令来对某一行进行加锁：</p><p>​                              </p><p>​        sql        复制代码      </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加读锁（共享锁）</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-comment">-- 添加写锁（排他锁）</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>使用InnoDB的情况下，在执行更新、删除、插入操作时，数据库也会自动为所涉及的行添加写锁（排他锁），直到事务提交时，才会释放锁，执行普通的查询操作时，不会添加任何锁。使用MyISAM的情况下，在执行更新、删除、插入操作时，数据库会对涉及的表添加写锁，在执行查询操作时，数据库会对涉及的表添加读锁。</p><p><strong>提问：</strong> 当我们不使用id进行选择，行锁会发生什么变化？（行锁升级）</p><h3 id="记录锁、间隙锁和临键锁"><a href="#记录锁、间隙锁和临键锁" class="headerlink" title="记录锁、间隙锁和临键锁"></a>记录锁、间隙锁和临键锁</h3><p>我们知道InnoDB支持使用行锁，但是行锁比较复杂，它可以继续分为多个类型。</p><h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><p>（Record Locks）记录锁, 仅仅锁住索引记录的一行，在单条索引记录上加锁。Record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加写锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>（Gap Locks）仅仅锁住一个索引区间（开区间，不包括双端端点）。在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。比如在 1、2中，间隙锁的可能值有 (-∞, 1)，(1, 2)，(2, +∞)，间隙锁可用于防止幻读，保证索引间的不会被插入数据。</p><h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h4><p>（Next-Key Locks）Record lock + Gap lock，左开右闭区间。默认情况下，<code>InnoDB</code>正是使用Next-key Locks来锁定记录（如select … for update语句）它还会根据场景进行灵活变换：</p><table><thead><tr><th align="left">场景</th><th>转换</th></tr></thead><tbody><tr><td align="left">使用唯一索引进行精确匹配，但表中不存在记录</td><td>自动转换为 Gap Locks</td></tr><tr><td align="left">使用唯一索引进行精确匹配，且表中存在记录</td><td>自动转换为 Record Locks</td></tr><tr><td align="left">使用非唯一索引进行精确匹配</td><td>不转换</td></tr><tr><td align="left">使用唯一索引进行范围匹配</td><td>不转换，但是只锁上界，不锁下界</td></tr></tbody></table><p><a href="https://zhuanlan.zhihu.com/p/48269420">https://zhuanlan.zhihu.com/p/48269420</a></p><p>————————————————</p><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/vkpmw9wbej21nei6">https://www.itbaima.cn/document/vkpmw9wbej21nei6</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 容器技术</title>
    <link href="/post/4fd66ff9-ef1e-4a91-912a-4271ef291763/"/>
    <url>/post/4fd66ff9-ef1e-4a91-912a-4271ef291763/</url>
    
    <content type="html"><![CDATA[<h3 id="Docker-容器技术"><a href="#Docker-容器技术" class="headerlink" title="Docker 容器技术"></a>Docker 容器技术</h3><p><code>hexo template generate by typora plugin templater</code></p><p><img src="docker-1720456734236-247.jpg" alt="Docker 容器技术"></p><h1 id="Docker容器技术"><a href="#Docker容器技术" class="headerlink" title="Docker容器技术"></a>Docker容器技术</h1><p>Docker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：<strong>Java SpringBoot 篇</strong>（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。</p><p><strong>Docker官网：</strong> <a href="https://www.docker.com/">https://www.docker.com</a></p><p><strong>课前准备：</strong> 配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。</p><h2 id="容器技术入门"><a href="#容器技术入门" class="headerlink" title="容器技术入门"></a>容器技术入门</h2><p>随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？</p><p>包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。</p><p>真的有这么神奇吗？我们来试试看。</p><h3 id="环境安装和部署"><a href="#环境安装和部署" class="headerlink" title="环境安装和部署"></a>环境安装和部署</h3><p>首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用：</p><ul><li>Ubuntu 22.04 操作系统</li></ul><p>Docker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><p>首先安装一些工具：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install ca-certificates curl gnupg lsb-release<br></code></pre></td></tr></table></figure><p>不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings<br><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br></code></pre></td></tr></table></figure><p>最后将Docker的库添加到apt资源列表中：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>接着我们更新一次apt：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br></code></pre></td></tr></table></figure><p>最后安装Docker CE版本：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install docker-ce<br></code></pre></td></tr></table></figure><p>等待安装完成就可以了：</p><p><img src="D1GXAQdUsgmTawq.jpg" alt="image-20220630161240162"></p><p><img src="oI26yQiqhABN3UP.jpg" alt="image-20220630161341541"></p><p>可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo usermod -aG docker &lt;用户名&gt;<br></code></pre></td></tr></table></figure><p>配置好后，我们先退出SSH终端，然后重新连接就可以生效了。</p><p>这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker run -d -p 80:80 nginx<br></code></pre></td></tr></table></figure><p><img src="sPVpLI9bXlzdKeO.jpg" alt="image-20220630165259663"></p><p>首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看：</p><p><img src="fP5TsQnqUbmXoaA.jpg" alt="image-20220630165430159"></p><p><img src="lPZYrUn2D1gNjx8.jpg" alt="image-20220630165440751"></p><p>可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。</p><h3 id="从虚拟机到容器"><a href="#从虚拟机到容器" class="headerlink" title="从虚拟机到容器"></a>从虚拟机到容器</h3><p>前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。</p><p>在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核：</p><p><img src="DPxA9MsZ3WGl62X.jpg" alt="image-20220630171220207"></p><p>我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多：</p><p><img src="cKlhRZ9Sw1Q4uEX.jpg" alt="image-20220630172135408"></p><p>并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在）</p><p>服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。</p><p>所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。</p><p>虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件：</p><p><img src="St3hfELQHNdRZmA.jpg" alt="image-20220630173915254"></p><p>我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样：</p><p><img src="BmnC1xETQM4uRHO.jpg" alt="image-20220630174945749"></p><p>相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。</p><p>实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。</p><p>那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。</p><p>容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。</p><p><img src="31GZSh5DE9Vilet.jpg" alt="image-20220630181037698"></p><p>因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。</p><p>不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。</p><p>而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。</p><p><img src="NTnU8iSj51CspFw.jpg" alt="image-20220630182136717"></p><p>而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。</p><h3 id="容器工作机制简述"><a href="#容器工作机制简述" class="headerlink" title="容器工作机制简述"></a>容器工作机制简述</h3><p>我们先来看看Docker的整体架构：</p><p><img src="PeaxwNQXkiYSlUv.jpg" alt="image-20220630184857540"></p><p>实际上分为三个部分：</p><ul><li>Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。</li><li>Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。</li><li>Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。</li></ul><p>当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker run -d -p 80:80 nginx<br></code></pre></td></tr></table></figure><p>实际上这个命令输入之后：</p><ol><li>Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。</li><li>Docker服务端先看看本地有没有这个镜像，发现没有。</li><li>接着只能从公共仓库Docker Hub去查找下载镜像了。</li><li>下载完成，镜像成功保存到本地。</li><li>Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响）</li></ol><p>所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。</p><p>不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。</p><p>从下一章开始，我们就正式地来学习一下Docker的各种操作。</p><hr><h2 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h2><p>要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。</p><h3 id="初识容器镜像"><a href="#初识容器镜像" class="headerlink" title="初识容器镜像"></a>初识容器镜像</h3><p>首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull hello-world<br></code></pre></td></tr></table></figure><p>只需要输入<code>pull</code>命令，就可以直接下载到指定的镜像了：</p><p><img src="tZ4S2HYvNKr7qiD.jpg" alt="image-20220701111043417"></p><p>可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是<code>repository</code>，还有一个是<code>tag</code>，一般情况下约定<code>repository</code>就是镜像名称，<code>tag</code>作为版本，默认为latest，表示最新版本。所以指定版本运行的话：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 名称:版本<br></code></pre></td></tr></table></figure><p>之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。</p><p>镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入<code>run</code>命令就可以了：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run hello-world<br></code></pre></td></tr></table></figure><p>当然如果仅仅是只想创建而不想马上运行的话，可以使用<code>create</code>命令：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker create hello-world<br></code></pre></td></tr></table></figure><p>可以看到成功启动了：</p><p><img src="Brl4cnK8WsjP7LV.jpg" alt="image-20220701111314331"></p><p>启动之后，会使用当前镜像自动创建一个容器，我们可以输入<code>ps</code>命令来查看当前容器的容器列表：</p><p>​                              </p><p>​                复制代码      </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p>注意后面要加一个<code>-a</code>表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了：</p><p><img src="zMN3TPR7aHu5YGb.jpg" alt="image-20220701111840091"></p><p>可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。</p><p>我们可以手动指定名称启动，在使用<code>run</code>命令时，添加<code>--name</code>参数即可：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name=lbwnb hello-world<br></code></pre></td></tr></table></figure><p><img src="qOblnhr5CJiIBG6.jpg" alt="image-20220701125951980"></p><p>我们可以手动开启处于停止状态的容器：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker start &lt;容器名称/容器ID&gt;<br></code></pre></td></tr></table></figure><p>注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。</p><p><img src="XfFORtqhK9lcBi7.jpg" alt="image-20220701124845982"></p><p>如果想要停止容器直接输入<code>stop</code>命令就可以了：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker stop &lt;容器名称/容器ID&gt;<br></code></pre></td></tr></table></figure><p>或是重启：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker restart &lt;容器名称/容器ID&gt;<br></code></pre></td></tr></table></figure><p><img src="Q2tor6KRIeUEhO4.jpg" alt="image-20220701125025173"></p><p>如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> &lt;容器名称/容器ID&gt;<br></code></pre></td></tr></table></figure><p>当然如果我们希望容器在停止后自动删除，我们可以在运行时添加<code>--rm</code>参数：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --<span class="hljs-built_in">rm</span> 镜像名称<br></code></pre></td></tr></table></figure><p><img src="3MlPUpjoV1Qg8DX.jpg" alt="image-20220701125108834"></p><p>删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像：</p><p><img src="bmHqND36yCUBPVj.jpg" alt="image-20220701125204728"></p><p>我们可以使用<code>images</code>命令来检查一下当前本地有那些镜像：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker images<br></code></pre></td></tr></table></figure><p><img src="fEscbGJXw4e7YFK.jpg" alt="image-20220701125514145"></p><p>至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。</p><h3 id="镜像结构介绍"><a href="#镜像结构介绍" class="headerlink" title="镜像结构介绍"></a>镜像结构介绍</h3><p>前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。</p><p>我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。</p><p>一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull centos<br></code></pre></td></tr></table></figure><p><img src="oFKxiMzA3fs2aIl.jpg" alt="image-20220701132622893"></p><p>可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制：</p><p><img src="dvmqAjKHkucbLFh.jpg" alt="image-20220701133111829"></p><p>Linux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加<code>bootfs</code>文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分：</p><ul><li>bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。</li><li>rootfs则包含了系统上的常见的目录结构，包括<code>/dev</code>、<code> /proc</code>、 <code>/bin</code>等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。</li></ul><p>base镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。</p><p>使用<code>uname</code>命令可以查看当前内核版本：</p><p><img src="mZjupCUktL7Ab2R.jpg" alt="image-20220701135056123"></p><p>因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -it centos<br></code></pre></td></tr></table></figure><p>注意这里需要添加<code>-it</code>参数进行启动，其中<code>-i</code>表示在容器上打开一个标准的输入接口，<code>-t</code>表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。</p><p><img src="13BYcCWHsDMrwvq.jpg" alt="image-20220701135834325"></p><p>可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本：</p><p><img src="PtGwRWfXlTh67qm.jpg" alt="image-20220701140018095"></p><p>可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入<code>exit</code>就可以退出容器终端了，可以看到退出后容器也停止了：</p><p><img src="u5MQnWVihlbkyx1.jpg" alt="image-20220701140225415"></p><p>当然我们也可以再次启动，注意启动的时候要加上<code>-i</code>才能进入到容器进行交互，否则会在后台运行：</p><p><img src="QCsY5EyGSja6Khl.jpg" alt="image-20220701140706977"></p><p>基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的：</p><p><img src="SDwEqz2b7lA9nJa.jpg" alt="image-20220701143105247"></p><p>每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？</p><p>我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？</p><p>我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下：</p><ul><li>文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。</li><li>文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。</li><li>删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。</li></ul><p>也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用<code>commit</code>命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。</p><p>这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像）</p><p>咱们先启动Ubuntu镜像，然后使用<code>yum</code>命令（跟apt比较类似）来安装Java环境，首先是<code>run</code>命令：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull ubuntu<br></code></pre></td></tr></table></figure><p><img src="tP5rhQuqfpxcRHL.jpg" alt="image-20220701151405640"></p><p>接着启动：</p><p><img src="l86G4dK71UwcZPi.jpg" alt="image-20220701151433520"></p><p>直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包：</p><p><img src="RAzQr7P8C9aJwxK.jpg" alt="image-20220701151600847"></p><p>接着输入：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>等待安装完成：</p><p><img src="Fezitl7PDb19BL4.jpg" alt="image-20220701152018041"></p><p>这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像：</p><p><img src="LAIx5GYCJhsbmSo.jpg" alt="image-20220701152130041"></p><p>使用<code>commit</code>命令可以将容器保存为新的镜像：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker commit 容器名称/ID 新的镜像名称<br></code></pre></td></tr></table></figure><p><img src="sbWLlEoMj2ZPcUV.jpg" alt="image-20220701152302171"></p><p><img src="3q4juA8vOJew9W6.jpg" alt="image-20220701152418060"></p><p>可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。</p><p>我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为<code>Dockerfile</code>的文件：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">touch</span> Dockerfile<br></code></pre></td></tr></table></figure><p>接着我们来进行编辑，<code>Dockerfile</code>内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息：</p><p>​                              </p><p>​        dockerfile        复制代码      </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> &lt;基础镜像&gt;<br></code></pre></td></tr></table></figure><p>首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用<code>ubuntu</code>作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用<code>scratch</code>表示从零开始构建，这里就不演示了。</p><p>基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用<code>RUN</code>指令：</p><p>​                              </p><p>​        dockerfile        复制代码      </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y openjdk-8-jdk</span><br></code></pre></td></tr></table></figure><p>每条指令执行之后，都会生成一个新的镜像层。</p><p>OK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t &lt;镜像名称&gt; &lt;构建目录&gt;<br></code></pre></td></tr></table></figure><p>执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令：</p><p><img src="g6RFwA5t4EsdvnY.jpg" alt="image-20220701155443170"></p><p>构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括<code>pull</code>时也会有类似的机制）</p><p><img src="foLHIZScQ1KVbvC.jpg" alt="image-20220701155812315"></p><p>最后成功安装，会出现在本地：</p><p><img src="95ueUgyaTcrz6Mi.jpg" alt="image-20220701155847721"></p><p>可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用<code>history</code>命令来查看构建历史：</p><p><img src="GYyHFcjSKJwvWi6.jpg" alt="image-20220701160128689"></p><p>可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过<code>commit</code>命令来生成的镜像没有这个记录：</p><p><img src="qWUeSF3aKrvwJ8p.jpg" alt="image-20220701160406891"></p><p>如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了：</p><p><img src="STmdFvBIbN4VAl1.jpg" alt="image-20220701161546279"></p><p>有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。</p><h3 id="发布镜像到远程仓库"><a href="#发布镜像到远程仓库" class="headerlink" title="发布镜像到远程仓库"></a>发布镜像到远程仓库</h3><p>前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：<a href="https://hub.docker.com/repositories%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%B4%A6%E5%8F%B7%E7%9A%84%E5%85%88%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C%E3%80%82">https://hub.docker.com/repositories，没有账号的先去进行注册。</a></p><p><img src="3T8xJLgER4cWuQq.jpg" alt="image-20220701164609666"></p><p>点击右上角的创建仓库，然后填写信息：</p><p><img src="SkCKJmU6Rw2lfzP.jpg" alt="image-20220701164939268"></p><p>创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用<code>tag</code>命令来重新打标签：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag ubuntu-java-file:latest 用户名/仓库名称:版本<br></code></pre></td></tr></table></figure><p>这里我们将版本改成1.0版本吧，不用默认的latest了。</p><p><img src="chAPS2DFW5q7GkE.jpg" alt="image-20220701165231001"></p><p>修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下：</p><p><img src="T3YC4pfaLEo85Oz.jpg" alt="image-20220701165446859"></p><p>登录成功后我们就可以上传了：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push nagocoler/ubuntu-java:1.0<br></code></pre></td></tr></table></figure><p><img src="CXoBhpZUl79aDRQ.jpg" alt="image-20220701165744647"></p><p>哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了：</p><p><img src="3UD9y8frEIX1JY6.jpg" alt="image-20220701165920060"></p><p><img src="9sVSjcGCo5mTu61.jpg" alt="image-20220701170053250"></p><p>注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用<code>search</code>命令即可：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker search nagocoler/ubuntu-java<br></code></pre></td></tr></table></figure><p><img src="SIUpBOzN5vsiydn.jpg" alt="image-20220701170253126"></p><p>我们可以使用pull命令将其下载下来：</p><p>​                              </p><p>​        sh        复制代码      </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull nagocoler/ubuntu-java:1.0<br></code></pre></td></tr></table></figure><p><img src="uXBk3WPsDM4aZKo.jpg" alt="image-20220701171148334"></p><p>上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看：</p><p><img src="RJVdstMnxjSYFoW.jpg" alt="image-20220701171253440"></p><p>当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。</p><p>Docker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。</p><p> 前往下一部分继续阅读，当前位于 1 &#x2F; 3 分段</p><p>————————————————</p><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/zj9uvg0sp3b0sok8">https://www.itbaima.cn/document/zj9uvg0sp3b0sok8</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-行为型</title>
    <link href="/post/1c1b547d-7703-4fbf-a6ac-730f751693e2/"/>
    <url>/post/1c1b547d-7703-4fbf-a6ac-730f751693e2/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式-行为型"><a href="#设计模式-行为型" class="headerlink" title="设计模式-行为型"></a>设计模式-行为型</h3><p><code>hexo template generate by typora plugin templater</code></p><p><img src="CratwlYFIfVnH7q-1720456464219-241.jpg" alt="image-20230301112135747"></p><h1 id="设计模式（行为型）"><a href="#设计模式（行为型）" class="headerlink" title="设计模式（行为型）"></a>设计模式（行为型）</h1><p>前面我们已经学习了12种设计模式，分为两类：</p><ul><li>创建型：关注对象创建</li><li>结构型：关注类和对象的结构组织</li></ul><p>我们接着来看最后一种设计模式，也是最多的一种，行为型设计模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>这种模式的使用场景较少，很少使用的一种设计模式，这里提一下就行。</p><p>解释器顾名思义，就是对我们的语言进行解释，根据不同的语义来做不同的事情，比如我们在SE中学习的双栈计算器，正是根据我们输入的算式，去进行解析，并根据不同的运算符来不断进行计算。</p><p>比如我们输入：1+2*3</p><p>那么计算器就会进行解析然后根据语义优先计算2*3的结果然后在计算1+6最后得到7，详细实现请参考JavaSE篇双栈计算器实现。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式我们之前也见到过许多，我们先来看看什么是模板方法。</p><p>有些时候，我们的业务可能需要经历很多个步骤来完成，比如我们生病了在医院看病，首先是去门诊挂号，然后等待叫号，然后是去找医生看病，确定病因后，就根据医生的处方去前台开药，最后付钱。这一整套流程看似是规规矩矩的，但是在这其中，某些步骤并不是确定的，比如医生看病这一步，由于不同的病因，可能会进行不同的处理，最后开出来的药方也会不同，所以，整套流程中，有些操作是固定的，有些操作可能需要根据具体情况而定。</p><p><img src="PjOsmFXyI2Cl3pU.jpg" alt="image-20230301112153648"></p><p>在我们的程序中也是如此，可能某些操作是固定的，我们就可以直接在类中对应方法进行编写，但是可能某些操作需要视情况而定，由不同的子类实现来决定，这时，我们就需要让这些操作由子类来延迟实现了。现在我们就需要用到模板方法模式。</p><p>我们先来写个例子：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象诊断方法，因为现在只知道挂号和看医生是固定模式，剩下的开处方和拿药都是不确定的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDiagnosis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天头好晕，不想起床，开摆，先跟公司请个假&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;去医院看病了~&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1 &gt;&gt; 先挂号&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;2 &gt;&gt; 等待叫号&quot;</span>);<br>        <span class="hljs-comment">//由于现在不知道该开什么处方，所以只能先定义一下行为，然后具体由子类实现</span><br>      <span class="hljs-comment">//大致的流程先定义好就行</span><br>        <span class="hljs-built_in">this</span>.prescribe();<br>        <span class="hljs-built_in">this</span>.medicine();  <span class="hljs-comment">//开药同理</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prescribe</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//开处方操作根据具体病症决定了</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">medicine</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//拿药也是根据具体的处方去拿</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们定义好了抽象方法，只是将具体的流程先定义出来了，但是部分方法需要根据实现决定：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 感冒相关的具体实现子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColdDiagnosis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDiagnosis</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prescribe</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;3 &gt;&gt; 一眼丁真，鉴定为假，你这不是感冒，纯粹是想摆烂&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">medicine</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;4 &gt;&gt; 开点头孢回去吃吧&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就有了一个具体的实现类，并且由于看病的逻辑已经由父类定义好了，所以子类只需要实现需要实现的部分即可，这样我们就实现了简单的模板方法模式：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AbstractDiagnosis</span> <span class="hljs-variable">diagnosis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColdDiagnosis</span>();<br>    diagnosis.test();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="IVyz42i1brvUWfl.jpg" alt="image-20230301112206668"></p><p>最后我们来看看在JUC中讲解AQS源码实现中出现的代码：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;    <span class="hljs-comment">//AQS的锁释放操作</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;   <span class="hljs-comment">//可以看到这里调用了tryRelease方法，但是此方法并不是在AQS实现的，而是不同的锁自行实现，因为AQS也不知道你这种类型的锁到底该怎么去解锁</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   <span class="hljs-comment">//AQS中不支持，需要延迟到具体的子类去实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法模式，实际上部分功能的实现是在子类完成的：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;   <br>  <span class="hljs-comment">//ReentrantLock中的AQS Sync实现类，对tryRelease方法进行了具体实现</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是现在感觉，这种层层套娃的写法，好像并不是这些大佬故意为了装逼才这样写的，而是真的在遵守规范编写，让代码更易懂一些，甚至你现在再回去推一遍会发现思路非常清晰。当然，除了这里之外，还有很多框架都使用了模板方法模式来设计类结构，还请各位小伙伴自行探索。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式也非常好理解，比如我们的钉钉审批，实际上就是一条流水线一样的操作，由你发起申请，然后经过多个部门主管审批，最后才能通过，所以你的申请表相当于是在一条责任链上传递。当然除了这样的直线型责任链之外，还有环形、树形等。</p><p><img src="l4C6SmDYKb2QeTi.jpg" alt="image-20230301112223069"></p><p>实际上我们之前也遇到过很多种责任链，比如JavaWeb中学习的Filter过滤器，正是采用的责任链模式，通过将请求一级一级不断向下传递，来对我们所需要的请求进行过滤和处理。</p><p><img src="gO5IUmS17tQouAh.jpg" alt="image-20230301112235576"></p><p>这里我们就使用责任链模式来模拟一个简单的面试过程，我们面试也是一面二面三面这样走的流程，这里我们先设计一下责任链上的各个处理器：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> Handler successor;    <span class="hljs-comment">//这里我们就设计责任链以单链表形式存在，这里存放后继节点</span><br><br>    <span class="hljs-keyword">public</span> Handler <span class="hljs-title function_">connect</span><span class="hljs-params">(Handler successor)</span>&#123;     <span class="hljs-comment">//拼接后续节点</span><br>        <span class="hljs-built_in">this</span>.successor = successor;<br>        <span class="hljs-keyword">return</span> successor;  <span class="hljs-comment">//这里返回后继节点，方便我们一会链式调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.doHandle();   <span class="hljs-comment">//由不同的子类实现具体处理过程</span><br>        Optional<br>                .ofNullable(successor)<br>                .ifPresent(Handler::handle);    <span class="hljs-comment">//责任链上如果还有后继节点，就继续向下传递</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//结合上节课学习的模板方法，交给子类实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为面试有很多轮，所以我们这里创建几个处理器的实现：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;   <span class="hljs-comment">//用于一面的处理器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;============= 白马程序员一面 ==========&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1. 谈谈你对static关键字的理解？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;2. 内部类可以调用外部的数据吗？如果是静态的呢？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;3. hashCode()方法是所有的类都有吗？默认返回的是什么呢？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;  <span class="hljs-comment">//二面</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;============= 白马程序员二面 ==========&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1. 如果我们自己创建一个java.lang包并且编写一个String类，能否实现覆盖JDK默认的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;2. HashMap的负载因子有什么作用？变化规律是什么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;3. 线程池的运作机制是什么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;4. ReentrantLock公平锁和非公平锁的区别是什么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandle</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;============= 白马程序员三面 ==========&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1. synchronized关键字了解吗？如何使用？底层是如何实现的？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;2. IO和NIO的区别在哪里？NIO三大核心组件？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;3. TCP握手和挥手流程？少一次握手可以吗？为什么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;4. 操作系统中PCB是做什么的？运行机制是什么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就编写好了每一轮的面试流程，现在我们就可以构建一个责任链了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstHandler</span>();  <span class="hljs-comment">//一面首当其冲</span><br>    handler<br>            .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondHandler</span>())   <span class="hljs-comment">//继续连接二面和三面</span><br>            .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdHandler</span>());<br>    handler.handle();   <span class="hljs-comment">//开始面试</span><br>&#125; <br></code></pre></td></tr></table></figure><p>可以看到最后结果也是按照我们的责任链来进行的。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>大家有没有发现现在的家电都在趋向于智能化，通过一个中央控制器，我们就可以对家里的很多电器进行控制，比如国内做的比较好的小米智能家居系列，还有Apple的HomeKit等，我们只需要在一个终端上进行操作，就可以随便控制家里的电器。</p><p><img src="SuaYPFW4kojctM6.jpg" alt="image-20230301112308454"></p><p>比如现在我们有很多的类，彩电、冰箱、空调、洗衣机、热水器等，既然现在我们要通过一个遥控器去控制他们，那么我们就需要将控制这些电器的指令都给设计好才行，并且还不能有太强的关联性。</p><p>所有的电器肯定需要通过蓝牙或是红外线接受遥控器发送的请求，所以所有的电器都是接收者：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//具体行为，这里就写一个算了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们要控制这些电器，那么肯定需要一个指令才能控制：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;   <span class="hljs-comment">//指令抽象，不同的电器有指令</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Receiver receiver;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Command</span><span class="hljs-params">(Receiver receiver)</span>&#123;   <span class="hljs-comment">//指定此命令对应的电器（接受者）</span><br>        <span class="hljs-built_in">this</span>.receiver = receiver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.action();   <span class="hljs-comment">//执行命令，实际上就是让接收者开始干活</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来安排一个遥控器：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller</span> &#123;   <span class="hljs-comment">//遥控器只需要把我们的指令发出去就行了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">(Command command)</span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们创建一个空调，那么它就是作为我们命令的接收者：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AirConditioner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Receiver</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;空调已开启，呼呼呼&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们创建一个开启空调的命令：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OpenCommand</span><span class="hljs-params">(AirConditioner airConditioner)</span> &#123;<br>        <span class="hljs-built_in">super</span>(airConditioner);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们只需要通过遥控器发送出去就可以了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AirConditioner</span> <span class="hljs-variable">airConditioner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirConditioner</span>();   <span class="hljs-comment">//先创建一个空调</span><br>    Controller.call(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenCommand</span>(airConditioner));   <span class="hljs-comment">//直接通过遥控器来发送空调开启命令</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，遥控器这个角色并不需要知道具体会执行什么，只需要发送命令即可，遥控器和电器的关联性就不再那么强了。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器我们在JavaSE篇就已经讲解过了，迭代器可以说是我们学习Java语言的基础，没有迭代器，集合类的遍历就成了问题，正是因为有迭代器的存在，我们才能更加优雅的使用foreach语法。</p><p>回顾我们之前使用迭代器的场景：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;   <span class="hljs-comment">//使用foreach语法糖进行迭代，依次获取每一个元素</span><br>        System.out.println(s);   <span class="hljs-comment">//打印一下</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后的代码如下：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> list.iterator();   <span class="hljs-comment">//实际上这里本质是通过List生成的迭代器来遍历我们每个元素的</span><br><br>    <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;   <span class="hljs-comment">//判断是否还有元素可以迭代，没有就false</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var2.next();   <span class="hljs-comment">//通过next方法得到下一个元素，每调用一次，迭代器会向后移动一位</span><br>        System.out.println(s);    <span class="hljs-comment">//打印一下</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当我们使用迭代器对List进行遍历时，实际上就像一个指向列表头部的指针，我们通过不断向后移动指针来依次获取所指向的元素：</p><p><img src="RjZSDFcPm4q7odM.jpg" alt="image-20230301112320947"></p><p><img src="B7P3OlIQz8wgTAR.jpg" alt="image-20230301112329551"></p><p>这里，我们依照JDK提供的迭代器接口（JDK已经为我们定义好了一个迭代器的具体相关操作），也来设计一个迭代器：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayCollection</span>&lt;T&gt; &#123;    <span class="hljs-comment">//首先设计一个简单的数组集合，一会我们就迭代此集合内的元素</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T[] array;   <span class="hljs-comment">//底层使用一个数组来存放数据</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ArrayCollection</span><span class="hljs-params">(T[] array)</span>&#123;   <span class="hljs-comment">//private掉，自己用</span><br>        <span class="hljs-built_in">this</span>.array = array;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; ArrayCollection&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T[] array)</span>&#123;   <span class="hljs-comment">//开个静态方法直接吧数组转换成ArrayCollection，其实和直接new一样，但是这样写好看一点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayCollection</span>&lt;&gt;(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以将数据存放在此集合中了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;DDD&quot;</span>&#125;;<br>    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们就可以来实现迭代器接口了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayCollection</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt;&#123;   <span class="hljs-comment">//实现Iterable接口表示此类是支持迭代的</span><br><br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//需要实现iterator方法，此方法会返回一个迭代器，用于迭代我们集合中的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;   <span class="hljs-comment">//这里实现一个，注意别用静态，需要使用对象中存放的数组</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//这里我们通过一个指针表示当前的迭代位置</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;     <span class="hljs-comment">//判断是否还有下一个元素</span><br>            <span class="hljs-keyword">return</span> cur &lt; array.length;   <span class="hljs-comment">//如果指针大于或等于数组最大长度，就不能再继续了</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//返回当前指针位置的元素并向后移动一位</span><br>            <span class="hljs-keyword">return</span> array[cur++];   <span class="hljs-comment">//正常返回对应位置的元素，并将指针自增</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们就可以对我们自己编写的一个简单集合类进行迭代了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;DDD&quot;</span>&#125;;<br>    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);<br>    <span class="hljs-keyword">for</span> (String s : collection) &#123;    <span class="hljs-comment">//可以直接使用foreach语法糖，当然最后还是会变成迭代器调用</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编译出来的样子：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;DDD&quot;</span>&#125;;<br>    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> collection.iterator();   <span class="hljs-comment">//首先获取迭代器，实际上就是调用我们实现的iterator方法</span><br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var3.next();   <span class="hljs-comment">//直接使用next()方法不断向下获取</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就实现了一个迭代器来遍历我们的元素。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>在早期，我们想要和别人进行语音聊天，一般都是通过电话的方式，我们通过拨打他人的电话号码，来建立会话，不过这样有一个问题，比如我现在想要通知通知3个人某件事情，那么我就得依次给三个人打电话，甚至还会遇到一种情况，就是我们没有某个人的电话号码，但是其他人有，这时还需要告知这个人并进行转告，就很麻烦。</p><p><img src="UoChEBnujTDMGpF.jpg" alt="image-20230301112503997"></p><p>但是现在我们有了Facetime、有了微信，我们可以同时让多个人参与到群通话中进行群聊，这样我们就不需要一个一个单独进行通话或是转达了。实际上正是依靠了一个中间商给我们提供了进行群体通话的平台，我们才能实现此功能，而这个平台实际上就是一个中间人。又比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢？于是我们就会上各大租房APP上去找房源，同样的，如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房APP上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上也是一种中介的模式。</p><p>在我们的程序中，可能也会出现很多的对象，但是这些对象之间的相互调用关系错综复杂，可能一个对象要做什么事情就得联系好几个对象：</p><p><img src="Pobq2ZB1dyExNs9.jpg" alt="image-20230301112515239"></p><p>但是如果我们在这中间搞一个中间人：</p><p><img src="fru13VTnkDS2y4v.jpg" alt="image-20230301112526146"></p><p>这样当我们要联系其他人时，一律找中介就可以了，中介存储了所有人的联系方式，这样就不会像上面一样乱成一团了。这里我们就以房产中介的例子来编写：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;   <span class="hljs-comment">//房产中介</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, User&gt; userMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();   <span class="hljs-comment">//在出售的房子需要存储一下</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String address, User user)</span>&#123;   <span class="hljs-comment">//出售房屋的人，需要告诉中介他的房屋在哪里</span><br>        userMap.put(address, user);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">find</span><span class="hljs-params">(String address)</span>&#123;   <span class="hljs-comment">//通过此方法来看看有没有对应的房源</span><br>        <span class="hljs-keyword">return</span> userMap.get(address);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是用户了，用户有两种角色，一种是租房，一种是出租：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;   <span class="hljs-comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span><br>    String name;<br>    String tel;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String tel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.tel = tel;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">find</span><span class="hljs-params">(String address, Mediator mediator)</span>&#123;   <span class="hljs-comment">//找房子的话，需要一个中介和你具体想找的地方</span><br>        <span class="hljs-keyword">return</span> mediator.find(address);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot; (电话：&quot;</span>+tel+<span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来测试一下：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;刘女士&quot;</span>, <span class="hljs-string">&quot;10086&quot;</span>);   <span class="hljs-comment">//出租人</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;李先生&quot;</span>, <span class="hljs-string">&quot;10010&quot;</span>);   <span class="hljs-comment">//找房人</span><br>    <span class="hljs-type">Mediator</span> <span class="hljs-variable">mediator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mediator</span>();   <span class="hljs-comment">//我是黑心中介</span><br><br>    mediator.register(<span class="hljs-string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, user0);   <span class="hljs-comment">//先把房子给中介挂上去</span><br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> user1.find(<span class="hljs-string">&quot;成都市武侯区天府五街下硅谷&quot;</span>, mediator);  <span class="hljs-comment">//开始找房子</span><br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>) System.out.println(<span class="hljs-string">&quot;没有找到对应的房源&quot;</span>);<br><br>    user = user1.find(<span class="hljs-string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, mediator);  <span class="hljs-comment">//开始找房子</span><br>    System.out.println(user);   <span class="hljs-comment">//成功找到对应房源</span><br>&#125;<br></code></pre></td></tr></table></figure><p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系，更容易理解一些。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote><p>2021年10月1日下午，河南驻马店的一名13岁女中学生，因和同学发生不愉快喝下半瓶百草枯。</p><p>10月5日，抢救四天情况恶化，家属泣不成声称“肺部一个小时一变”。</p><p>10月6日下午，据武警河南省总队医院消息，“目前女孩仍在医院救治。”</p></blockquote><p>喝下百草枯，会给你后悔的时间，但是不会给你后悔的机会（百草枯含有剧毒物质，会直接导致肺部纤维化，这是不可逆的，一般死亡过程在一周左右，即使家里花了再多的钱，接受了再多的治疗，也无法逆转这一过程）相信如果再给这位小女孩一次机会，回到拿起百草枯的那一刻，一定不会再冲动地喝下了吧。</p><p><img src="PnkvjD7GORWNCaZ.jpg" alt="image-20230301112608808"></p><p>备忘录模式，就为我们的软件提供了一个可回溯的时间节点，可能我们程序在运行过程中某一步出现了错误，这时我们就可以回到之前的某个被保存的节点上重新来过（就像艾克的大招），我们平时编辑文本的时候，当我们编辑出现错误时，就需要撤回，而我们只需要按下<code>Ctrl+Z</code>就可以回到上一步，这样就大大方便了我们的文本编辑。</p><p>其实备忘录模式也可以应用到我们的程序中，如果你学习过安卓开发，安卓程序在很多情况下都会重新加载<code>Activity</code>，实际上安卓中<code>Activity</code>的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>就是用到了备忘录模式，分别用于保存和恢复，这样就算重新加载也可以恢复到之前的状态。</p><p>这里我们就模拟一下对象的状态保存：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String currentWork;   <span class="hljs-comment">//当前正在做的事情</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> percentage;   <span class="hljs-comment">//当前的工作完成百分比</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(String currentWork)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currentWork = currentWork;<br>        <span class="hljs-built_in">this</span>.percentage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我现在正在做：&quot;</span>+currentWork+<span class="hljs-string">&quot; (进度：&quot;</span>+percentage+<span class="hljs-string">&quot;%)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要保存它在某一时刻的状态，我们来编写一个状态保存类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">final</span> String currentWork;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> percentage;<br><br>    State(String currentWork, <span class="hljs-type">int</span> percentage) &#123;   <span class="hljs-comment">//仅开放给同一个包下的Student类使用</span><br>        <span class="hljs-built_in">this</span>.currentWork = currentWork;<br>        <span class="hljs-built_in">this</span>.percentage = percentage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来将状态的保存和恢复操作都实现一下：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(currentWork, percentage);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">(State state)</span>&#123;<br>        <span class="hljs-built_in">this</span>.currentWork = state.currentWork;<br>        <span class="hljs-built_in">this</span>.percentage = state.percentage;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来测试一下吧：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.work(<span class="hljs-string">&quot;学Java&quot;</span>);   <span class="hljs-comment">//开始学Java</span><br>    System.out.println(student);<br><br>    <span class="hljs-type">State</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> student.save();   <span class="hljs-comment">//保存一下当前的状态</span><br><br>    student.work(<span class="hljs-string">&quot;打电动&quot;</span>);   <span class="hljs-comment">//刚打开B站播放视频，学一半开始摆烂了</span><br>    System.out.println(student);<br><br>    student.restore(savedState);   <span class="hljs-comment">//两级反转！回到上一个保存的状态</span><br>    System.out.println(student);   <span class="hljs-comment">//回到学Java的状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，虽然在学习Java的过程中，中途摆烂了，但是我们可以时光倒流，回到还没开始摆烂的时候，继续学习Java：</p><p><img src="ohGTRiEMYAay3zB.jpg" alt="image-20230301112626822"></p><p>不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，我们需要合理的使用才能保证程序稳定运行。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>牵一发而动全身，一幅有序摆放的多米诺骨牌，在我们推到第一个骨牌时，后面的骨牌会不断地被上一个骨牌推倒：</p><p><img src="vZBkdeXEQrcTagV.jpg" alt="image-20230301112702467"></p><p>在Java中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。我们可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作，我们先定义一个观察者接口：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;   <span class="hljs-comment">//观察者接口</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//当对象有更新时，会回调此方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来写一个支持观察者的实体类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">observe</span><span class="hljs-params">(Observer observer)</span> &#123;   <span class="hljs-comment">//添加观察者</span><br>        observerSet.add(observer);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//模拟对象进行修改</span><br>        observerSet.forEach(Observer::update);   <span class="hljs-comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们就可以测试一下了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br>    subject.observe(() -&gt; System.out.println(<span class="hljs-string">&quot;我是一号观察者！&quot;</span>));<br>    subject.observe(() -&gt; System.out.println(<span class="hljs-string">&quot;我是二号观察者！&quot;</span>));<br>    subject.modify();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就简单实现了一下观察者模式，当然JDK也为我们提供了实现观察者模式相关的接口：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Observable;    <span class="hljs-comment">//java.util包下提供的观察者抽象类</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span> &#123;   <span class="hljs-comment">//继承此抽象类表示支持观察者</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对对象进行修改！&quot;</span>);<br>        <span class="hljs-built_in">this</span>.setChanged();    <span class="hljs-comment">//当对对象修改后，需要setChanged来设定为已修改状态</span><br>        <span class="hljs-built_in">this</span>.notifyObservers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());   <span class="hljs-comment">//使用notifyObservers方法来通知所有的观察者</span><br>      <span class="hljs-comment">//注意只有已修改状态下通知观察者才会有效，并且可以给观察者传递参数，这里传递了一个时间对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();<br>    subject.addObserver((o, arg) -&gt; System.out.println(<span class="hljs-string">&quot;监听到变化，并得到参数：&quot;</span>+arg));  <br>  <span class="hljs-comment">//注意这里的Observer是java.util包下提供的</span><br>    subject.modify();   <span class="hljs-comment">//进行修改操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而我们的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，我们就可以通过状态模式来实现。</p><p><img src="gyAHTPpVQ2c5Y3E.jpg" alt="image-20230301112716993"></p><p>我们来设计一个学生类，然后学生的学习方法会根据状态不同而发生改变，我们先设计一个状态枚举：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;   <span class="hljs-comment">//状态直接使用枚举定义</span><br>    NORMAL, LAZY<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来编写一个学生类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> State state;   <span class="hljs-comment">//使用一个成员来存储状态</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">switch</span> (state) &#123;   <span class="hljs-comment">//根据不同的状态，学习方法会有不同的结果</span><br>            <span class="hljs-keyword">case</span> LAZY:<br>                System.out.println(<span class="hljs-string">&quot;只要我不努力，老板就别想过上想要的生活，开摆！&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> NORMAL:<br>                System.out.println(<span class="hljs-string">&quot;拼搏百天，我要上清华大学！&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看，在不同的状态下，是否学习会出现不同的效果：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setState(State.NORMAL);   <span class="hljs-comment">//先正常模式</span><br>    student.study();<br><br>    student.setState(State.LAZY);   <span class="hljs-comment">//开启摆烂模式</span><br>    student.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>状态模式更加强调当前的对象所处的状态，我们需要根据对象不同的状态决定其他的处理逻辑。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>对面卡兹克打野被开了，我们是去打小龙还是打大龙呢？这就要看我们团队这一局的打法策略了。</p><p><img src="3WAha1ZeQUTHvCi.jpg" alt="image-20230301112727567"></p><p>我们可以为对象设定一种策略，这样对象之后的行为就会按照我们在一开始指定的策略而决定了，看起来和前面的状态模式很像，但是，它与状态模式的区别在于，这种转换是“主动”的，是由我们去指定，而状态模式，可能是在运行过程中自动切换的。</p><p>其实策略模式我们之前也遇到过，比如线程池的拒绝策略：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>,<br>            TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),  <span class="hljs-comment">//这里不给排队</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());   <span class="hljs-comment">//当线程池无法再继续创建新任务时，我们可以自由决定使用什么拒绝策略</span><br><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;;<br>    <br>    executor.execute(runnable);   <span class="hljs-comment">//连续提交两次任务，肯定塞不下，这时就得走拒绝了</span><br>    executor.execute(runnable);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们如果使用AbortPolicy，那么就是直接抛出异常：</p><p><img src="j3NdO1tzHfBDAn7.jpg" alt="image-20230301112805739"></p><p>我们也可以使用其他的策略：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>,<br>            TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());   <span class="hljs-comment">//使用DiscardOldestPolicy策略从队列中丢弃</span><br></code></pre></td></tr></table></figure><p>这种策略就会从等待队列中踢出一个之前的，不过我们这里的等待队列是没有容量的那种，所以会直接炸掉：</p><p><img src="di5A9acmTXOuv2V.jpg" alt="image-20230301112814947"></p><p>至于具体原因，可以回去看看JUC篇视频教程。</p><p>再比如我们现在有一个排序类，但是根据不同的策略，会使用不同的排序方案：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;   <span class="hljs-comment">//策略接口，不同的策略实现也不同</span><br><br>    <span class="hljs-type">Strategy</span> <span class="hljs-variable">SINGLE</span> <span class="hljs-operator">=</span> Arrays::sort;   <span class="hljs-comment">//单线程排序方案</span><br>    <span class="hljs-type">Strategy</span> <span class="hljs-variable">PARALLEL</span> <span class="hljs-operator">=</span> Arrays::parallelSort;   <span class="hljs-comment">//并行排序方案</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们编写一个排序类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sorter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Strategy strategy;   <span class="hljs-comment">//策略</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span>&#123;<br>        strategy.sort(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以指定不同的策略进行排序了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Sorter</span> <span class="hljs-variable">sorter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sorter</span>();<br>    sorter.setStrategy(Strategy.PARALLEL);    <span class="hljs-comment">//指定为并行排序方案</span><br>    <br>    sorter.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药，相对于处方单来说，划价员和药房工作人员就是它的访问者，不过访问者的访问方式可能会不同。</p><p><img src="Iws7kQE8Z6MCfNp.jpg" alt="image-20230301112827540"></p><p>在我们的Java程序中，也可能会出现这种情况，我们就可以通过访问者模式来进行设计。</p><p>比如我们日以继夜地努力，终于在某某比赛赢得了冠军，而不同的人对于这分荣誉，却有着不同的反应：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Prize</span> &#123;   <span class="hljs-comment">//奖</span><br>    String name;   <span class="hljs-comment">//比赛名称</span><br>    String level;    <span class="hljs-comment">//等级</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Prize</span><span class="hljs-params">(String name, String level)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先定义一个访问者接口：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Prize prize)</span>;   <span class="hljs-comment">//visit方法来访问我们的奖项</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是访问者相关的实现了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;   <span class="hljs-comment">//指导老师作为一个访问者</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Prize prize)</span> &#123;   <span class="hljs-comment">//它只关心你得了什么奖以及是几等奖，这也关乎老师的荣誉</span><br>        System.out.println(<span class="hljs-string">&quot;你得奖是什么奖？&quot;</span>+prize.name);<br>        System.out.println(<span class="hljs-string">&quot;你得了几等奖？&quot;</span>+prize.level);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Boss</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;    <span class="hljs-comment">//你的公司老板作为一个访问者</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Prize prize)</span> &#123;   <span class="hljs-comment">//你的老板只关心这些能不能为公司带来什么效益，奖本身并不重要</span><br>        System.out.println(<span class="hljs-string">&quot;你的奖项大么，能够为公司带来什么效益么？&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;还不如老老实实加班给我多干干，别去搞这些没用的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Classmate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;   <span class="hljs-comment">//你的同学也可以作为一个访问者</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Prize prize)</span> &#123;   <span class="hljs-comment">//你的同学也关心你得了什么奖，不过是因为你是他的奖学金竞争对手，他其实并不希望你得奖</span><br>        System.out.println(<span class="hljs-string">&quot;你得了&quot;</span>+prize.name+<span class="hljs-string">&quot;奖啊，还可以&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;不过这个奖没什么含金量，下次别去了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Family</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span>&#123;    <span class="hljs-comment">//你的家人也可以是一个访问者</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Prize prize)</span> &#123;   <span class="hljs-comment">//你的家人并不是最关心你得了什么奖，而是先关心你自己然后才是奖项，他们才是真正希望你好的人。这个世界很残酷，可能你会被欺负得遍体鳞伤，可能你会觉得活着如此艰难，但是你的背后至少还有爱你的人，为了他们，怎能就此驻足。</span><br>        System.out.println(<span class="hljs-string">&quot;孩子，辛苦了，有没有好好照顾自己啊&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;你得了什么奖啊？&quot;</span>+prize.name+<span class="hljs-string">&quot;，很不错，要继续加油啊！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里我们就设计了四种访问者，但是不同的访问者对于某一件事务的处理可能会不同。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可相对自由地演化，我们上面就是将奖项本身的属性和对于奖项的不同操作进行了分离。</p><hr><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/6386mh7anqt4tzyv">https://www.itbaima.cn/document/6386mh7anqt4tzyv</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-结构型</title>
    <link href="/post/b096a378-bcc1-42bf-96dc-658502442b53/"/>
    <url>/post/b096a378-bcc1-42bf-96dc-658502442b53/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式-结构型"><a href="#设计模式-结构型" class="headerlink" title="设计模式-结构型"></a>设计模式-结构型</h3><p><code>hexo template generate by typora plugin templater</code></p><p><img src="zsQt38PgRYnXcjH-1720456474374-243.jpg" alt="image-20230301111823966"></p><h1 id="设计模式（结构型）"><a href="#设计模式（结构型）" class="headerlink" title="设计模式（结构型）"></a>设计模式（结构型）</h1><p>结构型设计模式关注如何将现有的类或对象组织在一起形成更加强大的结构。并且根据我们前面学习的合成复用原则，我们该如何尽可能地使用关联关系来代替继承关系是我们本版块需要重点学习的内容。</p><h2 id="类-对象适配器模式"><a href="#类-对象适配器模式" class="headerlink" title="类&#x2F;对象适配器模式"></a>类&#x2F;对象适配器模式</h2><p>在生活中，我们经常遇到这样的一个问题：笔记本太轻薄了，以至于没有RJ45网口和USB A口（比如Macbook为了轻薄甚至全是type-c形式的雷电口）但是现在我们因为工作需要，又得使用这些接口来连接线缆，这时我们想到的第一个解决方案，就是去买一个转接口（扩展坞），扩展坞可以将type-c口转换为其他类型的接口供我们使用，实际上这就是一种适配模式。</p><p><img src="5HkWt8fhwIZCxPE.jpg" alt="image-20230301111837481"></p><p>由于我们的电脑没有这些接口，但是提供了type-c类型的接口，虽然接口类型不一样，但是同样可以做其他接口能做的事情，比如USB文件传输、有线网络连接等，所以，这个时候，我们只需要添加一个中间人来帮我们转换一下接口形态即可。包括我们常用的充电头，为什么叫电源适配器呢？我们知道传统的供电是220V交流电，但是我们的手机可能只需要5V的电压进行充电，虽然现在有电，但是不能直接充，我们也不可能让电力公司专门为我们提供一个5V的直流电使用。这时电源适配器就开始发挥作用了，比如苹果的祖传5V1A充电头，实际上就是将220V交流电转换为5V的直流电进行传输，这样就相当于在220V交流电和我们的手机之前，做了一个适配器的角色。</p><p>在我们的Java程序中，也会经常遇到这样的问题，比如：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSupplier</span> &#123;   <span class="hljs-comment">//手机供应商</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSupply</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;iPhone 14 Pro&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestSupplier</span> <span class="hljs-variable">supplier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestSupplier</span>();<br>      test( ? );   <span class="hljs-comment">//我们没有Target类型的手机供应商，只有其他的，那这里该填个啥</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Target target)</span>&#123;   <span class="hljs-comment">//现在我们需要调用test方法，但是test方法需要Target类型的手机供应商</span><br>        System.out.println(<span class="hljs-string">&quot;成功得到：&quot;</span>+target.supply());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span> &#123;    <span class="hljs-comment">//现在的手机供应商，并不是test方法所需要的那种类型</span><br><br>    String <span class="hljs-title function_">supply</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，我们就可以使用适配器模式了，适配器模式分为类适配器和对象适配器，我们首先来看看如何使用类适配器解决这种问题，我们直接创建一个适配器类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestSupplier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span> &#123;  <br>  <span class="hljs-comment">//让我们的适配器继承TestSupplier并且实现Target接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">supply</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//接着实现supply方法，直接使用TestSupplier提供的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.doSupply();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就得到了一个Target类型的实现类，并且同时采用的是TestSupplier提供的实现。</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">TestAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestAdapter</span>();<br>    test(adapter);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Target target)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;成功得到：&quot;</span>+target.supply());<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，这种实现方式需要占用一个继承坑位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了。同时根据合成复用原则，我们应该更多的通过合成的方式去实现功能，所以我们来看看第二种，也是用的比较多的一种模式，对象适配器：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&#123;   <span class="hljs-comment">//现在不再继承TestSupplier，仅实现Target</span><br><br>    TestSupplier supplier;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestAdapter</span><span class="hljs-params">(TestSupplier supplier)</span>&#123;<br>        <span class="hljs-built_in">this</span>.supplier = supplier;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">supply</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.doSupply();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们就将对象以组合的形式存放在TestAdapter中，依然是通过存放的对象调用具体实现。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>相信各位都去奶茶店买过奶茶，在购买奶茶的时候，店员首先会问我们，您需要什么类型的奶茶，比如我们此时点了一杯啵啵芋圆奶茶，接着店员会直接问我们需要大杯、中杯还是小杯，最后还会询问我们需要加什么配料，比如椰果、珍珠等，最后才会给我们制作奶茶。</p><p><img src="ZAjo69kfFUuIJ52.jpg" alt="image-20230301111852891"></p><p>那么现在让你来设计一下这种模式的Java类，该怎么做呢？首先我们要明确，一杯奶茶除了类型之外，还分大中小杯，甚至可能还分加什么配料，这个时候，如果我们按照接口实现的写法：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Tea</span> &#123;   <span class="hljs-comment">//由具体类型的奶茶实现</span><br>    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//不同的奶茶返回的类型不同</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Size</span> &#123;   <span class="hljs-comment">//分大杯小杯中杯</span><br>    String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们创建一个新的类型：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大杯芋圆啵啵奶茶</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeKissTea</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tea</span>, Size&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;大杯&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;芋圆啵啵奶茶&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样设计起来还挺合理的，但是如果现在我们的奶茶品种多起来了，并且每种奶茶都有大中小杯，现在一共有两个维度需要考虑，那么我们岂不是得一个一个去创建这些类？甚至如果还要考虑配料，那么光创建类就得创建不知道多少个了。显然这种设计不太好，我们得换个方式。</p><p>这时，就可以使用我们的桥接模式了，现在我们面临的问题是，维度太多，不可能各种类型各种尺寸的奶茶都去创建一个类，那么我们就还是单独对这些接口进行简单的扩展，单独对不同的维度进行控制，但是如何实现呢？我们不妨将奶茶的类型作为最基本的抽象类，然后对尺寸、配料等属性进行桥接：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractTea</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> Size size;   <span class="hljs-comment">//尺寸作为桥接属性存放在类中</span><br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractTea</span><span class="hljs-params">(Size size)</span>&#123;   <span class="hljs-comment">//在构造时需要知道尺寸属性</span><br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//具体类型依然是由子类决定</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过这个抽象类提供的方法还不全面，仅仅只有Tea的getType方法，我们还需要添加其他维度的方法，所以继续编写一个子类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstractTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTea</span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RefinedAbstractTea</span><span class="hljs-params">(Size size)</span> &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//添加尺寸维度获取方式</span><br>        <span class="hljs-keyword">return</span> size.getSize();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们只需要单独为Size创建子类即可：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Large</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Size</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;大杯&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们如果需要一个大杯的啵啵芋圆奶茶，只需要：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KissTea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RefinedAbstractTea</span>&#123;   <span class="hljs-comment">//创建一个啵啵芋圆奶茶的子类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">KissTea</span><span class="hljs-params">(Size size)</span> &#123;   <span class="hljs-comment">//在构造时需要指定具体的大小实现</span><br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;啵啵芋圆奶茶&quot;</span>;   <span class="hljs-comment">//返回奶茶类型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就将两个维度拆开，可以分别进行配置了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">KissTea</span> <span class="hljs-variable">tea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KissTea</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Large</span>());<br>    System.out.println(tea.getType());<br>    System.out.println(tea.getSize());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过桥接模式，使得抽象和实现可以沿着各自的维度来进行变化，不再是固定的绑定关系。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件：</p><p><img src="MYPyj9edEOmNWwU.jpg" alt="image-20230301111907078"></p><p>它就像是一个树形结构一样，有分支有叶子，而组合模式则是可以对整个树形结构上的所有节点进行递归处理，比如我们现在希望将所有文件夹中的文件的名称前面都添加一个前缀，那么就可以使用组合模式。</p><p><img src="FzeBOp53ojM4Sui.jpg" alt="image-20230301111916996"></p><p>组合模式的示例如下，这里我们就用文件和文件夹的例子来讲解：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addComponent</span><span class="hljs-params">(Component component)</span>;    <span class="hljs-comment">//添加子组件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeComponent</span><span class="hljs-params">(Component component)</span>;   <span class="hljs-comment">//删除子组件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;   <span class="hljs-comment">//获取子组件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//执行对应的业务方法，比如修改文件名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来编写两种实现类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;   <span class="hljs-comment">//目录可以包含多个文件或目录</span><br><br>    List&lt;Component&gt; child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();   <span class="hljs-comment">//这里我们使用List来存放目录中的子组件</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        child.add(component);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        child.remove(component);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> child.get(index);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        child.forEach(Component::test);   <span class="hljs-comment">//将继续调用所有子组件的test方法执行业务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span>&#123;   <span class="hljs-comment">//文件就相当于是树叶，无法再继续添加子组件了</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   <span class="hljs-comment">//不支持这些操作了</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件名称修改成功！&quot;</span>+<span class="hljs-built_in">this</span>);   <span class="hljs-comment">//具体的名称修改操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们来测试一下：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>();   <span class="hljs-comment">//新建一个外层目录</span><br>    <span class="hljs-type">Directory</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>();   <span class="hljs-comment">//新建一个内层目录</span><br>    outer.addComponent(inner);<br>    outer.addComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>());   <span class="hljs-comment">//在内层目录和外层目录都添加点文件，注意别导错包了</span><br>    inner.addComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>());<br>    inner.addComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>());<br>    outer.test();    <span class="hljs-comment">//开始执行文件名称修改操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们对最外层目录进行操作后，会递归向下处理当前目录和子目录中所有的文件。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式就像其名字一样，为了对现有的类进行装饰。比如一张相片就一张纸，如果直接贴在墙上，总感觉少了点什么，但是我们给其添加一个好看的相框，就会变得非常对味。装饰模式的核心就在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。</p><p>比如我们现在有一个普通的功能类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;   <span class="hljs-comment">//顶层抽象类，定义了一个test方法执行业务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是业务方法&quot;</span>);   <span class="hljs-comment">//具体的业务方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过现在的实现类太单调了，我们来添加一点装饰上去：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;   <span class="hljs-comment">//装饰者需要将装饰目标组合到类中</span><br><br>    <span class="hljs-keyword">protected</span> Base base;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Base base)</span> &#123;<br>        <span class="hljs-built_in">this</span>.base = base;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        base.test();    <span class="hljs-comment">//这里暂时还是使用目标的原本方法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;   <span class="hljs-comment">//装饰实现</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorImpl</span><span class="hljs-params">(Base base)</span> &#123;<br>        <span class="hljs-built_in">super</span>(base);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//对原本的方法进行装饰，我们可以在前后都去添加额外操作</span><br>        System.out.println(<span class="hljs-string">&quot;装饰方法：我是操作前逻辑&quot;</span>);<br>        <span class="hljs-built_in">super</span>.test();<br>        System.out.println(<span class="hljs-string">&quot;装饰方法：我是操作后逻辑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就通过装饰模式对类的功能进行了扩展：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseImpl</span>();<br>    <span class="hljs-type">Decorator</span> <span class="hljs-variable">decorator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImpl</span>(base);  <span class="hljs-comment">//将Base实现装饰一下</span><br>    <span class="hljs-type">Decorator</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoratorImpl</span>(decorator);  <span class="hljs-comment">//装饰者还可以嵌套</span><br><br>    decorator.test();<br><br>    outer.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就实现了装饰模式。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式和装饰模式很像，初学者很容易搞混，所以这里我们得紧接着来讲解一下。首先请记住，当无法直接访问某个对象或访问某个对象存在困难时，我们就可以通过一个代理对象来间接访问。</p><p>实际上代理在我们生活中处处都存在，比如手机厂商要去销售手机，但是手机厂商本身没有什么渠道可以大规模地进行售卖，很难与这些消费者进行对接，这时就得交给代理商去进行出售，比如Apple在中国的直营店很少，但是在中国的授权经销商却很多，手机厂商通过交给旗下代理商的形式来进行更大规模的出售。比如我们经常要访问Github，但是直接连接会发现很难连的上，这时我们加了一个代理就可以轻松访问，也是在体现代理的作用。</p><p><img src="4yRZix1FfvaYboj.jpg" alt="image-20230301111934493"></p><p>同时，代理类需要保证客户端使用的透明性，也就是说操作起来需要与原本的真实对象相同，比如我们访问Github只需要输入网址即可访问，而添加代理之后，也是使用同样的方式去访问Github，所以操作起来是一样的。包括Spring框架其实也是依靠代理模式去实现的AOP记录日志等。</p><p>比如现在有一个目标类，但是我们现在需要通过代理来使用它：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubjectImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;  <span class="hljs-comment">//此类无法直接使用，需要我们进行代理</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们为其建立一个代理类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span>&#123;   <span class="hljs-comment">//为了保证和Subject操作方式一样，保证透明性，也得继承</span><br><br>    Subject target;   <span class="hljs-comment">//被代理的对象（甚至可以多重代理）</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(Subject subject)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = subject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//由代理去执行被代理对象的方法，并且我们还可以在前后添油加醋</span><br>        System.out.println(<span class="hljs-string">&quot;代理前绕方法&quot;</span>);<br>        target.test();<br>        System.out.println(<span class="hljs-string">&quot;代理后绕方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看，这不跟之前的装饰模式一模一样吗？</p><p>对装饰器模式来说，装饰者和被装饰者都实现同一个接口&#x2F;抽象类。对代理模式来说，代理类和被代理的类都实现同一个接口&#x2F;抽象类，在结构上确实没有啥区别。但是他们的作用不同，装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能，增强后你还是你，只不过被强化了而已；代理模式强调要让别人帮你去做事情，以及添加一些本身与你业务没有太多关系的事情（记录日志、设置缓存等）重点在于让别人帮你做。</p><p>装饰模式和代理模式的不同之处在于思想。</p><p>当然实现代理模式除了我们上面所说的这种方式之外，我们还可以使用JDK为我们提供的动态代理机制，我们不再需要手动编写继承关系创建代理类，它能够在运行时通过反射机制为我们自动生成代理类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;  <span class="hljs-comment">//JDK提供的动态代理只支持接口</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubjectImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是测试方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要创建一个动态代理的处理逻辑：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;    <span class="hljs-comment">//代理类，需要实现InvocationHandler接口</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object object;   <span class="hljs-comment">//这里需要保存一下被代理的对象，下面需要用到</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestProxy</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//此方法就是调用代理对象的对应方法时会进入，这里我们就需要编写如何进行代理了</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>     <span class="hljs-comment">//method就是调用的代理对象的哪一个方法，args是实参数组</span><br>        System.out.println(<span class="hljs-string">&quot;代理的对象：&quot;</span>+proxy.getClass());   <span class="hljs-comment">//proxy就是生成的代理对象了，我们看看是什么类型的</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(object, args);   <span class="hljs-comment">//在代理中调用被代理对象原本的方法，因为你是代理，还是得执行一下别人的业务，当然也可以不执行，但是这样就失去代理的意义了，注意要用上面的object</span><br>        System.out.println(<span class="hljs-string">&quot;方法调用完成，返回值为：&quot;</span>+res);   <span class="hljs-comment">//看看返回值是什么</span><br>        <span class="hljs-keyword">return</span> res;   <span class="hljs-comment">//返回返回值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来看看如何创建一个代理类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SubjectImpl</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubjectImpl</span>();   <span class="hljs-comment">//被代理的大冤种</span><br>    <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestProxy</span>(subject);<br>    <span class="hljs-type">Subject</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Subject) Proxy.newProxyInstance(<br>            subject.getClass().getClassLoader(),    <span class="hljs-comment">//需要传入被代理的类的类加载器</span><br>            subject.getClass().getInterfaces(),    <span class="hljs-comment">//需要传入被代理的类的接口列表</span><br>            handler);    <span class="hljs-comment">//最后传入我们实现的代理处理逻辑实现类</span><br>    proxy.test();    <span class="hljs-comment">//比如现在我们调用代理类的test方法，那么就会进入到我们上面TestProxy中invoke方法，走我们的代理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行一次，可以看到调用代理类的方法，最终会走到我们的invoke方法中进行：</p><p><img src="RipPFu3Q6Y5Idel.jpg" alt="image-20230301112001604"></p><p>根据接口，代理对象是<code>com.sun.proxy.$Proxy0</code>类（看名字就知道不对劲），这个类是动态生成的，我们也找不到具体的源代码。</p><p>不过JDK提供的动态代理只能使用接口，如果换成我们一开始的抽象类，就没办法了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如Spring都在使用的CGLib框架，Maven依赖如下：</p><p>​                              </p><p>​        xml        复制代码      </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于CGlib底层使用ASM框架（JVM篇视频教程有介绍）进行字节码编辑，所以能够实现不仅仅局限于对接口的代理：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;  <span class="hljs-comment">//首先还是编写我们的代理逻辑</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;   <span class="hljs-comment">//这些和之前JDK动态代理写法是一样的</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//我们也是需要在这里去编写我们的代理逻辑</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;现在是由CGLib进行代理操作！&quot;</span>+o.getClass());<br>        <span class="hljs-keyword">return</span> method.invoke(target, objects);   <span class="hljs-comment">//也是直接调用代理对象的方法即可</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来创建一下代理类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SubjectImpl</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubjectImpl</span>();<br><br>    <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();   <span class="hljs-comment">//增强器，一会就需要依靠增强器来为我们生成动态代理对象</span><br>    enhancer.setSuperclass(SubjectImpl.class);    <span class="hljs-comment">//直接选择我们需要代理的类型，直接不需要接口或是抽象类，SuperClass作为代理类的父类存在，这样我们就可以按照指定类型的方式去操作代理类了</span><br>    enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestProxy</span>(subject));  <span class="hljs-comment">//设定我们刚刚编写好的代理逻辑</span><br><br>    <span class="hljs-type">SubjectImpl</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (SubjectImpl) enhancer.create();   <span class="hljs-comment">//直接创建代理类</span><br><br>    proxy.test();   <span class="hljs-comment">//调用代理类的test方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，效果其实是差不多的：</p><p><img src="Y1bHtnZTIoq8pBu.jpg" alt="image-20230301112013486"></p><p>可以看到代理类是<code>包名.SubjectImpl$$EnhancerByCGLIB$$47f6ed3a</code>，也是动态生成的一个类，所以我们无法去查看源码，不过此类是继承自我们指定的类型的。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>你是否经历过类似的情况：今年计算机学院的奖学金评定工作开始了，由于你去年一不小心拿了个ACM的区域赛金牌，觉得自己又行了，于是也想参与到奖学金的争夺中，首先你的辅导员会通知你去打印你的获奖材料，然后你高高兴兴拿给辅导员之后，辅导员又给了你一张表，让你打印了之后填写一下，包括你的个人信息还有一些个人介绍，完成后，你本以为可以坐等发奖了，结果辅导员又跟你说我们评定还要去某某地方盖章，盖完章还要去找谁谁谁签字，最后还要参加一下答辩… 看着如此复杂的流程，你瞬间不想搞了。</p><p><img src="y2wzFh1UWYmpgJX.jpg" alt="image-20230301112039165"></p><p>实际上我们生活中很多时候都是这样，可能在办一件事情的时候，由于部门职能的不同，你得各个部门到处跑，你肯定会抱怨一句，就不能有个人来统一一下吗，就不能在一个地方一起把事情都办了吗？这时，我们就可以用到外观模式了。</p><p>外观模式充分体现了迪米特法则。可能我们的整个项目有很多个子系统，但是我们可以在这些子系统的上面加一个门面（Facade）当我们外部需要与各个子系统交互时，无需再去直接使用各个子系统，而是与门面进行交互，再由门面与后面的各个子系统操作，这样，我们以后需要办什么事情，就统一找门面就行了。这样的好处是，首先肯定方便了代码的编写，统一找门面就行，不需要去详细了解子系统，并且，当子系统需要修改时，也只需要修改门面中的逻辑，不需要大面积的变动，遵循迪米特法则尽可能少的交互。</p><p><img src="BylhOfcFtni29uQ.jpg" alt="image-20230301112103676"></p><p>比如现在我们设计了三个子系统，分别是排队、结婚、领证，正常情况下我们是需要分别去找这三个部门去完成的，但是现在我们通过门面统一来完成：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;排队&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemB</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;结婚&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;领证&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在三个系统太复杂了，我们添加一个门面：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br><br>    <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>    <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>    <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//红白喜事一条龙服务</span><br>        a.test1();<br>        b.test2();<br>        c.test3();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们只需要一个门面就能直接把事情办完了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br>    facade.marry();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用外观模式，我们就大大降低了类与类直接的关联程度，并且简化了流程。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>最后我们来看看享元模式（Flyweight），那么这个”享元”代表什么意思呢？我们先来看看下面的问题：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现上面的例子中，两个字符串虽然长短不同，但是却包含了一段相同的部分，那么现在我们如果要对内存进行优化：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;efg&quot;</span>;   <span class="hljs-comment">//由于str1包含str2，所以我们可以去掉重复的部分，当需要原本的str1时，再合在一起</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>    System.out.println(<span class="hljs-string">&quot;str1 = &quot;</span>+str2+str1);<br>&#125;<br></code></pre></td></tr></table></figure><p>而享元模式就是这个思想，我们可以将那些重复出现的内容作为共享部分取出，这样当我们拥有大量对象时，我们把其中共同的部分抽取出来，由于提取的部分是多个对象共享只有一份，那么就可以减轻内存的压力。包括我们的围棋，实际上我们只需要知道棋盘上的各个位置是黑棋还是白棋，实际上没有毕业创建很多个棋子对象，我们只需要去复用一个黑棋和一个白棋子对象即可。</p><p>比如现在我们有两个服务，但是他们都需要使用数据库工具类来操作，实际上这个工具类没必要创建多个，我们这时就可以使用享元模式，让数据库工具类作为享元类，通过享元工厂来提供一个共享的数据库工具类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectDB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是数据库操作...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtilFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DBUtil</span> <span class="hljs-variable">UTIL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DBUtil</span>();   <span class="hljs-comment">//享元对象被存放在工厂中</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBUtil <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//获取享元对象</span><br>        <span class="hljs-keyword">return</span> UTIL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后当我们需要使用享元对象时，直接找享元工厂要就行了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;   <span class="hljs-comment">//用户服务</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">DBUtil</span> <span class="hljs-variable">util</span> <span class="hljs-operator">=</span> DBUtilFactory.getFlyweight();   <span class="hljs-comment">//通过享元工厂拿到DBUtil对象</span><br>        util.selectDB();    <span class="hljs-comment">//该干嘛干嘛</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这只是简单的享元模式实现，实际上我们一开始举例的String类，也在使用享元模式进行优化，比如下面的代码：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;cd&quot;</span>;<br>    System.out.println(str1 == str2);<br>    System.out.println(str1 == str3);   <span class="hljs-comment">//猜猜这三个对象是不是都是同一个？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然我们这里定义了三个字符串，但是我们发现，这三个对象指向的都是同一个对象，这是为什么呢？实际上这正是Java语言实现了数据的共享，想要了解具体实现请前往JVM篇视频教程。</p><hr><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/6386mh7anqt4tzyv">https://www.itbaima.cn/document/6386mh7anqt4tzyv</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-创建型</title>
    <link href="/post/88c4bd86-406b-4f82-b97f-94054c971e48/"/>
    <url>/post/88c4bd86-406b-4f82-b97f-94054c971e48/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式-创建型"><a href="#设计模式-创建型" class="headerlink" title="设计模式-创建型"></a>设计模式-创建型</h3><p><code>hexo template generate by typora plugin templater</code></p><p><img src="CZbSEekKftDYp25-1720456478594-245.jpg" alt="image-20230301111626247"></p><h1 id="设计模式（创建型）"><a href="#设计模式（创建型）" class="headerlink" title="设计模式（创建型）"></a>设计模式（创建型）</h1><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><blockquote><p>肯特·贝克和<a href="https://baike.baidu.com/item/%E6%B2%83%E5%BE%B7%C2%B7%E5%9D%8E%E5%AE%81%E5%AE%89/6488429">沃德·坎宁安</a>在1987年利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口的生成中。一年后Erich Gamma在他的<a href="https://baike.baidu.com/item/%E8%8B%8F%E9%BB%8E%E4%B8%96%E5%A4%A7%E5%AD%A6/1621125">苏黎世大学</a>博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991 年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Idioms。就在这一年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides合作出版了Design Patterns - Elements of Reusable Object-Oriented Software 一书，在此书中共收录了23个设计模式。这四位作者在软件开发领域里也以他们的匿名著称Gang of Four(四人帮，简称GoF),并且是他们在此书中的协作导致了软件设计模式的突破。</p></blockquote><p>我们先来看看有关对象创建的几种设计模式。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>首当其冲的是最简单的一种设计模式——工厂方法模式，我们知道，如果需要创建一个对象，那么最简单的方式就是直接new一个即可。而工厂方法模式代替了传统的直接new的形式，那么为什么要替代传统的new形式呢？</p><p>可以想象一下，如果所有的对象我们都通过new的方式去创建，那么当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那我们岂不是得挨个去进行修改？根据迪米特法则，我们应该尽可能地少与其他类进行交互，所以我们可以将那些需要频繁出现的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改。</p><p>同时，可能某些对象的创建并不只是一个new就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数，所以我们来看看如何使用<code>简单工厂模式</code>来创建对象，既然是工厂，那么我们就来创建点工厂需要生产的东西：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;   <span class="hljs-comment">//水果抽象类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot;@&quot;</span>+hashCode();   <span class="hljs-comment">//打印一下当前水果名称，还有对象的hashCode</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&#123;   <span class="hljs-comment">//苹果，继承自水果</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;苹果&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&#123;  <span class="hljs-comment">//橘子，也是继承自水果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;橘子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常情况下，我们直接new就可以得到对象了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>        System.out.println(apple);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们将对象的创建封装到工厂中：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里就直接来一个静态方法根据指定类型进行创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type 水果类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对应的水果对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;橘子&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以使用此工厂来创建对象了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> FruitFactory.getFruit(<span class="hljs-string">&quot;橘子&quot;</span>);   <span class="hljs-comment">//直接问工厂要，而不是我们自己去创建</span><br>        System.out.println(fruit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这样还是有一些问题，我们前面提到了开闭原则，一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭，但是如果我们现在需要新增一种水果，比如桃子，那么这时我们就得去修改工厂提供的工厂方法了，但是这样是不太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。</p><p>所以，我们就利用对扩展开放，对修改关闭的性质，将<code>简单工厂模式</code>改进为<code>工厂方法模式</code>，那现在既然不让改，那么我们就看看如何去使用扩展的形式：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; &#123;   <span class="hljs-comment">//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//不同的水果工厂，通过此方法生产不同的水果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FruitFactory</span>&lt;Apple&gt; &#123;  <span class="hljs-comment">//苹果工厂，直接返回Apple，一步到位</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容。</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactory</span>()::getFruit);   <span class="hljs-comment">//比如我们现在要吃一个苹果，那么就直接通过苹果工厂来获取苹果</span><br>    &#125;<br><br>    <span class="hljs-comment">//此方法模拟吃掉一个水果</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Supplier&lt;Fruit&gt; supplier)</span>&#123;<br>        System.out.println(supplier.get()+<span class="hljs-string">&quot; 被吃掉了，真好吃。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就简单实现了工厂方法模式，通过工厂来屏蔽对象的创建细节，使用者只需要关心如何去使用对象即可。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>前面我们介绍了工厂方法模式，通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。</p><p>不过这种模式只适用于简单对象，当我们需要生产许多个产品族的时候，这种模式就有点乏力了，比如：</p><p><img src="leHOprkRiys3WhN.jpg" alt="image-20230301111712035"></p><p>实际上这些产品都是成族出现的，比如小米的产品线上有小米12，小米平板等，华为的产品线上也有华为手机、华为平板，但是如果按照我们之前工厂方法模式来进行设计，那就需要单独设计9个工厂来生产上面这些产品，显然这样就比较浪费时间的。</p><p>但是现在有什么方法能够更好地处理这种情况呢？我们就可以使用抽象工厂模式，我们可以将多个产品，都放在一个工厂中进行生成，按不同的产品族进行划分，比如小米，那么我就可以安排一个小米工厂，而这个工厂里面就可以生产整条产品线上的内容，包括小米手机、小米平板、小米路由等。</p><p>所以，我们只需要建立一个抽象工厂即可：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Table</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Phone <span class="hljs-title function_">getPhone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Table <span class="hljs-title function_">getTable</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个工厂可以生产同一个产品族的所有产品，这样按族进行分类，显然比之前的工厂方法模式更好。</p><p>不过，缺点还是有的，如果产品族新增了产品，那么我就不得不去为每一个产品族的工厂都去添加新产品的生产方法，违背了开闭原则。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式也是非常常见的一种设计模式，我们经常看到有很多的框架都为我们提供了形如<code>XXXBuilder</code>的类型，我们一般也是使用这些类来创建我们需要的对象。</p><p>比如，我们在JavaSE中就学习过的<code>StringBuiler</code>类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();   <span class="hljs-comment">//创建一个StringBuilder来逐步构建一个字符串</span><br>    builder.append(<span class="hljs-number">666</span>);   <span class="hljs-comment">//拼接一个数字</span><br>    builder.append(<span class="hljs-string">&quot;老铁&quot;</span>);   <span class="hljs-comment">//拼接一个字符串</span><br>   builder.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;?&#x27;</span>);  <span class="hljs-comment">//在第三个位置插入一个字符</span><br>    System.out.println(builder.toString());   <span class="hljs-comment">//差不多成形了，最后转换为字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们是通过建造者来不断配置参数或是内容，当我们配置完所有内容后，最后再进行对象的构建。</p><p>相比直接去new一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置，同时如果一个类的构造方法参数过多，我们通过建造者模式来创建这个对象，会更加优雅。</p><p>比如我们现在有一个学生类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> grade;<br>    String name;<br>    String college;<br>    String profession;<br>    List&lt;String&gt; awards;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.grade = grade;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.college = college;<br>        <span class="hljs-built_in">this</span>.profession = profession;<br>        <span class="hljs-built_in">this</span>.awards = awards;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个学生类的属性是非常多的，所以构造方法不是一般的长，如果我们现在直接通过new的方式去创建：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;计算机学院&quot;</span>, <span class="hljs-string">&quot;计算机科学与技术&quot;</span>, Arrays.asList(<span class="hljs-string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="hljs-string">&quot;LPL 2022春季赛 冠军&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们光是填参数就麻烦，我们还得一个一个对应着去填，一不小心可能就把参数填到错误的位置了。</p><p>所以，我们现在可以使用建造者模式来进行对象的创建：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>...<br><br>    <span class="hljs-comment">//一律使用建造者来创建，不对外直接开放</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StudentBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//通过builder方法直接获取建造者</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentBuilder</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentBuilder</span>&#123;   <span class="hljs-comment">//这里就直接创建一个内部类</span><br>        <span class="hljs-comment">//Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span><br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-type">int</span> grade;<br>        String name;<br>        String college;<br>        String profession;<br>        List&lt;String&gt; awards;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;    <span class="hljs-comment">//直接调用建造者对应的方法，为对应的属性赋值</span><br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;   <span class="hljs-comment">//为了支持链式调用，这里直接返回建造者本身，下同</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>      <br>      ...<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">awards</span><span class="hljs-params">(String... awards)</span>&#123;<br>            <span class="hljs-built_in">this</span>.awards = Arrays.asList(awards);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, age, grade, name, college, profession, awards);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们就可以使用建造者来为我们生成对象了：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> Student.builder()   <span class="hljs-comment">//获取建造者</span><br>            .id(<span class="hljs-number">1</span>)    <span class="hljs-comment">//逐步配置各个参数</span><br>            .age(<span class="hljs-number">18</span>)<br>            .grade(<span class="hljs-number">3</span>)<br>            .name(<span class="hljs-string">&quot;小明&quot;</span>)<br>            .awards(<span class="hljs-string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="hljs-string">&quot;LPL 2022春季赛 冠军&quot;</span>)<br>            .build();   <span class="hljs-comment">//最后直接建造我们想要的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以让这些参数对号入座了，并且也比之前的方式优雅许多。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式其实在之前的课程中已经演示过很多次了，这也是使用频率非常高的一种模式。</p><p>那么，什么是单例模式呢？顾名思义，单例那么肯定就是只有一个实例对象，在我们的整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上我们只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。</p><p>这里还是还原一下我们之前使用的简单单例模式：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();   <span class="hljs-comment">//用于引用全局唯一的单例对象，在一开始就创建好</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;   <span class="hljs-comment">//不允许随便new，需要对象直接找getInstance</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//获取全局唯一的单例对象</span><br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当我们需要获取此对象时，只能通过<code>getInstance()</code>来获取唯一的对象：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，单例模式除了这种写法之外，还有其他写法，这种写法被称为饿汉式单例，也就是说在一开始类加载时就创建好了，我们来看看另一种写法——懒汉式：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE;   <span class="hljs-comment">//在一开始先不进行对象创建</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;   <span class="hljs-comment">//不用多说了吧</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//将对象的创建延后到需要时再进行</span><br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">//如果实例为空，那么就进行创建，不为空说明已经创建过了，那么就直接返回</span><br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，懒汉式就真的是条懒狗，你不去用它，它是不会给你提前准备单例对象的（延迟加载，懒加载），当我们需要获取对象时，才会进行检查并创建。虽然饿汉式和懒汉式写法不同，但是最后都是成功实现了单例模式。</p><p>不过，这里需要特别提醒一下，由于懒汉式是在方法中进行的初始化，在多线程环境下，可能会出现问题（建议学完JUC篇视频教程再来观看）大家可以试想一下，如果这个时候有多个线程同时调用了<code>getInstance()</code>方法，那么会出现什么问题呢？</p><p><img src="w1oN7u3SxG4cEzL.jpg" alt="image-20230301111737649"></p><p>可以看到，在多线程环境下，如果三条线程同时调用<code>getInstance()</code>方法，会同时进行<code>INSTANCE == null</code>的判断，那么此时由于确实还没有进行任何实例化，所以导致三条线程全部判断为<code>true</code>（而饿汉式由于在类加载时就创建完成，不会存在这样的问题）此时问题就来了，我们既然要使用单例模式，那么肯定是只希望对象只被初始化一次的，但是现在由于多线程的机制，导致对象被多次创建。</p><p>所以，为了避免线程安全问题，针对于懒汉式单例，我们还得进行一些改进：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//方法必须添加synchronized关键字加锁</span><br>    <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然多个线程要调用，那么我们就直接加一把锁，在方法上添加<code>synchronized</code>关键字即可，这样同一时间只能有一个线程进入了。虽然这样简单粗暴，但是在高并发的情况下，效率肯定是比较低的，我们来看看如何进行优化：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;    <span class="hljs-comment">//实际上只需要对赋值这一步进行加锁即可</span><br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();   <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这样还不完美，因为这样还是有可能多个线程同时判断为<code>null</code>而进入等锁的状态，所以，我们还得加一层内层判断：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">//内层还要进行一次检查，双重检查锁定</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过我们还少考虑了一样内容，其实IDEA此时应该是给了黄标了：</p><p><img src="I9PAi6HRbyMNsJn.jpg" alt="image-20230301111754155"></p><p>可以看到，这种情况下，IDEA会要求我们添加一个<code>volatile</code>给<code>INSTANCE</code>，各位还记得这个关键字有什么作用吗？没错，我们还需要保证<code>INSTANCE</code>在线程之间的可见性，这样当其他线程进入之后才会拿<code>INSTANCE</code>由其他线程更新的最新值去判断，这样，就差不多完美了。</p><p>那么，有没有一种更好的，不用加锁的方式也能实现延迟加载的写法呢？我们可以使用静态内部类：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span> &#123;   <span class="hljs-comment">//由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//只有真正使用内部类时，才会进行类初始化</span><br>        <span class="hljs-keyword">return</span> Holder.INSTANCE;   <span class="hljs-comment">//直接获取内部类中的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式显然是最完美的懒汉式解决方案，没有进行任何的加锁操作，也能保证线程安全，不过要实现这种写法，跟语言本身也有一定的关联，并不是所有的语言都支持这种写法。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式实际上与对象的拷贝息息相关，原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。</p><p>开始之前，我们先介绍一下对象的深拷贝和浅拷贝，首先我们来看浅拷贝：</p><ul><li><p><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">//基本类型浅拷贝</span><br>    System.out.println(a == b);<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> o;    <span class="hljs-comment">//引用类型浅拷贝，拷贝的仅仅是对上面对象的引用</span><br>    System.out.println(o == k);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</p></li></ul><p>在Java中，我们就可以使用Cloneable接口提供的拷贝机制，来实现原型模式：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;   <span class="hljs-comment">//注意需要实现Cloneable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;   <span class="hljs-comment">//提升clone方法的访问权限</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看克隆的对象是不是原来的对象：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> (Student) student0.clone();<br>    System.out.println(student0);<br>    System.out.println(student1);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过<code>clone()</code>方法克隆的对象并不是原来的对象，我们来看看如果对象内部有属性会不会一起进行克隆：</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> (Student) student0.clone();<br>    System.out.println(student0.getName() == student1.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。那么如何才能实现深拷贝呢？</p><p>​                              </p><p>​             </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;   <span class="hljs-comment">//这里我们改进一下，针对成员变量也进行拷贝</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) <span class="hljs-built_in">super</span>.clone();<br>    student.name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name);<br>    <span class="hljs-keyword">return</span> student;   <span class="hljs-comment">//成员拷贝完成后，再返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了深拷贝。</p><hr><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/6386mh7anqt4tzyv">https://www.itbaima.cn/document/6386mh7anqt4tzyv</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/post/3d053257-9a1f-4b4c-b2bc-eacffab49599/"/>
    <url>/post/3d053257-9a1f-4b4c-b2bc-eacffab49599/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p><code>hexo template generate by typora plugin templater</code></p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。</p><blockquote><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p></blockquote><p>比如我们现在有一个 People 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个人类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 人类会编程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;int mian() &#123;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   printf(\&quot;Holle Wrold!\&quot;);&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;啊嘞，怎么运行不起？明明照着老师敲的啊&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 工厂打螺丝也会</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;真开心，能进到富土康打螺丝&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;诶，怎么工友都提桶跑路了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 送外卖也会</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ride</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天终于通过美团最终面，加入了梦寐以求的大厂了&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，而我是现场问会不会骑车&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;（迫不及待穿上外卖服装）&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，这个 People 类可以说是十八般武艺样样精通了，啥都会，但是实际上，我们每个人最终都是在自己所擅长的领域工作，所谓闻道有先后，术业有专攻，会编程的就应该是程序员，会打螺丝的就应该是工人，会送外卖的应该是骑手，显然这个 People 太过臃肿（我们需要修改任意一种行为都需要修改 People 类，它拥有不止一个引起它变化的原因），所以根据单一职责原则，我们下需要进行更明确的划分，同种类型的操作我们一般才放在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 程序员会编程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;int mian() &#123;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   printf(\&quot;Hello World!\&quot;)&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;啊嘞，怎么运行不起？明明照着老师敲的啊&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 工人会打螺丝</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;真开心，能进到富土康打螺丝&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;诶，怎么工友都提桶跑路了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rider</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 骑手会送外卖</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ride</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天终于通过美团最终面，加入了梦寐以求的大厂&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，我是现场问会不会骑车&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;（迫不及待穿上外卖服装）&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计 Mapper、Service、Controller 等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现<strong>高内聚低耦合</strong>的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open Close Principle）也是重要的面向对象设计原则。</p><blockquote><p>软件实体应当对扩展开放，对修改关闭。</p></blockquote><p>一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。</p><p>比如我们的程序员分为 Java 程序员、C#程序员、C 艹程序员、PHP 程序员、前端程序员等，而他们要做的都是去打代码，而具体如何打代码是根据不同语言的程序员来决定的，我们可以将程序员打代码这一个行为抽象成一个统一的接口或是抽象类，这样我们就满足了开闭原则的第一个要求：对扩展开放，不同的程序员可以自由地决定他们该如何进行编程。而具体哪个程序员使用什么语言怎么编程，是自己在负责，不需要其他程序员干涉，所以满足第二个要求：对修改关闭，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coder</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Java太卷了T_T，快去学Go吧！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PHPCoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coder</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;PHP是世界上最好的语言&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>艹Coder <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coder</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;笑死，Java再牛逼底层不还得找我？&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过提供一个 Coder 抽象类，定义出编程的行为，但是不进行实现，而是开放给其他具体类型的程序员来实现，这样就可以根据不同的业务进行灵活扩展了，具有较好的延续性。</p><p>不过，回顾我们这一路的学习，好像处处都在使用开闭原则。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则（Liskov Substitution Principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在 1987 年在一次会议上名为 “数据的抽象与层次” 的演说中首先提出。</p><blockquote><p>所有引用基类的地方必须能透明地使用其子类的对象。</p></blockquote><p><strong>简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能：</strong></p><ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或与父类一样。</li></ol><p>比如我们下面的例子：</p><p>​                              </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会打代码&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coder</span>&#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 子类除了会打代码之外，还会打游戏</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">game</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;艾欧尼亚最强王者已上号&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 JavaCoder 虽然继承自 Coder，<strong>但是并没有对父类方法进行重写，并且还在父类的基础上进行额外扩展，符合里氏替换原则。</strong>但是我们再来看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会打代码&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Coder</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">game</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;艾欧尼亚最强王者已上号&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 这里我们对父类的行为进行了重写，现在它不再具备父类原本的能力了</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我寒窗苦读十六年，到最后还不如培训班三个月出来的程序员&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;想来想去，房子车子结婚彩礼，为什么这辈子要活的这么累呢？&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;难道来到这世间走这一遭就为了花一辈子时间买个房子吗？一个人不是也能活的轻松快乐吗？&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;摆烂了，啊对对对&quot;</span>);  <br>          <span class="hljs-comment">//好了，emo 结束，继续卷吧，人生因奋斗而美丽，这个世界虽然满目疮痍，但是还是有很多美好值得期待</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，现在我们对父类的方法进行了重写，显然，父类的行为已经被我们给覆盖了，这个子类已经不具备父类的原本的行为，很显然<strong>违背了里氏替换原则。</strong></p><p>要是程序员连敲代码都不会了，还能叫做程序员吗？</p><p>所以，对于这种情况，我们不需要再继承自 Coder 了，我们可以提升一下，将此行为定义到 People 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//这个行为还是定义出来，但是不实现</span><br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Coder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我会打代码&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">game</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;艾欧尼亚最强王者已上号&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">coding</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;摆烂了，啊对对对&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里氏替换也是实现开闭原则的重要方式之一。</p><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的 Spring 框架了。</p><blockquote><p>高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。</p></blockquote><p>还记得我们在我们之前的学习中为什么要一直使用接口来进行功能定义，然后再去实现吗？我们回顾一下在使用 Spring 框架之前的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>();<br>      <span class="hljs-comment">//该怎么用就这么用</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>        <span class="hljs-comment">//CRUD...</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserMapper</span>();<br>        <span class="hljs-comment">//业务代码....</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();<br>        <span class="hljs-comment">//业务代码....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是突然有一天，公司业务需求变化，现在用户相关的业务操作需要使用新的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>        <span class="hljs-comment">//CRUD...</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceNew</span> &#123;   <span class="hljs-comment">//由于 UserServiceNew 发生变化，会直接影响到其他高层模块</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserMapper</span>();<br>        <span class="hljs-comment">//业务代码....</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;   <span class="hljs-comment">//焯，干嘛改底层啊，我这又得重写了</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>();   <span class="hljs-comment">//哦豁，原来的不能用了</span><br>        <span class="hljs-type">UserServiceNew</span> <span class="hljs-variable">serviceNew</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceNew</span>();   <span class="hljs-comment">//只能修改成新的了</span><br>        <span class="hljs-comment">//业务代码....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，我们的各个模块之间实际上是具有强关联的，一个模块是直接指定依赖于另一个模块，虽然这样结构清晰，但是底层模块的变动，会直接影响到其他依赖于它的高层模块，如果我们的项目变得很庞大，那么这样的修改将是一场灾难。</p><p>而有了 Spring 框架之后，我们的开发模式就发生了变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserController</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>        <span class="hljs-comment">//接口中只做 CRUD 方法定义</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>        <span class="hljs-comment">//实现类完成 CRUD 具体实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>        <span class="hljs-comment">//业务代码定义....</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>        <span class="hljs-meta">@Resource</span>   <span class="hljs-comment">//现在由 Spring 来为我们选择一个指定的实现类，然后注入，而不是由我们在类中硬编码进行指定</span><br>        UserMapper mapper;<br>        <br>        <span class="hljs-comment">//业务代码具体实现</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>        <span class="hljs-meta">@Resource</span><br>        UserService service;   <span class="hljs-comment">//直接使用接口，就算你改实现，我也不需要再修改代码了</span><br><br>        <span class="hljs-comment">//业务代码....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过使用接口，我们就可以将原有的强关联给弱化，我们只需要知道接口中定义了什么方法然后去使用即可，而具体的操作由接口的实现类来完成，并由 Spring 来为我们注入，而不是我们通过硬编码的方式去指定。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。</p><blockquote><p>客户端不应依赖那些它不需要的接口。</p></blockquote><p>我们在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Device</span> &#123;<br>    String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//电脑就是一种电子设备，那么我们就实现此接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Device</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;i9-12900K&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电脑&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;32G DDR5&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电风扇也算是一种电子设备</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Device</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">//就一个破风扇，还需要 CPU？</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;风扇&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">//风扇也不需要内存吧</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然我们定义了一个 Device 接口，但是由于此接口的粒度不够细，虽然比较契合电脑这种设备，但是不适合风扇这种设备，因为风扇压根就不需要 CPU 和内存，所以风扇完全不需要这些方法。这时我们就必须要对其进行更细粒度的划分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmartDevice</span> &#123;   <span class="hljs-comment">//智能设备才有 getCpu 和 getMemory</span><br>    String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NormalDevice</span> &#123;   <span class="hljs-comment">//普通设备只有 getType</span><br>    String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//电脑就是一种电子设备，那么我们就继承此接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmartDevice</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;i9-12900K&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;电脑&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;32G DDR5&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电风扇也算是一种电子设备</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NormalDevice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;风扇&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就将接口进行了细粒度的划分，不同类型的电子设备就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则（Composite Reuse Principle）的核心就是委派。</p><blockquote><p>优先使用对象组合，而不是通过继承来达到复用的目的。</p></blockquote><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如 A 类实现了连接数据库的功能，恰巧 B 类中也需要，我们就可以通过继承来获得 A 已经写好的连接数据库的功能，这样就能直接复用 A 中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。</p><p>比如下面这个例子：</p><p>​                              </p><p>​        java        复制代码      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectDatabase</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是连接数据库操作！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-comment">//直接通过继承的方式，得到 A 的数据库连接逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);<br>        connectDatabase();   <span class="hljs-comment">//直接调用父类方法就行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。</p><p>可以看到通过继承的方式实现复用，我们是将类 B 直接指定继承自类 A 的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由 A 来负责，而是由新来的 C 去负责，那么这个时候，我们就不得不将需要复用 A 中方法的子类全部进行修改，很显然这样是费时费力的。</p><p>并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。</p><p>所以，当我们需要实现复用时，可以优先考虑以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectDatabase</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是连接数据库操作！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;   <span class="hljs-comment">//不进行继承，而是在用的时候给我一个 A，当然也可以抽象成一个接口，更加灵活</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(A a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);<br>        a.connectDatabase();   <span class="hljs-comment">//在通过传入的对象 A 去执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectDatabase</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是连接数据库操作！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <br>    A a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(A a)</span>&#123;   <span class="hljs-comment">//在构造时就指定好</span><br>        <span class="hljs-built_in">this</span>.a = a;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);<br>        a.connectDatabase();   <span class="hljs-comment">//也是通过对象 A 去执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对象之间的组合，我们就大大降低了类之间的耦合度，并且 A 的实现细节我们也不会直接得到了。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。</p><blockquote><p>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></blockquote><p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p><p>其实说白了，还是降低耦合度，我们还是来看一个例子：</p><p>​                              </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);   <span class="hljs-comment">//假设我们当前的程序需要进行网络通信</span><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        test.test(socket);   <span class="hljs-comment">//现在需要执行 test 方法来做一些事情</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 比如 test 方法需要得到我们当前 Socket 连接的本地地址</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Socket socket)</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;IP地址：&quot;</span>+socket.getLocalAddress());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，虽然上面这种写法没有问题，我们提供直接提供一个 Socket 对象，然后再由 test 方法来取出 IP 地址，但是这样显然违背了迪米特法则，实际上这里的 <code>test</code> 方法只需要一个 IP 地址即可，我们完全可以直接传入一个字符串，而不是整个 Socket 对象，我们需要保证与其他类的交互尽可能的少。</p><p>就像我们在餐厅吃完了饭，应该是我们自己扫码付款，而不是直接把手机交给老板来帮你操作付款。</p><p>要是某一天，Socket 类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。</p><p>所以，我们来改进改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>);<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        test.test(socket.getLocalAddress().getHostAddress());  <span class="hljs-comment">//在外面解析好就行了</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;   <span class="hljs-comment">//一个字符串就能搞定，就没必要丢整个对象进来</span><br>            System.out.println(<span class="hljs-string">&quot;IP地址：&quot;</span>+str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，类与类之间的耦合度再次降低。</p><hr><p>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。</p><p>原文链接：<a href="https://www.itbaima.cn/document/6386mh7anqt4tzyv">https://www.itbaima.cn/document/6386mh7anqt4tzyv</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>560. 和为 K 的子数组</title>
    <link href="/post/5114e513-0f9f-414d-887a-73479298e447/"/>
    <url>/post/5114e513-0f9f-414d-887a-73479298e447/</url>
    
    <content type="html"><![CDATA[<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; nums.length;i++)&#123;<br>             result += formIndexHasSubArraySum(nums,k,i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//从第 index 位开始寻找, 是否存在一个连续数组和等于 k , </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">formIndexHasSubArraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k , <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;nums.length; i++ )&#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span>(sum == k)&#123;<br>                count ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>中等</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49. 字母异位词分组</title>
    <link href="/post/634b9f44-37c7-4385-81d0-02957234546a/"/>
    <url>/post/634b9f44-37c7-4385-81d0-02957234546a/</url>
    
    <content type="html"><![CDATA[<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>            <span class="hljs-keyword">final</span> HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>                <span class="hljs-comment">//将每一个单词分解</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>                <span class="hljs-comment">//排序</span><br>                Arrays.sort(chars);<br>                <span class="hljs-comment">//组成key</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>                <span class="hljs-comment">//根据key 取一组异位词数据,没有就new 一个</span><br>                <span class="hljs-keyword">final</span> List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>                <span class="hljs-comment">//将当前词语放在这一组中</span><br>                list.add(str);<br>                <span class="hljs-comment">//更新数据</span><br>                map.put(key, list);<br>            &#125;<br>            <span class="hljs-comment">//返回map中所有的值</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> String[] strings = &#123;<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>&#125;;<br>    System.out.println(<span class="hljs-string">&quot;new Solution().groupAnagrams(strings) = &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>().groupAnagrams(strings));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>().groupAnagrams(strings) = [[eat, tea, ate], [bat], [tan, nat]]<br><br>进程已结束，退出代码为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Hot100</tag>
      
      <tag>中等</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot 核心特性</title>
    <link href="/post/2340056a-ebde-4c90-9452-04055c1a718a/"/>
    <url>/post/2340056a-ebde-4c90-9452-04055c1a718a/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-核心特性"><a href="#Spring-Boot-核心特性" class="headerlink" title="Spring Boot 核心特性"></a>Spring Boot 核心特性</h1><p>Spring 教程</p><hr><p>本部分将介绍 Spring Boot 相关的细节内容. 在这里, 您可以学习到可能需要使用和自定义的主要功能. 您如果还没有做好充分准备, 可能需要阅读 “<a href="https://sca.aliyun.com/learn/spring-boot/core/getting-started.html#getting-started">入门</a>” 和 “<a href="https://sca.aliyun.com/learn/spring-boot/core/using.html#using">使用 Spring Boot 进行开发</a>” , 以便打下前期基础.</p><h2 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a>1. SpringApplication</h2><p><code>SpringApplication</code> 类提供了一种可通过运行 <code>main()</code> 方法来启动 Spring 应用的简单方式. 大多数情况下, 您只需要委托给静态的 <code>SpringApplication.run</code> 方法:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplicationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;     <br>        SpringApplication.run(MyApplication.class, args);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当应用启动时, 您应该会看到类似以下的内容输出:</p><p>. ____ _ _ _ _ _ &#x2F;\ &#x2F; _ <em><em>’</em> _ _ _ <em>(</em>)_ _ _ _ _ _ \ \ \ \ ( ( )_</em> _ | ’_ | ’_| | ’_ / <em>&#96; | \ \ \ \ \&#x2F; <em>_<em>)| |</em>)| | | | | || (_| | ) ) ) ) ’ |</em></em><strong>| .</strong>|<em>| |</em>|<em>| |</em>_<em>, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</em>|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|<em>_<em>&#x2F;&#x3D;&#x2F;</em>&#x2F;_&#x2F;</em>&#x2F; :: Spring Boot :: (v3.0.0)</p><p>2022-11-24T17:03:48.214Z INFO 20764 — [ main] o.s.b.d.f.s.MyApplication : Starting MyApplication using Java 17.0.5 with PID 20764 (&#x2F;opt&#x2F;apps&#x2F;myapp.jar started by myuser in &#x2F;opt&#x2F;apps&#x2F;) 2022-11-24T17:03:48.219Z INFO 20764 — [ main] o.s.b.d.f.s.MyApplication : No active profile set, falling back to 1 default profile: “default” 2022-11-24T17:03:50.511Z INFO 20764 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2022-11-24T17:03:50.524Z INFO 20764 — [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2022-11-24T17:03:50.524Z INFO 20764 — [ main] o.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat&#x2F;10.1.1] 2022-11-24T17:03:50.623Z INFO 20764 — [ main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring embedded WebApplicationContext 2022-11-24T17:03:50.625Z INFO 20764 — [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2269 ms 2022-11-24T17:03:51.380Z INFO 20764 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ” 2022-11-24T17:03:51.418Z INFO 20764 — [ main] o.s.b.d.f.s.MyApplication : Started MyApplication in 3.872 seconds (process running for 5.008) 2022-11-24T17:03:51.506Z INFO 20764 — [ionShutdownHook] o.apache.catalina.core.StandardService : Stopping service [Tomcat]</p><p>默认情况下, 将显示 <code>INFO</code> 级别的日志信息, 包括一些应用启动相关信息. 如果您需要修改 <code>INFO</code> 日志级别, 请参考 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.logging.log-levels">日志等级</a>.</p><p>使用主应用程序类包中的实现版本来确定应用程序版本. 可以通过将 <code>spring.main.log-startup-info</code> 设置为 <code>false</code> 来关闭启动信息记录. 这还将关闭对应用程序 active 配置文件的日志记录.</p><p>要在启动期间添加其他日志记录, 可以在 <code>SpringApplication</code> 的子类中重写 <code>logStartupInfo(boolean)</code>.</p><h3 id="1-1-启动失败"><a href="#1-1-启动失败" class="headerlink" title="1.1. 启动失败"></a>1.1. 启动失败</h3><p>如果您的应用无法启动, 注册的 <code>FailureAnalyzers</code> 可能会提供有相关的错误信息和解决问题的具体方法. 例如, 如果您在已经被占用的 <code>8080</code> 端口上启动了一个 web 应用, 会看到类似以下的错误信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">**** **** **** **** **** **** *** APPLICATION FAILED TO START *** **** **** **** **** **** ****<br><br>Description:<br><br>Embedded servlet container failed to start. Port <span class="hljs-number">8080</span> was already in use.<br><br>Action:<br><br>Identify and stop the process that is listening on port <span class="hljs-number">8080</span> or configure <span class="hljs-built_in">this</span> application to listen on another port.<br></code></pre></td></tr></table></figure><p>Spring Boot 提供了许多的 <code>FailureAnalyzer</code> 实现, 您也可以 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.application.failure-analyzer">添加自己的实现</a>.</p><p>如果没有失败分析器能够处理的异常, 您仍然可以显示完整的条件报告以便更好地了解出现的问题. 为此, 您需要针对 <code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code> <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config">启用 <code>debug</code> 属性</a> 或者 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.logging.log-levels">开启 <code>DEBUG</code> 日志</a>.</p><p>例如, 如果您使用 <code>java -jar</code> 运行应用, 可以按以下方式启用 <code>debug</code> 属性:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>myproject<span class="hljs-number">-0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>-SNAPSHOT.<span class="hljs-keyword">jar </span>--<span class="hljs-built_in">debug</span><br></code></pre></td></tr></table></figure><h3 id="1-2-延迟初始化"><a href="#1-2-延迟初始化" class="headerlink" title="1.2. 延迟初始化"></a>1.2. 延迟初始化</h3><p><code>SpringApplication</code> 允许延迟地初始化应用程序. 启用延迟初始化后, 将根据需要创建 bean, 而不是在应用程序启动期间创建 bean. 因此, 启用延迟初始化可以减少应用程序启动所需的时间. 在 Web 应用程序中, 启用延迟初始化将导致许多与 Web 相关的 Bean 在收到 HTTP 请求后才被初始化.</p><p>延迟初始化的缺点是, 它可能会延迟发现应用程序问题的时间. 如果配置错误的 Bean 延迟初始化, 则在启动期间不会发生问题, 并且只有在初始化 Bean 时问题才会变得明显. 还必须注意确保 JVM 有足够的内存来容纳所有应用程序的 bean, 而不仅仅是启动期间初始化的 bean. 由于这些原因, 默认情况下不会启用延迟初始化, 因此建议在启用延迟初始化之前先对 JVM 的堆大小进行微调.</p><p>可以使用 <code>SpringApplicationBuilder</code> 上的 <code>lazyInitialization</code> 方法或 <code>SpringApplication</code> 上的 <code>setLazyInitialization</code> 方法以编程方式启用延迟初始化. 另外, 可以使用 <code>spring.main.lazy-initialization</code> 属性启用它, 如以下示例所示:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">main:</span><br><br>    <span class="hljs-attr">lazy-initialization:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果您禁用了延迟初始化，但对应用程序其余部分使用延迟初始化时, 则可以使用 <code>@Lazy(false)</code> 注解将它们的延迟属性显式设置为 <code>false</code>.</p><h3 id="1-3-自定义-banner"><a href="#1-3-自定义-banner" class="headerlink" title="1.3. 自定义 banner"></a>1.3. 自定义 banner</h3><p>可以通过在 classpath 下添加一个 <code>banner.txt</code> 文件, 或者将 <code>spring.banner.location</code> 属性指向该文件的位置来更改启动时打印的 banner. 如果文件采用了非 UTF-8 编码, 您可以设置 <code>spring.banner.charset</code> 来解决.</p><p>您可以在 <code>banner.txt</code> 文件中使用 <code>Environment</code> 环境变量以及以下占位符:</p><p>Table 1. Banner 变量</p><p>变量</p><p>描述</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$&#123;<span class="hljs-built_in">application</span>.<span class="hljs-built_in">version</span>&#125;<br></code></pre></td></tr></table></figure><p>您的应用版本号, 声明在 <code>MANIFEST.MF</code> 中. 例如, <code>Implementation-Version: 1.0</code> 将被打印为 <code>1.0</code>.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$&#123;<span class="hljs-built_in">application</span>.formatted-<span class="hljs-built_in">version</span>&#125;<br></code></pre></td></tr></table></figure><p>您的应用版本号, 声明在 <code>MANIFEST.MF</code> 中, 格式化之后打印 (用括号括起来, 以 <code>v</code> 为前缀) , 例如 <code>(v1.0)</code>.</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword">version</span>&#125;<br></code></pre></td></tr></table></figure><p>您使用的 Spring Boot 版本. 例如 <code>3.0.0</code>.</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.formatted-<span class="hljs-keyword">version</span>&#125;<br></code></pre></td></tr></table></figure><p>您使用的 Spring Boot 版本格式化之后显示 (用括号括起来, 以 <code>v</code> 为前缀) . 例如 <code>(v3.0.0)</code>.</p><p><code>$&#123;Ansi.NAME&#125;</code> (or <code>$&#123;AnsiColor.NAME&#125;</code>, <code>$&#123;AnsiBackground.NAME&#125;</code>, <code>$&#123;AnsiStyle.NAME&#125;</code>)</p><p>其中 <code>NAME</code> 是 ANSI 转义码的名称. 有关详细信息, 请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$&#123;<span class="hljs-built_in">application</span>.title&#125;<br></code></pre></td></tr></table></figure><p>您的应用标题, 声明在 <code>MANIFEST.MF</code> 中, 例如 <code>Implementation-Title: MyApp</code> 打印为 <code>MyApp</code>.</p><p>如果您想以编程的方式生成 banner, 可以使用 <code>SpringApplication.setBanner(…)</code> 方法. 使用 <code>org.springframework.boot.Banner</code> 接口并实现自己的 <code>printBanner()</code> 方法.</p><p>您还可以使用 <code>spring.main.banner-mode</code> 属性来确定是否必须在 <code>System.out</code> (<code>console</code>) 上打印 banner, 还是使用日志记录器 (<code>log</code>) 或者都不打印 (<code>off</code>).</p><p>打印的 banner 的单例 bean 为： <code>springBootBanner</code> .</p><p>只有在使用 Spring Boot 启动时， <code>$ &#123;application.version&#125;</code> 和 <code>$&#123;application.formatted-version&#125;</code> 属性才可用. 如果您运行的是未打包的 jar 并以 <code>java -cp &lt;classpath&gt; &lt;mainclass&gt;</code> 开头， 则无法解析这些值.</p><p>这就是为什么我们建议您始终使用通过 <code>java org.springframework.boot.loader.JarLauncher</code> 来启动未打包的 jar 的原因. 这将在构建类路径并启动您的应用程序之前初始化 <code>application.*</code> 变量.</p><h3 id="1-4-自定义-SpringApplication"><a href="#1-4-自定义-SpringApplication" class="headerlink" title="1.4. 自定义 SpringApplication"></a>1.4. 自定义 SpringApplication</h3><p>如果 <code>SpringApplication</code> 的默认设置不符合您的想法, 您可以创建本地实例进行定制化. 例如, 要关闭 banner, 您可以这样:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplicationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(MyApplication.class);        application.setBannerMode(Banner.Mode.OFF);   <br>        application.run(args);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入 <code>SpringApplication</code> 的构造参数是 Spring beans 的配置源. 大多情况下是引用 <code>@Configuration</code> 类, 但您也可以引用 XML 配置或者被扫描的包.</p><p>也可以使用 <code>application.properties</code> 文件配置 <code>SpringApplication</code>. 有关详细信息, 请参见 <em><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config">外部化配置</a></em>.</p><p>关于配置选项的完整列表, 请参阅 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a>.</p><h3 id="1-5-Fluent-Builder-API-流式构建-API"><a href="#1-5-Fluent-Builder-API-流式构建-API" class="headerlink" title="1.5. Fluent Builder API(流式构建 API)"></a>1.5. Fluent Builder API(流式构建 API)</h3><p>如果您需要构建一个有层级关系的 <code>ApplicationContext</code> (具有父&#x2F;子关系的多上下文) , 或者偏向使用 fluent (流式) 构建器 API, 可以使用 <code>SpringApplicationBuilder</code>.</p><p><code>SpringApplicationBuilder</code> 允许您链式调用多个方法, 包括能创建出具有层次结构的 <code>parent</code> 和 <code>child</code> 方法.</p><p>例如:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()<br><br>    .sources(Parent.class)<br><br>    .child(Application.class)<br><br>    .bannerMode(Banner.Mode.OFF)<br><br>    .run(args);<br></code></pre></td></tr></table></figure><p>创建层级的 <code>ApplicationContext</code> 时有部分限制, 比如 Web 组件必须包含在子上下文中, 并且相同的 <code>Environment</code> 将作用于父子上下文. 有关详细信息, 请参阅 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a> .</p><h3 id="1-6-应用程序的可用性"><a href="#1-6-应用程序的可用性" class="headerlink" title="1.6. 应用程序的可用性"></a>1.6. 应用程序的可用性</h3><p>在平台上部署后, 应用程序可以使用诸如 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Kubernetes Probes</a> 之类的基础结构向平台提供有关其可用性的信息. Spring Boot 对常用的 “liveness” 和 “readiness” 可用性状态提供了开箱即用的支持. 如果您使用了 Spring Boot 的 “actuator” 支持, 则这些状态将显示为运行状况端点组.</p><p>另外, 您还可以通过将 <code>ApplicationAvailability</code> 接口注入到您自己的 bean 中来获取可用性状态.</p><h4 id="1-6-1-Liveness-State"><a href="#1-6-1-Liveness-State" class="headerlink" title="1.6.1. Liveness State"></a>1.6.1. Liveness State</h4><p>应用程序的 “Liveness” 状态表明其内部是否正常运行, 或者在当前出现故障时自行恢复. 一个 broken （损坏）的 “Liveness” 状态意味着应用程序处于无法恢复的状态, 并且应重新启动应用程序.</p><p>通常,“Liveness” 状态不应基于外部检查 (例如 <a href="https://sca.aliyun.com/learn/spring-boot/core/actuator.html#actuator.endpoints.health">Health checks</a>) . 如果确实如此, 则发生故障的外部系统 (数据库, Web API, 外部缓存) 将触发整个平台的大量重启和级联故障.</p><p>Spring Boot 应用程序的内部状态主要由 Spring <code>ApplicationContext</code> 表示. 如果应用程序上下文已成功启动, 则 Spring Boot 会假定该应用程序处于有效状态. 刷新上下文后, 应用程序即被视为活动应用程序, 请参阅 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.spring-application.application-events-and-listeners">Spring Boot 应用程序生命周期和相关的应用程序事件</a>.</p><h4 id="1-6-2-Readiness-State"><a href="#1-6-2-Readiness-State" class="headerlink" title="1.6.2. Readiness State"></a>1.6.2. Readiness State</h4><p>应用程序的 “Readiness” 状态告诉应用程序是否已准备好处理流量. failing（失败的） “Readiness” 状态告诉平台当前不应将流量路由到应用程序. 这通常发生在启动过程中, 正在处理 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 组件时, 或者在应用程序认为它太忙而无法获得额外流量的情况下.</p><p>一旦调用了应用程序和命令行运行程序, 就认为该应用程序已准备就绪, 请参阅 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.spring-application.application-events-and-listeners">Spring Boot 应用程序生命周期和相关的应用程序事件</a>.</p><p>预期在启动期间运行的任务应由 <code>CommandLineRunner</code> 和 <code>ApplicationRunner</code> 组件执行, 而不是使用 Spring 组件生命周期回调 (如 <code>@PostConstruct</code>) 执行.</p><h4 id="1-6-3-管理应用程序可用性状态"><a href="#1-6-3-管理应用程序可用性状态" class="headerlink" title="1.6.3. 管理应用程序可用性状态"></a>1.6.3. 管理应用程序可用性状态</h4><p>通过注入 <code>ApplicationAvailability</code> 接口并调用其方法, 应用程序组件可以随时检索当前的可用性状态. 应用程序通常会希望监听状态更新或更新应用程序的状态.</p><p>例如, 我们可以将应用程序的 “Readiness” 状态导出到文件中, 以便 Kubernetes 的 “exec Probe” 可以查看此文件:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReadinessStateExporter</span> &#123;<br>    <span class="hljs-meta">@EventListener</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStateChange</span><span class="hljs-params">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> &#123;        <br>        <span class="hljs-keyword">switch</span> (event.getState()) &#123;   <br>            <span class="hljs-keyword">case</span> ACCEPTING_TRAFFIC:       <br>                <span class="hljs-comment">// create file /tmp/healthy   </span><br>                <span class="hljs-keyword">break</span>;       <br>            <span class="hljs-keyword">case</span> REFUSING_TRAFFIC:        <br>                <span class="hljs-comment">// remove file /tmp/healthy    </span><br>                <span class="hljs-keyword">break</span>;        &#125;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当应用程序崩溃且无法恢复时, 我们还可以更新应用程序的状态:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLocalCacheVerifier</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationEventPublisher eventPublisher;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLocalCacheVerifier</span><span class="hljs-params">(ApplicationEventPublisher eventPublisher)</span> &#123;   <br>        <span class="hljs-built_in">this</span>.eventPublisher = eventPublisher;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLocalCache</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// ...  </span><br>    &#125;        <span class="hljs-keyword">catch</span> (CacheCompletelyBrokenException ex) &#123;      <br>        AvailabilityChangeEvent.publish(<span class="hljs-built_in">this</span>.eventPublisher, ex, LivenessState.BROKEN);     <br>    &#125;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring Boot 通过 <a href="https://sca.aliyun.com/learn/spring-boot/core/actuator.html#actuator.endpoints.kubernetes-probes">Kubernetes HTTP probes for “Liveness” and “Readiness” with Actuator Health Endpoints</a>.您可以在专用部分中获得 <a href="https://sca.aliyun.com/learn/spring-boot/core/deployment.html#deployment.cloud.kubernetes">有关在 Kubernetes 上部署 Spring Boot 应用程序的更多指南</a>.</p><h3 id="1-7-应用程序事件与监听器"><a href="#1-7-应用程序事件与监听器" class="headerlink" title="1.7. 应用程序事件与监听器"></a>1.7. 应用程序事件与监听器</h3><p>除了常见的 Spring Framework 事件, 比如 <a href="https://docs.spring.io/spring-framework/docs/6.0.2/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a>, <code>SpringApplication</code> 还会发送其他应用程序事件.</p><p>在 <code>ApplicationContext</code> 创建之前, 实际上触发了一些事件, 因此您不能像 <code>@Bean</code> 一样注册监听器. 您可以通过 <code>SpringApplication.addListeners(…)</code> 或者 <code>SpringApplicationBuilder.listeners(…)</code> 方法注册它们.</p><p>如果您希望无论应用使用何种创建方式都能自动注册这些监听器, 您都可以将 <code>META-INF/spring.factories</code> 文件添加到项目中, 并使用 <code>org.springframework.context.ApplicationListener</code> 属性键指向您的监听器. 比如:</p><p>org.springframework.context.ApplicationListener &#x3D; com.example.project.MyListener</p><p>当您运行应用时, 应用程序事件将按照以下顺序发送:</p><ol><li>在开始应用开始运行但还没有进行任何处理时 (除了注册 listeners 和 initializers ) , 将发送 <code>ApplicationStartingEvent</code>.</li><li>当 <code>Environment</code> 被上下文使用, 但是在上下文创建之前, 将发送 <code>ApplicationEnvironmentPreparedEvent</code>.</li><li>准备 <code>ApplicationContext</code> 并调用 <code>ApplicationContextInitializers</code> 之后但在加载任何 bean 定义之前, 将发送 <code>ApplicationContextInitializedEvent</code>.</li><li>开始刷新之前, bean 定义被加载之后发送 <code>ApplicationPreparedEvent</code>.</li><li>在上下文刷新之后且所有的应用和命令行运行器 (command-line runner) 被调用之前发送 <code>ApplicationStartedEvent</code>.</li><li>紧随其后发送带有 <code>LivenessState.CORRECT</code> 的 <code>AvailabilityChangeEvent</code>, 以指示该应用程序处于活动状态.</li><li>在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.spring-application.command-line-runner">应用程序和命令行运行器 (command-line runner)</a> 被调用之后, 将发出, 将发送 <code>ApplicationReadyEvent</code>.</li><li>随即在 <code>ReadinessState.ACCEPTING_TRAFFIC</code> 之后发送 <code>AvailabilityChangeEvent</code>, 以指示该应用程序已准备就绪, 可以处理请求.</li><li>如果启动时发生异常, 则发送 <code>ApplicationFailedEvent</code>.</li></ol><p>上面的列表仅包含绑定到 <code>SpringApplication</code> 的 <code>SpringApplicationEvent</code> s. 除这些以外, 以下事件也在 <code>ApplicationPreparedEvent</code> 之后和 <code>ApplicationStartedEvent</code> 之前发布:</p><ol><li><code>WebServer</code> 准备就绪后, 将发送 <code>WebServerInitializedEvent</code>. <code>ServletWebServerInitializedEvent</code> 和 <code>ReactiveWebServerInitializedEvent</code> 分别是 servlet 和 reactive 变量.</li><li>刷新 <code>ApplicationContext</code> 时, 将发送 <code>ContextRefreshedEvent</code> 事件.</li></ol><p>您可能不会经常使用应用程序事件, 但了解他们的存在还是很有必要的. 在框架内部, Spring Boot 使用这些事件来处理各种任务.</p><p>默认情况下, 事件监听器不应该运行可能很长的任务, 因为它们在同一个线程中执行.考虑改用 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.spring-application.command-line-runner">application and command-line runners</a>.</p><p>应用程序事件发送使用了 Spring Framework 的事件发布机制. 该部分机制确保在子上下文中发布给监听器的事件也会发布给所有祖先上下文中的监听器. 因此, 如果您的应用程序使用有层级结构的 <code>SpringApplication</code> 实例, 则监听器可能会收到同种类型应用程序事件的多个实例.</p><p>为了让监听器能够区分其上下文事件和后代上下文事件, 您应该注入其应用程序上下文, 然后将注入的上下文与事件的上下文进行比较. 可以通过实现 <code>ApplicationContextAware</code> 来注入上下文, 如果监听器是 bean, 则使用 <code>@Autowired</code> 注入上下文.</p><h3 id="1-8-Web-环境"><a href="#1-8-Web-环境" class="headerlink" title="1.8. Web 环境"></a>1.8. Web 环境</h3><p><code>SpringApplication</code> 试图为您创建正确类型的 <code>ApplicationContext</code>. 确定 <code>WebApplicationType</code> 的算法非常简单:</p><ul><li>如果存在 Spring MVC, 则使用 <code>AnnotationConfigServletWebServerApplicationContext</code></li><li>如果 Spring MVC 不存在且存在 Spring WebFlux, 则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li><li>否则, 使用 <code>AnnotationConfigApplicationContext</code></li></ul><p>这意味着如果您在同一个应用程序中使用了 Spring MVC 和 Spring WebFlux 中的新 <code>WebClient</code>, 默认情况下将使用 Spring MVC. 您可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 修改默认行为.</p><p>也可以调用 <code>setApplicationContextClass(…)</code> 来完全控制 <code>ApplicationContext</code> 类型.</p><p>在 JUnit 测试中使用 <code>SpringApplication</code> 时, 通常需要调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>.</p><h3 id="1-9-访问应用程序参数"><a href="#1-9-访问应用程序参数" class="headerlink" title="1.9. 访问应用程序参数"></a>1.9. 访问应用程序参数</h3><p>如果您需要访问从 <code>SpringApplication.run(…)</code> 传入的应用程序参数, 可以注入一个 <code>org.springframework.boot.ApplicationArguments</code> bean. <code>ApplicationArguments</code> 接口提供了访问原始 <code>String[]</code> 参数以及解析后的 <code>option</code> 和 <code>non-option</code> 参数的方法:</p><p>Java</p><p>Kotlin</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Componentpublic <span class="hljs-keyword">class</span> MyBean &#123;<br>    <span class="hljs-built_in">public</span> MyBean(ApplicationArguments args) &#123;        <span class="hljs-type">boolean</span> <span class="hljs-keyword">debug</span> = args.containsOption(&quot;debug&quot;);        List&lt;String&gt; files = args.getNonOptionArgs();        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">debug</span>) &#123;            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(files);        &#125;        // <span class="hljs-keyword">if</span> run <span class="hljs-keyword">with</span> &quot;--debug logfile.txt&quot; prints [&quot;logfile.txt&quot;]    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring Boot 还向 Spring <code>Environment</code> 注册了一个 <code>CommandLinePropertySource</code>. 这允许您可以使用 <code>@Value</code> 注解注入单个应用参数.</p><h3 id="1-10-使用-ApplicationRunner-或-CommandLineRunner"><a href="#1-10-使用-ApplicationRunner-或-CommandLineRunner" class="headerlink" title="1.10. 使用 ApplicationRunner 或 CommandLineRunner"></a>1.10. 使用 ApplicationRunner 或 CommandLineRunner</h3><p>如果您需要在 <code>SpringApplication</code> 启动时运行一些代码, 可以实现 <code>ApplicationRunner</code> 或者 <code>CommandLineRunner</code> 接口. 这两个接口的工作方式是一样的, 都提供了一个单独的 <code>run</code> 方法, 它将在 <code>SpringApplication.run(…)</code> 完成之前调用.</p><p>这个契约非常适合那些应该在应用程序启动后但在它开始接受流量之前运行的任务.</p><p><code>CommandLineRunner</code> 接口提供了访问应用程序字符串数组形式参数的方法, 而 <code>ApplicationRunner</code> 则使用了上述的 <code>ApplicationArguments</code> 接口. 以下示例展示 <code>CommandLineRunner</code> 和 <code>run</code> 方法的使用:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>... args</span>) &#123;        <span class="hljs-comment">// Do something...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果您定义了多个 <code>CommandLineRunner</code> 或者 <code>ApplicationRunner</code> bean, 则必须指定调用顺序, 您可以实现 <code>org.springframework.core.Ordered</code> 接口, 也可以使用 <code>org.springframework.core.annotation.Order</code> 注解解决顺序问题.</p><h3 id="1-11-应用程序退出"><a href="#1-11-应用程序退出" class="headerlink" title="1.11. 应用程序退出"></a>1.11. 应用程序退出</h3><p>每个 <code>SpringApplication</code> 注册了一个 JVM 关闭钩子, 以确保 <code>ApplicationContext</code> 在退出时可以优雅关闭. 所有标准的 Spring 生命周期回调 (比如 <code>DisposableBean</code> 接口, 或者 <code>@PreDestroy</code> 注解) 都可以使用.</p><p>此外, 如果希望在调用 <code>SpringApplication.exit()</code> 时返回特定的退出码, 则 bean 可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口. 之后退出码将传递给 <code>System.exit()</code> 以将其作为状态码返回, 如示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">@SpringBootApplicationpublic class MyApplication &#123;<br>    @Bean    public ExitCodeGenerator exitCodeGenerator() &#123;        return () -&gt; <span class="hljs-number">42</span>;    &#125;<br>    public static void main(String[] args) &#123;        System.<span class="hljs-keyword">exit</span>(SpringApplication.<span class="hljs-keyword">exit</span>(SpringApplication.run(MyApplication.class, args)));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外, <code>ExitCodeGenerator</code> 接口可以通过异常实现. 遇到这类异常时, Spring Boot 将返回实现的 <code>getExitCode()</code> 方法提供的退出码.</p><p>如果有多个 <code>ExitCodeGenerator</code>，则使用生成的第一个非零退出代码。 要控制调用生成器的顺序，请另外实现 <code>org.springframework.core.Ordered</code> 接口或使用 <code>org.springframework.core.annotation.Order</code> 注解。</p><h3 id="1-12-Admin-Features（管理功能）"><a href="#1-12-Admin-Features（管理功能）" class="headerlink" title="1.12. Admin Features（管理功能）"></a>1.12. Admin Features（管理功能）</h3><p>可以通过指定 <code>spring.application.admin.enabled</code> 属性来为应用程序启用管理相关的功能. 其将在 <code>MBeanServer</code> 平台上暴露 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>. 您可以使用此功能来远程管理 Spring Boot 应用. 该功能对服务包装器的实现也是非常有用的.</p><p>如果您想知道应用程序在哪一个 HTTP 端口上运行, 请使用 <code>local.server.port</code> 键获取该属性.</p><h3 id="1-13-Application-Startup-tracking（应用程序启动跟踪）"><a href="#1-13-Application-Startup-tracking（应用程序启动跟踪）" class="headerlink" title="1.13. Application Startup tracking（应用程序启动跟踪）"></a>1.13. Application Startup tracking（应用程序启动跟踪）</h3><p>在应用程序启动期间，<code>SpringApplication</code> 和 <code>ApplicationContext</code> 执行许多与应用程序生命周期、bean 生命周期甚至处理应用程序事件相关的任务. 使用 <a href="https://docs.spring.io/spring-framework/docs/6.0.2/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html"><code>ApplicationStartup</code></a>, Spring 框架允许你使用 <a href="https://sca.aliyun.com/blog/learning/spring/core/ioc#context-functionality-startup"><code>StartupStep</code> 对象跟踪应用程序的启动顺序</a>. 收集这些数据可以用于分析目的，或者只是为了更好地理解应用程序启动过程.</p><p>您可以在设置 <code>SpringApplication</code> 实例时选择 <code>ApplicationStartup</code> 实现. 例如，要使用 <code>BufferingApplicationStartup</code>，您可以编写:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplicationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;        <span class="hljs-title class_">SpringApplication</span> application = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(<span class="hljs-title class_">MyApplication</span>.<span class="hljs-property">class</span>);        application.<span class="hljs-title function_">setApplicationStartup</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferingApplicationStartup</span>(<span class="hljs-number">2048</span>));        application.<span class="hljs-title function_">run</span>(args);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个可用的实现是由 Spring 框架提供的 <code>FlightRecorderApplicationStartup</code>. 它将特定于 Spring 的启动事件添加到 Java Flight Recorder 会话中，用于分析应用程序，并将其 Spring 上下文生命周期与 JVM 事件(如 allocations、gc、类加载……)关联起来. 一旦配置好，你就可以通过启用 Flight Recorder 运行应用程序来记录数据:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>java -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:StartFlightRecording</span><span class="hljs-symbol">:filename=recording</span>.jfr,duration=10s -jar demo.jar<br></code></pre></td></tr></table></figure><p>Spring Boot 附带 <code>BufferingApplicationStartup</code> , 这个实现的目的是缓冲启动步骤，并将它们抽取到外部指标系统中. 应用程序可以在任何组件中请求 <code>BufferingApplicationStartup</code> 类型的 bean. 此外，Spring Boot Actuator 将 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/actuator-api/htmlsingle/#startup">将暴露一个 <code>startup</code> 端点以将此信息公开为 JSON 文档</a>.</p><h2 id="2-外部化配置"><a href="#2-外部化配置" class="headerlink" title="2. 外部化配置"></a>2. 外部化配置</h2><p>Spring Boot 可以让您的配置外部化, 以便可以在不同环境中使用相同的应用程序代码. 您可以使用各种外部配置源, 包括 Java properties 文件、YAML 文件、环境变量或者命令行参数.</p><p>可以使用 <code>@Value</code> 注解将属性值直接注入到 bean 中, 可通过 Spring 的 <code>Environment</code> 访问, 或者通过 <code>@ConfigurationProperties</code> <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties">绑定到结构化对象</a>.</p><p>Spring Boot 使用了一个非常特别的 <code>PropertySource</code> 指令, 用于覆盖默认值. 属性将按照以下顺序处理(后面的值覆盖前面的值):</p><ol><li>默认属性 (通过设置 <code>SpringApplication.setDefaultProperties</code> 指定).</li><li><code>@Configuration</code> 类上的 <a href="https://docs.spring.io/spring-framework/docs/6.0.2/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> 注解. 请注意，在刷新应用程序上下文之前，不会将此类属性添加到 <code>Environment</code> 中. 这时配置某些属性(如 <code>logging.*</code> and <code>spring.main.*</code>) 已经太晚了. 这些属性在刷新开始之前就已读取.</li><li>配置数据 (例如 <code>application.properties</code> 文件)</li><li>只有 <code>random.*</code> 属性的 <code>RandomValuePropertySource</code>.</li><li>操作系统环境变量.</li><li>Java System 属性 (<code>System.getProperties()</code>).</li><li>来自 <code>java:comp/env</code> 的 JNDI 属性 .</li><li><code>ServletContext</code> 初始化参数.</li><li><code>ServletConfig</code> 初始化参数.</li><li>来自 <code>SPRING_APPLICATION_JSON</code> 的属性 (嵌入在环境变量或者系统属性中的内联 JSON) .</li><li>命令行参数.</li><li>测试中的 <code>properties</code>.</li><li>在测试中使用到的 <code>properties</code> 属性, 可以是 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a> 和 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-tests">用于测试应用程序某部分的测试注解</a>.</li><li>在测试中使用到的 <a href="https://docs.spring.io/spring-framework/docs/6.0.2/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> 注解.</li><li>当 devtools 被激活, <code>$HOME/.config/spring-boot</code> 目录中的 <a href="https://sca.aliyun.com/learn/spring-boot/core/using.html#using.devtools.globalsettings">Devtools 全局设置属性</a>.</li></ol><p>配置数据文件按以下顺序进行：</p><ol><li>在已打包的 jar 内部的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files">Application properties</a> 文件 (<code>application.properties</code> 和 YAML 变量).</li><li>在已打包的 jar 内部的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">指定 profile 的应用属性文件</a> (<code>application-&#123;profile&#125;.properties</code> 和 YAML 变量).</li><li>在已打包的 jar 外部的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files">Application properties</a> 文件 (<code>application.properties</code> 和 YAML 变量).</li><li>在已打包的 jar 外部的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">指定 profile 的应用属性文件</a> (<code>application-&#123;profile&#125;.properties</code> 和 YAML 变量).</li></ol><p>建议您在整个应用程序中坚持使用一种格式. 如果在相同的位置有 <code>.properties</code> 和 <code>.yml</code> 格式的配置文件，则 <code>.properties</code> 优先.</p><p>举个例子, 假设开发的 <code>@Component</code> 使用了 <code>name</code> 属性, 可以这样:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> &#123;<br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>&quot;</span>)</span>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在您的应用程序的 classpath 中 (比如在 jar 中) , 您可以有一个 <code>application.properties</code>, 它为 name 提供了一个合适的默认属性值. 当在新环境中运行时, 您可以在 jar 外面提供一个 <code>application.properties</code> 来覆盖 <code>name</code>. 对于一次性测试, 您可以使用命令行指定形式启动 (比如 <code>java -jar app.jar --name=&quot;Spring&quot;</code>) .</p><p><code>env</code> 和 <code>configprops</code> 端点在确定属性的特定值时很有用. 您可以使用这两个端点来诊断意外的属性值. 有关详细信息， 请参见 “<a href="https://sca.aliyun.com/learn/spring-boot/core/actuator.html#actuator.endpoints">生产就绪</a>” 部分.</p><h3 id="2-1-访问命令行属性"><a href="#2-1-访问命令行属性" class="headerlink" title="2.1. 访问命令行属性"></a>2.1. 访问命令行属性</h3><p>默认情况下，<code>SpringApplication</code> 将任何命令行选项参数(即以 <code>--</code> 开头的参数，例如 <code>--server.port=9000</code> )转换为属性，并将它们添加到 Spring <code>Environment</code> 中. 如前所述，命令行属性总是优先于基于文件的属性.</p><p>如果不希望将命令行属性添加到 <code>Environment</code> 中，可以使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 禁用它们.</p><h3 id="2-2-JSON-应用程序属性"><a href="#2-2-JSON-应用程序属性" class="headerlink" title="2.2. JSON 应用程序属性"></a>2.2. JSON 应用程序属性</h3><p>环境变量和系统属性通常有限制，这意味着某些属性名不能使用. 为了帮助实现这一点，Spring Boot 允许您将属性块编码到单个 JSON 结构中.</p><p>当应用程序启动时，任何 <code>spring.application.json</code> 或 <code>SPRING_APPLICATION_JSON</code> 属性都将被解析并添加到 <code>Environment</code> 中.</p><p>例如，<code>SPRING_APPLICATION_JSON</code> 属性可以在命令行中提供一个环境变量. 比如在 UN*X shell 中:</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scilab">$ SPRING_APPLICATION_JSON=<span class="hljs-string">&#x27;&#123;&quot;</span>my<span class="hljs-string">&quot;:&#123;&quot;</span>name<span class="hljs-string">&quot;:&quot;</span>test<span class="hljs-string">&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar<br></code></pre></td></tr></table></figure><p>在此示例中, 您可以在 Spring <code>Environment</code> 中使用 <code>my.name=test</code>。</p><p>同样的 JSON 也可以作为系统属性提供:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ java -Dspring.<span class="hljs-built_in">application</span>.json=&#x27;&#123;<span class="hljs-string">&quot;my&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;&#125;&#x27; -jar myapp.jar<br></code></pre></td></tr></table></figure><p>或者您可以使用命令行参数提供 JSON:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ java -jar myapp.jar <span class="hljs-params">--spring</span>.application.json=&#x27;&#123;<span class="hljs-string">&quot;my&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>如果您正在部署到一个经典的应用程序服务器，您还可以使用名为 <code>java:comp/env/spring.application.json</code> 的 JNDI 变量.</p><p>尽管 JSON 中的 <code>null</code> 被添加到结果属性集中, 但 <code>PropertySourcesPropertyResolver</code> 将 <code>null</code> 属性视为缺失值. 这意味着 JSON 无法使用 <code>null</code> 覆盖在属性集中具有低优先级的属性.</p><h3 id="2-3-外部应用程序属性"><a href="#2-3-外部应用程序属性" class="headerlink" title="2.3. 外部应用程序属性"></a>2.3. 外部应用程序属性</h3><p>应用程序启动时，Spring Boot 将自动从以下位置查找并加载 <code>application.properties</code> 和 <code>application.yaml</code> 文件:</p><ol><li>从 classpath<ol><li>classpath 根目录</li><li>classpath 上的 <code>/config</code> 包</li></ol></li><li>从当前目录<ol><li>当前目录</li><li>当前目录下的 <code>config/</code> 子目录</li><li><code>config/</code> 子目录的直接子目录</li></ol></li></ol><p>该列表按优先级排序(较低项的值覆盖较早项的值). 加载文件中的文档作为 <code>PropertySources</code> 添加到 Spring <code>Environment</code> 中.</p><p>如果您不喜欢 <code>application.properties</code> 作为配置文件名, 则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名.</p><p>例如，要查找 <code>myproject.properties</code> 和 <code>myproject.yaml</code> 文件，您可以按如下方式运行应用程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>myproject.<span class="hljs-keyword">jar </span>--spring.config.name=myproject<br></code></pre></td></tr></table></figure><p>您还可以使用 <code>spring.config.location</code> 环境属性来显式引用一个位置 (以逗号分隔的目录位置或文件路径列表) .</p><p>以下示例展示了如何指定两个位置:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ java -jar myproject.jar --spring.config.location=\<br><br>    optional:classpath:/<span class="hljs-keyword">default</span>.properties,\<br><br>    optional:classpath:/<span class="hljs-keyword">override</span>.properties<br></code></pre></td></tr></table></figure><p>如果 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.optional-prefix">locations are optional</a>，可以使用前缀 <code>optional:</code> ，并且您不介意它们是否存在.</p><p><code>spring.config.name</code> <code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 在程序启动早期就用来确定哪些文件必须加载. 它们必须定义为一个环境属性(通常是一个 OS 环境变量、一个系统属性或一个命令行参数).</p><p>如果 <code>spring.config.location</code> 包含目录 (而不是文件) , 则它们应该以 <code>/</code> 结尾。在运行时，在加载之前追加从 <code>spring.config.name</code> 生成的名称. <code>spring.config.location</code> 中指定的文件直接导入.</p><p>目录和文件的位置值也被扩展为检查 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">profile-specific files</a>. 例如，如果您有一个 <code>classpath:myconfig.properties</code> 的 <code>spring.config.location</code>，您还会发现加载了相应的 <code>classpath:myconfig-&lt;profile&gt;.properties</code> 文件。</p><p>在大多数情况下，您添加的每个 <code>spring.config.location</code> 项都将引用单个文件或目录。 位置按照定义的顺序进行处理，后面的 locations 可以覆盖前面的 locations.</p><p>如果您有一个复杂的位置设置，并且您使用特定于配置文件的配置文件，您可能需要提供进一步的提示，以便 Spring Boot 知道应该如何对它们进行分组.</p><p>location 组是所有被视为同一级别的 location 的集合。 例如，您可能希望对所有类路径位置进行分组，然后对所有外部位置进行分组。location 组中的应使用 <code>;</code> 分隔。</p><p>有关详细信息，请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">特定 Profile 的属性文件</a>” 部分中的示例.</p><p>当使用了 <code>spring.config.location</code> 配置自定义配置位置时, 默认位置配置将被替代. 例如，如果 <code>spring.config.location</code> 配置为 <code>optional:classpath:/custom-config/,optional:file:./custom-config/</code> 时，完整位置集是:</p><ol><li><code>optional:classpath:custom-config/</code></li><li><code>optional:file:./custom-config/</code></li></ol><p>或者, 当使用 <code>spring.config.additional-location</code> 配置自定义配置位置时, 除了使用默认位置外, 还会使用它们. 例如，如果 <code>spring.config.additional-location</code> 配置为 <code>optional:classpath:/custom-config/,optional:file:./custom-config/</code>，完整位置集是:</p><ol><li><code>optional:classpath:/;optional:classpath:/config/</code></li><li><code>optional:file:./;optional:file:./config/;optional:file:./config/*/</code></li><li><code>optional:classpath:custom-config/</code></li><li><code>optional:file:./custom-config/</code></li></ol><p>该搜索顺序允许您在一个配置文件中指定默认值, 然后有选择地覆盖另一个配置文件中的值. 您可以在 <code>application.properties</code> (或您使用 <code>spring.config.name</code> 指定的其他文件) 中的某个默认位置为应用程序提供默认值. 之后, 在运行时, 这些默认值将被自定义位置中的某个文件所覆盖.</p><p>如果您使用的是环境变量而不是系统属性, 大部分操作系统都不允许使用 . 分隔的键名, 但您可以使用下划线来代替 (例如, 使用 <code>SPRING_CONFIG_NAME</code> 而不是 <code>spring.config.name</code>) .查看 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables">从环境变量绑定</a> 获取更多细节信息.</p><p>如果您的应用程序运行在 servlet 容器或应用服务器中, 则可以使用 JNDI 属性 (<code>java:comp/env</code>) 或 servlet 上下文初始化参数来代替环境变量或系统属性.</p><h4 id="2-3-1-Optional-Locations（可选位置）"><a href="#2-3-1-Optional-Locations（可选位置）" class="headerlink" title="2.3.1. Optional Locations（可选位置）"></a>2.3.1. Optional Locations（可选位置）</h4><p>默认情况下，当指定的配置数据位置不存在时，Spring Boot 将抛出 <code>ConfigDataLocationNotFoundException</code> 并且您的应用程序将不会启动.</p><p>如果您想指定一个位置，但他有可能不存在，这时，您可以在 <code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 属性中使用 <code>optional:</code> 前缀，以及 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.importing"><code>spring.config.import</code></a> 声明.</p><p>例如，当 <code>spring.config.import</code> 的值为 <code>optional:file:./myconfig.properties</code> 时. 允许您的应用程序启动，即使 <code>myconfig.properties</code> 文件丢失.</p><p>如果你想忽略所有的 <code>ConfigDataLocationNotFoundExceptions</code> 而总是继续启动你的应用程序，你可以使用 <code>spring.config.on-not-found</code> 属性. 使用 <code>SpringApplication.setDefaultProperties(…)</code> 或使用系统&#x2F;环境变量将该值设置为 <code>ignore</code>.</p><h4 id="2-3-2-Wildcard-Locations（通配符位置）"><a href="#2-3-2-Wildcard-Locations（通配符位置）" class="headerlink" title="2.3.2. Wildcard Locations（通配符位置）"></a>2.3.2. Wildcard Locations（通配符位置）</h4><p>如果配置文件的位置包含最后一个路径段的 <code>*</code> ，则将其视为通配符位置. 加载配置时，通配符会扩展，以便检查子目录. 当存在多个配置属性源时, 通配符位置在诸如 Kubernetes 之类的环境中特别有用.</p><p>例如, 如果您有一些 Redis 配置和某些 MySQL 配置, 则可能希望将这两个配置分开, 同时要求这两个配置都存在于该应用程序可以绑定到的 <code>application.properties</code> 中. 这可能会导致两个单独的 <code>application.properties</code> 文件安装在不同的位置, 例如 <code>/config/redis/application.properties</code> 和 <code>/config/mysql/application.properties</code>. 在这种情况下, 当通配符位置为 <code>config/*/</code> 将导致两个文件都被处理.</p><p>默认情况下，Spring Boot 搜索的位置中包含 <code>config/*/</code>. 这意味着将搜索 jar 之外 <code>/config</code> 目录的所有子目录.</p><p>您可以使用 <code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 属性指定通配符位置.</p><p>通配符位置必须仅包含一个 <code>*</code> 并以 <code>*/</code> 结尾 (对于目录的搜索位置) 或 <code>*/&lt;filename&gt;</code> (对于文件的搜索位置) .带通配符的位置根据文件名的绝对路径按字母顺序排序.</p><p>通配符位置仅适用于外部目录. 您不能在 <code>classpath:</code> 位置中使用通配符.</p><h4 id="2-3-3-特定-Profile-的属性文件"><a href="#2-3-3-特定-Profile-的属性文件" class="headerlink" title="2.3.3. 特定 Profile 的属性文件"></a>2.3.3. 特定 Profile 的属性文件</h4><p>除 <code>application.properties</code> 文件外, 还可以使用以下命名约定定义特定 profile 的属性文件: <code>application-&#123;profile&#125;</code>. 例如，如果您的应用程序激活了一个名为 <code>prod</code> 的 profile 文件并使用 YAML 文件，那么这两个 <code>application.yml</code> 和 <code>application-prod.yml</code> 将被加载.</p><p>特定 profile 的属性文件从与标准 <code>application.properties</code> 相同的位置加载, 特定 profile 的属性文件始终覆盖非特定文件. 如果指定了多个配置文件，则应用 last-wins 策略 (优先采取最后一个) .例如，如果 由 <code>spring.profiles.active</code> 指定 <code>prod,live</code> profiles , <code>application-prod.properties</code> 中的属性值将被 <code>application-live.properties</code> 中的值覆盖</p><p>最后获胜策略适用于 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.location-groups">location group</a> 级别。 <code>spring.config.location</code> 为 <code>classpath:/cfg/,classpath:/ext/</code> 不会具有与 <code>classpath:/cfg/;classpath:/ext/</code> 相同的覆盖规则</p><p>例如，继续上面的 <code>prod,live</code> 示例，我们可能有以下文件:</p><p>&#x2F;cfg application-live.properties &#x2F;ext application-live.properties application-prod.properties</p><p>当 <code>spring.config.location</code> 为 <code>classpath:/cfg/,classpath:/ext/</code> 时，我们会在所有 <code>/ext</code> 文件之前处理所有 <code>/cfg</code> 文件：:</p><ol><li><code>/cfg/application-live.properties</code></li><li><code>/ext/application-prod.properties</code></li><li><code>/ext/application-live.properties</code></li></ol><p>当我们使用 <code>classpath:/cfg/;classpath:/ext/</code> 代替（使用 <code>;</code> 分隔符）时，我们在同一级别处理 <code>/cfg</code> 和 <code>/ext</code>：</p><ol><li><code>/ext/application-prod.properties</code></li><li><code>/cfg/application-live.properties</code></li><li><code>/ext/application-live.properties</code></li></ol><p>Environment 有一组默认配置文件 (默认情况下为 <code>[default]</code>) , 如果未设置激活的 (active) profile, 则使用这些配置文件. 换句话说, 如果没有显式激活 profile, 则会加载 <code>application-default</code> 中的属性.</p><p>NOTE: 属性文件只加载一次. 如果您已经直接 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.importing">imported</a> 了特定于配置文件的属性文件，那么它将不会被再次导入.</p><h4 id="2-3-4-导入其他数据"><a href="#2-3-4-导入其他数据" class="headerlink" title="2.3.4. 导入其他数据"></a>2.3.4. 导入其他数据</h4><p>应用程序属性可以使用 <code>Spring.config.import</code> 属性导入来自其他位置的其他配置数据. 导入是在发现它们时进行处理的，并且被视为直接插入在声明导入的文档下面的附加文档.</p><p>例如，您的 ClassPath <code>application.properties</code> 文件中可能具有以下内容:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;myapp&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    import:</span> <span class="hljs-string">&quot;optional:file:./dev.properties&quot;</span><br></code></pre></td></tr></table></figure><p>这将触发当前目录中 <code>dev.properties</code> 文件的导入(如果存在这样的文件). 导入的 <code>dev.properties</code> 中的值将优先于触发导入的文件. 在上面的例子中，<code>dev.properties</code> 可以将 <code>spring.application.name</code> 重定义为不同的值.</p><p>无论声明了多少次，导入都只会被导入一次. 在 properties&#x2F;yaml 文件中的单个文档中定义导入的顺序并不重要. 例如，下面两个例子产生相同的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">spring: <br>config:  <br><span class="hljs-keyword">import</span>: <span class="hljs-string">&quot;my.properties&quot;</span>my:  property: <span class="hljs-string">&quot;value&quot;</span><br>my:  property: <span class="hljs-string">&quot;value&quot;</span>spring:  config:    <span class="hljs-keyword">import</span>: <span class="hljs-string">&quot;my.properties&quot;</span><br></code></pre></td></tr></table></figure><p>在上述两个示例中，来自 <code>my.properties</code> 文件的值将优先于触发其导入的文件.</p><p>可以在单个 <code>spring.config.import</code> key 指定多个位置. 位置将按照它们定义的顺序进行处理，稍后的导入优先.</p><p>适当时，还会考虑导入 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">Profile-specific variants</a> 。 上面的示例将导入 <code>my.properties</code> 以及任何 <code>my-&lt;profile&gt;.properties</code> 变体.</p><p>Spring Boot 包括可插拔 API，允许支持各种不同的位置地址. 默认情况下，您可以导入 Java 属性，yaml 和 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.configtree">使用配置树</a>”.</p><p>第三方 JAR 可以提供对附加技术的支持(不需要文件是本地的). 例如，您可以想象配置数据来自外部存储，例如 Consul，Apache Zookeeper 或 Netflix Archaius.</p><p>如果要支持自己的位置，请参阅 <code>org.springframework.boot.context.config</code> 包中的 <code>ConfigDataLocationResolver</code> 和 <code>ConfigDataLoader</code> 类.</p><h4 id="2-3-5-导入无扩展名文件"><a href="#2-3-5-导入无扩展名文件" class="headerlink" title="2.3.5. 导入无扩展名文件"></a>2.3.5. 导入无扩展名文件</h4><p>一些云平台不能为挂载的文件添加文件扩展名. 要导入这些无扩展文件，您需要给 Spring Boot 一个提示，以便它知道如何加载它们. 您可以通过将扩展提示放在方括号中来实现这一点.</p><p>例如，假设您有一个 <code>/etc/config/myconfig</code> 文件，希望导入为 yaml. 您可以使用以下的 <code>application.properties</code> 导入:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    import:</span> <span class="hljs-string">&quot;file:/etc/config/myconfig[.yaml]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-6-使用配置树"><a href="#2-3-6-使用配置树" class="headerlink" title="2.3.6. 使用配置树"></a>2.3.6. 使用配置树</h4><p>在云平台上运行应用程序（例如 Kubernetes），您通常需要阅读平台提供的配置值. 使用环境变量来实现这类目的并不少见，但是这样做可能会有缺点，特别是在值应该保密的情况下.</p><p>作为环境变量的替代方案，许多云平台现在允许您将配置映射到安装的数据卷中. 例如，Kubernetes 可以同时卷载 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap"><code>ConfigMaps</code></a> 和 <a href="https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod"><code>Secrets</code></a>.</p><p>有两种常见的卷挂载模式可以使用:</p><ol><li>单个文件包含一组完整的属性(通常以 YAML 的形式编写).</li><li>多个文件被写入一个目录树，文件名成为 ‘key’，内容成为 ‘value’.</li></ol><p>对于第一种情况，您可以像 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.importing">上面描述</a> 的那样直接使用 <code>spring.config.import</code> 导入 YAML 或 Properties 文件. 对于第二种情况，您需要使用 <code>configtree:</code> 前缀，以便 Spring Boot 知道它需要将所有文件作为属性公开.</p><p>举个例子，假设 Kubernetes 已经挂载了下面的卷:</p><p>etc&#x2F; config&#x2F; myapp&#x2F; username password</p><p><code>username</code> 文件的内容将是一个配置值，<code>password</code> 的内容将是一个 secret.</p><p>要导入这些属性，可以将以下内容添加到 <code>application.properties</code> 或 <code>application.yaml</code> 文件:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    import:</span> <span class="hljs-string">&quot;optional:configtree:/etc/config/&quot;</span><br></code></pre></td></tr></table></figure><p>然后，您可以向往常一样从 <code>Environment</code> 中访问或注入 <code>myapp.username</code> 和 <code>myapp.password</code> .</p><p>配置树下的文件夹构成属性名称。在上面的示例中，要以 <code>username</code> 和 <code>password</code> 访问属性，可以将 <code>spring.config.import</code> 设置为 <code>optional:configtree:/etc/config/myapp</code>。</p><p>带有 . 符号的文件名也被正确映射。 例如，在上面的示例中，<code>/etc/config</code> 中名为 <code>myapp.username</code> 的文件将导致 <code>Environment</code> 中的 <code>myapp.username</code> 属性。</p><p>根据所期望的内容，配置树值可以绑定到字符串 <code>String</code> 和 <code>byte[]</code> 类型.</p><p>如果有多个配置树要从同一个父文件夹导入，可以使用通配符快捷方式. 任何以 <code>/*/</code> 结尾的 <code>configtree:</code> location 将导入所有直接子树作为配置树.</p><p>例如，给定以下卷:</p><p>etc&#x2F; config&#x2F; dbconfig&#x2F; db&#x2F; username password mqconfig&#x2F; mq&#x2F; username password</p><p>你可以使用 <code>configtree:/etc/config/*/</code> 作为导入位置:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    import:</span> <span class="hljs-string">&quot;optional:configtree:/etc/config/*/&quot;</span><br></code></pre></td></tr></table></figure><p>这将会添加 <code>db.username</code>, <code>db.password</code>, <code>mq.username</code> 和 <code>mq.password</code> 属性.</p><p>使用通配符加载的目录按字母顺序排序. 如果您需要不同的顺序，那么您应该将每个位置作为单独的导入列出</p><p>配置树也可以用于 Docker secrets. 当一个 Docker 集群服务被授权访问一个 secrets 时，这个 secrets 就会被安装到容器中. 例如，如果一个 secrets 命名为 <code>db.password</code> 被挂载在 <code>/run/secrets/</code> 位置，则可以使用以下内容使 <code>db.password</code> 可用于 Spring 环境:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    import:</span> <span class="hljs-string">&quot;optional:configtree:/run/secrets/&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-7-属性中的占位符"><a href="#2-3-7-属性中的占位符" class="headerlink" title="2.3.7. 属性中的占位符"></a>2.3.7. 属性中的占位符</h4><p><code>application.properties</code> 和 <code>application.yml</code> 中的值在使用时通过现有的 <code>Environment</code> 进行过滤, 因此您可以返回之前定义的值 (例如, 从系统属性或环境变量) . 标准的 <code>$&#123;name&#125;</code> 属性占位符语法可以在值的任何地方使用. 属性占位符还可以使用 <code>:</code> 指定默认值，以将默认值与属性名称分开，例如 <code>$&#123;name:default&#125;</code>。</p><p>以下示例显示了使用带和不带默认值的占位符:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">app:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;MyApp&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  description:</span> <span class="hljs-string">&quot;$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>假设 <code>username</code> 属性没有在其他地方设置，<code>app.description</code> 将为 <code>MyApp is a Spring Boot application written by Unknown</code>.</p><p>您应该始终使用规范形式（kebab-case 仅使用小写字母）引用占位符中的属性名称。 这将允许 Spring Boot 使用与 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding">relaxed binding</a> <code>@ConfigurationProperties</code> 相同的逻辑。</p><p>例如，<code>$&#123;demo.item-price&#125;</code> 将从 <code>application.properties</code> 文件中提取 <code>demo.item-price</code> 和 <code>demo.itemPrice</code> 属性，以及从系统环境中提取 <code>DEMO_ITEMPRICE</code>。 如果您改用 <code>$&#123;demo.itemPrice&#125;</code>，则不会考虑 <code>demo.item-price</code> 和 <code>DEMO_ITEMPRICE</code>。</p><p>您还可以使用此技术创建现有 Spring Boot 属性的简短形式. 有关详细信息, 请参见 <em><a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.properties-and-configuration.short-command-line-arguments">howto.html</a></em> .</p><h4 id="2-3-8-处理多文档文件"><a href="#2-3-8-处理多文档文件" class="headerlink" title="2.3.8. 处理多文档文件"></a>2.3.8. 处理多文档文件</h4><p>Spring Boot 允许您将单个物理文件拆分为多个逻辑文档，每个逻辑文件都是独立添加的. 文档按顺序处理，从上到下处理. 后面的文档可以覆盖早期定义的属性.</p><p>对于 <code>application.yml</code> 文件，使用标准 yaml 多文档语法. <code>---</code> 字符代表一个文档的结尾，并开始下一个文档.</p><p>例如，以下文件具有两个逻辑文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">application:</span><br><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;MyApp&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">application:</span><br><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;MyCloudApp&quot;</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-cloud-platform:</span> <span class="hljs-string">&quot;kubernetes&quot;</span><br></code></pre></td></tr></table></figure><p>对于 <code>application.properties</code> 文件，特殊 <code>#---</code> 或 <code>!---</code> 注释用于标记文档拆分:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=MyApp<br><br><span class="hljs-comment">#---</span><br><br><span class="hljs-attr">spring.application.name</span>=MyCloudApp<br><br><span class="hljs-attr">spring.config.activate.on-cloud-platform</span>=kubernetes<br></code></pre></td></tr></table></figure><p>属性文件分隔符必须没有任何前导空格，并且必须恰好有三个连字符. 分隔符前后的行不能是相同的注释前缀.</p><p>多文档属性文件通常与激活属性一起使用，例如 <code>spring.config.activate.on-profile</code> 。有关详细信息，<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.activation-properties">请参阅下一节</a>.</p><p>无法使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解加载多文档属性文件.</p><h4 id="2-3-9-Activation-Properties（激活属性）"><a href="#2-3-9-Activation-Properties（激活属性）" class="headerlink" title="2.3.9. Activation Properties（激活属性）"></a>2.3.9. Activation Properties（激活属性）</h4><p>有时，只在满足某些条件时才激活给定的属性是有用的. 例如，您可能拥有仅在特定概要文件激活时才相关的属性.</p><p>您可以使用 <code>spring.config.activate.*</code> 有条件地激活属性文档.</p><p>以下激活属性可用:</p><p>Table 2. activation properties</p><p>Property</p><p>Note</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">on</span>-<span class="hljs-keyword">profile</span><br></code></pre></td></tr></table></figure><p>要使文档处于活动状态，必须匹配的配置文件表达式。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">on</span>-cloud-<span class="hljs-keyword">platform</span><br></code></pre></td></tr></table></figure><p>要使文档处于活动状态，必须检测到 <code>CloudPlatform</code>.</p><p>例如，下面的命令指定第二个文档只有在 Kubernetes 上运行时是激活的，并且只有在 “prod” 或 “staging” 配置文件是激活的时候:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">myprop:</span><br><br>  <span class="hljs-string">&quot;always-set&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-cloud-platform:</span> <span class="hljs-string">&quot;kubernetes&quot;</span><br><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;prod | staging&quot;</span><br><br><span class="hljs-attr">myotherprop:</span> <span class="hljs-string">&quot;sometimes-set&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-Encrypting-Properties"><a href="#2-4-Encrypting-Properties" class="headerlink" title="2.4. Encrypting Properties"></a>2.4. Encrypting Properties</h3><p>Spring Boot 没有为加密属性值提供任何内置支持, 然而, 它提供了修改 Spring <code>Environment</code> 包含的值所必需的钩子. <code>EnvironmentPostProcessor</code> 接口允许您在应用程序启动之前操作 <code>Environment</code>. 有关详细信息, 请参见 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.application.customize-the-environment-or-application-context">howto.html</a>.</p><p>如果您正在寻找一种可用于存储凭据和密码的安全方法, <a href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a> 项目支持在 <a href="https://www.vaultproject.io/">HashiCorp Vault</a> 中存储外部化配置.</p><h3 id="2-5-使用-YAML"><a href="#2-5-使用-YAML" class="headerlink" title="2.5. 使用 YAML"></a>2.5. 使用 YAML</h3><p><a href="https://yaml.org/">YAML</a> 是 JSON 的超集, 是一个可用于指定层级配置数据的便捷格式. 只要在 classpath 上有 <a href="https://github.com/snakeyaml/snakeyaml">SnakeYAML</a> 库, <code>SpringApplication</code> 类就会自动支持 YAML 作为属性文件 (properties) 的替代.</p><p>如果使用 <code>starter</code>, 则 <code>spring-boot-starter</code> 会自动提供 SnakeYAML.</p><h4 id="2-5-1-使用-YAML-代替属性文件"><a href="#2-5-1-使用-YAML-代替属性文件" class="headerlink" title="2.5.1. 使用 YAML 代替属性文件"></a>2.5.1. 使用 YAML 代替属性文件</h4><p>YAML 文档需要从其分层格式转换为可与 Spring <code>Environment</code> 一起使用的平面结构. 例如，考虑以下 YAML 文档:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">environments:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  dev:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    url:</span> <span class="hljs-string">&quot;https://dev.example.com&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;Developer Setup&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  prod:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    url:</span> <span class="hljs-string">&quot;https://another.example.com&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    name:</span> <span class="hljs-string">&quot;My Cool App&quot;</span><br></code></pre></td></tr></table></figure><p>为了从 <code>Environment</code> 访问这些属性，它们将被扁平化如下:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">environments.dev.url</span>=https://dev.example.com<br><br><span class="hljs-attr">environments.dev.name</span>=Developer Setup<br><br><span class="hljs-attr">environments.prod.url</span>=https://another.example.com<br><br><span class="hljs-attr">environments.prod.name</span>=My Cool App<br></code></pre></td></tr></table></figure><p>同样，YAML 列表也需要被展平，YAML 列表表示带有 <code>[index]</code> 下标引用的属性键. 例如以下 YAM:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">my:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> servers:</span><br><br> - <span class="hljs-string">&quot;dev.example.com&quot;</span><br><br> - <span class="hljs-string">&quot;another.example.com&quot;</span><br></code></pre></td></tr></table></figure><p>以上示例将转成以下属性:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my<span class="hljs-selector-class">.servers</span><span class="hljs-selector-attr">[0]</span>=dev<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span><br><br>my<span class="hljs-selector-class">.servers</span><span class="hljs-selector-attr">[1]</span>=another<span class="hljs-selector-class">.example</span>.com<br></code></pre></td></tr></table></figure><p>使用 <code>[index]</code> 表示的属性可以通过 Spring Boot 的 <code>Binder</code> 类绑定到 Java <code>List</code> 或 <code>Set</code> 对象. 有关更多细节，请参阅下面的 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties">类型安全的配置属性</a>” 一节.</p><p>YAML 文件不能通过使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解加载. 因此，在你需要以这种方式加载值的情况下，你需要使用一个属性文件.</p><h4 id="2-5-2-直接加载-YAML"><a href="#2-5-2-直接加载-YAML" class="headerlink" title="2.5.2. 直接加载 YAML"></a>2.5.2. 直接加载 YAML</h4><p>Spring Framework 提供了两个方便的类，可用于加载 YAML 文档. <code>YamlPropertiesFactoryBean</code> 以 <code>Properties</code> 的形式加载 YAML，而 <code>YamlMapFactoryBean</code> 以 <code>Map</code> 的形式加载 YAML.</p><p>你也可以使用 <code>YamlPropertySourceLoader</code> 类，如果你想加载 YAML 作为一个 Spring <code>PropertySource</code>.</p><h3 id="2-6-配置随机值"><a href="#2-6-配置随机值" class="headerlink" title="2.6. 配置随机值"></a>2.6. 配置随机值</h3><p><code>RandomValuePropertySource</code> 对于注入随机值(例如，注入 secrets 或测试用例)很有用. 它可以产生 integers, longs, uuids, 或 strings，如下例所示:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span>:<br><br>  secret: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.value&#125;</span>&quot;</span><br><br>  number: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.int&#125;</span>&quot;</span><br><br>  bignumber: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.long&#125;</span>&quot;</span><br><br>  uuid: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.uuid&#125;</span>&quot;</span><br><br>  number-less-than-ten: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.int(<span class="hljs-number">10</span>)&#125;</span>&quot;</span><br><br>  number-in-range: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;random.int[<span class="hljs-number">1024</span>,<span class="hljs-number">65536</span>]&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p><code>random.int*</code> 语法是 <code>OPEN value (,max) CLOSE</code>，其中 <code>OPEN,CLOSE</code> 为任意字符，<code>value,max</code> 为整数. 如果提供了 <code>max</code>，那么 <code>value</code> 是最小值，<code>max</code> 是最大值(不包括).</p><h3 id="2-7-配置系统环境属性"><a href="#2-7-配置系统环境属性" class="headerlink" title="2.7. 配置系统环境属性"></a>2.7. 配置系统环境属性</h3><p>Spring Boot 可以为环境属性设置前缀。 如果系统环境由具有不同配置要求的多个 Spring Boot 应用程序共享，这将很有用。 系统环境属性的前缀可以直接在 <code>SpringApplication</code> 上设置。</p><p>例如，如果您将前缀设置为 <code>input</code>，那么在系统环境中，<code>remote.timeout</code> 等属性也会被解析为 <code>input.remote.timeout</code>.</p><h3 id="2-8-类型安全的配置属性"><a href="#2-8-类型安全的配置属性" class="headerlink" title="2.8. 类型安全的配置属性"></a>2.8. 类型安全的配置属性</h3><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 注解来注入配置属性有时会很麻烦, 特别是如果您使用了多个属性或者您的数据本质上是分层结构. Spring Boot 提供了另一种使用属性的方法, 该方法使用强类型的 bean 来管理和验证应用程序的配置, 如下所示:</p><p>另请参见 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.vs-value-annotation"><code>@Value</code> 和类型安全的配置属性之间的区别</a>.</p><h4 id="2-8-1-JavaBean-属性绑定"><a href="#2-8-1-JavaBean-属性绑定" class="headerlink" title="2.8.1. JavaBean 属性绑定"></a>2.8.1. JavaBean 属性绑定</h4><p>可以绑定一个声明标准 JavaBean 属性的 bean, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@ConfigurationProperties</span>(<span class="hljs-string">&quot;my.service&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProperties</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> boolean enabled;<br>    <span class="hljs-keyword">private</span> InetAddress remoteAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Security security = <span class="hljs-keyword">new</span> <span class="hljs-type">Security</span>();<br>    <span class="hljs-comment">// getters / setters...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Security</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> username;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;<br>        <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">String</span>&gt; roles = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;(Collections.singleton(<span class="hljs-string">&quot;USER&quot;</span>));<br>        <span class="hljs-comment">// getters / setters...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的 POJO 定义了以下属性:</p><ul><li><code>my.service.enabled</code>, 默认值为 <code>false</code>.</li><li><code>my.service.remote-address</code>, 可以从 <code>String</code> 强制转换的类型.</li><li><code>my.service.security.username</code>, 内嵌一个 <code>security</code> 对象, 其名称由属性名称决定. 特别是, 返回类型根本没有使用, 可能是 <code>SecurityProperties</code>.</li><li><code>my.service.security.password</code>.</li><li><code>my.service.security.roles</code>, <code>String</code> 集合. 默认为 <code>USER</code>.</li></ul><p>Spring Boot 自动配置大量使用 <code>@ConfigurationProperties</code> 来轻松配置自动配置的 bean. 与自动配置类相似, Spring Boot 中可用的 <code>@ConfigurationProperties</code> 类仅供内部使用. 通过属性文件, YAML 文件, 环境变量等配置的映射到该类的属性是 public API, 但类本身的访问器（getter&#x2F;setter）并不意味着可以直接使用。.</p><p>依赖于默认的空构造函，getter 和 setter 通常是必需的, 因为绑定是通过标准的 Java Bean 属性描述符来完成, 就像在 Spring MVC 中一样. 以下情况可以省略 setter:</p><ul><li>Map, 只需要初始化, 就需要一个 getter 但不一定需要 setter, 因为它们可以被 binder 修改.</li><li>集合和数组可以通过一个索引 (通常使用 YAML) 或使用单个逗号分隔值 (属性) 进行访问. 最后一种情况必须使用 setter. 我们建议始终为此类型添加 setter. 如果初始化集合, 请确保它是可变的 (如上例所示) .</li><li>如果初始化嵌套的 POJO 属性 (如前面示例中的 <code>Security</code> 字段) , 则不需要 setter. 如果您希望 binder 使用其默认构造函数动态创建实例, 则需要一个 setter.</li></ul><p>有些人可能会使用 Project Lombok 来自动生成 getter 和 setter. 请确保 Lombok 不为此类型生成任何特定构造函数, 因为容器会自动使用它来实例化对象.</p><p>最后, 考虑到标准 Java Bean 属性, 不支持对静态属性的绑定.</p><h4 id="2-8-2-构造函数绑定"><a href="#2-8-2-构造函数绑定" class="headerlink" title="2.8.2. 构造函数绑定"></a>2.8.2. 构造函数绑定</h4><p>上一节中的示例可以以不变的方式重写, 如下例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(<span class="hljs-string">&quot;my.service&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-comment">// fields...</span><br>    <span class="hljs-keyword">public</span> MyProperties(boolean enabled, InetAddress remoteAddress, Security security) &#123;        <span class="hljs-keyword">this</span>.enabled = enabled;        <span class="hljs-keyword">this</span>.remoteAddress = remoteAddress;        <span class="hljs-keyword">this</span>.security = security;    &#125;<br>    <span class="hljs-comment">// getters...</span><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Security</span> &#123;<br>        <span class="hljs-comment">// fields...</span><br>        <span class="hljs-keyword">public</span> Security(String username, String password, <span class="hljs-meta">@DefaultValue(<span class="hljs-string">&quot;USER&quot;</span>)</span> List&lt;String&gt; roles) &#123;            <span class="hljs-keyword">this</span>.username = username;            <span class="hljs-keyword">this</span>.password = password;            <span class="hljs-keyword">this</span>.roles = roles;        &#125;<br>        <span class="hljs-comment">// getters...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此设置中，只有一个参数构造函数，这意味着应使用构造函数绑定。 这意味着绑定器将期望找到带有您希望绑定的参数的构造函数。 如果您的类有多个构造函数，则可以使用 <code>@ConstructorBinding</code> 注解来指定用于构造函数绑定的构造函数。 若要选择退出具有一个参数化构造函数的类的构造函数绑定，必须使用 <code>@Autowired</code> 注解构造函数。 如果您使用的是 Java 16 或更高版本，则可以将构造函数绑定与 records 一起使用。在这种情况下，除非你的 record 有多个构造函数，否则没有必要使用 <code>@ConstructorBinding</code>。</p><p>构造函数绑定类的嵌套成员 (例如上例中的 <code>Security</code> ) 也将通过其构造函数进行绑定.</p><p>可以在构造函数参数和 record 组件上使用 <code>@DefaultValue</code> 指定默认值，转换服务将 <code>String</code> 值强制为缺少属性的目标类型.</p><p>默认情况下, 如果没有属性绑定到 <code>Security</code>, 则 <code>MyProperties</code> 实例的 <code>security</code> 为 <code>null</code>. 如果您希望即使没有绑定任何属性都返回 <code>Security</code> 的非空实例, 则可以使用空的 <code>@DefaultValue</code> 注解来这样做（使用 Kotlin 时，需要将 <code>Security</code> 的 <code>username</code> 和 <code>password</code> 参数声明为可为空，因为它们没有默认值）:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> MyProperties(boolean enabled, InetAddress remoteAddress, <span class="hljs-meta">@DefaultValue</span> Security security) &#123;<br><br>    <span class="hljs-keyword">this</span>.enabled = enabled;<br><br>    <span class="hljs-keyword">this</span>.remoteAddress = remoteAddress;<br><br>    <span class="hljs-keyword">this</span>.security = security;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要使用构造函数绑定, 必须使用 <code>@EnableConfigurationProperties</code> 或配置属性扫描来启用该类. 您不能对通过常规 Spring 机制创建的 bean 使用构造函数绑定 (例如 <code>@Component</code> bean, 通过 <code>@Bean</code> 方法创建的 bean 或使用 <code>@Import</code> 加载的 bean)</p><p>要在原生镜像中使用构造函数绑定，必须使用 <code>-parameters</code> 编译该类。 如果您使用 Spring Boot 的 Gradle 插件，或者如果您使用 Maven 和 <code>spring-boot-starter-parent</code>，这将自动发生。</p><p>不建议将 <code>java.util.Optional</code> 与 <code>@ConfigurationProperties</code> 一起使用, 因为它主要是用作返回类型. 因此, 它不太适合配置属性注入. 为了与其他类型的属性保持一致, 如果确实声明了 <code>Optional</code> 属性并且没有任何值, 则将绑定 <code>null</code> 而不是空的 <code>Optional</code>.</p><h4 id="2-8-3-启用-ConfigurationProperties-注解的类型"><a href="#2-8-3-启用-ConfigurationProperties-注解的类型" class="headerlink" title="2.8.3. 启用 @ConfigurationProperties 注解的类型"></a>2.8.3. 启用 <code>@ConfigurationProperties</code> 注解的类型</h4><p>Spring Boot 提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为 Bean 的基础架构. 您可以逐类启用配置属性, 也可以启用与组件扫描类似的方式进行配置属性扫描.</p><p>有时, 用 <code>@ConfigurationProperties</code> 注解的类可能不适用于扫描, 例如, 如果您正在开发自己的自动配置, 或者想要有条件地启用它们. 在这些情况下, 请使用 <code>@EnableConfigurationProperties</code> 注解 指定要处理的类型列表. 可以在任何 <code>@Configuration</code> 类上完成此操作, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)<span class="hljs-variable">@EnableConfigurationProperties</span>(SomeProperties.class)public class MyConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用配置属性扫描, 请将 <code>@ConfigurationPropertiesScan</code> 注解 添加到您的应用程序. 通常, 它被添加到使用 <code>@SpringBootApplication</code> 注解的主应用程序类中, 但可以将其添加到任何 <code>@Configuration</code> 类中. 默认情况下, 将从声明注解的类的包中进行扫描. 如果要定义要扫描的特定程序包, 可以按照以下示例所示进行操作:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@ConfigurationPropertiesScan</span>(&#123; <span class="hljs-string">&quot;com.example.app&quot;</span>, <span class="hljs-string">&quot;com.example.another&quot;</span> &#125;)public class MyApplication &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>当以配置属性或者通过 <code>@EnableConfigurationProperties</code> 注册 <code>@ConfigurationProperties</code> bean 时, bean 具有一个固定格式的名称: <code>&lt;prefix&gt;-&lt;fqn&gt;</code>, 其中 <code>&lt;prefix&gt;</code> 是 <code>@ConfigurationProperties</code> 注解中指定的环境 key 前缀, <code>&lt;fqn&gt;</code> 是 bean 的完全限定类名. 如果注解未提供任何前缀, 则仅使用 bean 的完全限定类名.</p><p>上面示例中的 bean 名称为 <code>com.example.app-com.example.app.SomeProperties</code>.</p><p>我们也建议 <code>@ConfigurationProperties</code> 只处理环境 (environment) , 特别是不要从上下文中注入其他 bean. 对于极端情况, 可以使用 setter 注入或框架提供的任何 <code>*Aware</code> 接口 (例如, 需要访问 <code>Environment</code> 的 <code>EnvironmentAware</code>) . 如果仍然想使用构造函数注入其他 bean, 则必须使用 <code>@Component</code> 注解配置属性 bean, 并使用基于 JavaBean 的属性绑定.</p><h4 id="2-8-4-使用-ConfigurationProperties-注解类型"><a href="#2-8-4-使用-ConfigurationProperties-注解类型" class="headerlink" title="2.8.4. 使用 @ConfigurationProperties 注解类型"></a>2.8.4. 使用 @ConfigurationProperties 注解类型</h4><p>这种配置样式与 <code>SpringApplication</code> 外部 YAML 配置特别有效, 如以下示例所示:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">my:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  service:</span><br><br>    remote-address: <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    security:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      username:</span> <span class="hljs-string">&quot;admin&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      roles:</span><br><br>      - <span class="hljs-string">&quot;USER&quot;</span><br><br>      - <span class="hljs-string">&quot;ADMIN&quot;</span><br></code></pre></td></tr></table></figure><p>要使用 <code>@ConfigurationProperties</code> bean, 您可以使用与其他 bean 相同的方式注入它们, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Servicepublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyProperties properties;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(MyProperties properties)</span> &#123;        <span class="hljs-built_in">this</span>.properties = properties;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openConnection</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-built_in">this</span>.properties.getRemoteAddress());        server.start();        <span class="hljs-comment">// ...    &#125;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>@ConfigurationProperties</code> 还可以生成元数据文件, IDE 可以通过这些文件来为您自己的 key 提供自动完成功能. 有关详细信息, 请参阅 <a href="https://sca.aliyun.com/learn/spring-boot/core/configuration-metadata.html#appendix.configuration-metadata">附录 B: 配置元数据</a> .</p><h4 id="2-8-5-第三方配置"><a href="#2-8-5-第三方配置" class="headerlink" title="2.8.5. 第三方配置"></a>2.8.5. 第三方配置</h4><p><code>@ConfigurationProperties</code> 除了可以使用来注解类之外, 您还可以在公共的 <code>@Bean</code> 方法上使用. 当您想要将属性绑定到您掌控之外的第三方组件时, 这样做特别有用.</p><p>要使用 <code>Environment</code> 属性配置 bean, 请将 <code>@ConfigurationProperties</code> 添加到 bean 注册上, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)public class ThirdPartyConfiguration &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;another&quot;</span>)    public AnotherComponent <span class="hljs-built_in">anotherComponent</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">AnotherComponent</span>();    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>another</code> 前缀定义的所有属性都使用与前面的 <code>SomeProperties</code> 示例类似的方式映射到 <code>AnotherComponent</code> bean.</p><h4 id="2-8-6-宽松绑定"><a href="#2-8-6-宽松绑定" class="headerlink" title="2.8.6. 宽松绑定"></a>2.8.6. 宽松绑定</h4><p>Spring Boot 使用一些宽松的规则将 <code>Environment</code> 属性绑定到 <code>@ConfigurationProperties</code> bean, 因此 <code>Environment</code> 属性名不需要和 bean 属性名精确匹配. 常见的示例包括使用了 <code>-</code> 符号分割的环境属性 (例如, <code>context-path</code> 绑定到 <code>contextPath</code>) 和大写环境属性 (例如, <code>PORT</code> 绑定到 <code>port</code>) .</p><p>如下 <code>@ConfigurationProperties</code> 类:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;my.main-project.person&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPersonProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> firstName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getFirstName</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setFirstName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> firstName</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中, 同样可以使用以下属性名称:</p><p>Table 3. 宽松绑定</p><p>属性</p><p>描述</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">my</span>.main-project.person.<span class="hljs-keyword">first</span>-<span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p>Kebab 风格 (短横线命名) , 建议在 <code>.properties</code> 和 <code>.yml</code> 文件中使用.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my<span class="hljs-selector-class">.main-project</span><span class="hljs-selector-class">.person</span>.firstName<br></code></pre></td></tr></table></figure><p>标准驼峰式风格.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my<span class="hljs-selector-class">.main-project</span><span class="hljs-selector-class">.person</span>.first_name<br></code></pre></td></tr></table></figure><p>下划线表示法, <code>.properties</code> 和 <code>.yaml</code> 文件中的另外一种格式..</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">MY_MAINPROJECT_PERSON_FIRSTNAME</span><br></code></pre></td></tr></table></figure><p>大写风格, 当使用系统环境变量时推荐使用该风格.</p><p>注解的 <code>prefix</code> 值必须是 kebab (短横线命名)风格 (小写并用 <code>-</code> 分隔, 例如 <code>my.main-project.person</code>) .</p><p>Table 4. 每种属性源 (property source) 的宽松绑定规则</p><p>属性源</p><p>简单类型</p><p>列表集合类型</p><p>Properties 文件</p><p>驼峰式、短横线式或下划线式</p><p>标准列表语法使用 <code>[ ]</code> 或逗号分隔值</p><p>YAML 文件</p><p>驼峰式、短横线式或者下划线式</p><p>标准 YAML 列表语法或者逗号分隔值</p><p>环境变量</p><p>大写并且以下划线作为定界符,(查看 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables">从环境变量绑定</a>).</p><p>数字值两边使用下划线连接 (查看 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables">从环境变量绑定</a>)</p><p>系统属性</p><p>驼峰式、短横线式或者下划线式</p><p>标准列表语法使用 <code>[ ]</code> 或逗号分隔值</p><p>我们建议, 属性尽可能以小写的短横线格式存储, 比如 <code>my.person.first-name=Rod</code>.</p><h5 id="绑定-Maps"><a href="#绑定-Maps" class="headerlink" title="绑定 Maps"></a>绑定 Maps</h5><p>当绑定到 <code>Map</code> 属性时, 如果 <code>key</code> 包含除小写字母数字字符或 <code>-</code> 以外的任何内容, 则需要使用括号表示法来保留原始值. 如果 key 没有使用 <code>[]</code> 包裹, 则里面的任何非字母数字字符或 <code>-</code> 或 <code>.</code> 的字符都将被删除.</p><p>例如, 将以下属性绑定到一个 <code>Map&lt;String,String&gt;</code>:</p><p>Properties</p><p>Yaml</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my<span class="hljs-selector-class">.map</span>.<span class="hljs-selector-attr">[/key1]</span>=value1<br><br>my<span class="hljs-selector-class">.map</span>.<span class="hljs-selector-attr">[/key2]</span>=value2<br><br>my<span class="hljs-selector-class">.map</span>./key3=value3<br></code></pre></td></tr></table></figure><p>对于 YAML 文件, 方括号需要用引号引起来, 以便正确解析 keys.</p><p>上面的属性将绑定到一个 <code>Map</code> 上, 其中 <code>/key1</code>, <code>/key2</code> 和 <code>key3</code> 作为 map 的 key. <code>key3</code> 中的斜杠会被删除， 因为它没有被方括号包围.</p><p>当绑定标量值时，其中带有 <code>.</code> 的 key 不需要被 <code>[]</code> 包围。标量值都包含枚举类型，<code>java.lang</code> 包中除 <code>Object</code> 类型之外的所有类型。 将 <code>a.b=c</code> 绑定到 <code>Map&lt;String, String&gt;</code> 中时，将在 key 中保留 <code>.</code> 并返回带有 <code>&#123;&quot;a.b&quot;=&quot;c&quot;&#125;</code> 的 Map。 对于任何其他类型，如果您的 <code>key</code> 包含 <code>.</code>，则需要使用括号表示法。 例如，将 <code>a.b=c</code> 绑定到 <code>Map&lt;String, Object&gt;</code> 将返回一个带有 <code>&#123;&quot;a&quot;=&#123;&quot;b&quot;=&quot;c&quot;&#125;&#125;</code> entry 的 Map，而 <code>[a.b]=c</code> 将返回一个带有 <code>&#123;&quot;a.b&quot;=&quot;c&quot;&#125;</code> entry 的 Map。</p><h5 id="从环境变量绑定"><a href="#从环境变量绑定" class="headerlink" title="从环境变量绑定"></a>从环境变量绑定</h5><p>大多数操作系统在对于环境变量有严格规范. 例如, Linux shell 变量只能包含字母(<code>a</code> to <code>z</code> 或 <code>A</code> to <code>Z</code>), 数字(<code>0</code> to <code>9</code>) 或下划线字符(<code>_</code>). 按照约定, Unix shell 变量也可以用大写字母命名.</p><p>Spring Boot 的宽松绑定规则尽可能设计成与这些命名限制兼容.</p><p>要将规范形式的属性名称转换为环境变量名称, 可以遵循以下规则:</p><ul><li>使用下划线 (<code>_</code>) 替代 (<code>.</code>).</li><li>删除所有 (<code>-</code>).</li><li>转换为大写.</li></ul><p>例如, 配置属性 <code>spring.main.log-startup-info</code> 是一个名为 <code>SPRING_MAIN_LOGSTARTUPINFO</code> 的环境变量.</p><p>当绑定到对象列表时, 也可以使用环境变量. 要绑定到 <code>List</code>, 元素编号应在变量名称中用下划线括起来.</p><p>例如, 配置属性 <code>my.service[0].other</code> 使用名为 <code>MY_SERVICE_0_OTHER</code> 的环境变量.</p><h4 id="2-8-7-合并复杂类型"><a href="#2-8-7-合并复杂类型" class="headerlink" title="2.8.7. 合并复杂类型"></a>2.8.7. 合并复杂类型</h4><p>当列表集合 (list) 在多个地方配置时, 整个列表集合将被替换.</p><p>例如, 假设 <code>MyPojo</code> 对象带有 <code>name</code> 和 <code>description</code> 属性并且默认为 <code>null</code>. 以下示例中, <code>MyProperties</code> 暴露了一个 <code>MyPojo</code> 对象列表集合:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(<span class="hljs-string">&quot;my&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;MyPojo&gt; getList() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置可以如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">list:</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;my name&quot;</span><br><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;my description&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;dev&quot;</span><br><br><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">list:</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;my another name&quot;</span><br></code></pre></td></tr></table></figure><p>如果 <code>dev</code> 配置文件未激活, 则 <code>MyProperties.list</code> 只包含一个 <code>MyPojo</code> , 如之前所述. 但是, 如果激活了 <code>dev</code> 配置文件, 列表集合仍然只包含一个条目 (name 属性值为 <code>my another name</code>, description 为 <code>null</code>) . 此配置不会向列表集合中添加第二个 <code>MyPojo</code> 实例, 也不会合并条目.</p><p>在多个配置文件中指定一个 <code>List</code> 时, 最高优先级 (并且只有一个) 的列表集合将被使用. 可做如下配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">list:</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;my name&quot;</span><br><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;my description&quot;</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;another name&quot;</span><br><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;another description&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;dev&quot;</span><br><br><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">list:</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;my another name&quot;</span><br></code></pre></td></tr></table></figure><p>在前面示例中, 如果 <code>dev</code> 配置文件处于 active 状态, 则 <code>MyProperties.list</code> 包含一个 <code>MyPojo</code> 条目 (name 为 <code>my another name</code>, description 为 <code>null</code>) . 对于 YAML 而言, 逗号分隔的列表和 YAML 列表同样会完全覆盖列表集合的内容.</p><p>对于 <code>Map</code> 属性, 您可以绑定来自多个源中提取的属性值. 但是, 对于多个源中的相同属性, 则使用高优先级最高的属性. 以下示例从 <code>MyProperties</code> 暴露了一个 <code>Map&lt;String, MyPojo&gt;</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ConfigurationProperties</span>(<span class="hljs-string">&quot;my&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">MyPojo</span>&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">MyPojo</span>&gt; <span class="hljs-title function_">getMap</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑以下配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">map:</span><br><br>    <span class="hljs-attr">key1:</span><br><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;my name 1&quot;</span><br><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;my description 1&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;dev&quot;</span><br><br><span class="hljs-attr">my:</span><br><br>  <span class="hljs-attr">map:</span><br><br>    <span class="hljs-attr">key1:</span><br><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;dev name 1&quot;</span><br><br>    <span class="hljs-attr">key2:</span><br><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;dev name 2&quot;</span><br><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;dev description 2&quot;</span><br></code></pre></td></tr></table></figure><p>如果 <code>dev</code> 配置文件未激活, 则 <code>MyProperties.map</code> 只包含一个带 <code>key1</code> 的 entry (name 为 <code>my name 1</code>, description 为 <code>my description 1</code>) . 如果激活了 <code>dev</code> 配置文件, 则 map 将包含两个 entry, key 分别为 <code>key1</code> (name 为 <code>dev name 1</code> 和 description 为 <code>my description 1</code>) 和 <code>key2</code> (name 为 <code>dev name 2</code> 和 description 为 <code>dev description 2</code>) .</p><p>前面的合并规则适用于所有不同属性源的属性, 而不仅仅是文件.</p><h4 id="2-8-8-属性转换"><a href="#2-8-8-属性转换" class="headerlink" title="2.8.8. 属性转换"></a>2.8.8. 属性转换</h4><p>当外部应用程序属性 (application properties) 绑定到 <code>@ConfigurationProperties</code> bean 时, Spring Boot 会尝试将其属性强制转换为正确的类型. 如果需要自定义类型转换, 可以提供 <code>ConversionService</code> bean (名为 <code>conversionService</code> 的 bean) 或自定义属性编辑器 (通过 <code>CustomEditorConfigurer</code> bean) 或自定义 <code>Converters</code> (带有注解为 <code>@ConfigurationPropertiesBinding</code> 的 bean 定义) .</p><p>由于该 bean 在应用程序生命周期早期就会使用 , 因此请限制 <code>ConversionService</code> 您使用的依赖. 因为有可能在创建时可能无法完全初始化所需的依赖. 如果配置 key 为非强制需要, 您可能希望重命名自定义的 <code>ConversionService</code>, 并仅依赖于使用 <code>@ConfigurationPropertiesBinding</code> 限定的自定义转换器.</p><h5 id="转换-Durations"><a href="#转换-Durations" class="headerlink" title="转换 Durations"></a>转换 Durations</h5><p>Spring Boot 支持持续时间 (duration) 表达. 如果您暴露一个 <code>java.time.Duration</code> 属性, 则可以在应用程序属性中使用以下格式:</p><ul><li>常规 <code>long</code> 表示 (除非指定 <code>@DurationUnit</code>, 否则使用毫秒作为默认单位)</li><li><a href="https://docs.oracle.com/javase/17/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-">used by <code>java.time.Duration</code></a> 使用的标准 ISO-8601 格式</li><li>一种更易读的格式, 值和单位在一起 (例如 <code>10s</code> 表示 10 秒)</li></ul><p>思考以下示例:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;my&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-meta">@DurationUnit(ChronoUnit.SECONDS)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">Duration</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> Duration.ofSeconds(<span class="hljs-number">30</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Duration</span> <span class="hljs-variable">readTimeout</span> <span class="hljs-operator">=</span> Duration.ofMillis(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// getters / setters...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>指定一个会话超时时间为 <code>30</code> 秒, 使用 <code>30</code>、<code>PT30S</code> 和 <code>30s</code> 等形式都是可以的. 读取超时时间设置为 <code>500ms</code>, 可以采用以下任何一种形式: <code>500</code>、<code>PT0.5S</code> 和 <code>500ms</code>.</p><p>您也可以使用任何支持的单位来标识:</p><ul><li><code>ns</code> 纳秒</li><li><code>us</code> 微秒</li><li><code>ms</code> 毫秒</li><li><code>s</code> 秒</li><li><code>m</code> 分</li><li><code>h</code> 小时</li><li><code>d</code> 天</li></ul><p>默认单位是毫秒, 可以使用 <code>@DurationUnit</code> 配合上面的单位示例重写. 请注意, 只有使用 getter 和 setter 的 JavaBean 样式的属性绑定才支持 <code>@DurationUnit</code>.构造函数绑定不支持.</p><p>如果您更喜欢使用构造函数绑定，则可以公开相同的属性，如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(<span class="hljs-string">&quot;my&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-comment">// fields...</span><br>    <span class="hljs-keyword">public</span> MyProperties(<span class="hljs-meta">@DurationUnit(ChronoUnit.SECONDS)</span> <span class="hljs-meta">@DefaultValue(<span class="hljs-string">&quot;30s&quot;</span>)</span> Duration sessionTimeout,            <span class="hljs-meta">@DefaultValue(<span class="hljs-string">&quot;1000ms&quot;</span>)</span> Duration readTimeout) &#123;        <span class="hljs-keyword">this</span>.sessionTimeout = sessionTimeout;        <span class="hljs-keyword">this</span>.readTimeout = readTimeout;    &#125;<br>    <span class="hljs-comment">// getters...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果您要升级 <code>Long</code> 属性，如果它不是毫秒，请确保使用 <code>@DurationUnit</code> 定义单位。 这样做提供了一个透明的升级路径，同时支持更丰富的格式.</p><h5 id="转换-periods"><a href="#转换-periods" class="headerlink" title="转换 periods"></a>转换 periods</h5><p>除了持续时间, Spring Boot 还可以使用 <code>java.time.Period</code> 类型. 可以在应用程序属性中使用以下格式:</p><ul><li>常规的 <code>int</code> 表示形式 (使用天作为默认单位, 除非已指定 <code>@PeriodUnit</code>)</li><li><a href="https://docs.oracle.com/javase/17/docs/api/java/time/Period.html#parse-java.lang.CharSequence-"><code>java.time.Period</code></a> 使用的标准 ISO-8601 格式。</li><li>将值和单位对耦合在一起 (e.g. <code>1y3d</code> 表示 1 年零 3 天)</li></ul><p>简单格式支持以下单位:</p><ul><li><code>y</code> 年</li><li><code>m</code> 月</li><li><code>w</code> 周</li><li><code>d</code> 天</li></ul><p><code>java.time.Period</code> 类型实际上从不存储星期数, 这是一个快捷方式, 表示 “7 days”.</p><h5 id="转换-Data-Sizes"><a href="#转换-Data-Sizes" class="headerlink" title="转换 Data Sizes"></a>转换 Data Sizes</h5><p>Spring Framework 有一个 <code>DataSize</code> 值类型, 允许以字节表示大小. 如果暴露一个 <code>DataSize</code> 属性, 则可以在应用程序属性中使用以下格式:</p><ul><li>常规的 <code>long</code> 表示 (使用字节作为默认单位, 除非指定了 <code>@DataSizeUnit</code>)</li><li>更具有可读性的格式, 值和单位在一起 (例如 <code>10MB</code> 表示 10 兆字节)</li></ul><p>请思考以下示例:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;my&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-meta">@DataSizeUnit(DataUnit.MEGABYTES)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataSize</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> DataSize.ofMegabytes(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataSize</span> <span class="hljs-variable">sizeThreshold</span> <span class="hljs-operator">=</span> DataSize.ofBytes(<span class="hljs-number">512</span>);<br>    <span class="hljs-comment">// getters/setters...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要指定 <code>10</code> 兆字节的缓冲大小, 使用 <code>10</code> 和 <code>10MB</code> 是等效的. <code>256</code> 字节的大小可以指定为 <code>256</code> 或 <code>256B</code>.</p><p>您也可以使用任何支持的单位:</p><ul><li><code>B</code> 字节</li><li><code>KB</code> 千字节</li><li><code>MB</code> 兆字节</li><li><code>GB</code> 千兆字节</li><li><code>TB</code> 兆兆字节</li></ul><p>默认单位是字节, 可以使用 <code>@DataSizeUnit</code> 配合上面的单位重写.</p><p>如果您更喜欢使用构造函数绑定，则可以公开相同的属性，如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(<span class="hljs-string">&quot;my&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProperties</span> &#123;<br>    <span class="hljs-comment">// fields...</span><br>    <span class="hljs-keyword">public</span> MyProperties(<span class="hljs-meta">@DataSizeUnit(DataUnit.MEGABYTES)</span> <span class="hljs-meta">@DefaultValue(<span class="hljs-string">&quot;2MB&quot;</span>)</span> DataSize bufferSize,            <span class="hljs-meta">@DefaultValue(<span class="hljs-string">&quot;512B&quot;</span>)</span> DataSize sizeThreshold) &#123;        <span class="hljs-keyword">this</span>.bufferSize = bufferSize;        <span class="hljs-keyword">this</span>.sizeThreshold = sizeThreshold;    &#125;<br>    <span class="hljs-comment">// getters...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果您要升级 <code>Long</code> 属性，如果它不是字节，请确保定义单位（使用 <code>@DataSizeUnit</code>）。 这样做提供了一个透明的升级路径，同时支持更丰富的格式。</p><h4 id="2-8-9-ConfigurationProperties-验证"><a href="#2-8-9-ConfigurationProperties-验证" class="headerlink" title="2.8.9. @ConfigurationProperties 验证"></a>2.8.9. @ConfigurationProperties 验证</h4><p>只要使用了 Spring 的 <code>@Validated</code> 注解, Spring Boot 就会尝试验证 <code>@ConfigurationProperties</code> 类. 您可以直接在配置类上使用 JSR-303 <code>javax.validation</code> 约束注解. 为此, 请确保 JSR-303 实现在 classpath 上, 然后将约束注解添加到字段上, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ConfigurationProperties</span>(<span class="hljs-string">&quot;my.service&quot;</span>)<span class="hljs-variable">@Validatedpublic</span> class MyProperties &#123;<br>    <span class="hljs-variable">@NotNull</span>    private InetAddress remoteAddress;<br>    <span class="hljs-comment">// getters/setters...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>您还可以通过使用 <code>@Validated</code> 注解创建配置属性的 <code>@Bean</code> 方法来触发验证.</p><p>虽然绑定时也会验证嵌套属性, 但最好的做法还是将关联字段注解上 <code>@Valid</code>. 这可确保即使未找到嵌套属性也会触发验证. 以下示例基于前面的 <code>MyProperties</code> 示例:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ConfigurationProperties</span>(<span class="hljs-string">&quot;my.service&quot;</span>)<span class="hljs-variable">@Validatedpublic</span> class MyProperties &#123;<br>    <span class="hljs-variable">@NotNull</span>    private InetAddress remoteAddress;<br>    <span class="hljs-variable">@Valid</span>    private final Security security = new <span class="hljs-built_in">Security</span>();<br>    <span class="hljs-comment">// getters/setters...</span><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">Security</span> &#123;<br>        <span class="hljs-variable">@NotEmpty</span>        private String username;<br>        <span class="hljs-comment">// getters/setters...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您还可以通过创建一个名为 <code>configurationPropertiesValidator</code> 的 bean 定义来添加自定义 Spring <code>Validator</code>. 应该将 <code>@Bean</code> 方法声明为 <code>static</code>. 配置属性验证器在应用程序生命周期的早期创建, 将 <code>@Bean</code> 方法声明为 <code>static</code> 可以无需实例化 <code>@Configuration</code> 类来创建 bean. 这样做可以避免早期实例化可能导致的意外问题. 这里有一个属性验证示例, 讲解了如何设置.</p><p><code>spring-boot-actuator</code> 模块包括一个暴露所有 <code>@ConfigurationProperties</code> bean 的端点. 可将 Web 浏览器指向 <code>/actuator/configprops</code> 或使用等效的 JMX 端点. 有关详细信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/actuator.html#actuator.endpoints">生产就绪功能</a>” 部分.</p><h4 id="2-8-10-ConfigurationProperties-vs-Value"><a href="#2-8-10-ConfigurationProperties-vs-Value" class="headerlink" title="2.8.10. @ConfigurationProperties vs. @Value"></a>2.8.10. @ConfigurationProperties vs. @Value</h4><p><code>@Value</code> 注解是核心容器功能, 它不提供与类型安全配置属性相同的功能. 下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 支持的功能:</p><p>功能</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ConfigurationProperties</span><br><span class="hljs-variable">@Value</span><br></code></pre></td></tr></table></figure><p><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding">宽松绑定</a></p><p>Yes</p><p>有限制 (查看 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.vs-value-annotation.note">note below</a>)</p><p><a href="https://sca.aliyun.com/learn/spring-boot/core/configuration-metadata.html#appendix.configuration-metadata">元数据支持</a></p><p>Yes</p><p>No</p><p><code>SpEL</code> 表达式</p><p>No</p><p>Yes</p><p>如果您确实想使用 <code>@Value</code>, 我们建议您以规范形式引用属性名称( kebab-case 仅使用小写字母), 这与 Spring Boot <code>@ConfigurationProperties</code> <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.relaxed-binding">宽松绑定</a> 使用相同的逻辑.</p><p>例如, <code>@Value(&quot;$&#123;demo.item-price&#125;&quot;)</code> 将从 <code>application.properties</code> 文件以及 <code>DEMO_ITEMPRICE</code> 环境变量中获取 <code>demo.item-price</code> 和 <code>demo.itemPrice</code> 形式. 如果您使用的是 <code>@Value(&quot;$&#123;demo.itemPrice&#125;&quot;)</code> , 则不会考虑 <code>demo.item-price</code> 和 <code>DEMO_ITEMPRICE</code> 环境变量.</p><p>如果您要为自己的组件定义一组配置 key, 我们建议您将它们分组到使用 <code>@ConfigurationProperties</code> 注解的 POJO 中.这样做将为您提供结构化, 类型安全的对象, 您可以将其注入到自己的 bean 中.</p><p>解析这些文件并填充环境时, 不会处理来自 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files">应用程序属性文件</a> 的 SpEL 表达式. 但是, 可以在 <code>@Value</code> 中编写 SpEL 表达式. 如果 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files">应用程序属性文件</a> 中的属性值是 SpEL 表达式, 则在通过 <code>@Value</code> 进行使用时将对其进行评估.</p><h2 id="3-Profiles"><a href="#3-Profiles" class="headerlink" title="3. Profiles"></a>3. Profiles</h2><p>Spring Profile 提供了一种能够将应用程序的部分配置隔离，并使其仅在特定环境中可用的方法. 可以使用 <code>@Profile</code> 来注解任何 <code>@Component</code> 或 <code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 以指定何时加载它, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)<span class="hljs-variable">@Profile</span>(<span class="hljs-string">&quot;production&quot;</span>)public class ProductionConfiguration &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>@ConfigurationProperties</code> Bean 是通过 <code>@EnableConfigurationProperties</code> 而非自动扫描注册的, 则需要在 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解. 在扫描 <code>@ConfigurationProperties</code> 的情况下, 可以在 <code>@ConfigurationProperties</code> 类本身上指定 <code>@Profile</code>.</p><p>您可以使用 <code>spring.profiles.active</code> <code>Environment</code> 属性指定哪些配置文件处于激活状态. 您可以使用本章前面介绍的任何方法指定属性. 例如, 您可以将其包含在 <code>application.properties</code> 中, 如下所示:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  profiles:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    active:</span> <span class="hljs-string">&quot;dev,hsqldb&quot;</span><br></code></pre></td></tr></table></figure><p>您还可以在命令行上使用以下开关指定它: <code>--spring.profiles.active=dev,hsqldb</code>.</p><p>如果没有配置文件处于活动状态，则启用默认配置文件。 默认配置文件的名称是 <code>default</code>，可以使用 <code>spring.profiles.default</code> <code>Environment</code> 属性对其进行调整，如下例所示:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  profiles:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    default:</span> <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p><code>spring.profiles.active</code> 和 <code>spring.profiles.default</code> 只能在非配置文件特定的文档中使用。 这意味着它们不能在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">profile specific files</a> 或 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.activation-properties">documents activated</a> 中包含 <code>spring.config.activate.on-profile</code>。</p><p>例如, 第二个文档配置无效:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># this document is valid</span><br><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">profiles:</span><br><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&quot;prod&quot;</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># this document is invalid</span><br><br><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">config:</span><br><br>    <span class="hljs-attr">activate:</span><br><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;prod&quot;</span><br><br>  <span class="hljs-attr">profiles:</span><br><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&quot;metrics&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-1-添加激活-Profile"><a href="#3-1-添加激活-Profile" class="headerlink" title="3.1. 添加激活 Profile"></a>3.1. 添加激活 Profile</h3><p><code>spring.profiles.active</code> 属性遵循与其他属性相同的排序规则: 应用优先级最高的 <code>PropertySource</code>. 这意味着您可以在 <code>application.properties</code> 中指定激活配置文件, 然后使用命令行切换替换它们.</p><p>有时, 将特定 profile 的属性添加到激活配置文件而不是替换它们, 这种方式也是很有用的.<code>spring.profiles.include</code> 属性可用于在 <code>spring.profiles.active</code> 属性激活的配置文件之上添加激活的配置文件。</p><p><code>SpringApplication</code> 入口还有一个 Java API, 用于设置其他 profile，请参阅 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/SpringApplication.html">SpringApplication</a> 的 <code>setAdditionalProfiles()</code> 方法.</p><p>例如，当运行具有以下属性的应用程序时，即使使用 —spring.profiles.active 运行，也会激活 common 和 local 配置文件：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  profiles:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    include:</span><br><br>      - <span class="hljs-string">&quot;common&quot;</span><br><br>      - <span class="hljs-string">&quot;local&quot;</span><br></code></pre></td></tr></table></figure><p>与 <code>spring.profiles.active</code> 一样, <code>spring.profiles.include</code> 只能在非配置文件特定的文档中使用. 这意味着它们不能在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">profile specific files</a> 或 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.activation-properties">documents activated</a> 包含 <code>spring.config.activate.on-profile</code>.</p><p>如果给定的 Profile 是激活的，还可以使用 Profile 组(将在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.profiles.groups">下一节中</a> 进行描述)添加激活的配置文件:</p><h3 id="3-2-Profile-组"><a href="#3-2-Profile-组" class="headerlink" title="3.2. Profile 组"></a>3.2. Profile 组</h3><p>有时，您在应用程序中定义和使用的 Profile 粒度太细，使用起来很麻烦. 例如，您可以使用 <code>proddb</code> 和 <code>prodmq</code> Profile 独立地启用数据库和消息传递特性.</p><p>为了帮助实现这一点，Spring Boot 允许您定义 Profile 组. Profile 组允许您为相关的 Profile 组定义逻辑名称.</p><p>例如，我们可以创建一个由 <code>proddb</code> 和 <code>prodmq</code> 配置文件组成的 <code>production</code> 组.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  profiles:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    group:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      production:</span><br><br>      - <span class="hljs-string">&quot;proddb&quot;</span><br><br>      - <span class="hljs-string">&quot;prodmq&quot;</span><br></code></pre></td></tr></table></figure><p>我们的应用程序现在可以使用 <code>--spring.profiles.active=production</code> 启动. 一次性激活 <code>production</code>, <code>proddb</code> 和 <code>prodmq</code> 配置文件.</p><h3 id="3-3-以编程方式设置-Profiles"><a href="#3-3-以编程方式设置-Profiles" class="headerlink" title="3.3. 以编程方式设置 Profiles"></a>3.3. 以编程方式设置 Profiles</h3><p>您可以在应用程序运行之前通过调用 <code>SpringApplication.setAdditionalProfiles(…)</code> 以编程方式设置 active 配置文件. 也可以使用 Spring 的 <code>ConfigurableEnvironment</code> 接口激活 profile.</p><h3 id="3-4-特定-Profile-的配置文件"><a href="#3-4-特定-Profile-的配置文件" class="headerlink" title="3.4. 特定 Profile 的配置文件"></a>3.4. 特定 Profile 的配置文件</h3><p>特定 profile 的 <code>application.properties</code> (或 <code>application.yml</code>) 和通过 <code>@ConfigurationProperties</code> 引用的文件被当做文件并加载. 有关详细信息, 请参见 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.profile-specific">特定 Profile 的属性文件</a>”.</p><h2 id="4-日志记录"><a href="#4-日志记录" class="headerlink" title="4. 日志记录"></a>4. 日志记录</h2><p>Spring Boot 使用 <a href="https://commons.apache.org/logging">Commons Logging</a> 记录所有内部日志, 但保留底层日志实现. 其为 <a href="https://docs.oracle.com/javase/17/docs/api/java/util/logging/package-summary.html">Java Util Logging</a>, <a href="https://logging.apache.org/log4j/2.x/">Log4J2</a> 和 <a href="https://logback.qos.ch/">Logback</a> 提供了默认配置. 每种日志记录器都预先配置为使用控制台输出, 并且还提供可选的文件输出.</p><p>默认情况下, 如果您使用了 <code>Starter</code>, 则使用 Logback 进行日志记录.还包括合适的 Logback 路由, 以确保在使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作.</p><p>Java 有很多日志框架可供使用. 如果以上列表让您感到困惑, 请不要担心. 通常, 您不需要更改日志依赖, 并且 Spring Boot 提供的默认配置可以保证日志正常工作.</p><p>将应用程序部署到 Servlet 容器或应用程序服务器时, 通过 Java Util Logging API 执行的日志记录不会路由到应用程序的日志中. 这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中.</p><h3 id="4-1-日志格式"><a href="#4-1-日志格式" class="headerlink" title="4.1. 日志格式"></a>4.1. 日志格式</h3><p>Spring Boot 默认日志输出类似于以下示例:</p><p>2019-03-05 10:57:51.112 INFO 45469 — [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat&#x2F;7.0.52 2019-03-05 10:57:51.253 INFO 45469 — [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring embedded WebApplicationContext 2019-03-05 10:57:51.253 INFO 45469 — [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1358 ms 2019-03-05 10:57:51.698 INFO 45469 — [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean : Mapping servlet: ‘dispatcherServlet’ to [&#x2F;] 2019-03-05 10:57:51.702 INFO 45469 — [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean : Mapping filter: ‘hiddenHttpMethodFilter’ to: [&#x2F;*]</p><p>输出以下项:</p><ul><li>日期和时间: 毫秒精度, 易于排序.</li><li>日志级别: <code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code> 或 <code>TRACE</code>.</li><li>进程 ID.</li><li>一个 <code>---</code> 分隔符, 用于区分实际日志内容的开始.</li><li>线程名称: 在方括号中 (可能会截断控制台输出) .</li><li>日志记录器名称: 这通常是源类名称 (通常为缩写) .</li><li>日志内容.</li></ul><p>Logback 没有 <code>FATAL</code> 级别. 该级别映射到 <code>ERROR</code>.</p><h3 id="4-2-控制台输出"><a href="#4-2-控制台输出" class="headerlink" title="4.2. 控制台输出"></a>4.2. 控制台输出</h3><p>默认日志配置会在写入时将消息回显到控制台. 默认情况下, 会记录 <code>ERROR</code>、<code>WARN</code> 和 <code>INFO</code> 级别的日志. 您还可以通过使用 <code>--debug</code> 标志启动应用程序来启用调试模式.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>myapp.<span class="hljs-keyword">jar </span>--<span class="hljs-built_in">debug</span><br></code></pre></td></tr></table></figure><p>您还可以在 <code>application.properties</code> 中指定 <code>debug=true</code>.</p><p>启用调试模式后, 核心日志记录器 (内嵌容器、Hibernate 和 Spring Boot) 将被配置为输出更多日志信息. 启用调试模式不会将应用程序配置为使用 <code>DEBUG</code> 级别记录所有日志内容.</p><p>或者, 您可以通过使用 <code>--trace</code> 标志 (或在 <code>application.properties</code> 中的设置 <code>trace=true</code>) 启动应用程序来启用跟踪模式. 这样做可以为选择的核心日志记录器 (内嵌容器、Hibernate 模式生成和整个 Spring 组合) 启用日志追踪.</p><h4 id="4-2-1-着色输出"><a href="#4-2-1-着色输出" class="headerlink" title="4.2.1. 着色输出"></a>4.2.1. 着色输出</h4><p>如果您的终端支持 ANSI, 则可以使用颜色输出来提高可读性. 您可以将 <code>spring.output.ansi.enabled</code> 设置为 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html">受支持的值</a> 以覆盖自动检测:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">clr</span>(%5p)</span><br></code></pre></td></tr></table></figure><p>下表描述日志级别与颜色的映射关系:</p><p>Level</p><p>Color</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FATAL</span><br></code></pre></td></tr></table></figure><p>Red</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ERROR</span><br></code></pre></td></tr></table></figure><p>Red</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">WARN</span><br></code></pre></td></tr></table></figure><p>Yellow</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">INFO</span><br></code></pre></td></tr></table></figure><p>Green</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DEBUG</span><br></code></pre></td></tr></table></figure><p>Green</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">TRACE</span><br></code></pre></td></tr></table></figure><p>Green</p><p>或者, 您可以通过将其作为转换选项指定应使用的颜色或样式. 例如, 要将文本变为黄色, 请使用以下设置:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">clr</span>(%d&#123;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&#125;)&#123;yellow&#125;</span><br></code></pre></td></tr></table></figure><p>支持以下颜色和样式:</p><ul><li><code>blue</code></li><li><code>cyan</code></li><li><code>faint</code></li><li><code>green</code></li><li><code>magenta</code></li><li><code>red</code></li><li><code>yellow</code></li></ul><h3 id="4-3-文件输出"><a href="#4-3-文件输出" class="headerlink" title="4.3. 文件输出"></a>4.3. 文件输出</h3><p>默认情况下, Spring Boot 仅记录到控制台, 不会写入日志文件. 想除了控制台输出之外还要写入日志文件, 则需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性 (例如, 在 <code>application.properties</code> 中) .</p><p>下表展示了如何与 <code>logging.*</code> 属性一起使用:</p><p>Table 5. Logging 属性</p><p>configprop: logging .file.name []</p><p>configprop: logging .file.path []</p><p>Example</p><p>Description</p><p><em>(none)</em></p><p><em>(none)</em></p><p>仅在控制台输出</p><p>指定文件</p><p><em>(none)</em></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">my</span>.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>写入指定的日志文件. 名称可以是绝对位置或相对于当前目录.</p><p><em>(none)</em></p><p>指定目录</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">/<span class="hljs-keyword">var</span>/<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>将 <code>spring.log</code> 写入指定的目录. 名称可以是绝对位置或相对于当前目录.</p><p>日志文件在达到 <code>10MB</code> 时会轮转, 并且与控制台输出一样, 默认情况下会记录 <code>ERROR</code>、<code>WARN</code> 和 <code>INFO</code> 级别的内容.</p><p>日日志属性独立于实际的日志底层. 因此, spring Boot 不管理特定的配置 key (例如 Logback 的 <code>logback.configurationFile</code>) .</p><h3 id="4-4-File-Rotation"><a href="#4-4-File-Rotation" class="headerlink" title="4.4. File Rotation"></a>4.4. File Rotation</h3><p>如果您正在使用 Logback，则可以使用 <code>application.properties</code> 或 <code>application.yaml</code> 设置 log rotation. 对于所有其他日志系统，您需要自己直接配置 rotation 设置(例如，如果您使用 Log4J2，那么您可以添加一个 <code>log4j.xml</code> 或 <code>log4j2-spring.xml</code> 文件).</p><p>支持以下 rotation 策略属性:</p><p>Name</p><p>Description</p><p>configprop: logging .logback.rollingpolicy.file-name-pattern []</p><p>The filename pattern used to create log archives.</p><p>configprop: logging .logback.rollingpolicy.clean-history-on-start []</p><p>If log archive cleanup should occur when the application starts.</p><p>configprop: logging .logback.rollingpolicy.max-file-size []</p><p>The maximum size of log file before it is archived.</p><p>configprop: logging .logback.rollingpolicy.total-size-cap []</p><p>The maximum amount of size log archives can take before being deleted.</p><p>configprop: logging .logback.rollingpolicy.max-history []</p><p>The maximum number of archive log files to keep (defaults to 7).</p><h3 id="4-5-日志等级"><a href="#4-5-日志等级" class="headerlink" title="4.5. 日志等级"></a>4.5. 日志等级</h3><p>所有受支持的日志记录系统都可以使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 来设置 Spring <code>Environment</code> 中的记录器等级 (例如, 在 <code>application.properties</code> 中) . 其中 level 是 <code>TRACE</code>、<code>DEBUG</code>、<code>INFO</code>、<code>WARN</code>、<code>ERROR</code>、<code>FATAL</code> 和 <code>OFF</code> 其中之一. 可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器.</p><p>以下示例展示了 <code>application.properties</code> 中默认的日志记录设置:</p><p>Properties</p><p>Yaml</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">logging.level.root</span>=warn<br><br><span class="hljs-attr">logging.level.org.springframework.web</span>=debug<br><br><span class="hljs-attr">logging.level.org.hibernate</span>=error<br></code></pre></td></tr></table></figure><p>也可以使用环境变量设置日志记录级别. 例如, <code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 会将 <code>org.springframework.web</code> 设置为 <code>DEBUG</code>.</p><p>以上方法仅适用于程序包级别的日志记录. 由于宽松的绑定总是将环境变量转换为小写, 因此无法以这种方式为单个类配置日志记录. 如果需要为类配置日志记录, 则可以使用 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.application-json"><code>SPRING_APPLICATION_JSON</code></a> 变量.</p><h3 id="4-6-日志组"><a href="#4-6-日志组" class="headerlink" title="4.6. 日志组"></a>4.6. 日志组</h3><p>将相关记录器组合在一起以便可以同时配置, 这通常很有用. 例如, 您可以更改所有 Tomcat 相关记录器的日志记录级别, 但您无法轻松记住顶层的包名.</p><p>为了解决这个问题, Spring Boot 允许您在 Spring <code>Environment</code> 中定义日志记录组. 例如, 以下通过将 “tomcat” 组添加到 <code>application.properties</code> 来定义 tomcat 组:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  group:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    tomcat:</span> <span class="hljs-string">&quot;org.apache.catalina,org.apache.coyote,org.apache.tomcat&quot;</span><br></code></pre></td></tr></table></figure><p>定义后, 您可以使用一行配置来更改组中所有记录器的级别:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  level:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    tomcat:</span> <span class="hljs-string">&quot;trace&quot;</span><br></code></pre></td></tr></table></figure><p>Spring Boot 包含以下预定义的日志记录组, 可以直接使用:</p><p>名称</p><p>日志记录器</p><p>web</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core</span>.codec`, `org<span class="hljs-selector-class">.springframework</span>.http`, `org<span class="hljs-selector-class">.springframework</span>.web`, `org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.actuate</span><span class="hljs-selector-class">.endpoint</span>.web`, `org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span>.ServletContextInitializerBeans<br></code></pre></td></tr></table></figure><p>sql</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.jdbc</span>.core`, `org<span class="hljs-selector-class">.hibernate</span>.SQL`, `org<span class="hljs-selector-class">.jooq</span><span class="hljs-selector-class">.tools</span>.LoggerListener<br></code></pre></td></tr></table></figure><h3 id="4-7-使用日志-Shutdown-钩子"><a href="#4-7-使用日志-Shutdown-钩子" class="headerlink" title="4.7. 使用日志 Shutdown 钩子"></a>4.7. 使用日志 Shutdown 钩子</h3><p>为了在您的应用程序终止时释放日志记录资源，提供了一个 shutdown hook（勾子），该勾子将在 JVM 退出时触发日志系统清理。 除非您的应用程序部署为 war 文件，否则此 shutdown 勾子会自动注册。 如果您的应用程序具有复杂的上下文层次结构，则 shutdown 勾子可能无法满足您的需求。 如果没有，请禁用 shutdown 勾子 并调查底层日志记录系统直接提供的选项。 例如，Logback 提供 <a href="https://logback.qos.ch/manual/loggingSeparation.html">context selectors</a>，它允许在自己的上下文中创建每个 Logger。</p><p>您可以使用 <code>logging.register-shutdown-hook</code> 属性来禁用 shutdown 勾子。将其设置为 <code>false</code> 将禁用注册。 您可以在 <code>application.properties</code> 或 <code>application.yaml</code> 文件中设置属性：</p><p>对于在自己的 JVM 中部署的简单 “jar” 应用程序， 可以使用 <code>logging.register-shutdown-hook</code> 属性. 将 <code>logging.register-shutdown-hook</code> 设置为 <code>true</code> 将注册一个关闭钩子， 当 JVM 退出时， 该钩子将触发日志系统清理.</p><p>您可以在 <code>application.properties</code> 或 <code>application.yaml</code> 文件中设置属性:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">logging:<br><br>  <span class="hljs-keyword">register</span>-shutdown-hook: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="4-8-自定义日志配置"><a href="#4-8-自定义日志配置" class="headerlink" title="4.8. 自定义日志配置"></a>4.8. 自定义日志配置</h3><p>可以通过在 classpath 中引入适合的库来激活各种日志记录系统, 并且可以通过在 classpath 的根目录中或在以下 Spring Environment 属性指定的位置提供合适的配置文件来进一步自定义: <code>logging.config</code>.</p><p>您可以使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性强制 Spring Boot 使用特定的日志记录系统. 该值应该是一个实现了 <code>LoggingSystem</code> 的类的完全限定类名. 您还可以使用 <code>none</code> 值完全禁用 Spring Boot 的日志记录配置.</p><p>由于日志记录在创建 <code>ApplicationContext</code> 之前初始化, 因此无法在 Spring <code>@Configuration</code> 文件中控制来自 <code>@PropertySources</code> 的日志记录. 更改日志记录系统或完全禁用它的唯一方法是通过系统属性设置.</p><p>根据您的日志记录系统, 将加载以下文件:</p><p>日志记录系统</p><p>文件</p><p>Logback</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">logback-spring.xml`, `logback-spring.groovy`, `logback.xml`, 或者 `logback.groovy<br></code></pre></td></tr></table></figure><p>Log4j2</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">log4j2-spring.xml` 或者 `log4j2.xml<br></code></pre></td></tr></table></figure><p>JDK (Java Util Logging)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">logging.<span class="hljs-keyword">properties</span><br></code></pre></td></tr></table></figure><p>如果可能, 我们建议您使用 <code>-spring</code> 的形式来配置日志记录 (比如 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>) . 如果使用标准的配置位置, Spring 无法完全控制日志初始化.</p><p>Java Util Logging 存在已知的类加载问题, 这些问题在以 ‘executable jar’ 运行时会触发. 如果可能的话, 我们建议您在使用可执行 jar 方式运行时避免使用它. .</p><p>为了进行自定义, 部分其他属性会从 Spring <code>Environment</code> 传输到 <code>System</code> 属性, 如下表所述:</p><p>Spring Environment</p><p>系统属性</p><p>说明</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">logging.<span class="hljs-keyword">exception</span>-<span class="hljs-keyword">conversion</span>-word<br>LOG_EXCEPTION_CONVERSION_WORD<br></code></pre></td></tr></table></figure><p>记录异常时使用的转换字.</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">logging.<span class="hljs-keyword">file</span>.<span class="hljs-keyword">name</span><br>LOG_FILE<br></code></pre></td></tr></table></figure><p>如果已定义, 则在默认日志配置中使用它.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.file</span><span class="hljs-selector-class">.path</span><br>LOG_PATH<br></code></pre></td></tr></table></figure><p>如果已定义, 则在默认日志配置中使用它.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.pattern</span><span class="hljs-selector-class">.console</span><br>CONSOLE_LOG_PATTERN<br></code></pre></td></tr></table></figure><p>要在控制台上使用的日志模式 (stdout) .</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.pattern</span><span class="hljs-selector-class">.dateformat</span><br>LOG_DATEFORMAT_PATTERN<br></code></pre></td></tr></table></figure><p>日志日期格式的 Appender 模式. (仅支持默认的 Logback 设置. )</p><p>configprop: logging .charset.console []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">CONSOLE_LOG_CHARSET</span><br></code></pre></td></tr></table></figure><p>The charset to use for console logging.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.pattern</span><span class="hljs-selector-class">.file</span><br>FILE_LOG_PATTERN<br></code></pre></td></tr></table></figure><p>要在文件中使用的日志模式 (如果启用了 <code>LOG_FILE</code>) .</p><p>configprop: logging .charset.file []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FILE_LOG_CHARSET</span><br></code></pre></td></tr></table></figure><p>The charset to use for file logging (if <code>LOG_FILE</code> is enabled).</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">logging<span class="hljs-selector-class">.pattern</span><span class="hljs-selector-class">.level</span><br>LOG_LEVEL_PATTERN<br></code></pre></td></tr></table></figure><p>渲染日志级别时使用的格式 (默认值为 <code>%5p</code>) .</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">PID</span><br><span class="hljs-attribute">PID</span><br></code></pre></td></tr></table></figure><p>当前进程 ID (如果可能, 则在未定义为 OS 环境变量时发现) .</p><p>如果您使用的是 Logback，以下属性也会被转移:</p><p>Spring Environment</p><p>System Property</p><p>Comments</p><p>configprop: logging .logback.rollingpolicy.file-name-pattern []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN</span><br></code></pre></td></tr></table></figure><p>Pattern for rolled-over log file names (default <code>$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz</code>).</p><p>configprop: logging .logback.rollingpolicy.clean-history-on-start []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START</span><br></code></pre></td></tr></table></figure><p>Whether to clean the archive log files on startup.</p><p>configprop: logging .logback.rollingpolicy.max-file-size []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE</span><br></code></pre></td></tr></table></figure><p>Maximum log file size.</p><p>configprop: logging .logback.rollingpolicy.total-size-cap []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP</span><br></code></pre></td></tr></table></figure><p>Total size of log backups to be kept.</p><p>configprop: logging .logback.rollingpolicy.max-history []</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LOGBACK_ROLLINGPOLICY_MAX_HISTORY</span><br></code></pre></td></tr></table></figure><p>Maximum number of archive log files to keep.</p><p>所有受支持的日志记录系统在解析其配置文件时都可以参考系统属性. 有关示例, 请参阅 <code>spring-boot.jar</code> 中的默认配置:</p><ul><li><a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></li></ul><p>如果要在日志记录属性中使用占位符, 则应使用 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.files.property-placeholders">Spring Boot 的语法</a>, 而不是使用底层框架的语法. 值得注意的是, 如果使用 Logback, 则应使用 <code>:</code> 作为属性名称与其默认值之间的分隔符, 而不是使用 <code>:-</code>.</p><p>您可以通过仅覆盖 <code>LOG_LEVEL_PATTERN</code> (或带 Logback 的 <code>logging.pattern.level</code>) 将 MDC 和其他特别的内容添加到日志行. 例如, 如果使用 <code>logging.pattern.level=user:%X&#123;user&#125; %5p</code>, 则默认日志格式包含 user MDC 项 (如果存在) , 如下所示:</p><p>2019-08-30 12:30:04.031 user: someone INFO 22174 — [ nio-8080-exec-0] demo.Controller Handling authenticated request</p><h3 id="4-9-Logback-扩展"><a href="#4-9-Logback-扩展" class="headerlink" title="4.9. Logback 扩展"></a>4.9. Logback 扩展</h3><p>Spring Boot 包含许多 Logback 扩展, 可用于进行高级配置. 您可以在 <code>logback-spring.xml</code> 配置文件中使用这些扩展.</p><p>由于标准的 <code>logback.xml</code> 配置文件加载过早, 因此无法在其中使用扩展. 您需要使用 <code>logback-spring.xml</code> 或定义 <code>logging.config</code> 属性.</p><p>扩展不能与 Logback 的 <a href="https://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a> 一起使用. 如果尝试这样做, 更改配置文件会导致发生类似以下错误日志: .</p><p>ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</p><h4 id="4-9-1-特定-Profile-配置"><a href="#4-9-1-特定-Profile-配置" class="headerlink" title="4.9.1. 特定 Profile 配置"></a>4.9.1. 特定 Profile 配置</h4><p><code>&lt;springProfile&gt;</code> 标签允许您根据激活的 Spring profile 选择性地包含或排除配置部分. 在 <code>&lt;configuration&gt;</code> 元素中的任何位置都支持配置 profile. 使用 <code>name</code> 属性指定哪个 profile 接受配置. <code>&lt;springProfile&gt;</code> 标记可以包含简单的 proifle 名称 (例如 <code>staging</code>) 或 profile 表达式. profile 表达式允许表达更复杂的 profile 逻辑, 例如 <code>production &amp; (eu-central | eu-west)</code>. 有关详细信息, 请查阅 <a href="https://sca.aliyun.com/blog/learning/spring/core/ioc#beans-definition-profiles-java">Spring Framework 参考指南</a> . 以下清单展示了三个示例 profile:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;staging&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev | staging&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!production&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-9-2-环境属性"><a href="#4-9-2-环境属性" class="headerlink" title="4.9.2. 环境属性"></a>4.9.2. 环境属性</h4><p>使用 <code>&lt;springProperty&gt;</code> 标签可以让您暴露 Spring 环境 (<code>Environment</code>) 中的属性, 以便在 Logback 中使用. 如果在 Logback 配置中访问来自 <code>application.properties</code> 文件的值, 这样做很有用. 标签的工作方式与 Logback 的标准 <code>&lt;property&gt;</code> 标签类似. 但是, 您可以指定属性 (来自 <code>Environment</code>) 的 <code>source</code>, 而不是指定直接的 <code>value</code>. 如果需要将属性存储在 <code>local</code> 作用域以外的其他位置, 则可以使用 <code>scope</code> 属性. 如果需要回退值 (如果未在 <code>Environment</code> 中设置该属性) , 则可以使用 <code>defaultValue</code> 属性. 以下示例展示了如何暴露属性以便在 Logback 中使用:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fluentHost&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml"></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FLUENT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">remoteHost</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;fluentHost&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">remoteHost</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    ...</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>必须以 kebab 风格 (短横线小写风格) 指定 <code>source</code> (例如 <code>my.property-name</code>) . 但可以使用宽松规则将属性添加到 <code>Environment</code> 中.</p><h3 id="4-10-Log4j2-扩展"><a href="#4-10-Log4j2-扩展" class="headerlink" title="4.10. Log4j2 扩展"></a>4.10. Log4j2 扩展</h3><p>Spring Boot 包括许多对 Log4j2 的扩展，可以进行高级配置。您可以在任何 <code>log4j2-spring.xml</code> 配置文件中使用这些扩展。</p><p>由于标准 <code>log4j2.xml</code> 配置文件加载得太早，因此不能在其中使用扩展。您需要使用 <code>log4j2-spring.xml</code> 或定义 <code>logging.config</code> 属性。</p><p>这些扩展取代了 <a href="https://logging.apache.org/log4j/2.x/log4j-spring-boot/index.html">Spring Boot 提供的对</a> Log4J 的支持。你应该确保在你的构建中不包含 <code>org.apache.logging.log4j:log4j-spring-boot</code> 模块。</p><h4 id="4-10-1-Profile-specific-Configuration"><a href="#4-10-1-Profile-specific-Configuration" class="headerlink" title="4.10.1. Profile-specific Configuration"></a>4.10.1. Profile-specific Configuration</h4><p><code>&lt;SpringProfile&gt;</code> 标签允许您根据激活的 Spring profile 选择性地包含或排除部分配置。Profile 部分在 <code>&lt;Configuration&gt;</code> 元素中的任何位置都受支持。 使用 <code>name</code> 属性指定哪个配置文件接受配置。 <code>&lt;SpringProfile&gt;</code> 标签可以包含配置文件名称（例如 <code>staging</code>）或配置文件表达式。 配置文件表达式允许表达更复杂的配置文件逻辑，例如 <code>production &amp; (eu-central | eu-west)</code>。 查看 <a href="https://sca.aliyun.com/blog/learning/spring/core/ioc#beans-definition-profiles-java">Spring Framework 参考指南</a> 以获取更多详细信息。 以下清单显示了三个示例配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;staging&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev | staging&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!production&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-10-2-Environment-Properties-Lookup"><a href="#4-10-2-Environment-Properties-Lookup" class="headerlink" title="4.10.2. Environment Properties Lookup"></a>4.10.2. Environment Properties Lookup</h4><p>如果你想在 Log4j2 配置中引用 Spring <code>Environment</code> 中的属性，你可以使用前缀 <code>spring:</code> <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">lookups</a>。 如果要访问 Log4j2 配置中的 <code>application.properties</code> 文件中的值，这样做会很有用。</p><p>下面的示例演示如何设置一个名为 <code>applicationName</code> 的 Log4j2 属性，该属性从 Spring <code>Environment</code> 中读取 <code>spring.application.name</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;applicationName&quot;</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring:spring.application.name&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>查找的 key 应该以 kebab case 命名 (such as <code>my.property-name</code>).</p><h4 id="4-10-3-Log4j2-系统属性"><a href="#4-10-3-Log4j2-系统属性" class="headerlink" title="4.10.3. Log4j2 系统属性"></a>4.10.3. Log4j2 系统属性</h4><p>Log4j2 支持许多可用于配置各种项目的 <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html#SystemProperties">System Properties</a> 。 例如， <code>log4j2.skipJansi</code> 系统属性可用于配置 <code>ConsoleAppender</code> 是否将尝试在 Windows 上使用 <a href="https://github.com/fusesource/jansi">Jansi</a> 输出流。</p><p>在 Log4j2 初始化后加载的所有系统属性都可以从 Spring 的 <code>Environment</code> 中获得。 例如，您可以将 <code>log4j2.skipJansi=false</code> 添加到 <code>application.properties</code> 文件中，以使 <code>ConsoleAppender</code> 在 Windows 上使用 Jansi。</p><p>仅当系统属性和操作系统环境变量不包含正在加载的值时，才会考虑 Spring <code>Environment</code></p><p>在早期 Log4j2 初始化期间加载的系统属性不能引用 Spring 的 <code>Environment</code>。 例如，在 Spring 环境可用之前，将使用 Log4j2 用于允许选择默认 Log4j2 实现的属性。</p><h2 id="5-国际化"><a href="#5-国际化" class="headerlink" title="5. 国际化"></a>5. 国际化</h2><p>Spring Boot 支持本地化消息, 因此您的应用程序可以迎合不同语言首选项的用户. 默认情况下, Spring Boot 在类路径的根目录下查找 <code>messages</code> 资源包的存在.</p><p>当已配置资源束的默认属性文件可用时 (即默认情况下为 <code>messages.properties</code>) , 将应用自动配置. 如果您的资源包仅包含特定于语言的属性文件, 则需要添加默认文件. 如果找不到与任何配置的基本名称匹配的属性文件, 将没有自动配置的 <code>MessageSource</code>.</p><p>可以使用 <code>spring.messages</code> 命名空间配置资源包的基本名称以及其他几个属性, 如以下示例所示:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><br>  <span class="hljs-attr">messages:</span><br><br>    <span class="hljs-attr">basename:</span> <span class="hljs-string">&quot;messages,config.i18n.messages&quot;</span><br><br>    <span class="hljs-attr">fallback-to-system-locale:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>spring.messages.basename</code> 支持以逗号分隔的位置列表, 可以是包限定符, 也可以是从类路径根目录解析的资源.</p><p>有关更多支持的选项, 请参见 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a></p><h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a>6. JSON</h2><p>Spring Boot 为三个 JSON 映射库提供了内置集成:</p><ul><li>Gson</li><li>Jackson</li><li>JSON-B</li></ul><p>Jackson 是首选和默认的库.</p><h3 id="6-1-Jackson"><a href="#6-1-Jackson" class="headerlink" title="6.1. Jackson"></a>6.1. Jackson</h3><p>Spring Boot 提供了 Jackson 的自动配置, Jackson 是 <code>spring-boot-starter-json</code> 的一部分. 当 Jackson 在 classpath 上时, 会自动配置 <code>ObjectMapper</code> bean. Spring Boot 提供了几个配置属性来 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.spring-mvc.customize-jackson-objectmapper">自定义 <code>ObjectMapper</code> 的配置</a>.</p><h4 id="6-1-1-自定义序列化和反序列化器"><a href="#6-1-1-自定义序列化和反序列化器" class="headerlink" title="6.1.1. 自定义序列化和反序列化器"></a>6.1.1. 自定义序列化和反序列化器</h4><p>如果使用 Jackson 序列化和反序列化 JSON 数据，则可能需要编写自己的 <code>JsonSerializer</code> 和 <code>JsonDeserializer</code> 类。 自定义序列化器通常是 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块向 Jackson 注册</a>，但 Spring Boot 提供了一个替代的 <code>@JsonComponent</code> 注解， 使得直接注册 Spring Beans 变得更加容易。</p><p>您可以直接在 <code>JsonSerializer</code>, <code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。 还可以在包含序列化器&#x2F;反序列化器作为内部类的类上使用它，如以下示例所示：</p><p>Java</p><p>Kotlin</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@JsonComponentpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJsonComponent</span> </span>&#123;<br>    public static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonSerializer&lt;MyObject&gt;</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span>        public void serialize(<span class="hljs-type">MyObject</span> value, <span class="hljs-type">JsonGenerator</span> jgen, <span class="hljs-type">SerializerProvider</span> serializers) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;            jgen.writeStartObject();            jgen.writeStringField(<span class="hljs-string">&quot;name&quot;</span>, value.getName());            jgen.writeNumberField(<span class="hljs-string">&quot;age&quot;</span>, value.getAge());            jgen.writeEndObject();        &#125;<br>    &#125;<br>    public static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonDeserializer&lt;MyObject&gt;</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span>        public <span class="hljs-type">MyObject</span> deserialize(<span class="hljs-type">JsonParser</span> jsonParser, <span class="hljs-type">DeserializationContext</span> ctxt) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;            <span class="hljs-type">ObjectCodec</span> codec = jsonParser.getCodec();            <span class="hljs-type">JsonNode</span> tree = codec.readTree(jsonParser);            <span class="hljs-type">String</span> name = tree.get(<span class="hljs-string">&quot;name&quot;</span>).textValue();            int age = tree.get(<span class="hljs-string">&quot;age&quot;</span>).intValue();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyObject</span>(name, age);        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> bean 都会自动向 Jackson 注册。 由于 <code>@JsonComponent</code> 是用 <code>@Component</code> 进行元注解的，因此通常的组件扫描规则适用。</p><p>Spring Boot 还提供了 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a> 和 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a> 基类， 它们在序列化对象时提供了标准 Jackson 版本的有用替代方案。 有关详细信息，请参阅 Javadoc 中的 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/jackson/JsonObjectSerializer.html/[%60JsonObjectSerializer%60/]">https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/jackson/JsonObjectSerializer.html\[`JsonObjectSerializer`\]</a> 和 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/jackson/JsonObjectDeserializer.html"><code>JsonObjectDeserializer</code></a>。</p><p>上面的示例可以重写为使用 <code>JsonObjectSerializer</code>&#x2F;<code>JsonObjectDeserializer</code> ，如下所示：</p><p>Java</p><p>Kotlin</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@JsonComponentpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJsonComponent</span> </span>&#123;<br>    public static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectSerializer&lt;MyObject&gt;</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">protected</span> void serializeObject(<span class="hljs-type">MyObject</span> value, <span class="hljs-type">JsonGenerator</span> jgen, <span class="hljs-type">SerializerProvider</span> provider)                <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;            jgen.writeStringField(<span class="hljs-string">&quot;name&quot;</span>, value.getName());            jgen.writeNumberField(<span class="hljs-string">&quot;age&quot;</span>, value.getAge());        &#125;<br>    &#125;<br>    public static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectDeserializer&lt;MyObject&gt;</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">protected</span> <span class="hljs-type">MyObject</span> deserializeObject(<span class="hljs-type">JsonParser</span> jsonParser, <span class="hljs-type">DeserializationContext</span> context, <span class="hljs-type">ObjectCodec</span> codec,                <span class="hljs-type">JsonNode</span> tree) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;            <span class="hljs-type">String</span> name = nullSafeValue(tree.get(<span class="hljs-string">&quot;name&quot;</span>), <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);            int age = nullSafeValue(tree.get(<span class="hljs-string">&quot;age&quot;</span>), <span class="hljs-type">Integer</span>.<span class="hljs-keyword">class</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyObject</span>(name, age);        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-Mixins"><a href="#6-1-2-Mixins" class="headerlink" title="6.1.2. Mixins"></a>6.1.2. Mixins</h4><p>Jackson 支持混合，可用于将其他注解混合到已在目标类上声明的注解中。 Spring Boot 的 Jackson 自动配置将扫描应用程序的包以查找带有 <code>@JsonMixin</code> 注解的类，并将它们注册到自动配置的 <code>ObjectMapper</code>。 注册由 Spring Boot 的 <code>JsonMixinModule</code> 执行。</p><h3 id="6-2-Gson"><a href="#6-2-Gson" class="headerlink" title="6.2. Gson"></a>6.2. Gson</h3><p>Spring Boot 提供 Gson 的自动配置. 当 <code>Gson</code> 在 classpath 上时, 会自动配置 Gson bean. Spring Boot 提供了几个 <code>spring.gson.*</code> 配置属性来自定义配置. 为了获得更多控制, 可以使用一个或多个 <code>GsonBuilderCustomizer</code> bean.</p><h3 id="6-3-JSON-B"><a href="#6-3-JSON-B" class="headerlink" title="6.3. JSON-B"></a>6.3. JSON-B</h3><p>Spring Boot 提供了 JSON-B 的自动配置. 当 JSON-B API 和实现在 classpath 上时, 将自动配置 <code>Jsonb</code> bean. 首选的 JSON-B 实现是 Apache Johnzon, 它提供了依赖管理.</p><h2 id="7-任务执行与调度"><a href="#7-任务执行与调度" class="headerlink" title="7. 任务执行与调度"></a>7. 任务执行与调度</h2><p>在上下文中没有 <code>Executor</code> bean 的情况下, Spring Boot 会自动配置一个有合理默认值的 <code>ThreadPoolTaskExecutor</code>, 它可以自动与异步任务执行 (<code>@EnableAsync</code>) 和 Spring MVC 异步请求处理相关联.</p><p>如果您在上下文中定义了自定义 <code>Executor</code>, 则常规任务执行 (即 <code>@EnableAsync</code>) 将透明地使用它, 但不会配置 Spring MVC 支持, 因为它需要 <code>AsyncTaskExecutor</code> 实现 (名为 <code>applicationTaskExecutor</code>) . 根据您的目标安排, 您可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code>, 或者定义 <code>Executor</code> 的 <code>ThreadPoolTaskExecutor</code> 和 <code>AsyncConfigurer</code> 来包装自定义的 <code>Executor</code>.</p><p>您可以使用自动配置的 <code>TaskExecutorBuilder</code> 来轻松创建实例, 以复制默认的自动配置.</p><p>线程池使用 8 个核心线程, 可根据负载情况增加和减少. 可以使用 <code>spring.task.execution</code> 命名空间对这些默认设置进行微调, 如下所示:</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>  <span class="hljs-attribute">task</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>    <span class="hljs-attribute">execution</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>      <span class="hljs-attribute">pool</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>        <span class="hljs-attribute">max-size</span><span class="hljs-punctuation">:</span> <span class="hljs-string">16</span><br><br>        <span class="hljs-attribute">queue-capacity</span><span class="hljs-punctuation">:</span> <span class="hljs-string">100</span><br><br>        <span class="hljs-attribute">keep-alive</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10s&quot;</span><br></code></pre></td></tr></table></figure><p>这会将线程池更改为使用有界队列, 在队列满 (100 个任务) 时, 线程池将增加到最多 16 个线程. 当线程在闲置 10 秒 (而不是默认的 60 秒) 时回收线程, 池的收缩更为明显.</p><p>如果需要与调度任务执行 (<code>@EnableScheduling</code>) 相关联, 可以自动配置一个 <code>ThreadPoolTaskScheduler</code>. 默认情况下, 线程池使用一个线程, 可以使用 <code>spring.task.scheduling</code> 命名空间对这些设置进行微调.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  task:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    scheduling:</span><br><br>      thread-name-prefix: <span class="hljs-string">&quot;scheduling-&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      pool:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">        size:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果需要创建自定义 executor 或 scheduler , 则在上下文中可以使用 <code>TaskExecutorBuilder</code> bean 和 <code>TaskSchedulerBuilder</code> bean.</p><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8. 测试"></a>8. 测试</h2><p>Spring Boot 提供了许多工具类和注解, 可以在测试应用程序时提供帮助. 主要由两个模块提供: <code>spring-boot-test</code> 包含核心项, <code>spring-boot-test-autoconfigure</code> 支持测试的自动配置.</p><p>大多数开发人员都使用 <code>spring-boot-starter-test</code> “Starter”, 它会导入 Spring Boot 测试模块以及 JUnit Jupiter, AssertJ, Hamcrest 和许多其他有用的库.</p><p>如果您有使用 JUnit 4 的测试，可以使用 JUnit 5 的 vintage engine 来运行它们。要使用 vintage engine，添加一个依赖 <code>junit-vintage-engine</code>，如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>hamcrest-core</code> 被排除在外，因为 <code>spring-boot-starter-test</code> 默认支持 <code>org.hamcrest:hamcrest</code> 。</p><h3 id="8-1-测试依赖"><a href="#8-1-测试依赖" class="headerlink" title="8.1. 测试依赖"></a>8.1. 测试依赖</h3><p><code>spring-boot-starter-test</code> “Starter” (在 <code>test</code> <code>scope</code>) 包含以下的库:</p><ul><li><a href="https://junit.org/junit5/">JUnit 5</a>: Java 应用程序单元测试的标准。</li><li><a href="https://sca.aliyun.com/blog/learning/spring/core/testing#integration-testing">Spring 测试</a> &amp; Spring Boot 测试: 对 Spring Boot 应用程序的实用程序和集成测试支持.</li><li><a href="https://assertj.github.io/doc/">AssertJ</a>: 流式的断言库.</li><li><a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a>: 匹配对象库 (也称为约束或断言) .</li><li><a href="https://site.mockito.org/">Mockito</a>: 一个 Java 模拟框架.</li><li><a href="https://github.com/skyscreamer/JSONassert">JSONassert</a>: JSON 的断言库.</li><li><a href="https://github.com/jayway/JsonPath">JsonPath</a>: JSON 的 XPath.</li></ul><p>通常, 我们发现这些通用库在编写测试时很有用. 如果这些库不满足您的需求, 则可以添加自己的其他测试依赖.</p><h3 id="8-2-测试-Spring-应用程序"><a href="#8-2-测试-Spring-应用程序" class="headerlink" title="8.2. 测试 Spring 应用程序"></a>8.2. 测试 Spring 应用程序</h3><p>依赖注入的主要优点之一是, 它应该使您的代码更易于进行单元测试. 您可以不使用 Spring， 使用 <code>new</code> 运算符实例化对象. 您还可以使用 <em>mock objects</em> 而不是实际的依赖.</p><p>通常, 您可能不仅仅需要单元测试，也需要集成测试 (使用 Spring <code>ApplicationContext</code>) . 能够进行集成测试而无需部署应用程序或连接到其他基础结构是很有用的.</p><p>Spring 框架包括用于此类集成测试的专用测试模块. 您可以直接声明 <code>org.springframework:spring-test</code> 依赖, 也可以使用 <code>spring-boot-starter-test</code> “Starter” 将其传递.</p><p>如果您以前没有使用过 <code>spring-test</code> 模块, 则应先阅读 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#testing">Spring Framework 参考文档的相关部分</a> .</p><h3 id="8-3-测试-Spring-Boot-应用程序"><a href="#8-3-测试-Spring-Boot-应用程序" class="headerlink" title="8.3. 测试 Spring Boot 应用程序"></a>8.3. 测试 Spring Boot 应用程序</h3><p>Spring Boot 应用程序是 Spring <code>ApplicationContext</code>, 因此除了对普通 Spring 上下文进行常规测试以外, 无需执行任何其他特殊操作即可对其进行测试.</p><p>默认情况下, 仅当您使用 <code>SpringApplication</code> 创建 Spring Boot 的外部属性, 日志记录和其他功能时, 才将它们安装在上下文中.</p><p>Spring Boot 提供了 <code>@SpringBootTest</code> 注解, 当您需要 Spring Boot 功能时, 可以将其用作标准 <code>spring-test</code> <code>@ContextConfiguration</code> 注解的替代方法. <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.detecting-configuration">注解通过 <code>SpringApplication</code> 在测试中创建 <code>ApplicationContext</code> 来使用</a>. 除了 <code>@SpringBootTest</code> 之外, 还提供了许多其他注解来测试应用程序的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-tests">特定的部分</a>.</p><p>如果您使用的是 JUnit 4, 请不要忘记也将 <code>@RunWith(SpringRunner.class)</code> 添加到测试中, 否则注解将被忽略. 如果您使用的是 JUnit 5, 则无需将等效的 <code>@ExtendWith(SpringExtension.class)</code> 添加为 <code>@SpringBootTest</code>, 而其他 <code>@…Test</code> 注解已经在其中进行了注解.</p><p>默认情况下, <code>@SpringBootTest</code> 将不会启动服务器. 您可以使用 <code>@SpringBootTest</code> 的 <code>webEnvironment</code> 属性来进一步完善测试的运行方式:</p><ul><li><code>MOCK</code>(默认) : 加载 Web ApplicationContext 并提供模拟 Web 环境. 使用此注解时, 不会启动嵌入式服务器. 如果您的类路径上没有 Web 环境, 则此模式将透明地退回到创建常规的非 Web <code>ApplicationContext</code>. 它可以与 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.with-mock-environment"><code>@AutoConfigureMockMvc</code> 或 <code>@AutoConfigureWebTestClient</code></a> 结合使用, 以对 Web 应用程序进行基于 Mock 的测试.</li><li><code>RANDOM_PORT</code>: 加载 <code>WebServerApplicationContext</code> 并提供真实的 Web 环境. 在随机的端口启动并监听嵌入式服务器.</li><li><code>DEFINED_PORT</code>: 加载 <code>WebServerApplicationContext</code> 并提供真实的 Web 环境. 在定义的端口(来自 <code>application.properties</code>) 或 <code>8080</code> 端口启动并监听嵌入式服务器</li><li><code>NONE</code>: 使用 <code>SpringApplication</code> 加载 <code>ApplicationContext</code>, 但不提供任何 Web 环境 (模拟或其他方式) .</li></ul><p>如果您测试的是 <code>@Transactional</code>, 则默认情况下它将在每个测试方法的末尾回滚事务. 但是, 由于将这种安排与 <code>RANDOM_PORT</code> 或 <code>DEFINED_PORT</code> 一起使用隐式提供了一个真实的 Servlet 环境, 因此 HTTP 客户端和服务器在单独的线程中运行, 因此在单独的事务中运行. 在这种情况下, 服务器上启动的任何事务都不会回滚.</p><p>如果您的应用程序将不同的端口用于管理服务器, 则 <code>@SpringBootTest</code> 的 <code>webEnvironment=WebEnvironment.RANDOM_PORT</code> 也将在单独的随机端口上启动管理服务器.</p><h4 id="8-3-1-检测-Web-应用程序类型"><a href="#8-3-1-检测-Web-应用程序类型" class="headerlink" title="8.3.1. 检测 Web 应用程序类型"></a>8.3.1. 检测 Web 应用程序类型</h4><p>如果 Spring MVC 可用, 则配置基于常规 MVC 的应用程序上下文. 如果您只有 Spring WebFlux, 我们将检测到该情况并配置基于 WebFlux 的应用程序上下文.</p><p>如果两者都存在, 则 Spring MVC 优先. 如果要在这种情况下测试响应式 Web 应用程序, 则必须设置 <code>spring.main.web-application-type</code> 属性:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SpringBootTest(properties = <span class="hljs-string">&quot;spring.main.web-application-type=reactive&quot;</span>)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebFluxTests</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-2-检测测试配置"><a href="#8-3-2-检测测试配置" class="headerlink" title="8.3.2. 检测测试配置"></a>8.3.2. 检测测试配置</h4><p>如果您熟悉 Spring Test Framework, 则可能习惯于使用 <code>@ContextConfiguration(classes=…)</code> 以指定要加载哪个 Spring <code>@Configuration</code>. 另外, 您可能经常在测试中使用嵌套的 <code>@Configuration</code> 类.</p><p>在测试 Spring Boot 应用程序时, 通常不需要这样做. 只要您没有明确定义, Spring Boot 的 <code>@*Test</code> 注解就会自动搜索您的主要配置.</p><p>搜索算法从包含测试的程序包开始工作, 直到找到带有 <code>@SpringBootApplication</code> 或 <code>@SpringBootConfiguration</code> 注解的类. 只要您以合理的方式对 <a href="https://sca.aliyun.com/learn/spring-boot/core/using.html#using.structuring-your-code">代码进行结构化</a>, 通常就可以找到您的主要配置.</p><p>如果您使用 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-tests">测试注解来测试应用程序的特定部分</a> , 则应避免在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.user-configuration-and-slicing">应用程序的 main 方法</a> 中添加特定于特定区域的配置设置.</p><p><code>@SpringBootApplication</code> 的基础组件扫描配置定义了排除过滤器, 这些过滤器用于确保切片按预期工作. 如果在 <code>@SpringBootApplication</code> 注解的类上使用显式的 <code>@ComponentScan</code> 指令, 请注意这些过滤器将被禁用. 如果使用切片, 则应再次定义它们.</p><p>如果要自定义主要配置类, 则可以使用嵌套的 <code>@TestConfiguration</code> 类. 与嵌套的 <code>@Configuration</code> 类不同，它将用于代替应用程序的主要配置 , 嵌套的 <code>@TestConfiguration</code> 类用于应用程序的主要配置之外。</p><p>Spring 的测试框架在测试之间缓存应用程序上下文. 因此, 只要您的测试共享相同的配置 (无论如何发现) , 加载上下文的潜在耗时过程就只会发生一次.</p><h4 id="8-3-3-使用测试配置主方法"><a href="#8-3-3-使用测试配置主方法" class="headerlink" title="8.3.3. 使用测试配置主方法"></a>8.3.3. 使用测试配置主方法</h4><p>通常， <code>@SpringBootTest</code> 发现的测试配置将是您的主要 <code>@SpringBootApplication</code>。 在大多数的应用程序中，此配置类还将包括用于启动应用程序的 <code>main</code> 方法。</p><p>例如，以下是一个典型的 Spring Boot 应用程序非常常见的代码模式：</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplicationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">MyApplication</span>.<span class="hljs-property">class</span>, args);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>main</code> 方法除了委托给 <code>SpringApplication.run</code> 之外没有做任何事情。 但是，可以有一个更复杂的 <code>main</code> 方法，在调用 <code>SpringApplication.run</code> 之前应用定制。</p><p>例如，这是一个更改 banner 模式并设置其他配置文件的应用程序：</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplicationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;        <span class="hljs-title class_">SpringApplication</span> application = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(<span class="hljs-title class_">MyApplication</span>.<span class="hljs-property">class</span>);        application.<span class="hljs-title function_">setBannerMode</span>(<span class="hljs-title class_">Banner</span>.<span class="hljs-property">Mode</span>.<span class="hljs-property">OFF</span>);        application.<span class="hljs-title function_">setAdditionalProfiles</span>(<span class="hljs-string">&quot;myprofile&quot;</span>);        application.<span class="hljs-title function_">run</span>(args);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>main</code> 方法中的自定义会影响生成的 <code>ApplicationContext</code>，因此您可能还想使用 <code>main</code> 方法来创建用于测试的 <code>ApplicationContext</code>。 默认情况下， <code>@SpringBootTest</code> 不会调用您的 <code>main</code> 方法，而是直接使用类本身来创建 <code>ApplicationContext</code></p><p>如果要更改此行为，可以将 <code>@SpringBootTest</code> 的 <code>useMainMethod</code> 属性更改为 <code>UseMainMethod.ALWAYS</code> 或 <code>UseMainMethod.WHEN_AVAILABLE</code>。 当设置为 <code>ALWAYS</code> 时，如果找不到 <code>main</code> 方法，测试将失败。 当设置为 <code>WHEN_AVAILABLE</code> 时，如果可用，将使用 <code>main</code> 方法，否则将使用标准加载机制。</p><p>例如，以下测试将调用 <code>MyApplication</code> 的 <code>main</code> 方法来创建 <code>ApplicationContext</code>。 如果 main 方法设置了额外的配置文件，那么这些配置文件将在 <code>ApplicationContext</code> 启动时处于活动状态。</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(useMainMethod = UseMainMethod.ALWAYS)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">exampleTest</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-4-排除测试配置"><a href="#8-3-4-排除测试配置" class="headerlink" title="8.3.4. 排除测试配置"></a>8.3.4. 排除测试配置</h4><p>如果您的应用程序使用了组件扫描 (例如, 如果使用 <code>@SpringBootApplication</code> 或 <code>@ComponentScan</code> ) , 则可能会发现偶然为各地创建的仅为特定测试创建的顶级配置类.</p><p><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.detecting-configuration">如前所述</a>, <code>@TestConfiguration</code> 可以用于测试的内部类以自定义主要配置. 当放置在顶级类上时, <code>@TestConfiguration</code> 指示不应通过扫描选择 <code>src/test/java</code> 中的类. 然后, 可以在需要的位置显式导入该类, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span><span class="hljs-variable">@Import</span>(MyTestsConfiguration.class)class MyTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">exampleTest</span>() &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接使用 <code>@ComponentScan</code> (即不是通过 <code>@SpringBootApplication</code>) , 则需要向其中注册 <code>TypeExcludeFilter</code>. 有关详细信息, 请参见 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/context/TypeExcludeFilter.html">Javadoc</a>.</p><h4 id="8-3-5-使用应用程序参数"><a href="#8-3-5-使用应用程序参数" class="headerlink" title="8.3.5. 使用应用程序参数"></a>8.3.5. 使用应用程序参数</h4><p>如果您的应用程序需要 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.spring-application.application-arguments">参数</a>, 则可以使用 <code>args</code> 属性让 <code>@SpringBootTest</code> 注入参数.</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span>(args = <span class="hljs-string">&quot;--app.test=one&quot;</span>)class MyApplicationArgumentTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">applicationArgumentsPopulated</span>(<span class="hljs-variable">@Autowired</span> ApplicationArguments args) &#123;        <span class="hljs-selector-tag">assertThat</span>(args.<span class="hljs-built_in">getOptionNames</span>())<span class="hljs-selector-class">.containsOnly</span>(<span class="hljs-string">&quot;app.test&quot;</span>);        <span class="hljs-selector-tag">assertThat</span>(args.<span class="hljs-built_in">getOptionValues</span>(<span class="hljs-string">&quot;app.test&quot;</span>))<span class="hljs-selector-class">.containsOnly</span>(<span class="hljs-string">&quot;one&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-6-在模拟环境中进行测试"><a href="#8-3-6-在模拟环境中进行测试" class="headerlink" title="8.3.6. 在模拟环境中进行测试"></a>8.3.6. 在模拟环境中进行测试</h4><p>默认情况下, <code>@SpringBootTest</code> 不会启动服务器. 而是设置一个模拟环境来测试 Web 端点.</p><p>使用 Spring MVC，我们可以使用 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#spring-mvc-test-framework"><code>MockMvc</code></a> 或 <code>WebTestClient</code> 查询我们的 Web 端点，如下例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span><span class="hljs-variable">@AutoConfigureMockMvcclass</span> MyMockMvcTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">testWithMockMvc</span>(<span class="hljs-variable">@Autowired</span> MockMvc mvc) throws Exception &#123;        <span class="hljs-selector-tag">mvc</span><span class="hljs-selector-class">.perform</span>(<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/&quot;</span>))<span class="hljs-selector-class">.andExpect</span>(<span class="hljs-built_in">status</span>().<span class="hljs-built_in">isOk</span>())<span class="hljs-selector-class">.andExpect</span>(<span class="hljs-built_in">content</span>().<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello World&quot;</span>));    &#125;<br>    <span class="hljs-comment">// If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient    @Test    void testWithWebTestClient(@Autowired WebTestClient webClient) &#123;        webClient                .get().uri(&quot;/&quot;)                .exchange()                .expectStatus().isOk()                .expectBody(String.class).isEqualTo(&quot;Hello World&quot;);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想关注 Web 层而不希望启动完整的 <code>ApplicationContext</code>, 请考虑使用 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.spring-mvc-tests"><code>@WebMvcTest</code></a>.</p><p>使用 Spring WebFlux 端点, 您可以配置 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#webtestclient-tests"><code>WebTestClient</code></a> , 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span><span class="hljs-variable">@AutoConfigureWebTestClientclass</span> MyMockWebTestClientTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">exampleTest</span>(<span class="hljs-variable">@Autowired</span> WebTestClient webClient) &#123;        <span class="hljs-selector-tag">webClient</span>            <span class="hljs-selector-class">.get</span>()<span class="hljs-selector-class">.uri</span>(<span class="hljs-string">&quot;/&quot;</span>)            <span class="hljs-selector-class">.exchange</span>()            <span class="hljs-selector-class">.expectStatus</span>()<span class="hljs-selector-class">.isOk</span>()            <span class="hljs-selector-class">.expectBody</span>(String.class)<span class="hljs-selector-class">.isEqualTo</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在模拟环境中进行测试通常比在完整的 Servlet 容器中运行更快.但是, 由于模拟发生在 Spring MVC 层, 因此无法使用 MockMvc 直接测试依赖于较低级别 Servlet 容器行为的代码.</p><p>例如, Spring Boot 的错误处理基于 Servlet 容器提供的 “error page” 支持. 这意味着, 尽管您可以按预期测试 MVC 层引发并处理异常, 但是您无法直接测试是否呈现了特定的 <a href="https://sca.aliyun.com/learn/spring-boot/core/web.html#web.servlet.spring-mvc.error-handling.error-pages">自定义错误页面</a>. 如果需要测试这些较低级别的问题, 则可以按照下一节中的描述启动一个完全运行的服务器.</p><h4 id="8-3-7-使用正在运行的服务器进行测试"><a href="#8-3-7-使用正在运行的服务器进行测试" class="headerlink" title="8.3.7. 使用正在运行的服务器进行测试"></a>8.3.7. 使用正在运行的服务器进行测试</h4><p>如果需要启动完全运行的服务器, 建议您使用随机端口. 如果使用 <code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>, 则每次运行测试时都会随机选择一个可用端口.</p><p><code>@LocalServerPort</code> 注解可用于将 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.webserver.discover-port">将实际使用的端口注入</a> 测试中. 为了方便起见, 需要对已启动的服务器进行 REST 调用的测试可以 <code>@Autowire</code> 附加地使用 <code>WebTestClient</code>, 该 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#webtestclient-tests"><code>WebTestClient</code></a> 解析到正在运行的服务器的相对链接, 并带有用于验证响应的专用 API, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)class MyRandomPortWebTestClientTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">exampleTest</span>(<span class="hljs-variable">@Autowired</span> WebTestClient webClient) &#123;        <span class="hljs-selector-tag">webClient</span>            <span class="hljs-selector-class">.get</span>()<span class="hljs-selector-class">.uri</span>(<span class="hljs-string">&quot;/&quot;</span>)            <span class="hljs-selector-class">.exchange</span>()            <span class="hljs-selector-class">.expectStatus</span>()<span class="hljs-selector-class">.isOk</span>()            <span class="hljs-selector-class">.expectBody</span>(String.class)<span class="hljs-selector-class">.isEqualTo</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>WebTestClient</code> 可用于实时服务器和 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.with-mock-environment">mock 环境</a>.</p><p>这种设置需要在类路径上使用 <code>spring-webflux</code>. 如果您不能 webflux, 则 Spring Boot 还提供了 <code>TestRestTemplate</code> 工具:</p><p>Java</p><p>Kotlin</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRandomPortTestRestTemplateTests</span> &#123;<br>    @Test    <span class="hljs-keyword">void</span> exampleTest(@Autowired TestRestTemplate restTemplate) &#123;        <span class="hljs-built_in">String</span> body = restTemplate.getForObject(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>);        assertThat(body).isEqualTo(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-8-自定义-WebTestClient"><a href="#8-3-8-自定义-WebTestClient" class="headerlink" title="8.3.8. 自定义 WebTestClient"></a>8.3.8. 自定义 WebTestClient</h4><p>要定制 <code>WebTestClient</code> bean, 请配置 <code>WebTestClientBuilderCustomizer</code> bean. 将使用用于创建 <code>WebTestClient</code> 的 <code>WebTestClient.Builder</code> 调用任何此类 bean.</p><h4 id="8-3-9-使用-JMX"><a href="#8-3-9-使用-JMX" class="headerlink" title="8.3.9. 使用 JMX"></a>8.3.9. 使用 JMX</h4><p>由于测试上下文框架缓存上下文, 因此默认情况下禁用 JMX 以防止相同组件在同一 domain 上注册. 如果此类测试需要访问 <code>MBeanServer</code>, 请考虑将其标记为 dirty:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span>(properties = <span class="hljs-string">&quot;spring.jmx.enabled=true&quot;</span>)<span class="hljs-variable">@DirtiesContextclass</span> MyJmxTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private MBeanServer mBeanServer;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">exampleTest</span>() &#123;        <span class="hljs-selector-tag">assertThat</span>(this.mBeanServer.<span class="hljs-built_in">getDomains</span>())<span class="hljs-selector-class">.contains</span>(<span class="hljs-string">&quot;java.lang&quot;</span>);        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-10-使用-Metrics"><a href="#8-3-10-使用-Metrics" class="headerlink" title="8.3.10. 使用 Metrics"></a>8.3.10. 使用 Metrics</h4><p>无论您的类路径是什么，在使用 <code>@SpringBootTest</code> 时，meter 注册表(内存中支持的除外)都不会自动配置。</p><p>如果您需要将指标作为集成测试的一部分导出到不同的后端，请使用 <code>@AutoConfigureMetrics</code> 注解它。</p><h4 id="8-3-11-Using-Tracing"><a href="#8-3-11-Using-Tracing" class="headerlink" title="8.3.11. Using Tracing"></a>8.3.11. Using Tracing</h4><p>无论您的类路径如何，使用 <code>@SpringBootTest</code> 时都不会自动配置追踪。</p><p>如果您需要将跟踪作为集成测试的一部分，请使用 <code>@AutoConfigureObservability</code> 对其进行注解。</p><h4 id="8-3-12-Mocking（模拟）-和-Spying（检测）-Beans"><a href="#8-3-12-Mocking（模拟）-和-Spying（检测）-Beans" class="headerlink" title="8.3.12. Mocking（模拟） 和 Spying（检测） Beans"></a>8.3.12. Mocking（模拟） 和 Spying（检测） Beans</h4><p>运行测试时, 有时有必要在应用程序上下文中模拟某些组件. 例如, 您可能在开发过程中无法使用某些远程服务的 facade. 当您要模拟在实际环境中可能难以触发的故障时, 模拟也很有用.</p><p>Spring Boot 包含一个 <code>@MockBean</code> 注解, 可用于为 <code>ApplicationContext</code> 中的 bean 定义 <code>Mockito</code> 模拟. 您可以使用注解添加新 bean 或替换单个现有 bean 定义. 注解可以直接用于测试类, 测试中的字段或 <code>@Configuration</code> 类和字段. 在字段上使用时, 还将注入创建的模拟的实例. 每种测试方法后, 模拟 Bean 都会自动重置.</p><p>如果您的测试使用 Spring Boot 的测试注解之一 (例如 <code>@SpringBootTest</code>) , 则会自动启用此功能. 要以其他方式使用此功能, 必须显式添加监听器, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ContextConfiguration</span>(classes = MyConfig.class)<span class="hljs-variable">@TestExecutionListeners</span>(&#123; MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class &#125;)class MyTests &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面的示例用模拟实现替换现有的 <code>RemoteService</code> bean:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootTestclass</span> <span class="hljs-title class_">MyTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Reverser</span> reverser;<br>    <span class="hljs-meta">@MockBean</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RemoteService</span> remoteService;<br>    <span class="hljs-meta">@Test</span>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">exampleTest</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">given</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteService</span>.<span class="hljs-title function_">getValue</span>()).<span class="hljs-title function_">willReturn</span>(<span class="hljs-string">&quot;spring&quot;</span>);        <span class="hljs-title class_">String</span> reverse = <span class="hljs-variable language_">this</span>.<span class="hljs-property">reverser</span>.<span class="hljs-title function_">getReverseValue</span>(); <span class="hljs-comment">// Calls injected RemoteService        assertThat(reverse).isEqualTo(&quot;gnirps&quot;);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@MockBean</code> 不能用于模拟应用程序上下文刷新期间执行的 bean 的行为. 到执行测试时, 应用程序上下文刷新已完成, 并且配置模拟行为为时已晚. 我们建议在这种情况下使用 <code>@Bean</code> 方法创建和配置模拟.</p><p>此外, 您可以使用 <code>@SpyBean</code> 用 Mockito <code>spy</code> 包装任何现有的 bean. 有关完整的详细信息, 请参见 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a>.</p><p>CGLib 代理 (例如为作用域内的 Bean 创建的代理) 将代理方法声明为 <code>final</code>. 这将阻止 Mockito 正常运行, 因为它无法在其默认配置中模拟或监视最终方法. 如果要模拟或监视这样的 bean, 请通过将 <code>org.mockito:mockito-inline</code> 添加到应用程序的测试依赖中, 将 Mockito 配置为使用其嵌入式模拟生成器. 这允许 Mockito 模拟和监视 <code>final</code> 方法.</p><p>Spring 的测试框架在测试之间缓存应用程序上下文, 并为共享相同配置的测试重用上下文, 而 <code>@MockBean</code> 或 <code>@SpyBean</code> 的使用会影响缓存键, 这很可能会增加上下文数量.</p><p>如果您使用 <code>@SpyBean</code> 通过 <code>@Cacheable</code> 方法监视通过名称引用参数的 bean, 则必须使用 <code>-parameters</code> 编译应用程序. 这样可以确保一旦侦察到 bean, 参数名称就可用于缓存基础结构.</p><p>当您使用 <code>@SpyBean</code> 监视由 Spring 代理的 bean 时, 在某些情况下, 例如使用 <code>given</code> 或 <code>when</code> 设置期望值时, 您可能需要删除 Spring 的代理. 使用 <code>AopTestUtils.getTargetObject(yourProxiedSpy)</code></p><h4 id="8-3-13-自动配置测试"><a href="#8-3-13-自动配置测试" class="headerlink" title="8.3.13. 自动配置测试"></a>8.3.13. 自动配置测试</h4><p>Spring Boot 的自动配置适用于应用程序, 但有时对测试来说可能有点过多. 它通常仅有助于加载测试应用程序 “切片” 所需的配置部分. 例如, 您可能想要在测试运行时测试 Spring MVC 控制器是否正确映射了 URL, 并且您不想在这些测试中涉及数据库调用, 或者您想要测试 JPA 实体.</p><p><code>spring-boot-test-autoconfigure</code> 模块包括许多注解, 可用于自动配置此类 “切片”. 它们中的每一个都以相似的方式工作, 提供了一个 <code>@…Test</code> 注解 (该注解加载了 <code>ApplicationContext</code>) 以及一个或多个 <code>@AutoConfigure…</code> (可用于自定义自动配置设置的注解) .</p><p>每个 “slicing” 将组件扫描限制为适当的组件, 并加载一组非常受限制的自动配置类. 如果您需要排除其中之一, 大多数 <code>@…Test</code> 注解提供了 <code>excludeAutoConfiguration</code> 属性. 或者, 您可以使用 <code>@ImportAutoConfiguration#exclude</code>.</p><p>不支持在一个测试中使用多个 <code>@…Test</code> 注解来包含多个 “片段”. 如果您需要多个 “slices”, 请选择 <code>@…Test</code> 注解之一, 并手动添加其他 “slices” 的 <code>@AutoConfigure…</code> 注解.</p><p>也可以将 <code>@AutoConfigure…</code> 注解与标准的 <code>@SpringBootTest</code> 注解一起使用. 如果您对 “slicing” 应用程序不感兴趣, 但需要一些自动配置的测试 bean, 则可以使用此组合.</p><h4 id="8-3-14-自动配置的-JSON-测试"><a href="#8-3-14-自动配置的-JSON-测试" class="headerlink" title="8.3.14. 自动配置的 JSON 测试"></a>8.3.14. 自动配置的 JSON 测试</h4><p>要测试对象 JSON 序列化和反序列化是否按预期工作, 可以使用 <code>@JsonTest</code> 注解. <code>@JsonTest</code> 自动配置可用的受支持的 JSON 映射器, 该映射器可以是以下库之一:</p><ul><li>Jackson <code>ObjectMapper</code>, 任何使用 <code>@JsonComponent</code> 的 beans 和 任何 Jackson <code>Module</code></li><li><code>Gson</code></li><li><code>Jsonb</code></li></ul><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录</a> 中找到由 <code>@JsonTest</code> 启用的自动配置列表.</p><p>如果需要配置自动配置的元素, 则可以使用 <code>@AutoConfigureJsonTesters</code> 注解.</p><p>Spring Boot 包含基于 AssertJ 的帮助程序, 这些帮助程序可与 JSONAssert 和 JsonPath 库一起使用, 以检查 JSON 是否按预期方式显示. <code>JacksonTester</code>, <code>GsonTester</code>, <code>JsonbTester</code> 和 <code>BasicJsonTester</code> 类可以分别用于 Jackson, Gson, Jsonb 和 Strings. 使用 <code>@JsonTest</code> 时, 可以使用 <code>@Autowired</code> 测试类上的任何帮助程序字段. 以下示例显示了 Jackson 的测试类:</p><p>Java</p><p>Kotlin</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@JsonTestclass MyJsonTests &#123;<br>    @Autowired    private JacksonTester&lt;VehicleDetails&gt; <span class="hljs-type">json</span>;<br>    @Test    <span class="hljs-type">void</span> serialize() throws <span class="hljs-keyword">Exception</span> &#123;        VehicleDetails details = <span class="hljs-built_in">new</span> VehicleDetails(&quot;Honda&quot;, &quot;Civic&quot;);        // <span class="hljs-keyword">Assert</span> against a `.json` file <span class="hljs-keyword">in</span> the same package <span class="hljs-keyword">as</span> the test        assertThat(this.json.<span class="hljs-keyword">write</span>(details)).isEqualToJson(&quot;expected.json&quot;);        // <span class="hljs-keyword">Or</span> use <span class="hljs-type">JSON</span> <span class="hljs-keyword">path</span> based assertions        assertThat(this.json.<span class="hljs-keyword">write</span>(details)).hasJsonPathStringValue(&quot;@.make&quot;);        assertThat(this.json.<span class="hljs-keyword">write</span>(details)).extractingJsonPathStringValue(&quot;@.make&quot;).isEqualTo(&quot;Honda&quot;);    &#125;<br>    @Test    <span class="hljs-type">void</span> deserialize() throws <span class="hljs-keyword">Exception</span> &#123;        String content = &quot;&#123;\&quot;make\&quot;:\&quot;Ford\&quot;,\&quot;model\&quot;:\&quot;Focus\&quot;&#125;&quot;;        assertThat(this.json.parse(content)).isEqualTo(<span class="hljs-built_in">new</span> VehicleDetails(&quot;Ford&quot;, &quot;Focus&quot;));        assertThat(this.json.parseObject(content).getMake()).isEqualTo(&quot;Ford&quot;);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON 帮助程序类也可以直接在标准单元测试中使用. 为此, 如果不使用 <code>@JsonTest</code>, 请在 <code>@Before</code> 方法中调用帮助程序的 <code>initFields</code> 方法.</p><p>如果您使用的是 Spring Boot 基于 AssertJ 的帮助器, 以给定的 JSON 路径对数字值进行断言, 则取决于类型, 您可能无法使用 <code>isEqualTo</code>. 相反, 您可以使用 AssertJ 的满足条件来断言该值符合给定条件. 例如, 以下示例断言实际数是一个偏移量为 <code>0.01</code> 且接近 <code>0.15</code> 的浮点值.</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Test<br><br><span class="hljs-literal">void</span> someTest() throws Exception &#123;<br><br>    SomeObject value = <span class="hljs-keyword">new</span> SomeObject(<span class="hljs-number">0.152f</span>);<br><br>    assertThat(this.json.write(value)).extractingJsonPathNumberValue(<span class="hljs-string">&quot;@.test.numberValue&quot;</span>)<br><br>            .satisfies<span class="hljs-function"><span class="hljs-params">((number) -&gt; assertThat(number.floatValue()).isCloseTo(<span class="hljs-number">0.15f</span>, within(<span class="hljs-number">0.01f</span>)))</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="8-3-15-自动配置的-Spring-MVC-测试"><a href="#8-3-15-自动配置的-Spring-MVC-测试" class="headerlink" title="8.3.15. 自动配置的 Spring MVC 测试"></a>8.3.15. 自动配置的 Spring MVC 测试</h4><p>要测试 Spring MVC 控制器是否按预期工作, 请使用 <code>@WebMvcTest</code> 注解. <code>@WebMvcTest</code> 自动配置 Spring MVC 基础结构, 并将扫描的 bean 限制为 <code>@Controller</code>, <code>@ControllerAdvice</code>, <code>@JsonComponent</code>, <code>Converter</code>, <code>GenericConverter</code>, <code>Filter</code>, <code>HandlerInterceptor</code>, <code>WebMvcConfigurer</code>, <code>WebMvcRegistrations</code> 和 <code>HandlerMethodArgumentResolver</code>. 使用此注解时, 不扫描常规 <code>@Component</code> , <code>@ConfigurationProperties</code> bean. <code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到 <code>@WebMvcTest</code> 启用的自动配置设置的列表.</p><p>如果需要注册其他组件, 例如 Jackson <code>Module</code>, 则可以在测试中使用 <code>@Import</code> 导入其他配置类.</p><p><code>@WebMvcTest</code> 通常仅限于单个控制器, 并与 <code>@MockBean</code> 结合使用, 以为所需的协作者提供模拟实现.</p><p><code>@WebMvcTest</code> 还可以自动配置 <code>MockMvc</code>. Mock MVC 提供了一种强大的方法来快速测试 MVC 控制器, 而无需启动完整的 HTTP 服务器.</p><p>您还可以通过在非 <code>@WebMvcTest</code> (例如 <code>@SpringBootTest</code>) 中使用 <code>@AutoConfigureMockMvc</code> 对其进行注解来自动配置 <code>MockMvc</code>. 以下示例使用 <code>MockMvc</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@WebMvcTest(<span class="hljs-params">UserVehicleController.<span class="hljs-keyword">class</span></span>)class MyControllerTests &#123;</span><br><span class="hljs-meta">    @Autowired    private MockMvc mvc;</span><br><span class="hljs-meta">    @MockBean    private UserVehicleService userVehicleService;</span><br><span class="hljs-meta">    @Test    void testExample() throws Exception &#123;        given(<span class="hljs-params">this.userVehicleService.getVehicleDetails(<span class="hljs-params"><span class="hljs-string">&quot;sboot&quot;</span></span>)</span>)            .willReturn(<span class="hljs-params">new VehicleDetails(<span class="hljs-params"><span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-string">&quot;Civic&quot;</span></span>)</span>);        this.mvc.perform(<span class="hljs-params">get(<span class="hljs-params"><span class="hljs-string">&quot;/sboot/vehicle&quot;</span></span>).accept(<span class="hljs-params">MediaType.TEXT_PLAIN</span>)</span>)            .andExpect(<span class="hljs-params">status(<span class="hljs-params"></span>).isOk(<span class="hljs-params"></span>)</span>)            .andExpect(<span class="hljs-params">content(<span class="hljs-params"></span>).string(<span class="hljs-params"><span class="hljs-string">&quot;Honda Civic&quot;</span></span>)</span>);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果您需要配置自动配置的元素 (例如, 当应该应用 servlet 过滤器时) , 则可以使用 <code>@AutoConfigureMockMvc</code> 注解中的属性.</p><p>如果使用 HtmlUnit 或 Selenium, 则自动配置还会提供 HtmlUnit <code>WebClient</code> bean 和&#x2F;或 Selenium <code>WebDriver</code> bean. 以下示例使用 HtmlUnit:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebMvcTest(UserVehicleController.class)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHtmlUnitTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> WebClient webClient;<br>    <span class="hljs-meta">@MockBean</span>    <span class="hljs-keyword">private</span> UserVehicleService userVehicleService;<br>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        given(<span class="hljs-built_in">this</span>.userVehicleService.getVehicleDetails(<span class="hljs-string">&quot;sboot&quot;</span>)).willReturn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VehicleDetails</span>(<span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-string">&quot;Civic&quot;</span>));        <span class="hljs-type">HtmlPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.webClient.getPage(<span class="hljs-string">&quot;/sboot/vehicle.html&quot;</span>);        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="hljs-string">&quot;Honda Civic&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下, Spring Boot 将 <code>WebDriver</code> bean 放在特殊的 “scope” 中, 以确保驱动程序在每次测试后退出并注入新实例. 如果您不希望出现这种情况, 则可以将 <code>@Scope(&quot;singleton&quot;)</code> 添加到 <code>WebDriver</code> <code>@Bean</code> 定义中.</p><p>Spring Boot 创建的 <code>webDriver</code> 作用域将替换任何用户定义的同名作用域. 如果定义自己的 <code>webDriver</code> 作用域, 则使用 <code>@WebMvcTest</code> 时可能会发现它停止工作.</p><p>如果您在类路径上具有 Spring Security, 则 <code>@WebMvcTest</code> 还将扫描 <code>WebSecurityConfigurer</code> Bean. 您可以使用 Spring Security 的测试支持来代替完全禁用此类测试的安全性. 有关如何使用 Spring Security 的 <code>MockMvc</code> 支持的更多详细信息, 请参见 <em><a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.testing.with-spring-security">howto.html</a></em> 操作方法部分.</p><p>有时编写 Spring MVC 测试是不够的. Spring Boot 可以帮助您在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.with-running-server">实际服务器上运行完整的端到端测试</a>.</p><h4 id="8-3-16-自动配置的-Spring-WebFlux-测试"><a href="#8-3-16-自动配置的-Spring-WebFlux-测试" class="headerlink" title="8.3.16. 自动配置的 Spring WebFlux 测试"></a>8.3.16. 自动配置的 Spring WebFlux 测试</h4><p>要测试 Spring WebFlux 控制器是否按预期工作, 可以使用 <code>@WebFluxTest</code> 注解. <code>@WebFluxTest</code> 自动配置 Spring WebFlux 基础结构, 并将扫描的 bean 限制为 <code>@Controller</code>, <code>@ControllerAdvice</code>, <code>@JsonComponent</code>, <code>Converter</code>, <code>GenericConverter</code>, <code>WebFilter</code> 和 <code>WebFluxConfigurer</code>. 使用 <code>@WebFluxTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到 <code>@WebFluxTest</code> 启用的自动配置的列表. .</p><p>如果需要注册其他组件, 例如 Jackson <code>Module</code>, 则可以在测试中使用 <code>@Import</code> 导入其他配置类.</p><p>通常, <code>@WebFluxTest</code> 仅限于单个控制器, 并与 <code>@MockBean</code> 注解结合使用, 以为所需的协作者提供模拟实现.</p><p><code>@WebFluxTest</code> 还可以自动配置 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#webtestclient"><code>WebTestClient</code></a>, 它提供了一种强大的方法来快速测试 WebFlux 控制器, 而无需启动完整的 HTTP 服务器.</p><p>您还可以通过在非 <code>@WebFluxTest</code> (例如 <code>@SpringBootTest</code>) 中自动配置 <code>WebTestClient</code>, 方法是使用 <code>@AutoConfigureWebTestClient</code> 对其进行注解. 下面的示例显示一个同时使用 <code>@WebFluxTest</code> 和 <code>WebTestClient</code> 的类:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@WebFluxTest(UserVehicleController.class)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyControllerTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> WebTestClient webClient;<br>    <span class="hljs-meta">@MockBean</span>    <span class="hljs-keyword">private</span> UserVehicleService userVehicleService;<br>    <span class="hljs-meta">@Test</span>    void testExample() &#123;        given(<span class="hljs-keyword">this</span>.userVehicleService.getVehicleDetails(<span class="hljs-string">&quot;sboot&quot;</span>))            .willReturn(new VehicleDetails(<span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-string">&quot;Civic&quot;</span>));        <span class="hljs-keyword">this</span>.webClient.<span class="hljs-keyword">get</span>().uri(<span class="hljs-string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN).exchange()            .expectStatus().isOk()            .expectBody(String.<span class="hljs-keyword">class</span>).isEqualTo(<span class="hljs-string">&quot;Honda Civic&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>WebFlux 应用程序仅支持此设置, 因为在模拟的 Web 应用程序中使用 <code>WebTestClient</code> 目前仅与 WebFlux 一起使用.</p><p><code>@WebFluxTest</code> 无法检测通过功能 Web 框架注册的路由. 为了在上下文中测试 <code>RouterFunction</code> bean, 请考虑自己通过 <code>@Import</code> 或使用 <code>@SpringBootTest</code> 导入 <code>RouterFunction</code>.</p><p><code>@WebFluxTest</code> 无法检测通过 <code>SecurityWebFilterChain</code> 类型的 <code>@Bean</code> 注册的自定义安全配置. 要将其包括在测试中, 您将需要通过 <code>@Import</code> 导入或使用 <code>@SpringBootTest</code> 导入用于注册 bean 的配置.</p><p>有时编写 Spring WebFlux 测试是不够的. Spring Boot 可以帮助您在 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.with-running-server">实际服务器上运行完整的端到端测试</a>.</p><h4 id="8-3-17-Spring-GraphQL-测试自动配置"><a href="#8-3-17-Spring-GraphQL-测试自动配置" class="headerlink" title="8.3.17. Spring GraphQL 测试自动配置"></a>8.3.17. Spring GraphQL 测试自动配置</h4><p>Spring GraphQL 提供了专门的测试支持模块； 你需要将它添加到你的项目中：</p><p>Maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.graphql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-graphql-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- Unless already present in the compile scope --&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Gradle</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">dependencies</span> &#123;<br><br>  <span class="hljs-function"><span class="hljs-title">testImplementation</span>(<span class="hljs-string">&quot;org.springframework.graphql:spring-graphql-test&quot;</span>)</span><br><br>  <span class="hljs-comment">// Unless already present in the implementation configuration</span><br><br>  <span class="hljs-function"><span class="hljs-title">testImplementation</span>(<span class="hljs-string">&quot;org.springframework.boot:spring-boot-starter-webflux&quot;</span>)</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个测试模块附带了 GraphQlTester. spring-boot-project&#x2F;spring-boot-docs&#x2F;src&#x2F;docs&#x2F;asciidoc&#x2F;features&#x2F;testing.adoc</p><h4 id="8-3-18-自动配置-Cassandra-测试"><a href="#8-3-18-自动配置-Cassandra-测试" class="headerlink" title="8.3.18. 自动配置 Cassandra 测试"></a>8.3.18. 自动配置 Cassandra 测试</h4><p>您可以使用 <code>@DataCassandraTest</code> 注解来测试 Cassandra 应用程序. 默认情况下, 它将配置一个 <code>CassandraTemplate</code> 来扫描 <code>@Table</code> 类并配置 Spring Data Cassandra 存储库. 使用 <code>@DataCassandraTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean（有关在 Spring Boot 中使用 Cassandra 的更多信息，请参阅本章前面的 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.cassandra">data.html</a>”）</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataCassandraTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了在 Spring Boot 中使用 Cassandra 测试的典型设置:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataCassandraTestclass</span> MyDataCassandraTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private SomeRepository repository;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-19-自动配置-Data-Couchbase-测试"><a href="#8-3-19-自动配置-Data-Couchbase-测试" class="headerlink" title="8.3.19. 自动配置 Data Couchbase 测试"></a>8.3.19. 自动配置 Data Couchbase 测试</h4><p>您可以使用 <code>@DataCouchbaseTest</code> 注解来测试 Couchbase 应用程序. 默认情况下, 它将配置一个 <code>CouchbaseTemplate</code> 或 <code>ReactiveCouchbaseTemplate</code>, 来扫描 <code>@Document</code> 类并配置 Spring Data Couchbase 存储库. 使用 <code>@DataCouchbaseTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean（有关在 Spring Boot 中使用 Cassandra 的更多信息，请参阅本章前面的 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.couchbase">data.html</a>”）</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataCouchbaseTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了在 Spring Boot 中使用 Couchbase 测试的典型设置:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataCouchbaseTestclass</span> MyDataCouchbaseTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private SomeRepository repository;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-20-自动配置-Data-Elasticsearch-测试"><a href="#8-3-20-自动配置-Data-Elasticsearch-测试" class="headerlink" title="8.3.20. 自动配置 Data Elasticsearch 测试"></a>8.3.20. 自动配置 Data Elasticsearch 测试</h4><p>您可以使用 <code>@DataElasticsearchTest</code> 注解来测试 Elasticsearch 应用程序. 默认情况下, 它将配置一个 <code>ElasticsearchRestTemplate</code>, 来扫描 <code>@Document</code> 类并配置 Spring Data Elasticsearch 存储库. 使用 <code>@DataElasticsearchTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean（有关在 Spring Boot 中使用 Elasticsearch 的更多信息，请参阅本章前面的 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.elasticsearch">data.html</a>”）</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataElasticsearchTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了在 Spring Boot 中使用 Elasticsearch 测试的典型设置:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataElasticsearchTestclass</span> MyDataElasticsearchTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private SomeRepository repository;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-21-自动配置的-Data-JPA-测试"><a href="#8-3-21-自动配置的-Data-JPA-测试" class="headerlink" title="8.3.21. 自动配置的 Data JPA 测试"></a>8.3.21. 自动配置的 Data JPA 测试</h4><p>您可以使用 <code>@DataJpaTest</code> 注解来测试 JPA 应用程序. 默认情况下, 它将扫描 <code>@Entity</code> 类并配置 Spring Data JPA 存储库. 如果在类路径上有嵌入式数据库, 也会配置. 默认情况下， 通过将 <code>spring.jpa.show-sql</code> 属性设置为 <code>true</code> 来记录 SQL 查询. 可以使用注解的 <code>showSql()</code> 属性禁用此功能.</p><p>使用 <code>@DataJpaTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataJpaTest</code> 启用的自动配置设置的列表.</p><p>默认情况下, 数据 JPA 测试是事务性的, 并在每次测试结束时回滚. 有关更多详细信息, 请参见《Spring Framework 参考文档》中的 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#testcontext-tx-enabling-transactions">相关部分</a> . 如果这不是您想要的, 则可以按以下方式禁用测试或整个类的事务管理:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataJpaTest</span><span class="hljs-variable">@Transactional</span>(propagation = Propagation.<span class="hljs-keyword">NOT</span>_SUPPORTED)class MyNonTransactionalTests &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JPA 测试也可以注入 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java"><code>TestEntityManager</code></a> bean, 它为专门为测试设计的标准 JPA <code>EntityManager</code> 提供了替代方法.</p><p><code>TestEntityManager</code> 也可以通过添加 <code>@AutoConfigureTestEntityManager</code> 自动配置到任何基于 Spring 的测试类。 这样做时，请确保您的测试在事务中运行，例如通过在测试类或方法上添加 <code>@Transactional</code>。</p><p>如果需要, 还可以使用 <code>JdbcTemplate</code>. 以下示例显示了正在使用的 <code>@DataJpaTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@DataJpaTestclass MyRepositoryTests &#123;</span><br><span class="hljs-meta">    @Autowired    private TestEntityManager entityManager;</span><br><span class="hljs-meta">    @Autowired    private UserRepository repository;</span><br><span class="hljs-meta">    @Test    void testExample() &#123;        this.entityManager.persist(<span class="hljs-params">new User(<span class="hljs-params"><span class="hljs-string">&quot;sboot&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span></span>)</span>);        User user = this.repository.findByUsername(<span class="hljs-params"><span class="hljs-string">&quot;sboot&quot;</span></span>);        assertThat(<span class="hljs-params">user.getUsername(<span class="hljs-params"></span>)</span>).isEqualTo(<span class="hljs-params"><span class="hljs-string">&quot;sboot&quot;</span></span>);        assertThat(<span class="hljs-params">user.getEmployeeNumber(<span class="hljs-params"></span>)</span>).isEqualTo(<span class="hljs-params"><span class="hljs-string">&quot;1234&quot;</span></span>);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内存嵌入式数据库通常运行良好, 不需要任何安装, 因此通常可以很好地进行测试. 但是, 如果您希望对真实数据库运行测试, 则可以使用 <code>@AutoConfigureTestDatabase</code> 注解, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataJpaTest</span><span class="hljs-variable">@AutoConfigureTestDatabase</span>(replace = Replace.NONE)class MyRepositoryTests &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-22-自动配置的-JDBC-测试"><a href="#8-3-22-自动配置的-JDBC-测试" class="headerlink" title="8.3.22. 自动配置的 JDBC 测试"></a>8.3.22. 自动配置的 JDBC 测试</h4><p><code>@JdbcTest</code> 与 <code>@DataJpaTest</code> 相似, 但适用于仅需要 <code>DataSource</code> 并且不使用 Spring Data JDBC 的测试. 默认情况下, 它配置一个内存嵌入式数据库和一个 <code>JdbcTemplate</code>. 使用 <code>@JdbcTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到 <code>@JdbcTest</code> 启用的自动配置的列表.</p><p>默认情况下, JDBC 测试是事务性的, 并在每个测试结束时回滚. 有关更多详细信息, 请参见《 Spring Framework 参考文档》中的 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#testcontext-tx-enabling-transactions">相关部分</a>. 如果这不是您想要的, 则可以为测试或整个类禁用事务管理, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@JdbcTest</span><span class="hljs-variable">@Transactional</span>(propagation = Propagation.<span class="hljs-keyword">NOT</span>_SUPPORTED)class MyTransactionalTests &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您希望测试针对真实数据库运行, 则可以使用 <code>@AutoConfigureTestDatabase</code> 注解, 其方式与 <code>DataJpaTest</code> 相同. (请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-spring-data-jpa">自动配置的 Data JPA 测试</a>”. )。</p><h4 id="8-3-23-自动配置的-Data-JDBC-测试"><a href="#8-3-23-自动配置的-Data-JDBC-测试" class="headerlink" title="8.3.23. 自动配置的 Data JDBC 测试"></a>8.3.23. 自动配置的 Data JDBC 测试</h4><p><code>@DataJdbcTest</code> 与 <code>@JdbcTest</code> 相似, 但适用于使用 Spring Data JDBC 存储库的测试. 默认情况下, 它配置一个内存嵌入式数据库, 一个 <code>JdbcTemplate</code> 和 Spring Data JDBC 存储库. 使用 <code>@DataJdbcTest</code> 注释时仅扫描 <code>AbstractJdbcConfiguration</code> 子类，不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean。 <code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataJdbcTest</code> 启用的自动配置的列表.</p><p>默认情况下, Data JDBC 测试是事务性的, 并在每个测试结束时回滚. 有关更多详细信息, 请参见《Spring Framework 参考文档》中的 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#testcontext-tx-enabling-transactions">相关部分</a>. 如果这不是您想要的, 则可以禁用测试或整个测试类的事务管理, <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-jdbc">如 JDBC 示例所示</a>.</p><p>如果您希望测试针对真实数据库运行, 则可以使用 <code>@AutoConfigureTestDatabase</code> 注解, 其方式与 <code>DataJpaTest</code> 相同. (请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-spring-data-jpa">自动配置的 Data JPA 测试</a>”. )。</p><h4 id="8-3-24-自动配置的-jOOQ-Tests"><a href="#8-3-24-自动配置的-jOOQ-Tests" class="headerlink" title="8.3.24. 自动配置的 jOOQ Tests"></a>8.3.24. 自动配置的 jOOQ Tests</h4><p>您可以以与 <code>@JdbcTest</code> 类似的方式使用 <code>@JooqTest</code>, 但可以用于与 jOOQ 相关的测试. 由于 jOOQ 严重依赖与数据库模式相对应的基于 Java 的模式, 因此将使用现有的 <code>DataSource</code>. 如果要将其替换为内存数据库, 则可以使用 <code>@AutoConfigureTestDatabase</code> 覆盖这些设置. (有关在 Spring Boot 中使用 jOOQ 的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.sql.jooq">data.html</a>”. ) 使用 <code>@JooqTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到 <code>@JooqTest</code> 启用的自动配置的列表.</p><p><code>@JooqTest</code> 配置 <code>DSLContext</code>. . 以下示例显示了正在使用的 <code>@JooqTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@JooqTestclass</span> MyJooqTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private DSLContext dslContext;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JOOQ 测试是事务性的, 默认情况下会在每个测试结束时回滚. 如果这不是您想要的, 则可以禁用测试或整个测试类的事务管理, <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.autoconfigured-jdbc">如 JDBC 示例所示</a>.</p><h4 id="8-3-25-自动配置的-Data-MongoDB-测试"><a href="#8-3-25-自动配置的-Data-MongoDB-测试" class="headerlink" title="8.3.25. 自动配置的 Data MongoDB 测试"></a>8.3.25. 自动配置的 Data MongoDB 测试</h4><p>您可以使用 <code>@DataMongoTest</code> 测试 MongoDB 应用程序. 默认情况下, 它配置内存嵌入式 MongoDB (如果可用) , 配置 <code>MongoTemplate</code>, 扫描 <code>@Document</code> 类, 并配置 Spring Data MongoDB 存储库. 使用 <code>@DataMongoTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean (有关将 MongoDB 与 Spring Boot 结合使用的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.mongodb">data.html</a>”)</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataMongoTest</code> 启用的自动配置设置的列表.</p><p>此类显示正在使用的 <code>@DataMongoTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataMongoTestclass</span> MyDataMongoDbTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private MongoTemplate mongoTemplate;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-26-Auto-configured-Data-Neo4j-Tests"><a href="#8-3-26-Auto-configured-Data-Neo4j-Tests" class="headerlink" title="8.3.26. Auto-configured Data Neo4j Tests"></a>8.3.26. Auto-configured Data Neo4j Tests</h4><p>您可以使用 <code>@DataNeo4jTest</code> 来测试 Neo4j 应用程序. 默认情况下, 他会扫描 <code>@Node</code> 类, 并配置 Spring Data Neo4j 存储库. 使用 <code>@DataNeo4jTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean. (有关将 Neo4J 与 Spring Boot 结合使用的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.neo4j">data.html</a>”. )</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataNeo4jTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataNeo4jTestclass</span> MyDataNeo4jTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private SomeRepository repository;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下, Data Neo4j 测试是事务性的, 并在每次测试结束时回滚. 有关更多详细信息, 请参见《Spring Framework 参考文档》中的 <a href="https://sca.aliyun.com/blog/learning/spring/core/testing#testcontext-tx-enabling-transactions">相关部分</a> . 如果这不是您想要的, 则可以为测试或整个类禁用事务管理, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataNeo4jTest</span><span class="hljs-variable">@Transactional</span>(propagation = Propagation.<span class="hljs-keyword">NOT</span>_SUPPORTED)class MyDataNeo4jTests &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应式访问不支持事务性测试。如果您正在使用这种样式，您必须如上所述配置 <code>@DataNeo4jTest</code> 测试.</p><h4 id="8-3-27-自动配置的-Data-Redis-测试"><a href="#8-3-27-自动配置的-Data-Redis-测试" class="headerlink" title="8.3.27. 自动配置的 Data Redis 测试"></a>8.3.27. 自动配置的 Data Redis 测试</h4><p>您可以使用 <code>@DataRedisTest</code> 测试 Redis 应用程序. 默认情况下, 它会扫描 <code>@RedisHash</code> 类并配置 Spring Data Redis 存储库. 使用 <code>@DataRedisTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean. (有关将 Redis 与 Spring Boot 结合使用的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.redis">data.html</a>”. )</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataRedisTest</code> 启用的自动配置设置的列表.</p><p>下面的例子展示了使用中的 <code>@DataRedisTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataRedisTestclass</span> MyDataRedisTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private SomeRepository repository;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-28-自动配置的-Data-LDAP-测试"><a href="#8-3-28-自动配置的-Data-LDAP-测试" class="headerlink" title="8.3.28. 自动配置的 Data LDAP 测试"></a>8.3.28. 自动配置的 Data LDAP 测试</h4><p>您可以使用 <code>@DataLdapTest</code> 来测试 LDAP 应用程序. 默认情况下, 它配置内存嵌入式 LDAP (如果可用) , 配置 <code>LdapTemplate</code>, 扫描 <code>@Entry</code> 类, 并配置 Spring Data LDAP 存储库. 使用 <code>@DataLdapTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean. (有关将 LDAP 与 Spring Boot 结合使用的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/data.html#data.nosql.ldap">data.html</a>”. )</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@DataLdapTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了正在使用的 <code>@DataLdapTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@DataLdapTestclass</span> MyDataLdapTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private LdapTemplate ldapTemplate;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内存嵌入式 LDAP 通常非常适合测试, 因为它速度快并且不需要安装任何开发人员. 但是, 如果您希望针对真实的 LDAP 服务器运行测试, 则应排除嵌入式 LDAP 自动配置, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@DataLdapTest</span>(excludeAutoConfiguration = <span class="hljs-title class_">EmbeddedLdapAutoConfiguration</span>.<span class="hljs-keyword">class</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataLdapTests</span> &#123;<br>    <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-29-自动配置-REST-Clients"><a href="#8-3-29-自动配置-REST-Clients" class="headerlink" title="8.3.29. 自动配置 REST Clients"></a>8.3.29. 自动配置 REST Clients</h4><p>您可以使用 <code>@RestClientTest</code> 注解来测试 REST 客户端. 默认情况下, 它会自动配置 Jackson, GSON 和 Jsonb 支持, 配置 <code>RestTemplateBuilder</code>, 并添加对 <code>MockRestServiceServer</code> 的支持. 使用 <code>@RestClientTest</code> 注解时, 不扫描常规 <code>@Component</code> 和 <code>@ConfigurationProperties</code> bean.<code>@EnableConfigurationProperties</code> 可用于包含 <code>@ConfigurationProperties</code> 的 bean.</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@RestClientTest</code> 启用的自动配置设置的列表.</p><p>应该使用 <code>@RestClientTest</code> 的 <code>value</code> 或 <code>components</code> 属性来指定要测试的特定 bean, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestClientTest(RemoteVehicleDetailsService.class)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRestClientTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RemoteVehicleDetailsService service;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MockRestServiceServer server;<br>    <span class="hljs-meta">@Test</span>    void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() &#123;        <span class="hljs-keyword">this</span>.server.<span class="hljs-keyword">expect</span>(requestTo(<span class="hljs-string">&quot;/greet/details&quot;</span>)).andRespond(withSuccess(<span class="hljs-string">&quot;hello&quot;</span>, MediaType.TEXT_PLAIN));        String greeting = <span class="hljs-keyword">this</span>.service.callRestService();        assertThat(greeting).isEqualTo(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-30-自动配置的-Spring-REST-Docs-测试"><a href="#8-3-30-自动配置的-Spring-REST-Docs-测试" class="headerlink" title="8.3.30. 自动配置的 Spring REST Docs 测试"></a>8.3.30. 自动配置的 Spring REST Docs 测试</h4><p>您可以使用 <code>@AutoConfigureRestDocs</code> 注解在 Mock MVC, REST Assured 或 <code>WebTestClient</code> 的测试中使用 <a href="https://spring.io/projects/spring-restdocs">Spring REST Docs</a>. 它消除了 Spring REST Docs 中对 JUnit 扩展的需求.</p><p><code>@AutoConfigureRestDocs</code> 可用于覆盖默认输出目录 (如果使用 Maven, 则为 <code>target/generated-snippets</code> 如果使用 Gradle, 则为 <code>build/generated-snippets</code> ) . 它也可以用于配置出现在任何记录的 URI 中的 host, scheme, 和 port.</p><h5 id="使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试"><a href="#使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试" class="headerlink" title="使用 Mock MVC 自动配置的 Spring REST Docs 测试"></a>使用 Mock MVC 自动配置的 Spring REST Docs 测试</h5><p><code>@AutoConfigureRestDocs</code> 自定义 <code>MockMvc</code> bean 以使用 Spring REST Docs. 您可以使用 <code>@Autowired</code> 注入它, 并像通常使用 Mock MVC 和 Spring REST Docs 一样, 在测试中使用它, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@WebMvcTest</span>(UserController.class)<span class="hljs-variable">@AutoConfigureRestDocsclass</span> MyUserDocumentationTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private MockMvc mvc;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">listUsers</span>() throws Exception &#123;        <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.perform</span>(<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;/users&quot;</span>).<span class="hljs-built_in">accept</span>(MediaType.TEXT_PLAIN))            <span class="hljs-selector-class">.andExpect</span>(<span class="hljs-built_in">status</span>().<span class="hljs-built_in">isOk</span>())            <span class="hljs-selector-class">.andDo</span>(<span class="hljs-built_in">document</span>(<span class="hljs-string">&quot;list-users&quot;</span>));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要对 Spring REST Docs 配置进行更多控制, 而不是 <code>@AutoConfigureRestDocs</code> 属性提供的控制, 则可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code> bean, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@TestConfiguration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRestDocsConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RestDocsMockMvcConfigurationCustomizer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">customize</span>(<span class="hljs-params">MockMvcRestDocumentationConfigurer configurer</span>) &#123;        configurer.<span class="hljs-title function_">snippets</span>().<span class="hljs-title function_">withTemplateFormat</span>(<span class="hljs-title class_">TemplateFormats</span>.<span class="hljs-title function_">markdown</span>());    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要使用 Spring REST Docs 对参数化输出目录的支持, 可以创建 <code>RestDocumentationResultHandler</code> bean. 自动配置使用此结果处理程序调用 <code>alwaysDo</code>, 从而使每个 <code>MockMvc</code> 调用自动生成默认片段. 以下示例显示了定义的 <code>RestDocumentationResultHandler</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@TestConfiguration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResultHandlerConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">RestDocumentationResultHandler <span class="hljs-title">restDocumentation</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">return</span> MockMvcRestDocumentation.<span class="hljs-title">document</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;method-name&#125;&quot;</span>)</span></span>;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-WebTestClient-自动配置的-Spring-REST-Docs-测试"><a href="#使用-WebTestClient-自动配置的-Spring-REST-Docs-测试" class="headerlink" title="使用 WebTestClient 自动配置的 Spring REST Docs 测试"></a>使用 WebTestClient 自动配置的 Spring REST Docs 测试</h5><p><code>@AutoConfigureRestDocs</code> 也可以与 <code>WebTestClient</code> 一起使用. 您可以使用 <code>@Autowired</code> 注入它, 并像通常使用 <code>@WebFluxTest</code> 和 Spring REST Docs 一样在测试中使用它, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@WebFluxTest</span><span class="hljs-variable">@AutoConfigureRestDocsclass</span> MyUsersDocumentationTests &#123;<br>    <span class="hljs-variable">@Autowired</span>    private WebTestClient webTestClient;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">listUsers</span>() &#123;        <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.webTestClient</span>            <span class="hljs-selector-class">.get</span>()<span class="hljs-selector-class">.uri</span>(<span class="hljs-string">&quot;/&quot;</span>)        <span class="hljs-selector-class">.exchange</span>()        <span class="hljs-selector-class">.expectStatus</span>()            <span class="hljs-selector-class">.isOk</span>()        <span class="hljs-selector-class">.expectBody</span>()            <span class="hljs-selector-class">.consumeWith</span>(<span class="hljs-built_in">document</span>(<span class="hljs-string">&quot;list-users&quot;</span>));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要对 Spring REST Docs 配置进行更多控制, 而不是 <code>@AutoConfigureRestDocs</code> 属性提供的控制, 则可以使用 <code>RestDocsWebTestClientConfigurationCustomizer</code> bean, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@TestConfiguration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRestDocsConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RestDocsWebTestClientConfigurationCustomizer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">customize</span>(<span class="hljs-params">WebTestClientRestDocumentationConfigurer configurer</span>) &#123;        configurer.<span class="hljs-title function_">snippets</span>().<span class="hljs-title function_">withEncoding</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您想利用 Spring REST Docs 对参数化输出目录的支持，您可以使用 <code>WebTestClientBuilderCustomizer</code> 为每个实体 exchange 结果配置消费者。 下面的例子展示了一个被定义的 <code>WebTestClientBuilderCustomizer</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@TestConfiguration(proxyBeanMethods = <span class="hljs-literal">false</span>)public <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebTestClientBuilderCustomizerConfiguration</span> &#123;<br>    @Bean    public WebTestClientBuilderCustomizer restDocumentation<span class="hljs-function"><span class="hljs-params">()</span> &#123;        <span class="hljs-title">return</span> <span class="hljs-params">(builder)</span> -&gt;</span> builder.entityExchangeResultConsumer(document(<span class="hljs-string">&quot;&#123;method-name&#125;&quot;</span>));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-RES-TAssured-自动配置的-Spring-REST-Docs-测试"><a href="#使用-RES-TAssured-自动配置的-Spring-REST-Docs-测试" class="headerlink" title="使用 RES TAssured 自动配置的 Spring REST Docs 测试"></a>使用 RES TAssured 自动配置的 Spring REST Docs 测试</h5><p><code>@AutoConfigureRestDocs</code> 使一个 <code>RequestSpecification</code> Bean (可预配置为使用 Spring REST Docs) 可用于您的测试. 您可以使用 <code>@Autowired</code> 注入它, 并像在使用 REST Assured 和 Spring REST Docs 时一样, 在测试中使用它, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)<span class="hljs-variable">@AutoConfigureRestDocsclass</span> MyUserDocumentationTests &#123;<br>    <span class="hljs-variable">@Test</span>    void <span class="hljs-built_in">listUsers</span>(<span class="hljs-variable">@Autowired</span> RequestSpecification documentationSpec, <span class="hljs-variable">@LocalServerPort</span> int port) &#123;        <span class="hljs-selector-tag">given</span>(documentationSpec)            <span class="hljs-selector-class">.filter</span>(<span class="hljs-built_in">document</span>(<span class="hljs-string">&quot;list-users&quot;</span>))        <span class="hljs-selector-class">.when</span>()            <span class="hljs-selector-class">.port</span>(port)            <span class="hljs-selector-class">.get</span>(<span class="hljs-string">&quot;/&quot;</span>)        <span class="hljs-selector-class">.then</span>()<span class="hljs-selector-class">.assertThat</span>()            <span class="hljs-selector-class">.statusCode</span>(<span class="hljs-built_in">is</span>(<span class="hljs-number">200</span>));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您需要对 Spring REST Docs 配置进行更多控制, 而不是 <code>@AutoConfigureRestDocs</code> 属性所提供的控制, 则可以使用 <code>RestDocsRestAssuredConfigurationCustomizer</code> bean, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@TestConfiguration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRestDocsConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RestDocsRestAssuredConfigurationCustomizer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">customize</span>(<span class="hljs-params">RestAssuredRestDocumentationConfigurer configurer</span>) &#123;        configurer.<span class="hljs-title function_">snippets</span>().<span class="hljs-title function_">withTemplateFormat</span>(<span class="hljs-title class_">TemplateFormats</span>.<span class="hljs-title function_">markdown</span>());    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-31-Auto-configured-Spring-Web-Services-Tests"><a href="#8-3-31-Auto-configured-Spring-Web-Services-Tests" class="headerlink" title="8.3.31. Auto-configured Spring Web Services Tests"></a>8.3.31. Auto-configured Spring Web Services Tests</h4><h5 id="自动配置的-Spring-Web-Services-Client-测试"><a href="#自动配置的-Spring-Web-Services-Client-测试" class="headerlink" title="自动配置的 Spring Web Services Client 测试"></a>自动配置的 Spring Web Services Client 测试</h5><p>您可以使用 <code>@WebServiceClientTest</code> 来通过 Spring Web Services 项目测试使用呼叫 Web 服务的应用程序. 默认情况下, 它配置模拟 <code>WebServiceServer</code> bean 并自动自定义 <code>WebServiceTemplateBuilder</code>. (有关在 Spring Boot 中结合使用 Web 服务的更多信息, 请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/io.html#io.webservices">io.html</a>”.)</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@WebServiceClientTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了正在使用的 <code>@WebServiceClientTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@WebServiceClientTest(<span class="hljs-params">SomeWebService.<span class="hljs-keyword">class</span></span>)class MyWebServiceClientTests &#123;</span><br><span class="hljs-meta">    @Autowired    private MockWebServiceServer server;</span><br><span class="hljs-meta">    @Autowired    private SomeWebService someWebService;</span><br><span class="hljs-meta">    @Test    void mockServerCall() &#123;        this.server            .expect(<span class="hljs-params">payload(<span class="hljs-params">new StringSource(<span class="hljs-params"><span class="hljs-string">&quot;&lt;request/&gt;&quot;</span></span>)</span>)</span>)            .andRespond(<span class="hljs-params">withPayload(<span class="hljs-params">new StringSource(<span class="hljs-params"><span class="hljs-string">&quot;&lt;response&gt;&lt;status&gt;200&lt;/status&gt;&lt;/response&gt;&quot;</span></span>)</span>)</span>);        assertThat(<span class="hljs-params">this.someWebService.test(<span class="hljs-params"></span>)</span>)            .extracting(<span class="hljs-params">Response::getStatus</span>)            .isEqualTo(<span class="hljs-params"><span class="hljs-number">200</span></span>);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自动配置的-Spring-Web-Services-Server-测试"><a href="#自动配置的-Spring-Web-Services-Server-测试" class="headerlink" title="自动配置的 Spring Web Services Server 测试"></a>自动配置的 Spring Web Services Server 测试</h5><p>您可以使用 <code>@WebServiceServerTest</code> 来测试使用 Spring Web Services 项目实现 Web 服务的应用程序。 默认情况下，它配置了一个 <code>MockWebServiceClient</code> bean，可用于调用您的 Web 服务端点。 （有关在 Spring Boot 中使用 Web 服务的更多信息，请参阅 “<a href="https://sca.aliyun.com/learn/spring-boot/core/io.html#io.webservices">io.html</a>”。）</p><p>可以在 <a href="https://sca.aliyun.com/learn/spring-boot/core/test-auto-configuration.html#appendix.test-auto-configuration">附录中</a> 找到由 <code>@WebServiceServerTest</code> 启用的自动配置设置的列表.</p><p>以下示例显示了正在使用的 <code>@WebServiceServerTest</code> 注解:</p><p>Java</p><p>Kotlin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServiceServerTest(ExampleEndpoint.class)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebServiceServerTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MockWebServiceClient client;<br>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">mockServerCall</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.client            .sendRequest(RequestCreators.withPayload(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSource</span>(<span class="hljs-string">&quot;&lt;ExampleRequest/&gt;&quot;</span>)))            .andExpect(ResponseMatchers.payload(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSource</span>(<span class="hljs-string">&quot;&lt;ExampleResponse&gt;42&lt;/ExampleResponse&gt;&quot;</span>)));    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-32-其他的自动配置和切片"><a href="#8-3-32-其他的自动配置和切片" class="headerlink" title="8.3.32. 其他的自动配置和切片"></a>8.3.32. 其他的自动配置和切片</h4><p>每个切片提供一个或多个 <code>@AutoConfigure…</code> 注解, 即定义应包含在切片中的自动配置. 可以通过创建自定义 <code>@AutoConfigure…</code> 注解来添加其他自动配置, 也可以简单地通过将 <code>@ImportAutoConfiguration</code> 添加到测试中来添加其他自动配置, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@JdbcTest</span><span class="hljs-variable">@ImportAutoConfiguration</span>(IntegrationAutoConfiguration.class)class MyJdbcTests &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>确保不要使用常规的 <code>@Import</code> 注解导入自动配置, 因为它们是由 Spring Boot 以特定方式处理的.</p><p>或者, 可以通过在 <code>META-INF/spring.factories</code> 中注册切片注解的任何使用来添加其他自动配置, 如以下示例所示:</p><p>META-INF&#x2F;spring&#x2F;org.springframework.boot.test.autoconfigure.jdbc.JdbcTest.imports</p><p>com.example.IntegrationAutoConfiguration</p><p>在此示例中，在每个用 <code>@JdbcTest</code> 注解的测试上启用了 <code>com.example.IntegrationAutoConfiguration</code>。</p><p>您可以在此文件中通过 <code>#</code> 使用注释。</p><p>切片或 <code>@AutoConfigure…</code> 注解可以通过这种方式自定义, 只要使用 <code>@ImportAutoConfiguration</code> 对其进行元注解即可.</p><h4 id="8-3-33-用户配置和切片"><a href="#8-3-33-用户配置和切片" class="headerlink" title="8.3.33. 用户配置和切片"></a>8.3.33. 用户配置和切片</h4><p>如果您以合理的方式 <a href="https://sca.aliyun.com/learn/spring-boot/core/using.html#using.structuring-your-code">组织代码</a> , 则 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.detecting-configuration">默认情况下</a> 将 <code>@SpringBootApplication</code> 类用作测试的配置.</p><p>因此, 变得重要的是, 不要使用特定于其功能特定区域的配置设置来乱扔应用程序的主类.</p><p>假设您正在使用 Spring Batch, 并且依赖于它的自动配置. 您可以如下定义 <code>@SpringBootApplication</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableBatchProcessingpublic</span> class MyApplication &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为此类是测试的源配置, 所以任何切片测试实际上都尝试启动 Spring Batch, 这绝对不是您想要执行的操作. 建议的方法是将特定于区域的配置移动到与您的应用程序处于同一级别的单独的 <code>@Configuration</code> 类, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)<span class="hljs-variable">@EnableBatchProcessingpublic</span> class MyBatchConfiguration &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据您应用程序的复杂性, 您可以为您的自定义设置一个 <code>@Configuration</code> 类, 或者每个域区域一个类. 后一种方法使您可以在其中一个测试中使用 <code>@Import</code> 注解启用它.请参阅 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto.testing.slice-tests">this how-to section</a> 了解有关何时可能需要为切片测试启用特定 <code>@Configuration</code> 类的更多详细信息。</p><p>测试片将 <code>@Configuration</code> 类从扫描中排除. 例如, 对于 <code>@WebMvcTest</code>, 以下配置将在测试切片加载的应用程序上下文中不包括给定的 <code>WebMvcConfigurer</code> Bean:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWebConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">WebMvcConfigurer</span> <span class="hljs-title function_">testConfigurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebMvcConfigurer</span>() &#123;            <span class="hljs-comment">// ...        &#125;;    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是, 以下配置将导致自定义 <code>WebMvcConfigurer</code> 由测试片加载.</p><p>Java</p><p>Kotlin</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Componentpublic <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyWebMvcConfigurer</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>混乱的另一个来源是类路径扫描. 假定在以合理的方式组织代码的同时, 您需要扫描其他程序包. 您的应用程序可能类似于以下代码:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@ComponentScan</span>(&#123; <span class="hljs-string">&quot;com.example.app&quot;</span>, <span class="hljs-string">&quot;com.example.another&quot;</span> &#125;)public class MyApplication &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样做有效地覆盖了默认的组件扫描指令, 并且具有扫描这两个软件包的副作用, 而与您选择的切片无关. 例如, <code>@DataJpaTest</code> 似乎突然扫描了应用程序的组件和用户配置. 同样, 将自定义指令移至单独的类是解决此问题的好方法.</p><p>如果这不是您的选择, 则可以在测试层次结构中的某个位置创建 <code>@SpringBootConfiguration</code>, 以便代替使用它. 或者, 您可以为测试指定一个源, 从而禁用查找默认源的行为.</p><h4 id="8-3-34-使用-Spock-测试-Spring-Boot-应用程序"><a href="#8-3-34-使用-Spock-测试-Spring-Boot-应用程序" class="headerlink" title="8.3.34. 使用 Spock 测试 Spring Boot 应用程序"></a>8.3.34. 使用 Spock 测试 Spring Boot 应用程序</h4><p>如果您希望使用 Spock 2.x 来测试 Spring Boot 应用程序, 则应在应用程序的构建中添加对 Spock 的 <code>spock-spring</code> 模块的 <code>-groovy-4.0</code> 版本依赖. <code>spock-spring</code> 将 Spring 的测试框架集成到了 Spock 中. 有关更多详细信息, 请参见 <a href="https://spockframework.org/spock/docs/2.2-M1/modules.html#_spring_module">Spock 的 Spring 模块的文档</a>..</p><h3 id="8-4-测试实用工具"><a href="#8-4-测试实用工具" class="headerlink" title="8.4. 测试实用工具"></a>8.4. 测试实用工具</h3><p>一些测试实用工具类通常在测试您的应用程序时有用, 它们被打包为 <code>spring-boot</code> 的一部分.</p><h4 id="8-4-1-ConfigDataApplicationContextInitializer"><a href="#8-4-1-ConfigDataApplicationContextInitializer" class="headerlink" title="8.4.1. ConfigDataApplicationContextInitializer"></a>8.4.1. ConfigDataApplicationContextInitializer</h4><p><code>ConfigFileApplicationContextInitializer</code> 是一个 <code>ApplicationContextInitializer</code>, 您可以将其应用于测试以加载 Spring Boot <code>application.properties</code> 文件. 当不需要 <code>@SpringBootTest</code> 提供的全部功能时, 可以使用它, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@ContextConfiguration</span>(classes = <span class="hljs-title class_">Config</span>.<span class="hljs-keyword">class</span>, initializers = <span class="hljs-title class_">ConfigDataApplicationContextInitializer</span>.<span class="hljs-keyword">class</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfigFileTests</span> &#123;<br>    <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>单独使用 <code>ConfigFileApplicationContextInitializer</code> 不能提供对 <code>@Value(&quot;$&#123;…&#125;&quot;)</code> 注入的支持. 唯一的工作就是确保将 <code>application.properties</code> 文件加载到 Spring 的环境中. 为了获得 <code>@Value</code> 支持, 您需要另外配置 <code>PropertySourcesPlaceholderConfigurer</code> 或使用 <code>@SpringBootTest</code>, 后者会为您自动配置一个.</p><h4 id="8-4-2-TestPropertyValues"><a href="#8-4-2-TestPropertyValues" class="headerlink" title="8.4.2. TestPropertyValues"></a>8.4.2. TestPropertyValues</h4><p>使用 <code>TestPropertyValues</code>, 可以快速将属性添加到 <code>ConfigurableEnvironment</code> 或 <code>ConfigurableApplicationContext</code>. 您可以使用 <code>key=value</code> 字符串来调用它, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEnvironmentTests</span> &#123;<br><span class="hljs-meta">    @Test    void testPropertySources() &#123;        MockEnvironment environment = new MockEnvironment();        TestPropertyValues.of(<span class="hljs-params"><span class="hljs-string">&quot;org=Spring&quot;</span>, <span class="hljs-string">&quot;name=Boot&quot;</span></span>).applyTo(<span class="hljs-params">environment</span>);        assertThat(<span class="hljs-params">environment.getProperty(<span class="hljs-params"><span class="hljs-string">&quot;name&quot;</span></span>)</span>).isEqualTo(<span class="hljs-params"><span class="hljs-string">&quot;Boot&quot;</span></span>);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-4-3-OutputCapture"><a href="#8-4-3-OutputCapture" class="headerlink" title="8.4.3. OutputCapture"></a>8.4.3. OutputCapture</h4><p><code>OutputCapture</code> 是一个 JUnit 扩展, 可用于捕获 <code>System.out</code> 和 <code>System.err</code> 输出. 要使用 add <code>@ExtendWith(OutputCaptureExtension.class)</code> 并将 <code>CapturedOutput</code> 作为参数注入测试类构造函数或测试方法, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ExtendWith(<span class="hljs-params">OutputCaptureExtension.<span class="hljs-keyword">class</span></span>)class MyOutputCaptureTests &#123;</span><br><span class="hljs-meta">    @Test    void testName(<span class="hljs-params">CapturedOutput output</span>) &#123;        System.out.println(<span class="hljs-params"><span class="hljs-string">&quot;Hello World!&quot;</span></span>);        assertThat(<span class="hljs-params">output</span>).contains(<span class="hljs-params"><span class="hljs-string">&quot;World&quot;</span></span>);    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-4-4-TestRestTemplate"><a href="#8-4-4-TestRestTemplate" class="headerlink" title="8.4.4. TestRestTemplate"></a>8.4.4. TestRestTemplate</h4><p><code>TestRestTemplate</code> 是 Spring <code>RestTemplate</code> 的一种便捷替代方案, 在集成测试中非常有用. 您可以使用普通模板或发送基本 HTTP 身份验证 (带有用户名和密码) 的模板. 在任何一种情况下, 模版都具有容错性，这意味着它以一种测试友好的方式运行，不会在 4xx 和 5xx 错误上抛出异常。相反，可以通过返回的 <code>ResponseEntity</code> 及其状态码检测此类错误。</p><p>Spring Framework 5.0 提供了一个新的 <code>WebTestClient</code>, 可用于 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.spring-webflux-tests">WebFlux 集成测试</a> 和 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.with-running-server">WebFlux 和 MVC 端到端测试</a>. 与 <code>TestRestTemplate</code> 不同, 它为声明提供了流式的 API.</p><p>建议 (但不是强制性的) 使用 Apache HTTP Client (版本 4.3.2 或更高版本) . 如果您在类路径中具有该名称, 则 <code>TestRestTemplate</code> 会通过适当配置客户端进行响应. 如果您确实使用 Apache 的 HTTP 客户端, 则会启用一些其他易于测试的功能:</p><ul><li>不支持重定向(因此可以断言响应位置).</li><li>忽略 cookie(因此模板是无状态的).</li></ul><p><code>TestRestTemplate</code> 可以在你的集成测试中直接实例化, 如下面的例子所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTests</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TestRestTemplate <span class="hljs-keyword">template</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TestRestTemplate</span>();<br>    @<span class="hljs-function">Test    <span class="hljs-type">void</span> <span class="hljs-title">testRequest</span><span class="hljs-params">()</span> </span>&#123;        ResponseEntity&lt;<span class="hljs-type">String</span>&gt; headers = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">template</span>.<span class="hljs-built_in">getForEntity</span>(<span class="hljs-string">&quot;https://myhost.example.com/example&quot;</span>, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);        <span class="hljs-built_in">assertThat</span>(headers.<span class="hljs-built_in">getHeaders</span>().<span class="hljs-built_in">getLocation</span>()).<span class="hljs-built_in">hasHost</span>(<span class="hljs-string">&quot;other.example.com&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者, 如果将 <code>@SpringBootTest</code> 注解与 <code>WebEnvironment.RANDOM_PORT</code> 或 <code>WebEnvironment.DEFINED_PORT</code> 一起使用, 则可以注入完全配置的 <code>TestRestTemplate</code> 并开始使用它. 如有必要, 可以通过 <code>RestTemplateBuilder</code> bean 应用其他定制. 未指定主机和端口的所有 URL 都会自动连接到嵌入式服务器, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootTest</span>(webEnvironment = <span class="hljs-title class_">WebEnvironment</span>.<span class="hljs-property">RANDOM_PORT</span>)<span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpringBootTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">TestRestTemplate</span> template;<br>    <span class="hljs-meta">@Test</span>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">testRequest</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">HttpHeaders</span> headers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">template</span>.<span class="hljs-title function_">getForEntity</span>(<span class="hljs-string">&quot;/example&quot;</span>, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>).<span class="hljs-title function_">getHeaders</span>();        <span class="hljs-title function_">assertThat</span>(headers.<span class="hljs-title function_">getLocation</span>()).<span class="hljs-title function_">hasHost</span>(<span class="hljs-string">&quot;other.example.com&quot;</span>);    &#125;<br>    <span class="hljs-meta">@TestConfiguration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestTemplateBuilderConfiguration</span> &#123;<br>        <span class="hljs-meta">@Bean</span>        <span class="hljs-title class_">RestTemplateBuilder</span> <span class="hljs-title function_">restTemplateBuilder</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplateBuilder</span>().<span class="hljs-title function_">setConnectTimeout</span>(<span class="hljs-title class_">Duration</span>.<span class="hljs-title function_">ofSeconds</span>(<span class="hljs-number">1</span>))                    .<span class="hljs-title function_">setReadTimeout</span>(<span class="hljs-title class_">Duration</span>.<span class="hljs-title function_">ofSeconds</span>(<span class="hljs-number">1</span>));        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-创建自己的自动配置"><a href="#9-创建自己的自动配置" class="headerlink" title="9. 创建自己的自动配置"></a>9. 创建自己的自动配置</h2><p>如果您在公司负责开发公共类库, 或者如果您在开发一个开源或商业库, 您可能希望开发自己的自动配置. 自动配置类可以捆绑在外部 jar 中, 他仍然可以被 Spring Boot 获取.</p><p>自动配置可以与提供自动配置代码的 starter 以及您将使用的类库库相关联. 我们首先介绍构建自己的自动配置需要了解的内容, 然后我们将继续介绍创建 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.custom-starter">自定义 starter 所需的步骤</a>.</p><h3 id="9-1-理解自动配置的-Beans"><a href="#9-1-理解自动配置的-Beans" class="headerlink" title="9.1. 理解自动配置的 Beans"></a>9.1. 理解自动配置的 Beans</h3><p>实现自动配置的类用 <code>@AutoConfiguration</code> 注解。 此注解本身使用 <code>@Configuration</code> 进行元注解，使自动配置成为标准的 <code>@Configuration</code> 类。 <code>@Conditional</code> 注解用于约束何时应用自动配置。 通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。 这可确保仅在找到相关类时以及未声明您自己的 <code>@Configuration</code> 时才应用自动配置.</p><p>您可以浏览 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a> 的源代码, 以查看 Spring 提供的 <code>@AutoConfiguration</code> 类 (请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports"><code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></a> 文件).</p><h3 id="9-2-找到候选的自动配置"><a href="#9-2-找到候选的自动配置" class="headerlink" title="9.2. 找到候选的自动配置"></a>9.2. 找到候选的自动配置</h3><p>Spring Boot 会检查已发布 jar 中是否存在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件. 该文件列出您的配置类，每行一个类名，如以下示例所示：, 如下所示:</p><p>com.mycorp.libx.autoconfigure.LibXAutoConfiguration com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</p><p>TIP</p><p>您可以使用 <code>#</code> 号添加注释.</p><p>必须以这种方式加载自动配置. 确保它们在特定的包空间中定义, 并且它们不能是组件扫描的目标. 此外, 自动配置类不应启用组件扫描以查找其他组件. 应该使用特定的 <code>@Imports</code> 来代替.</p><p>如果需要按特定顺序应用配置, 则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfiguration.java"><code>@AutoConfiguration</code></a> 的 <code>before</code>, <code>beforeName</code>, <code>after</code> 和 <code>afterName</code> 属性。 或使用 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a> 或 <a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a> 注解. 例如, 如果您提供特定于 Web 的配置, 则可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用您的类.</p><p>如果您想排序某些不应该彼此直接了解的自动配置, 您也可以使用 <code>@AutoConfigureOrder</code>. 该注解与常规 <code>@Order</code> 注解有相同的语义, 但它为自动配置类提供了专用顺序.</p><p>与标准的 <code>@Configuration</code> 类一样, 自动配置类的应用顺序仅会影响其 bean 的定义顺序.随后创建这些 bean 的顺序不受影响, 并由每个 bean 的依赖关系和任何 <code>@DependsOn</code> 关系确定.</p><h3 id="9-3-条件注解"><a href="#9-3-条件注解" class="headerlink" title="9.3. 条件注解"></a>9.3. 条件注解</h3><p>您几乎总希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解. <code>@ConditionalOnMissingBean</code> 是一个常用的注解, 其允许开发人员在对您的默认值不满意用于覆盖自动配置.</p><p>Spring Boot 包含许多 <code>@Conditional</code> 注解, 您可以通过注解 <code>@Configuration</code> 类或单独的 <code>@Bean</code> 方法在您自己的代码中复用它们. 这些注解包括:</p><ul><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.class-conditions">类条件</a></li><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.bean-conditions">Bean 条件</a></li><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.property-conditions">属性条件</a></li><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.resource-conditions">资源条件</a></li><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.web-application-conditions">Web 应用程序条件</a></li><li><a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.developing-auto-configuration.condition-annotations.spel-conditions">SpEL 表达式条件</a></li></ul><h4 id="9-3-1-类条件"><a href="#9-3-1-类条件" class="headerlink" title="9.3.1. 类条件"></a>9.3.1. 类条件</h4><p><code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解允许根据特定类的是否存在来包含 <code>@Configuration</code> 类. 由于使用 <a href="https://asm.ow2.io/">ASM</a> 解析注解元数据, 您可以使用 <code>value</code> 属性来引用真实类, 即使该类实际上可能不会出现在正在运行的应用程序的 <code>classpath</code> 中. 如果您希望使用 <code>String</code> 值来指定类名, 也可以使用 <code>name</code> 属性.</p><p>此机制不会以相同的方式应用于返回类型是条件的目标的 <code>@Bean</code> 方法: 在方法上的条件应用之前, JVM 将加载类和可能处理的方法引用, 如果找不到类, 将发生失败.</p><p>要处理这种情况, 可以使用单独的 <code>@Configuration</code> 类来隔离条件, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfiguration</span><span class="hljs-comment">// Some conditions ...public class MyAutoConfiguration &#123;</span><br>    <span class="hljs-comment">// Auto-configured beans ...</span><br>    <span class="hljs-variable">@Configuration</span>(proxyBeanMethods = false)    <span class="hljs-variable">@ConditionalOnClass</span>(SomeService.class)    public static class SomeServiceConfiguration &#123;<br>        <span class="hljs-variable">@Bean</span>        <span class="hljs-variable">@ConditionalOnMissingBean</span>        public SomeService <span class="hljs-built_in">someService</span>() &#123;            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">SomeService</span>();        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 作为元注解的一部分来组成自己的组合注解, 则必须使用 <code>name</code> 来引用类, 在这种情况将不作处理.</p><h4 id="9-3-2-Bean-条件"><a href="#9-3-2-Bean-条件" class="headerlink" title="9.3.2. Bean 条件"></a>9.3.2. Bean 条件</h4><p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据特定 bean 是否存在来包含 bean. 您可以使用 <code>value</code> 属性按类型或使用 <code>name</code> 来指定 bean. <code>search</code> 属性允许您限制在搜索 bean 时应考虑的 <code>ApplicationContext</code> 层次结构.</p><p>放置在 <code>@Bean</code> 方法上时, 目标类型默认为方法的返回类型, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfigurationpublic</span> class MyAutoConfiguration &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@ConditionalOnMissingBean</span>    public SomeService <span class="hljs-built_in">someService</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">SomeService</span>();    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中, 如果 <code>ApplicationContext</code> 中不包含 <code>SomeService</code> 类型的 bean, 则将创建 <code>someService</code> bean.</p><p>您需要非常小心地添加 bean 定义的顺序, 因为这些条件是根据到目前为止已处理的内容进行计算的. 因此, 我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解 (因为这些注解保证在添加所有用户定义的 bean 定义后加载) .</p><p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类. 在类级别使用这些条件并使用注解标记每个包含 <code>@Bean</code> 方法的唯一区别是, 如果条件不匹配, 前者会阻止将 <code>@Configuration</code> 类注册为 bean.</p><p>声明 <code>@Bean</code> 方法时, 请在该方法的返回类型中提供尽可能多的类型信息.例如, 如果您的 bean 的具体类实现一个接口, 则 bean 方法的返回类型应该是具体的类而不是接口. 使用 bean 条件时, 在 <code>@Bean</code> 方法中提供尽可能多的类型信息尤为重要, 因为它们的评估只能依靠方法签名中可用的类型信息.</p><h4 id="9-3-3-属性条件"><a href="#9-3-3-属性条件" class="headerlink" title="9.3.3. 属性条件"></a>9.3.3. 属性条件</h4><p><code>@ConditionalOnProperty</code> 注解允许基于 Spring Environment 属性包含配置. 使用 <code>prefix</code> 和 <code>name</code> 属性指定需要检查的属性. 默认情况下, 匹配存在且不等于 <code>false</code> 的所有属性. 您还可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性创建更高级的检查.</p><h4 id="9-3-4-资源条件"><a href="#9-3-4-资源条件" class="headerlink" title="9.3.4. 资源条件"></a>9.3.4. 资源条件</h4><p><code>@ConditionalOnResource</code> 注解仅允许在存在特定资源时包含配置. 可以使用常用的 Spring 约定来指定资源, 如下所示: <code>file:/home/user/test.dat</code>.</p><h4 id="9-3-5-Web-应用程序条件"><a href="#9-3-5-Web-应用程序条件" class="headerlink" title="9.3.5. Web 应用程序条件"></a>9.3.5. Web 应用程序条件</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ConditionalOnWebApplication</span><span class="hljs-built_in">` 和 `</span><span class="hljs-variable">@ConditionalOnNotWebApplication</span><span class="hljs-built_in">` 注解在应用程序为 Web 应用程序的情况下是否包含配置. 基于 servlet 的 Web 应用程序是使用 Spring `</span>WebApplicationContext<span class="hljs-built_in">` 定义 `</span>session<span class="hljs-built_in">` 作用域或具有 `</span>ConfigurableWebEnvironment<span class="hljs-built_in">` 的任何应用程序。 响应式 Web 应用程序是使用 `</span>ReactiveWebApplicationContext<span class="hljs-built_in">` 或具有 `</span>ConfigurableReactiveWebEnvironment<br></code></pre></td></tr></table></figure><p>通过 <code>@ConditionalOnWarDeployment</code> 注解, 可以根据应用程序是否是已部署到容器的传统 WAR 应用程序进行配置.对于嵌入式服务器运行的应用程序, 此条件将不匹配.</p><h4 id="9-3-6-SpEL-表达式条件"><a href="#9-3-6-SpEL-表达式条件" class="headerlink" title="9.3.6. SpEL 表达式条件"></a>9.3.6. SpEL 表达式条件</h4><p><code>@ConditionalOnExpression</code> 注解允许根据 <a href="https://sca.aliyun.com/blog/learning/spring/core/ioc#expressions">SpEL 表达式</a> 的结果包含配置.</p><p>在表达式中引用 bean 将导致该 bean 在上下文刷新处理中很早就被初始化。 这样做的结果是，bean 将不适合进行后处理（例如配置属性绑定），并且其状态可能不完整。</p><h3 id="9-4-测试自动配置"><a href="#9-4-测试自动配置" class="headerlink" title="9.4. 测试自动配置"></a>9.4. 测试自动配置</h3><p>自动配置可能受许多因素的影响: 用户配置 (<code>@Bean</code> 定义和 <code>Environment</code> 自定义) 、条件评估 (存在特定的类库) 等. 具体而言, 每个测试都应该创建一个定义良好的 <code>ApplicationContext</code>, 它表示这些自定义的组合. <code>ApplicationContextRunner</code> 提供了一个好的实现方法.</p><p><code>ApplicationContextRunner</code> 通常被定义为测试类的一个字段, 用于收集基本的通用配置. 以下示例确保始终调用 <code>MyServiceAutoConfiguration</code>:</p><p>Java</p><p>Kotlin</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationContextRunner contextRunner = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ApplicationContextRunner</span>()<br><br>        .<span class="hljs-built_in">withConfiguration</span>(AutoConfigurations.<span class="hljs-built_in">of</span>(MyServiceAutoConfiguration.<span class="hljs-keyword">class</span>));<br></code></pre></td></tr></table></figure><p>如果必须定义多个自动配置, 则无需按照与运行应用程序时完全相同的顺序调用它们的声明.</p><p>每个测试都可以使用 runner 来表示特定的用例. 例如, 下面的示例调用用户配置 (<code>UserConfiguration</code>) 并检查自动配置是否正确退回. 调用 <code>run</code> 提供了一个可以与 <code>AssertJ</code> 一起使用的回调上下文.</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Testvoid defaultServiceBacksOff<span class="hljs-function"><span class="hljs-params">()</span> &#123;    <span class="hljs-title">this</span>.<span class="hljs-title">contextRunner</span>.<span class="hljs-title">withUserConfiguration</span><span class="hljs-params">(UserConfiguration.<span class="hljs-keyword">class</span>)</span>.<span class="hljs-title">run</span><span class="hljs-params">((context) -&gt; &#123;        assertThat(context).hasSingleBean(MyService.<span class="hljs-keyword">class</span>);        assertThat(context).getBean(<span class="hljs-string">&quot;myCustomService&quot;</span>).isSameAs(context.getBean(MyService.<span class="hljs-keyword">class</span>));    &#125;)</span>;&#125;</span><br><span class="hljs-function">@<span class="hljs-title">Configuration</span><span class="hljs-params">(proxyBeanMethods = <span class="hljs-literal">false</span>)</span><span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">UserConfiguration</span> &#123;</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span>    <span class="hljs-title">MyService</span> <span class="hljs-title">myCustomService</span><span class="hljs-params">()</span> &#123;        <span class="hljs-title">return</span> <span class="hljs-title">new</span> <span class="hljs-title">MyService</span><span class="hljs-params">(<span class="hljs-string">&quot;mine&quot;</span>)</span>;    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>也可以轻松自定义 <code>Environment</code>, 如下所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Test<br><br><span class="hljs-literal">void</span> serviceNameCanBeConfigured() &#123;<br><br>    this.contextRunner.withPropertyValues<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&quot;user.name=test123&quot;</span>)</span>.<span class="hljs-title">run</span><span class="hljs-params">((context) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        assertThat(context).hasSingleBean(MyService.<span class="hljs-keyword">class</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">        assertThat(context.getBean(MyService.<span class="hljs-keyword">class</span>).getName()).isEqualTo(<span class="hljs-string">&quot;test123&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>runner 还可用于展示 <code>ConditionEvaluationReport</code>. 报告可以在 <code>INFO</code> 或 <code>DEBUG</code> 级别下打印. 以下示例展示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报表.</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConditionEvaluationReportingTests</span> &#123;<br>    @Test    <span class="hljs-literal">void</span> autoConfigTest<span class="hljs-function"><span class="hljs-params">()</span> &#123;        <span class="hljs-title">new</span> <span class="hljs-title">ApplicationContextRunner</span><span class="hljs-params">()</span>            .<span class="hljs-title">withInitializer</span><span class="hljs-params">(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO))</span>            .<span class="hljs-title">run</span><span class="hljs-params">((context) -&gt; &#123;                    <span class="hljs-regexp">// Test something...            &#125;);    &#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;</span></span></span><br></code></pre></td></tr></table></figure><h4 id="9-4-1-模拟一个-Web-上下文"><a href="#9-4-1-模拟一个-Web-上下文" class="headerlink" title="9.4.1. 模拟一个 Web 上下文"></a>9.4.1. 模拟一个 Web 上下文</h4><p>如果需要测试一个仅在 Servlet 或响应式 Web 应用程序上下文中运行的自动配置, 请分别使用 <code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>.</p><h4 id="9-4-2-覆盖-Classpath"><a href="#9-4-2-覆盖-Classpath" class="headerlink" title="9.4.2. 覆盖 Classpath"></a>9.4.2. 覆盖 Classpath</h4><p>还可以测试在运行时不存在特定类和&#x2F;或包时发生的情况. Spring Boot 附带了一个可以由跑步者轻松使用的 <code>FilteredClassLoader</code>. 在以下示例中, 我们声明如果 <code>MyService</code> 不存在, 则会正确禁用自动配置:</p><p>Java</p><p>Kotlin</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Test<br><br><span class="hljs-literal">void</span> serviceIsIgnoredIfLibraryIsNotPresent() &#123;<br><br>    this.contextRunner.withClassLoader(<span class="hljs-keyword">new</span> FilteredClassLoader(MyService.<span class="hljs-keyword">class</span>))<br><br>            .run<span class="hljs-function"><span class="hljs-params">((context) -&gt; assertThat(context).doesNotHaveBean(<span class="hljs-string">&quot;myService&quot;</span>))</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="9-5-创建自己的-Starter"><a href="#9-5-创建自己的-Starter" class="headerlink" title="9.5. 创建自己的 Starter"></a>9.5. 创建自己的 Starter</h3><p>一个典型的 Spring Boot 启动器包含用于自动配置和使用的基础技术结构的代码, 我们称其为 “acme”. 为了使其易于扩展, 可以将命名空间中的许多配置项暴露给环境.最后, 提供了一个 “starter” 依赖, 以帮助用户尽可能轻松地入门.</p><p>具体而言, 自定义启动器可以包含以下内容:</p><ul><li><code>autoconfigure</code> 模块, 为 “acme” 包含自动配置代码.</li><li><code>starter</code> 模块, 它为 “acme” 提供对 <code>autoconfigure</code> 模块依赖以及类库和常用的其他依赖. 简而言之, 添加 starter 应该提供该库开始使用所需的一切依赖.</li></ul><p>完全没有必要将这两个模块分开.如果 “acme” 具有多种功能, 选项或可选功能, 则最好将自动配置分开, 这样您可以清楚地表示某些功能是可选的.此外, 您还可以制作一个启动器, 以提供有关可选的依赖. 同时, 其他人只能依靠 <code>autoconfigure</code> 模块来制作自己的具有不同选项的启动器.</p><p>如果自动配置相对简单并且不具有可选功能, 则将两个模块合并在启动器中绝对是一种选择.</p><h4 id="9-5-1-命名"><a href="#9-5-1-命名" class="headerlink" title="9.5.1. 命名"></a>9.5.1. 命名</h4><p>您应该确保为您的 starter 提供一个合适的命名空间. 即使您使用其他 Maven groupId, 也不要使用 <code>spring-boot</code> 作为模块名称的开头. 我们可能会为您以后自动配置的内容提供官方支持.</p><p>根据经验, 您应该在 starter 后命名一个组合模块. 例如, 假设您正在为 acme 创建一个 starter, 并且您将自动配置模块命名为 <code>acme-spring-boot</code>, 将 starter 命名为 <code>acme-spring-boot-starter</code>. 如果您只有一个组合这两者的模块, 请将其命名为 <code>acme-spring-boot-starter</code>.</p><h4 id="9-5-2-配置-keys"><a href="#9-5-2-配置-keys" class="headerlink" title="9.5.2. 配置 keys"></a>9.5.2. 配置 keys</h4><p>此外, 如果您的 starter 提供配置 key, 请为它们使用唯一的命名空间. 尤其是, 不要将您的 key 包含在 Spring Boot 使用的命名空间中 (例如 <code>server</code>、<code>management</code>、<code>spring</code> 等) . 如果您使用了相同的命名空间, 我们将来可能会以破坏您的模块的方式来修改这些命名空间. 根据经验, 所有 key 都必须拥有自己的命名空间 (例如 <code>acme</code>) .</p><p>通过为每个属性添加字段 javadoc 来确保记录了配置 keys, 如以下示例所示:</p><p>Java</p><p>Kotlin</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">@ConfigurationProperties(<span class="hljs-string">&quot;acme&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcmeProperties</span> &#123;<br>    <span class="hljs-comment">/**     * Whether to check the location of acme resources.     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> checkLocation = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/**     * Timeout for establishing a connection to the acme server.     */</span>    <span class="hljs-keyword">private</span> Duration loginTimeout = Duration.ofSeconds(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// getters/setters ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>您仅应将简单文本与 <code>@ConfigurationProperties</code> 字段 Javadoc 一起使用, 因为在将它们添加到 JSON 之前不会对其进行处理.</p><p>这是我们内部遵循的一些规则, 以确保描述一致:</p><ul><li>请勿以 “The” 或 “A” 头描述.</li><li>对于布尔类型, 请从 “Whether” 或 “Enable” 开始描述.</li><li>对于基于集合的类型, 请以 “以逗号分隔的列表” 开始描述</li><li>使用 <code>java.time.Duration</code> 而不是 <code>long</code>, 如果它不等于毫秒, 请说明默认单位, 例如 “如果未指定持续时间后缀, 则将使用秒”.</li><li>除非必须在运行时确定默认值, 否则请不要在描述中提供默认值.</li></ul><p>确保 <a href="https://sca.aliyun.com/learn/spring-boot/core/configuration-metadata.html#appendix.configuration-metadata.annotation-processor">触发元数据生成</a> , 以便为您的 key 提供 IDE 帮助. . 您可能需要查看生成的元数据 (<code>META-INF/spring-configuration-metadata.json</code>) , 以确保您的 key 记录是否正确. 在兼容的 IDE 中使用自己的 starter 也是验证元数据质量的好主意.</p><h4 id="9-5-3-autoconfigure-模块"><a href="#9-5-3-autoconfigure-模块" class="headerlink" title="9.5.3. autoconfigure 模块"></a>9.5.3. <code>autoconfigure</code> 模块</h4><p><code>autoconfigure</code> 模块包含类库开始使用所需的所有内容. 它还可以包含配置 key 定义 (例如 <code>@ConfigurationProperties</code>) 和任何可用于进一步自定义组件初始化方式的回调接口.</p><p>您应该将类库的依赖标记为可选, 以便您可以更轻松地在项目中包含 <code>autoconfigure</code> 模块. 如果以这种方式执行, 则不提供类库, 默认情况下, Spring Boot 将会退出.</p><p>Spring Boot 使用注解处理器来收集元数据文件 (<code>META-INF/spring-autoconfigure-metadata.properties</code>) 中自动配置的条件.如果该文件存在, 则用于快速过滤不匹配的自动配置, 缩短启动时间.</p><p>当使用 Maven 构件，建议在包含自动配置的模块中添加以下依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果您直接在应用程序中定义了自动配置, 请确保配置 <code>spring-boot-maven-plugin</code>, 以防止 <code>repackage</code> 目标将依赖添加到 fat jar 中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 Gradle , 应在 <code>annotationProcessor</code> 配置中声明依赖, 如下所示:</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">dependencies</span> &#123;<br><br>    annotationProcessor <span class="hljs-string">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-5-4-Starter-模块"><a href="#9-5-4-Starter-模块" class="headerlink" title="9.5.4. Starter 模块"></a>9.5.4. Starter 模块</h4><p>starter 真的是一个空 jar. 它的唯一目的是为使用类库提供必要的依赖. 您可以将其视为使用类库的一切基础.</p><p>不要对添加 starter 的项目抱有假设想法. 如果您自动配置的库经常需要其他 starter, 请一并声明它们. 如果可选依赖的数量很多, 则提供一组适当的默认依赖可能很难, 因为您本应该避免包含对常用库的使用不必要的依赖. 换而言之, 您不应该包含可选的依赖.</p><p>无论哪种方式, 您的 starter 必须直接或间接引用 Spring Boot 的 core starter (<code>spring-boot-starter</code>) (如果您的 starter 依赖于另一个 starter , 则无需添加它) . 如果只使用自定义 starter 创建项目, 则 Spring Boot 的核心功能将通过 core starter 来实现.</p><h2 id="10-Kotlin-支持"><a href="#10-Kotlin-支持" class="headerlink" title="10. Kotlin 支持"></a>10. Kotlin 支持</h2><p><a href="https://kotlinlang.org/">Kotlin</a> 是一种针对 JVM (和其他平台) 的静态类型语言, 它可编写出简洁而优雅的代码, 同时提供与使用 Java 编写的现有库的 <a href="https://kotlinlang.org/docs/reference/java-interop.html">互通性</a>.</p><p>开始学习 Spring Boot 和 Kotlin 最简单方法是遵循这个 <a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">全面教程</a>. 您可以通过 <a href="https://start.spring.io/#!language=kotlin">start.spring.io</a> 创建新的 Kotlin 项目. 如果您需要支持, 请免费加入 <a href="https://slack.kotlinlang.org/">Kotlin Slack</a> 的 #spring 频道或使用 <a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stack Overflow</a> 上的 <code>spring</code> 和 <code>kotlin</code> 标签提问.</p><h3 id="10-1-要求"><a href="#10-1-要求" class="headerlink" title="10.1. 要求"></a>10.1. 要求</h3><p>Spring Boot 支持 Kotlin 1.7.x. 要使用 Kotlin, classpath 下必须存在 <code>org.jetbrains.kotlin:kotlin-stdlib</code> 和 <code>org.jetbrains.kotlin:kotlin-reflect</code>. 也可以使用 <code>kotlin-stdlib</code> 的变体 <code>kotlin-stdlib-jdk7</code> 和 <code>kotlin-stdlib-jdk8</code>.</p><p>由于 <a href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">Kotlin 类默认为 final</a>, 因此您可能需要配置 <a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support">kotlin-spring</a> 插件以自动打开 <code>Spring-annotated</code> 类, 以便可以代理它们.</p><p>在 Kotlin 中序列化&#x2F;反序列化 JSON 数据需要使用 <a href="https://github.com/FasterXML/jackson-module-kotlin">Jackson 的 Kotlin 模块</a>. 在 classpath 中找到它时会自动注册. 如果 Jackson 和 Kotlin 存在但 Jackson Kotlin 模块不存在, 则会记录警告消息.</p><p>如果在 <a href="https://start.spring.io/#!language=kotlin">start.spring.io</a> 上创建 Kotlin 项目, 则默认提供这些依赖和插件.</p><h3 id="10-2-Null-安全"><a href="#10-2-Null-安全" class="headerlink" title="10.2. Null 安全"></a>10.2. Null 安全</h3><p>Kotlin 的一个关键特性是 <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>. 它在编译时处理空值, 而不是将问题推迟到运行时并遇到 <code>NullPointerException</code>. 这有助于消除常见的错误来源, 而无需支付像 <code>Optional</code> 这样的包装器的成本. Kotlin 还允许使用有可空值的, 如 Kotlin <code>null</code> <a href="https://www.baeldung.com/kotlin-null-safety">安全综合指南中</a> 所述.</p><p>虽然 Java 不允许在其类型系统中表示 <code>null</code> 安全, 但 Spring Framework、Spring Data 和 Reactor 现在通过易于使用的工具的注解提供其 API 的安全性. 默认情况下, Kotlin 中使用的 Java API 类型被识别为放宽空检查的 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">平台类型</a>. Kotlin 对 <a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">JSR 305 注解</a> 的支持与可空注解相结合, 为 Kotlin 中 Spring API 相关的代码提供了空安全.</p><p>可以通过使用以下选项添加 <code>-Xjsr305</code> 编译器标志来配置 JSR 305 检查: <code>-Xjsr305=&#123;strict|warn|ignore&#125;</code>. 默认行为与 <code>-Xjsr305=warn</code> 相同. 在从 Spring API 推断出的 Kotlin 类型中需要考虑 null 安全的 <code>strict</code> 值, 但是应该使用 Spring API 可空声明甚至可以在次要版本之间发展并且将来可能添加更多检查的方案.</p><p>尚不支持泛型类型参数、varargs 和数组元素可空性. 有关最新信息, 请参见 <a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a>. 另请注意, Spring Boot 自己的 API <a href="https://github.com/spring-projects/spring-boot/issues/10712">尚未注解</a>.</p><h3 id="10-3-Kotlin-API"><a href="#10-3-Kotlin-API" class="headerlink" title="10.3. Kotlin API"></a>10.3. Kotlin API</h3><h4 id="10-3-1-runApplication"><a href="#10-3-1-runApplication" class="headerlink" title="10.3.1. runApplication"></a>10.3.1. runApplication</h4><p>Spring Boot 提供了使用 <code>runApplication&lt;MyApplication&gt;(*args)</code> 运行应用程序的惯用方法, 如下所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SpringBootApplicationclass</span> MyApplication<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    runApplication&lt;MyApplication&gt;(*args)&#125;<br></code></pre></td></tr></table></figure><p>这是 <code>SpringApplication.run(MyApplication::class.java, *args)</code> 的替代方式. 它还允许自定义应用程序, 如下所示:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">runApplication&lt;MyApplication&gt;(*args) &#123;<br><br>    <span class="hljs-built_in">setBannerMode</span>(OFF)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-3-2-扩展"><a href="#10-3-2-扩展" class="headerlink" title="10.3.2. 扩展"></a>10.3.2. 扩展</h4><p>Kotlin <a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a> 提供了使用附加功能扩展现有类的能力. Spring Boot Kotlin API 利用这些扩展为现有 API 添加新的 Kotlin 特定便利.</p><p>提供的 <code>TestRestTemplate</code> 扩展类似于 Spring Framework 为 <code>RestOperations</code> 提供的. 除此之外, 扩展使得利用 Kotlin reified 类型参数变为可能.</p><h3 id="10-4-依赖管理"><a href="#10-4-依赖管理" class="headerlink" title="10.4. 依赖管理"></a>10.4. 依赖管理</h3><p>为了避免在 classpath 上混合不同版本的 Kotlin 依赖, Spring Boot 会导入 Kotlin BOM.</p><p>使用 Maven, 可以通过 <code>kotlin.version</code> 属性自定义 Kotlin 版本, 并且为 <code>kotlin-maven-plugin</code> 提供了插件管理. 使用 Gradle, Spring Boot 插件会自动将 <code>kotlin.version</code> 与 Kotlin 插件的版本保一致.</p><p>Spring Boot 还通过导入 Kotlin Coroutines BOM 管理 Coroutines 依赖的版本. 可以通过 <code>kotlin-coroutines.version</code> 属性自定义版本.</p><p>如果在 <a href="https://start.spring.io/#!language=kotlin">start.spring.io</a> 上构建的 Kotlin 项目有至少一个响应式依赖, 则默认提供 <code>org.jetbrains.kotlinx:kotlinx-coroutines-reactor</code> 依赖.</p><h3 id="10-5-ConfigurationProperties"><a href="#10-5-ConfigurationProperties" class="headerlink" title="10.5. @ConfigurationProperties"></a>10.5. @ConfigurationProperties</h3><p><code>@ConfigurationProperties</code> 与 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.external-config.typesafe-configuration-properties.constructor-binding"><code>@ConstructorBinding</code></a> 结合使用时, <code>@ConfigurationProperties</code> 支持具有不变 <code>val</code> 属性的类, 如以下示例所示:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@ConfigurationProperties(<span class="hljs-string">&quot;example.kotlin&quot;</span>)data <span class="hljs-keyword">class</span> <span class="hljs-symbol">KotlinExampleProperties</span>(        <span class="hljs-symbol">val</span> <span class="hljs-symbol">name: <span class="hljs-symbol">String</span>,        <span class="hljs-symbol">val</span></span> <span class="hljs-symbol">description: <span class="hljs-symbol">String</span>,        <span class="hljs-symbol">val</span></span> <span class="hljs-symbol">myService: <span class="hljs-symbol">MyService</span></span>) &#123;<br>    data <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyService</span>(            <span class="hljs-symbol">val</span> <span class="hljs-symbol">apiToken: <span class="hljs-symbol">String</span>,            <span class="hljs-symbol">val</span></span> <span class="hljs-symbol">uri: <span class="hljs-symbol">URI</span></span>    )&#125;<br></code></pre></td></tr></table></figure><p>为了使用注解处理器 <a href="https://sca.aliyun.com/learn/spring-boot/core/configuration-metadata.html#appendix.configuration-metadata.annotation-processor">生成自己的元数据</a> , 应该使用 <code>spring-boot-configuration-processor</code> 依赖配置 <a href="https://kotlinlang.org/docs/reference/kapt.html"><code>kapt</code></a> . 请注意, 由于 kapt 提供的模型的限制, 某些功能 (例如检测默认值或不推荐使用的项目) 无法正常工作.</p><h3 id="10-6-测试"><a href="#10-6-测试" class="headerlink" title="10.6. 测试"></a>10.6. 测试</h3><p>虽然可以使用 JUnit 4 来测试 Kotlin 代码, 但建议使用 JUnit 5. JUnit 5 允许测试类实例化一次, 并在所有类的测试中复用. 这使得可以在非静态方法上使用 <code>@BeforeAll</code> 和 <code>@AfterAll</code> 注解, 这非常适合 Kotlin.</p><p>要模拟 Kotlin 类, 建议使用 MockK. 如果您需要与 Mockito 特定的 <a href="https://sca.aliyun.com/learn/spring-boot/core/?spm=5176.29160081.0.0.6fd93d07hNfjnl&source=learn#features.testing.spring-boot-applications.mocking-beans"><code>@MockBean</code> 和 <code>@SpyBean</code> 注解</a> 相对应的 Mockk, 则可以使用 SpringMockK, 它提供类似的 <code>@MockkBean</code> 和 <code>@SpykBean</code> 注解.</p><h3 id="10-7-资源"><a href="#10-7-资源" class="headerlink" title="10.7. 资源"></a>10.7. 资源</h3><h4 id="10-7-1-进阶阅读"><a href="#10-7-1-进阶阅读" class="headerlink" title="10.7.1. 进阶阅读"></a>10.7.1. 进阶阅读</h4><ul><li><a href="https://kotlinlang.org/docs/reference/">Kotlin 语言参考</a></li><li><a href="https://kotlinlang.slack.com/">Kotlin Slack</a> (有专用的 #spring 频道)</li><li><a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow 上 <code>spring</code> 和 <code>kotlin</code> 标签</a></li><li><a href="https://try.kotlinlang.org/">在浏览器中尝试 Kotlin</a></li><li><a href="https://blog.jetbrains.com/kotlin/">Kotlin 博客</a></li><li><a href="https://kotlin.link/">Awesome Kotlin</a></li><li><a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">教程: 使用 Spring Boot 和 Kotlin 构建 Web 应用程序</a></li><li><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">使用 Kotlin 开发 Spring Boot 应用程序</a></li><li><a href="https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql">使用 Kotlin、Spring Boot 和 PostgreSQL 开发地理信息</a></li><li><a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">在 Spring Framework 5.0 中引入 Kotlin 支持</a></li><li><a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way">Spring Framework 5 Kotlin API 实现函数式</a></li></ul><h4 id="10-7-2-示例"><a href="#10-7-2-示例" class="headerlink" title="10.7.2. 示例"></a>10.7.2. 示例</h4><ul><li><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a>: regular Spring Boot + Spring Data JPA project</li><li><a href="https://github.com/mixitconf/mixit">mixit</a>: Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB</li><li><a href="https://github.com/sdeleuze/spring-kotlin-fullstack">spring-kotlin-fullstack</a>: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript</li><li><a href="https://github.com/spring-petclinic/spring-petclinic-kotlin">spring-petclinic-kotlin</a>: Kotlin version of the Spring PetClinic Sample Application</li><li><a href="https://github.com/sdeleuze/spring-kotlin-deepdive">spring-kotlin-deepdive</a>: a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin</li><li><a href="https://github.com/sdeleuze/spring-boot-coroutines-demo">spring-boot-coroutines-demo</a>: Coroutines sample project</li></ul><h2 id="11-下一步"><a href="#11-下一步" class="headerlink" title="11. 下一步"></a>11. 下一步</h2><p>如果您想了解本节中讨论的任何类目的更多信息, 可以查看 <a href="https://docs.spring.io/spring-boot/docs/3.0.0/api">Spring Boot API 文档</a> , 也可以直接浏览 <a href="https://github.com/spring-projects/spring-boot/tree/main">源代码</a> . 如果您有具体问题, 请查看 <a href="https://sca.aliyun.com/learn/spring-boot/core/howto.html#howto">how-to</a> 部分.</p><p>如果您对 Spring Boot 的核心功能感到满意, 可以继续阅读有关 t <a href="https://sca.aliyun.com/learn/spring-boot/core/actuator.html#actuator">生产就绪功能</a> 的内容.</p><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存</title>
    <link href="/post/eb33628b-f904-43e4-a665-86de378af284/"/>
    <url>/post/eb33628b-f904-43e4-a665-86de378af284/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>Spring 教程</p><hr><h2 id="5-缓存抽象"><a href="#5-缓存抽象" class="headerlink" title="5. 缓存抽象"></a>5. 缓存抽象</h2><p>从3.1版本开始,Spring框架为在现有的Spring应用程序透明地添加缓存提供了支持。 与<a href="https://sca.aliyun.com/learn/spring/integration/cache/data-access.html#transaction">事务</a>支持类似，缓存抽象允许一致地使用各种缓存解决方案，而对代码的影响最小。</p><p>从Spring 4.1开始，通过<a href="https://sca.aliyun.com/learn/spring/integration/cache/?spm=0.29160081.0.0.51f92e5dCHrGI4#cache-jsr-107">JSR-107注解</a>和更多自定义选项的支持，缓存抽象得到了显着改进。</p><h3 id="5-1-了解缓存抽象"><a href="#5-1-了解缓存抽象" class="headerlink" title="5.1. 了解缓存抽象"></a>5.1. 了解缓存抽象</h3><p>Cache vs Buffer</p><p>术语“buffer” 和 “cache,”倾向于可互换使用。 但请注意，它们代表不同的东西。 缓冲区通常用作快速和慢速实体之间的数据的中间临时存储区。由于一方必须等待另一个影响性能的因素， 因此缓冲区会通过允许整个数据块同时移动， 而不是一小块来缓解这一问题。数据只在缓冲区中写入和读取一次。此外， 缓冲区至少对知道它的一方是可见的。</p><p>另一方面，理论上的缓存是隐藏的，任何一方都不知道缓存是否发生。它还可以提高性能，而且相同的数据可以快速读取多次。</p><p>对两者更多的解释是在<a href="https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache">here</a> .</p><p>缓存抽象的核心是将缓存应用于Java方法，从而根据缓存中可用的信息减少执行次数。 也就是说，每次调用目标方法时，抽象都会应用一种缓存行为，该行为检查该方法是否已针对给定参数执行。 如果已执行，则返回缓存的结果，而不必执行实际方法。 如果该方法尚未执行，则执行该方法，并将结果缓存并返回给用户，以便下次调用该方法时，返回缓存的结果。 这样，对于给定的一组参数，昂贵的方法（无论是CPU还是IO）只能执行一次，并且重用结果而不必再次实际执行该方法。 缓存逻辑是透明应用的，不会对调用者造成任何干扰。</p><p>此方法仅适用于保证为给定输入（或参数）返回相同输出（结果）的方法，无论它执行多少次。</p><p>其他与缓存相关的操作由抽象提供，如更新缓存内容的能力或删除所有条目中的一个。如果缓存处理在应用程序过程中可以更改的数据，这些都是很有用的。</p><p>就像Spring框架中的其他服务一样，缓存服务是抽象(不是缓存实现)，需要使用实际存储来存储缓存数据，也就是说，抽象使开发人员不必编写缓存逻辑，但不提供实际的存储。此抽象由<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口具体化。</p><p>Spring提供了一些抽象实现：基于JDK <code>java.util.concurrent.ConcurrentMap</code>的缓存，<a href="http://ehcache.org/">Ehcache 2.x</a>，Gemfire缓存，<a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>和符合JSR-107的缓存（例如Ehcache 3.x）。 有关插入其他缓存存储和提供程序的详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/integration/cache/?spm=0.29160081.0.0.51f92e5dCHrGI4#cache-plug">不同的后端缓存</a>。</p><p>缓存抽象没有针对多线程和多进程环境的特殊处理，因为这些功能由缓存实现处理。</p><p>如果您具有多进程环境（即，部署在多个节点上的应用程序），则需要相应地配置缓存提供程序。 根据您的使用情况，几个节点上的相同数据的副本就足够了。 但是，如果在应用程序过程中更改数据，则可能需要启用其他传播机制。</p><p>在代码中直接添加缓存的经典流程有 get-if-not-found-then-proceed-and-put-eventually 这里没有用到锁。同时允许多线程同步时加载同一个缓存。同样对于回收缓存也是相似。但如果有多个线程试图更新或者回收数据的话，可能会用到旧数据。某些缓存为程序为该区域的操作提供了高级功能，请参阅您正在使用的缓存提供程序的文档以获取详细信息。</p><p>要使用缓存抽象，您需要注意两个方面：</p><ul><li>缓存声明：确定需要缓存的方法及其策略。</li><li>缓存配置：存储数据并从中读取数据的后端缓存。</li></ul><h3 id="5-2-基于注解声明缓存"><a href="#5-2-基于注解声明缓存" class="headerlink" title="5.2. 基于注解声明缓存"></a>5.2. 基于注解声明缓存</h3><p>对于缓存声明，Spring的缓存抽象提供了一组Java注解：</p><ul><li><code>@Cacheable</code>: 触发缓存储存</li><li><code>@CacheEvict</code>: 触发缓存回收</li><li><code>@CachePut</code>: 在不影响方法执行的情况下更新缓存</li><li><code>@Caching</code>: 重新在方法上应用多个缓存操作</li><li><code>@CacheConfig</code>: 在类级别共享与缓存有关的常见设置</li></ul><h4 id="5-2-1-Cacheable-注解"><a href="#5-2-1-Cacheable-注解" class="headerlink" title="5.2.1. @Cacheable 注解"></a>5.2.1. <code>@Cacheable</code> 注解</h4><p>顾名思义，<code>@Cacheable</code> 用于标定可缓存的方法 ， 即将结果存储到缓存中的方法，以便在后续调用中(使用相同的参数)，缓存的值可以在不执行方法的情况下返回。最简单的，注解声明要求带注解的方法关联缓存的名称。如下:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">Cacheable</span>(<span class="hljs-string">&quot;books&quot;</span>)<br><br>public <span class="hljs-type">Book</span> findBook(<span class="hljs-type">ISBN</span> isbn) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>在上面的代码段中，方法<code>findBook</code>与名为<code>books</code>的缓存关联。每次调用该方法时，都会检查缓存以查看是否已经执行了调用，并且不会重复。在大多数情况下，只有一个缓存被声明，注解允许指定多个名称，以便使用一个以上的缓存。在这种情况下，在执行方法之前将检查每个缓存，如果至少命中一个缓存，则将返回关联的值。如下：</p><p>即使未实际执行缓存的方法，也会更新不包含该值的所有其他缓存。</p><p>以下示例在 <code>findBook</code> 方法上使用<code>@Cacheable</code>:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">Cacheable</span>(&#123;<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;isbns&quot;</span>&#125;)<br><br>public <span class="hljs-type">Book</span> findBook(<span class="hljs-type">ISBN</span> isbn) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h5 id="默认的键生成"><a href="#默认的键生成" class="headerlink" title="默认的键生成"></a>默认的键生成</h5><p>由于缓存实质上是键-值存储区，因此需要将每个缓存方法的调用转换为适合缓存访问的键。缓存抽象使用基于以下算法使用简单的键生成器-<code>KeyGenerator</code>，做到开箱即用。:</p><ul><li>如果没有参数被指定，则返回<code>SimpleKey.EMPTY</code>.</li><li>如果只有一个参数被指定，则返回实例</li><li>如果多于一个参数被指定，则返回一个<code>SimpleKey</code>包含所有的参数</li></ul><p>这种方法适用于大多数用例。只要参数有自然的键并且实现了有效的<code>hashCode()</code> 和 <code>equals()</code>方法，如果不是这样的话， 那么战略就需要改变。</p><p>要提供不同的默认键生成器，您需要实现<code>org.springframework.cache.interceptor.KeyGenerator</code>接口。</p><p>默认的键生成策略在Spring 4.0版本有点改变。早期的Spring版本使用的键生成策略，对于多个键参数，只考虑参数的<code>hashCode()</code> 而没有考虑到 <code>equals()</code>方法，这将导致一定的碰撞（见<a href="https://jira.spring.io/browse/SPR-10237">SPR-10237</a>）。新的 <code>SimpleKeyGenerator</code> 为这种情况使用复合键。</p><p>如果您希望继续使用前面的 key strategy, 则可以配置已弃用的<code>org.springframework.cache.interceptor.DefaultKeyGenerator</code>类或创建自定义的基于<code>KeyGenerator</code>的实现。</p><h5 id="自定义键生成器"><a href="#自定义键生成器" class="headerlink" title="自定义键生成器"></a>自定义键生成器</h5><p>由于缓存是具有普遍性的，因此目标方法很可能具有不同的签名，不能简单地映射到缓存结构的顶部。当目标方法有多个参数时，问题显得更突出，其中只有一部分是适合于缓存的(其余仅由方法逻辑使用)。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(&quot;books&quot;)</span><br><br><span class="hljs-keyword">public</span> Book <span class="hljs-title function_">findBook</span><span class="hljs-params">(ISBN isbn, <span class="hljs-type">boolean</span> checkWarehouse, <span class="hljs-type">boolean</span> includeUsed)</span><br></code></pre></td></tr></table></figure><p>乍一看，虽然两个 <code>boolean</code>参数影响了book的发现方式，但它们对缓存没有用处。 如果两个中只有一个重要而另一个不重要怎么办？</p><p>对于这种情况，<code>@Cacheable</code>注解允许用户指定<code>key</code>的生成属性。开发人员可以使用<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#expressions">SpEL</a>)来选择感兴趣的参数(或它们的嵌套属性)执行操作，甚至调用任意方法，而不必编写任何代码或实现任何接口。这是在默认生成器。</p><p>以下示例是各种SpEL声明（如果您不熟悉SpEL，请阅读 <a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#expressions">Spring Expression Language</a>）:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;#isbn&quot;</span>)public Book <span class="hljs-built_in">findBook</span>(ISBN isbn, boolean checkWarehouse, boolean includeUsed)<br><span class="hljs-variable">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;#isbn.rawNumber&quot;</span>)public Book <span class="hljs-built_in">findBook</span>(ISBN isbn, boolean checkWarehouse, boolean includeUsed)<br><span class="hljs-variable">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;T(someType).hash(#isbn)&quot;</span>)public Book <span class="hljs-built_in">findBook</span>(ISBN isbn, boolean checkWarehouse, boolean includeUsed)<br></code></pre></td></tr></table></figure><p>上面的代码段显示了选择某个参数、某个属性甚至是任意(静态)方法是多么容易。</p><p>如果负责生成键的算法太特殊，或者需要共享，则可以在操作上定义一个自定义<code>keyGenerator</code>。为此，请指定要使用的<code>KeyGenerator</code> bean实现的名称。如下:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, keyGenerator=<span class="hljs-string">&quot;myKeyGenerator&quot;</span>)<br><br><span class="hljs-keyword">public</span> Book findBook(ISBN isbn, <span class="hljs-keyword">boolean</span> checkWarehouse, <span class="hljs-keyword">boolean</span> includeUsed)<br></code></pre></td></tr></table></figure><p><code>key</code>和 <code>keyGenerator</code>参数是互斥的， 指定两者的操作将导致异常。</p><h5 id="默认的缓存解析"><a href="#默认的缓存解析" class="headerlink" title="默认的缓存解析"></a>默认的缓存解析</h5><p>缓存抽象使用一个简单的 <code>CacheResolver</code>（可即用）它使用<code>CacheManager</code>配置检索在操作级别定义的缓存。</p><p>为了提供不同默认缓存解析，需要实现<code>org.springframework.cache.interceptor.CacheResolver</code> 接口.</p><h5 id="自定义缓存解析"><a href="#自定义缓存解析" class="headerlink" title="自定义缓存解析"></a>自定义缓存解析</h5><p>默认的缓存解析适合于应用对于使用单个<code>CacheManager</code>，并且不需要复杂的解析要求。</p><p>对于应用使用不同的缓存管理，可以设置<code>cacheManager</code> 使用每个操作。如以下示例所示：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, cacheManager=<span class="hljs-string">&quot;anotherCacheManager&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public <span class="hljs-type">Book</span> findBook(<span class="hljs-type">ISBN</span> isbn) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Specifying <code>anotherCacheManager</code>.</p><p>也可以完全以类似于 <a href="https://sca.aliyun.com/learn/spring/integration/cache/?spm=0.29160081.0.0.51f92e5dCHrGI4#cache-annotations-cacheable-key">key generation</a>的方式替换<code>CacheResolver</code>。为每个缓存操作请求该解决方案， 使实现能够根据运行时参数实际解析要使用的缓存。以下示例显示如何指定 <code>CacheResolver</code>：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">Cacheable</span>(cacheResolver=<span class="hljs-string">&quot;runtimeCacheResolver&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public <span class="hljs-type">Book</span> findBook(<span class="hljs-type">ISBN</span> isbn) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Specifying the <code>CacheResolver</code>.</p><p>Spring 4.1版本以后, 缓存注解的 <code>value</code>属性不再是强制性的了，因为无论注解的内容如何，<code>CacheResolver</code>都可以提供此特定信息。</p><p>与 <code>key</code>和<code>keyGenerator</code>似，<code>cacheManager</code>和<code>cacheResolver</code>参数是互斥的，同时指定两者的操作将导致异常，因为<code>CacheResolver</code>实现忽略了自定义<code>CacheManager</code>。这可能不是你所期望的。</p><h5 id="同步缓存"><a href="#同步缓存" class="headerlink" title="同步缓存"></a>同步缓存</h5><p>在多线程环境中，对于同一参数(通常在启动时)，可能会同时调用某些操。默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的值，从而无法达到缓存的目的。</p><p>对于这些特定情况，可以使用<code>sync</code>属性指示基础缓存提供程序在计算值时锁定缓存项。因此，只有一个线程将忙于计算该值，而其余的则被阻塞，直到在缓存中更新该项。以下示例显示了如何使用<code>sync</code>属性:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">Cacheable</span>(cacheNames=<span class="hljs-string">&quot;foos&quot;</span>, sync=<span class="hljs-literal">true</span>) (<span class="hljs-number">1</span>)<br><br>public <span class="hljs-type">Foo</span> executeExpensiveOperation(<span class="hljs-type">String</span> id) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using the <code>sync</code> attribute.</p><p>这是一个可选的功能，您喜欢的缓存库可能不支持它。核心框架提供的所有<code>CacheManager</code> 实现都支持它。有关详细信息，请参阅缓存提供程序的文档，</p><h5 id="条件缓存"><a href="#条件缓存" class="headerlink" title="条件缓存"></a>条件缓存</h5><p>有时，一个方法做缓存可能不是万能的(例如，它可能依赖于给定的参数)。缓存注解通过<code>condition</code>参数支持此类功能，它采用 <code>SpEL</code> 表达式，并将其计算为<code>true</code>或<code>false</code>。如果为<code>true</code>，则方法执行缓存。如果不是，则它的行为就像不缓存的方法一样。 每次不管缓存中的值是什么或使用了什么参数，都将执行它。例如，仅当参数名称的长度小于32时，才会缓存以下方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@Cacheable(<span class="hljs-attribute">cacheNames</span>=<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-attribute">condition</span>=<span class="hljs-string">&quot;#name.length() &lt; 32&quot;</span>) (1)<br><br>public Book findBook(String name)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Setting a condition on <code>@Cacheable</code>.</p><p>此外， 除了<code>condition</code>参数外， 还可以使用<code>unless</code> 参数来决定不想缓存的值。与 <code>condition</code>不同，， <code>unless</code>在调用方法后计算表达式。扩展上一示例。也许我们只想缓存平装书，如下例所示:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@Cacheable(<span class="hljs-attribute">cacheNames</span>=<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-attribute">condition</span>=<span class="hljs-string">&quot;#name.length() &lt; 32&quot;</span>, <span class="hljs-attribute">unless</span>=<span class="hljs-string">&quot;#result.hardback&quot;</span>) (1)<br><br>public Book findBook(String name)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using the <code>unless</code> attribute to block hardbacks.</p><p>缓存抽象支持<code>java.util.Optional</code>，仅在其存在时将其内容用作缓存值。 <code>#result</code>总是引用业务实体而从不支持包装器，因此前面的示例可以重写如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@Cacheable(<span class="hljs-attribute">cacheNames</span>=<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-attribute">condition</span>=<span class="hljs-string">&quot;#name.length() &lt; 32&quot;</span>, <span class="hljs-attribute">unless</span>=<span class="hljs-string">&quot;#result?.hardback&quot;</span>)<br><br>public Optional&lt;Book&gt; findBook(String name)<br></code></pre></td></tr></table></figure><p>请注意，<code>result</code>仍然引用 <code>Book</code> 而不是<code>Optional</code>。 由于它可能为<code>null</code>，我们应该使用安全导航操作符。</p><h5 id="可用的缓存SpEL表达式内容"><a href="#可用的缓存SpEL表达式内容" class="headerlink" title="可用的缓存SpEL表达式内容"></a>可用的缓存SpEL表达式内容</h5><p>每个<code>SpEL</code>表达式都可以用于再次指定的上下文值。除了在参数中生成外，框架还提供专用的与缓存相关的元数据(如参数名称)。下表列出了可用于<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#expressions-language-ref"><code>context</code></a>的项，以便可以使用这些项进行键和条件计算。</p><p>Table 11. 缓存SpEL可用的元数据</p><table><thead><tr><th>名字</th><th>位置</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>methodName</code></td><td>Root object</td><td>正在调用的方法的名称</td><td><code>#root.methodName</code></td></tr><tr><td><code>method</code></td><td>Root object</td><td>正在调用的方法</td><td><code>#root.method.name</code></td></tr><tr><td><code>target</code></td><td>Root object</td><td>正在调用的目标对象</td><td><code>#root.target</code></td></tr><tr><td><code>targetClass</code></td><td>Root object</td><td>被调用的目标的类</td><td><code>#root.targetClass</code></td></tr><tr><td><code>args</code></td><td>Root object</td><td>用于调用目标的参数（作为数组）</td><td><code>#root.args[0]</code></td></tr><tr><td><code>caches</code></td><td>Root object</td><td>执行当前方法的高速缓存的集合</td><td><code>#root.caches[0].name</code></td></tr><tr><td>Argument name</td><td>Evaluation context</td><td>任何方法参数的名称。 如果名称不可用（可能由于没有调试信息），参数名称也可以在<code>#a&lt;#arg&gt;</code>下获得，其中 <code>#arg</code>代表参数索引（从0开始）。</td><td><code>#iban</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</td></tr><tr><td><code>result</code></td><td>Evaluation context</td><td>方法调用的结果（要缓存的值）。 仅在<code>unless</code>表达式，缓存<code>cache put</code>表达式（计算<code>key</code>）或缓存<code>cache evict</code>表达式（当<code>beforeInvocation</code>为 <code>false</code>时）中可用。 对于受支持的包装器（例如<code>Optional</code>）， <code>#result</code>引用实际的对象，而不是包装器。</td><td><code>#result</code></td></tr></tbody></table><h4 id="5-2-2-CachePut-注解"><a href="#5-2-2-CachePut-注解" class="headerlink" title="5.2.2. @CachePut 注解"></a>5.2.2. <code>@CachePut</code> 注解</h4><p>对于需要更新缓存而不影响方法执行的情况，可以使用<code>@CachePut</code>注解。即，将始终执行该方法，并将其结果放入缓存(根据<code>@CachePut</code>选项)。它支持与<code>@Cacheable</code>相同的选项，，并且应用于缓存填充，而不是方法流优化。以下示例使用<code>@CachePut</code>注解:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@CachePut(<span class="hljs-attribute">cacheNames</span>=<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-attribute">key</span>=<span class="hljs-string">&quot;#isbn&quot;</span>)<br><br>public Book updateBook(ISBN isbn, BookDescriptor descriptor)<br></code></pre></td></tr></table></figure><p>通常强烈建议不要在同一方法上使用<code>@CachePut</code>和<code>@Cacheable</code> 注解，因为它们具有不同的行为。当后者导致使用缓存跳过方法执行时，前者强制执行以执行缓存更新。这会导致意外的行为，并且除了特定的某些情况(例如，有排除彼此的条件的注解)之外， 应避免此类声明。还要注意，此类条件不应依赖于结果对象(即<code>#result</code>变量)，因为它们是预先验证的，以确认排除。</p><h4 id="5-2-3-CacheEvict-注解"><a href="#5-2-3-CacheEvict-注解" class="headerlink" title="5.2.3. @CacheEvict 注解"></a>5.2.3. <code>@CacheEvict</code> 注解</h4><p>抽象缓存不仅允许缓存存储区的填充，而且还可以回收。此过程对于从缓存中删除陈旧或未使用的数据非常有用。相比于<code>@Cacheable</code>，注解 <code>@CacheEvict</code>执行缓存回收的区分方法，即充当从缓存中移除数据的触发器的方法。就像它的同级注解一样， <code>@CacheEvict</code>需要指定一个(或多个)受该操作影响的缓存，允许自定义缓存和键解析或指定的条件，但除此之外 ，还具有一个额外的参数<code>allEntries</code>，它指示是否需要进行缓存范围的回收，而不是只执行一项(基于键):</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@CacheEvict(<span class="hljs-attribute">cacheNames</span>=<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-attribute">allEntries</span>=<span class="hljs-literal">true</span>) (1)<br><br>public void loadBooks(InputStream batch)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using the <code>allEntries</code> attribute to evict all entries from the cache.</p><p>当需要清除整个缓存区域时，此选项会派上用场。然后将每个条目回收(这将需要很长时间，因为它的效率很低)，所有的条目都在一个操作中被移除，如上所示。请注意，框架将忽略此方案中指定的任何键，因为它不适用(整个缓存被回收的不仅仅是一个条目)。</p><p>您还可以通过使用<code>beforeInvocation</code>属性指示回收是在（默认）之后还是在方法执行之前进行的。前者提供与注解的其余部分相同的语义：一旦方法成功完成，就会执行缓存上的操作（在本例中为回收）。如果方法未执行（因为它可能被缓存）或抛出异常，则不会发生回收。 后者（<code>beforeInvocation=true</code>）导致回收始终在调用方法之前发生。 这在回收不需要与方法结果相关联的情况下非常有用。</p><p>必须注意的是，<code>void</code>方法可以与<code>@CacheEvict</code>一起使用-因为这些方法充当触发器,所以返回值被忽略(因为它们不与缓存交互)。<code>@Cacheable</code> 将数据添加&#x2F;更新到缓存中的情况并非如此，因此需要重新请求结果。</p><h4 id="5-2-4-Caching-注解"><a href="#5-2-4-Caching-注解" class="headerlink" title="5.2.4. @Caching 注解"></a>5.2.4. <code>@Caching</code> 注解</h4><p>在某些情况下，需要指定相同类型的多个注解(例如<code>@CacheEvict</code>或<code>@CachePut</code>)。例如，因为条件或键表达式在不同的缓存之间是不同的。 <code>@Caching</code>允许在同一方法上使用多个嵌套的<code>@Cacheable</code>、<code>@CachePut</code>和<code>@CacheEvict</code>。以下示例使用两个<code>@CacheEvict</code>注解:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Caching</span>(evict = &#123; <span class="hljs-variable">@CacheEvict</span>(<span class="hljs-string">&quot;primary&quot;</span>), <span class="hljs-variable">@CacheEvict</span>(cacheNames=<span class="hljs-string">&quot;secondary&quot;</span>, key=<span class="hljs-string">&quot;#p0&quot;</span>) &#125;)<br><br>public Book <span class="hljs-built_in">importBooks</span>(String deposit, Date date)<br></code></pre></td></tr></table></figure><h4 id="5-2-5-CacheConfig-注解"><a href="#5-2-5-CacheConfig-注解" class="headerlink" title="5.2.5. @CacheConfig 注解"></a>5.2.5. <code>@CacheConfig</code> 注解</h4><p>到目前为止，我们已经看到缓存操作提供了许多自定义选项，您可以为每个操作设置这些选项。但是，如果这些自定义选项适用于该类的所有操作，则可以对其进行配置。例如，指定要用于该类的每个缓存操作的缓存的名称可以由单个类级别定义替换。这就是<code>@CacheConfig</code>发挥作用的地方。 以下示例使用<code>@CacheConfig</code>设置缓存的名称:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim">@<span class="hljs-type">CacheConfig</span>(<span class="hljs-string">&quot;books&quot;</span>) (<span class="hljs-number">1</span>)public class <span class="hljs-type">BookRepositoryImpl</span> implements <span class="hljs-type">BookRepository</span> &#123;<br>    @<span class="hljs-type">Cacheable</span>    public <span class="hljs-type">Book</span> findBook(<span class="hljs-type">ISBN</span> isbn) <span class="hljs-meta">&#123;...&#125;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using <code>@CacheConfig</code> to set the name of the cache.</p><p><code>@CacheConfig</code>是一个类级注解，它允许共享缓存名称、自定义<code>KeyGenerator</code>、自定义<code>CacheManager</code>以及最终的自定义<code>CacheResolver</code>。将此注解放在类上不会打开任何缓存操作。</p><p>操作级自定义项将始终覆盖在<code>@CacheConfig</code>上设置的自定义项。因此，每个缓存操作都提供了三个级别的自定义项:</p><ul><li>全局配置, 适用于<code>CacheManager</code>, <code>KeyGenerator</code>.</li><li>在类级别, 使用@ <code>@CacheConfig</code>.</li><li>在操作级别</li></ul><h4 id="5-2-6-启用缓存注解"><a href="#5-2-6-启用缓存注解" class="headerlink" title="5.2.6. 启用缓存注解"></a>5.2.6. 启用缓存注解</h4><p>值得注意的是，即使声明缓存注解不会自动触发它们的操作(如Spring中的许多项)，该功能也必须以声明方式启用(这意味着如果您怀疑缓存是罪魁祸首，您可以通过只删除一个配置行而不是代码中的所有注解)。</p><p>要启用缓存注解，请将注解<code>@EnableCaching</code>添加到您的<code>@Configuration</code>类之一上:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@EnableCaching</span><br><br>public class AppConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在XML的配置中，可以使用<code>cache:annotation-driven</code> 元素:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:<span class="hljs-keyword">cache</span>=&quot;http://www.springframework.org/schema/<span class="hljs-keyword">cache</span>&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/<span class="hljs-keyword">cache</span> http://www.springframework.org/schema/<span class="hljs-keyword">cache</span>/spring-<span class="hljs-keyword">cache</span>.xsd&quot;&gt;<br>        &lt;<span class="hljs-keyword">cache</span>:annotation-driven/&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p><code>cache:annotation-driven</code> 元素和<code>@EnableCaching</code> 注解允许指定各种选项，从而影响通过AOP将缓存行为添加到应用程序的方式。此配置与<a href="https://sca.aliyun.com/learn/spring/integration/cache/data-access.html#tx-annotation-driven-settings"><code>@Transactional</code></a>很类似：</p><p>处理缓存注释的默认建议模式是<code>proxy</code>，它允许仅通过代理拦截调用。 同一类中的本地调用不能以这种方式截获。 对于更高级的拦截模式，请考虑结合编译时或加载时编织切换到<code>aspectj</code>模式。</p><p>有关实现<code>CachingConfigurer</code>所需的高级自定义（使用Java配置）的更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">javadoc</a>。</p><p>Table 12. Cache 注解设置</p><table><thead><tr><th>XML属性</th><th>注解属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>cache-manager</code></td><td>N&#x2F;A (see the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td>要使用的缓存管理器的名称。 使用此缓存管理器（或未设置的<code>cacheManager</code>）在后台初始化默认的<code>CacheResolver</code>。 要获得更精细的缓存fine-grained 管理，请考虑设置’cache-resolver’属性。</td><td><code>cacheManager</code></td></tr><tr><td><code>cache-resolver</code></td><td>N&#x2F;A (see the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td>A <code>SimpleCacheResolver</code> using the configured <code>cacheManager</code>.</td><td>用于解析后端缓存的CacheResolver的bean名称。 此属性不是必需的，只需要指定为’cache-manager’属性的替代。</td></tr><tr><td><code>key-generator</code></td><td>N&#x2F;A (see the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td><code>SimpleKeyGenerator</code></td><td>要使用的自定义键生成器的名称。</td></tr><tr><td><code>error-handler</code></td><td>N&#x2F;A (see the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td><code>SimpleCacheErrorHandler</code></td><td>要使用的自定义缓存错误处理程序的名称。 默认情况下，在缓存相关操作期间抛出的任何异常都会在客户端返回。</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td><code>proxy</code></td><td>默认模式（<code>proxy</code>）使用Spring的AOP框架处理要注释的注释bean（遵循代理语义，如前所述，仅适用于通过代理进入的方法调用）。 替代模式（<code>aspectj</code>）用Spring的AspectJ缓存方面编织受影响的类，修改目标类字节代码以应用于任何类型的方法调用。 AspectJ编织需要在类路径中使用<code>spring-aspects.jar</code>以及启用加载时织入（或编译时织入）。 （有关如何设置加载时织入的详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#aop-aj-ltw-spring">Spring configuration</a>。）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td><code>false</code></td><td>仅适用于代理模式。 控制为使用<code>@Cacheable</code>或<code>@CacheEvict</code>注解注释的类创建哪种类型的高速缓存代理。 如果<code>proxy-target-class</code> 属性设置为<code>true</code>，则创建基于类的代理。 如果<code>proxy-target-class</code>为<code>false</code>或者省略了该属性，则会创建基于标准JDK接口的代理。 （有关不同代理类型的详细检查，请参阅 <a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#aop-proxying">代理机制</a></td></tr><tr><td><code>order</code></td><td><code>order</code></td><td>Ordered.LOWEST_PRECEDENCE</td><td>定义应用于使用<code>@Cacheable</code>或<code>@CacheEvict</code>注解的bean的缓存通知的顺序。 （有关与订购AOP advice相关的规则的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#aop-ataspectj-advice-ordering">Advice Ordering</a>。）没有指定的排序意味着AOP子系统确定advice的顺序。</td></tr></tbody></table><p><code>&lt;cache:annotation-driven/&gt;</code>在 bean 中定义的应用程序上下文中只查找<code>@Cacheable/@CachePut/@CacheEvict/@Caching</code>。这意味着，如果你在<code>WebApplicationContext</code> 中为<code>DispatcherServlet</code>放置<code>&lt;cache:annotation-driven/&gt;</code>，他只会检查控制器中的bean，而不是你的服务。有关更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/integration/cache/web.html#mvc-servlet">MVC部分</a>。</p><p>方法可见和缓存注解</p><p>使用代理时，应仅将缓存注解应用于具有公共可见性的方法。如果使用这些注解对受保护的、私有的或包可见的方法进行注解，虽然不会引发任何错误，但注解的方法不会显示已配置的缓存设置。 如果需要在更改字节码本身时对非公共方法进行注解，请考虑使用AspectJ(请参阅本节的其余部分)</p><p>Spring建议您只用<code>@Cache*</code>注解来注解具体类(还有具体类的方法)，而不是注解接口。当然，您可以将<code>@Cache*</code>注解放在接口(或接口方法)上，但这只适用于您在使用基于代理时所期望的效果。Java注解不是从接口继承的这一事实意味着， 如果您使用的是基于类的代理(<code>proxy-target-class=&quot;true&quot;</code>)或weaving-based aspect(<code>mode=&quot;aspectj&quot;</code>)，则缓存设置无法被代理和编织基础结构，并且对象不会被包装在缓存代理中，这将是绝对糟糕的。</p><p>在代理模式(默认情况下), 仅截获通过代理进入的外部方法调用。这意味着，实际上，self-invocation在目标对象中调用目标对象的另一种方法时，在运行时不会导致实际的缓存，即使调用的方法标记为<code>@Cacheable</code>，考虑使用<code>aspectj</code>模式也是这种情况，此外，代理必须完全初始化以提供预期的行为，因此您不应依赖于初始化代码中的此功能，即<code>@PostConstruct</code>。</p><h4 id="5-2-7-使用自定义的注解"><a href="#5-2-7-使用自定义的注解" class="headerlink" title="5.2.7. 使用自定义的注解"></a>5.2.7. 使用自定义的注解</h4><p>自定义的注解和AspectJ</p><p>此功能仅在基于方法的情况下工作，但可以通过使用AspectJ的额外工作来启用。</p><p><code>spring-aspects</code> 模块定义了标准注解的切面。如果你定义自己的注解，则还需要为这些注解定义一个切面。请检查<code>AnnotationCacheAspect</code> 以查看示例：</p><p>缓存抽象允许您使用自己的注解来识别触发缓存储存或回收的方法。这在模板机制中非常方便，因为它消除了重复缓存注解声明的需要(在指定键或条件时尤其有用)，或者在您的代码库中不允许使用外部导入(<code>org.springframework</code>)。与<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#beans-stereotype-annotations">stereotype</a>注解的其余部分类似， <code>@Cacheable</code>, <code>@CachePut</code>、<code>@CacheEvict</code>, 和 <code>@CacheConfig</code>可以用作<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#beans-meta-annotations">meta-annotations</a>。这是可以注解其他注解的注解（就是元注解）。在下面的示例中，我们使用自己的自定义注释替换常见的<code>@Cacheable</code>声明：:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br><span class="hljs-variable">@Target</span>(&#123;ElementType.METHOD&#125;)<br><br><span class="hljs-variable">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;#isbn&quot;</span>)<br><br>public <span class="hljs-variable">@interface</span> SlowService &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中，我们定义了自己的<code>SlowService</code>注释，该注释本身使用<code>@Cacheable</code>进行注释。 现在我们可以替换以下代码:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;#isbn&quot;</span>)<br><br><span class="hljs-keyword">public</span> Book findBook(ISBN isbn, <span class="hljs-keyword">boolean</span> checkWarehouse, <span class="hljs-keyword">boolean</span> includeUsed)<br></code></pre></td></tr></table></figure><p>以下示例显示了自定义注释，我们可以使用它来替换前面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SlowService</span><br><br><span class="hljs-keyword">public</span> Book <span class="hljs-title function_">findBook</span><span class="hljs-params">(ISBN isbn, <span class="hljs-type">boolean</span> checkWarehouse, <span class="hljs-type">boolean</span> includeUsed)</span><br></code></pre></td></tr></table></figure><p>尽管<code>@SlowService</code>不是Spring注释，但容器会在运行时自动获取其声明并理解其含义。 请注意，<a href="https://sca.aliyun.com/learn/spring/integration/cache/?spm=0.29160081.0.0.51f92e5dCHrGI4#cache-annotation-enable">如前所述</a>，需要启用注释驱动的行为。</p><h3 id="5-3-JCache-JSR-107-注解"><a href="#5-3-JCache-JSR-107-注解" class="headerlink" title="5.3. JCache (JSR-107) 注解"></a>5.3. JCache (JSR-107) 注解</h3><p>自Spring框架4.1以来，缓存抽象完全支持JCache标准注释: <code>@CacheResult</code>, <code>@CachePut</code>, <code>@CacheRemove</code>, he <code>@CacheRemoveAll</code> 以及 <code>@CacheDefaults</code>, <code>@CacheKey</code>, 和 <code>@CacheValue</code>。这些注解可以正确地使用，而无需将缓存存储迁移到JSR-107。内部实现使用Spring的缓存抽象， 并提供默认的<code>CacheResolver</code>和<code>KeyGenerator</code>实现，它们符合规范。换言之，如果您已经在使用Spring的缓存抽象，则可以切换到这些标准注解，而无需更改缓存存储(或配置)。</p><h4 id="5-3-1-特性总结"><a href="#5-3-1-特性总结" class="headerlink" title="5.3.1. 特性总结"></a>5.3.1. 特性总结</h4><p>对于熟悉Spring缓存注解的用户，下表描述了Spring注解和JSR-107对应项之间的主要区别：</p><p>Table 13. Spring vs. JSR-107 缓存注解</p><table><thead><tr><th>Spring</th><th>JSR-107</th><th>备注</th></tr></thead><tbody><tr><td><code>@Cacheable</code></td><td><code>@CacheResult</code></td><td>非常相似。<code>@CacheResult</code>可以缓存特定的异常并强制执行该方法，而不管缓存的内容如何。</td></tr><tr><td><code>@CachePut</code></td><td><code>@CachePut</code></td><td>当Spring使用方法调用的结果更新缓存时，JCache要求将其作为使用<code>@CacheValue</code>注释的参数传递。 由于这种差异，JCache允许在实际方法调用之前或之后更新缓存。</td></tr><tr><td><code>@CacheEvict</code></td><td><code>@CacheRemove</code></td><td>非常相似。 当方法调用导致异常时，<code>@CacheRemove</code>支持条件回收。</td></tr><tr><td><code>@CacheEvict(allEntries=true)</code></td><td><code>@CacheRemoveAll</code></td><td>See <code>@CacheRemove</code>.</td></tr><tr><td><code>@CacheConfig</code></td><td><code>@CacheDefaults</code></td><td>允许您以类似的方式配置相同的概念。</td></tr></tbody></table><p>JCache具有与Spring的<code>CacheResolver</code>接口相同的<code>javax.cache.annotation.CacheResolver</code>，但JCache只支持单个缓存。默认情况下，一个简单的实现是根据注解上声明的名称检索要使用的缓存。 应该注意的是，如果在注解中没有指定缓存名称，则会自动生成默认值，参看<code>@CacheResult#cacheName()</code> 。</p><p><code>CacheResolver</code>实例由<code>CacheResolverFactory</code>检索。 可以为每个缓存操作自定义工厂，如以下示例所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@CacheResult(<span class="hljs-params">cacheNames=<span class="hljs-string">&quot;books&quot;</span>, cacheResolverFactory=MyCacheResolverFactory.<span class="hljs-keyword">class</span></span>) (<span class="hljs-params"><span class="hljs-number">1</span></span>)</span><br><br>public Book findBook(ISBN isbn)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、为此操作自定义工厂。</p><p>对于所有引用的类，Spring尝试查找具有给定类型的bean。如果存在多个匹配项，则会创建一个新实例，并且可以使用常规bean生命周期回调(如依赖项注入)。</p><p>键由<code>javax.cache.annotation.CacheKeyGenerator</code>方法生成，其作用与Spring的<code>KeyGenerator</code>一样。默认情况下，所有方法参数都将被考虑，除非至少有一个参数是用<code>@CacheKey</code>注解。这类似于Spring的<a href="https://sca.aliyun.com/learn/spring/integration/cache/?spm=0.29160081.0.0.51f92e5dCHrGI4#cache-annotations-cacheable-key">自定义键生成声明</a>。例如，同样的操作，一个使用Spring的抽象，另一个用JCache：:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Cacheable</span>(cacheNames=<span class="hljs-string">&quot;books&quot;</span>, key=<span class="hljs-string">&quot;#isbn&quot;</span>)public Book <span class="hljs-built_in">findBook</span>(ISBN isbn, boolean checkWarehouse, boolean includeUsed)<br><span class="hljs-variable">@CacheResult</span>(cacheName=<span class="hljs-string">&quot;books&quot;</span>)public Book <span class="hljs-built_in">findBook</span>(<span class="hljs-variable">@CacheKey</span> ISBN isbn, boolean checkWarehouse, boolean includeUsed)<br></code></pre></td></tr></table></figure><p>您还可以在操作上指定<code>CacheKeyResolver</code>，类似于指定<code>CacheResolverFactory</code>的方式。</p><p>JCache可以管理由注解的方法引发的异常。这可以防止缓存的更新，但也可以将异常缓存为失败的指示器，而不是再次调用该方法。让我们假设，如果ISBN的结构错误，则抛出<code>InvalidIsbnNotFoundException</code>。这是一个永久性的失败，没有book可以用这样的参数检索。下面抛出缓存异常，以便使用相同的无效ISBN进行进一步调用，直接抛出缓存的异常，而不是再次调用该方法。:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">@CacheResult</span>(cacheName=<span class="hljs-string">&quot;books&quot;</span>, exceptionCacheName=<span class="hljs-string">&quot;failures&quot;</span><br><br>            cachedExceptions = InvalidIsbnNotFoundException.<span class="hljs-keyword">class</span>)<br><br><span class="hljs-keyword">public</span> Book findBook(ISBN isbn)<br></code></pre></td></tr></table></figure><h4 id="5-3-2-启用-JSR-107-支持"><a href="#5-3-2-启用-JSR-107-支持" class="headerlink" title="5.3.2. 启用 JSR-107 支持"></a>5.3.2. 启用 JSR-107 支持</h4><p>除了Spring的声明性注解支持之外，不需要做任何具体的工作来启用JSR-107支持。如果<code>spring-context-support</code>模块已经在类加载路径中，那么使用<code>@EnableCaching</code>或者<code>cache:annotation-driven</code>元素都将自动启用JCache支持。</p><p>根据您的使用情况，选择使用与否由你选择。您甚至可以使用JSR-107 API和其他使用Spring自己的注解来混合使用服务。但是，请注意，如果这些服务影响到相同的缓存，则应使用一致的和相同的键生成实现。</p><h3 id="5-4-声明式基于XML的缓存"><a href="#5-4-声明式基于XML的缓存" class="headerlink" title="5.4. 声明式基于XML的缓存"></a>5.4. 声明式基于XML的缓存</h3><p>如果注解不是可选的(不能访问源代码或没有外部码)，则可以使用XML进行声明性缓存。因此，您不必对缓存方法进行注解，而是在外部指定目标方法和缓存指令(类似于声明性事务管理<a href="https://sca.aliyun.com/learn/spring/integration/cache/data-access.html#transaction-declarative-first-example">advice</a>)。上一节中的示例可以转换为以下示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- the service we want to make cacheable --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.service.DefaultBookService&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- cache definitions --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cache:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheAdvice&quot;</span> <span class="hljs-attr">cache-manager</span>=<span class="hljs-string">&quot;cacheManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">cache:caching</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">cache:cacheable</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;findBook&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;#isbn&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">cache:cache-evict</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;loadBooks&quot;</span> <span class="hljs-attr">all-entries</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">cache:caching</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache:advice</span>&gt;</span><br><span class="hljs-comment">&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;cacheAdvice&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(* x.y.BookService.*(..))&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-comment">&lt;!-- cache manager definition omitted --&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的配置中，<code>bookService</code>是可以缓存的。缓存语义被保存在<code>cache:advice</code>定义中，指定了方法<code>findBooks</code>用于将数据放入缓存，而方法<code>loadBooks</code>用于回收数据。这两个定义都可以使用 <code>books</code>缓存。</p><p><code>aop:config</code>定义使用AspectJ切点表达式将缓存通知应用于程序中的适当的切点(更多信息参看<a href="https://sca.aliyun.com/learn/spring/integration/cache/core.html#aop">Spring面向切面编程</a>)。在前面的示例中，将考虑<code>BookService</code>中的所有方法，并将缓存advice应用于它们。</p><p>声明性XML缓存支持所有基于注解的模型，因此在两者之间转换应该相当简单。在同一个应用程序中可以进一步使用它们。基于XML的方法不会设计到目标代码，但是编写它非常冗长无聊。在处理具有针对缓存的重载方法的类时，确定正确的方法确实需要额外工作，因为该方法参数不能很好的被辨别。在这些情况下， 在这些情况下，您可以使用AspectJ切入点来挑选目标方法并应用适当的缓存功能。然而，通过XML，更容易应用在包&#x2F;组&#x2F;接口范围上的缓存(再次因为AspectJ切点)和创建类似模板的定义(如我们在上面的例子中通过缓存定义目标的<code>cache:definitions</code>属性。</p><h3 id="5-5-配置缓存的存储"><a href="#5-5-配置缓存的存储" class="headerlink" title="5.5. 配置缓存的存储"></a>5.5. 配置缓存的存储</h3><p>缓存抽象集成了多个存储功能，可以开箱即用。为了使用他们，您需要声明一个适当的<code>CacheManager</code> （一个控制和管理<code>Cache</code>实例的实体，可用于检索这些实例以进行存储）。</p><h4 id="5-5-1-基于JDKConcurrentMap-缓存"><a href="#5-5-1-基于JDKConcurrentMap-缓存" class="headerlink" title="5.5.1. 基于JDKConcurrentMap 缓存"></a>5.5.1. 基于JDK<code>ConcurrentMap</code> 缓存</h4><p>基于JDK的<code>Cache</code>实现位于<code>org.springframework.cache.concurrent</code>包下。它允许您使用<code>ConcurrentHashMap</code>作为支持<code>Cache</code>存储。 以下示例显示如何配置两个缓存:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- simple cache manager --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.support.SimpleCacheManager&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;caches&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;default&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;books&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的代码段使用<code>SimpleCacheManager</code>为名为<code>default</code>和<code>books</code>的两个嵌套的<code>ConcurrentMapCache</code>实例创建<code>CacheManager</code>。请注意，这些名称是为每个缓存直接配置的。</p><p>由于缓存是由应用程序创建的，因此它被绑定到其生命周期，使其适合于基本用例、测试或简单应用程序。高速缓存的规模很大，而且速度非常快，但它不提供任何管理或持久性功能，也没有任何回收的程序。</p><h4 id="5-5-2-基于Ehcache的缓存"><a href="#5-5-2-基于Ehcache的缓存" class="headerlink" title="5.5.2. 基于Ehcache的缓存"></a>5.5.2. 基于Ehcache的缓存</h4><p>Ehcache 3.x完全与JSR-107兼容， 不需要专门的支持。</p><p>Ehcache 2.x实现在<code>org.springframework.cache.ehcache</code>包中。同样地，要使用它，需要简单地声明适当的 <code>CacheManager</code>。以下示例显示了如何执行此操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span> <span class="hljs-attr">p:cache-manager-ref</span>=<span class="hljs-string">&quot;ehcache&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- EhCache library setup --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ehcache&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span> <span class="hljs-attr">p:config-location</span>=<span class="hljs-string">&quot;ehcache.xml&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>此设置引导Spring IoC内部的ehcache库（通过<code>ehcache</code> bean），然后将其连接到专用的<code>CacheManager</code>实现中。 请注意，从<code>ehcache.xml</code>读取整个特定于<code>ehcache</code>的配置。</p><h4 id="5-5-3-Caffeine-Cache"><a href="#5-5-3-Caffeine-Cache" class="headerlink" title="5.5.3. Caffeine Cache"></a>5.5.3. Caffeine Cache</h4><p>Caffeine是Java 8重写了Guava的缓存，他的实现在<code>org.springframework.cache.caffeine</code>包中，并且提供了访问Caffeine特性的方法。</p><p>以下示例配置一个按需创建缓存的<code>CacheManager</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span><br><br>        <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>还可以提供缓存以显式使用，在这种情况下，只有manager才能提供这些内容。以下示例显示了如何执行此操作:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;caches&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>books<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Caffeine <code>CacheManager</code>也支持自定义的<code>Caffeine</code> 和 <code>CacheLoader</code>. 查阅 <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine 文档</a>了解更多信息。</p><h4 id="5-5-4-基于GemFire的缓存"><a href="#5-5-4-基于GemFire的缓存" class="headerlink" title="5.5.4. 基于GemFire的缓存"></a>5.5.4. 基于GemFire的缓存</h4><p>GemFire是一个面向内存&#x2F;磁盘存储的全局的备份数据库，它具有可伸缩的、可持续的、可扩展的、具有内置模式订阅通知功能等等特性。全局复制的数据库。并提供全功能的边缘缓存。 有关如何将GemFire用作<code>CacheManager</code>（以及更多）的更多信息，请参阅<a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire参考文档</a>。</p><h4 id="5-5-5-JSR-107-缓存"><a href="#5-5-5-JSR-107-缓存" class="headerlink" title="5.5.5. JSR-107 缓存"></a>5.5.5. JSR-107 缓存</h4><p>JSR-107兼容的缓存也可用于Spring的缓存抽象。JCache实现在<code>org.springframework.cache.jcache</code> 包中.</p><p>同样，要使用它，需要简单地声明适当的<code>CacheManager</code>。简单示例如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.jcache.JCacheCacheManager&quot;</span>        <span class="hljs-attr">p:cache-manager-ref</span>=<span class="hljs-string">&quot;jCacheManager&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- JSR-107 cache manager setup  --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jCacheManager&quot;</span> <span class="hljs-attr">...</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-5-6-处理没有后端的缓存"><a href="#5-5-6-处理没有后端的缓存" class="headerlink" title="5.5.6.处理没有后端的缓存"></a>5.5.6.处理没有后端的缓存</h4><p>有时在切换环境或进行测试时， 可能会只声明缓存， 而没有配置实际的后端缓存。由于这是一个无效的配置， 在运行时将引发异常， 因为缓存基础结构无法找到合适的存储。在这样的情况下， 与其删除缓存声明(这可能会很繁琐)， 你不如声明一个简单的，不执行缓存的虚拟缓存， 即强制每次执行缓存的方法。以下示例显示了如何执行此操作:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cacheManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.cache.support.CompositeCacheManager&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheManagers&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;jdkCache&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;gemfireCache&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fallbackToNoOpCache&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>CompositeCacheManager</code>使用了多个<code>CacheManager</code>实例。此外，通过<code>fallbackToNoOpCache</code> 标志，添加了一个没有op的缓存，为所有的定义没有被配置的缓存管理器处理。 也就是说，在<code>jdkCache</code>或<code>gemfireCache</code>(上面配置)中找不到的每个缓存定义都将由无op缓存来处理，并且不会存储目标方法的信息而方法每次都会被执行（就是多配置成可执行的无缓存操作）。</p><h3 id="5-6-各种各样的后端缓存插件"><a href="#5-6-各种各样的后端缓存插件" class="headerlink" title="5.6. 各种各样的后端缓存插件"></a>5.6. 各种各样的后端缓存插件</h3><p>显然，有大量的缓存产品可以用作后端存储。要将它们集成，需要提供<code>CacheManager</code>和<code>Cache</code>实现，因为不幸的是没有可用的标准，我们可以改用它。这听起来可能比使用它更难，因为在实践中，类往往是简单的<a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapters</a>，它将缓存抽象框架映射到存储API的顶部，就像<code>ehcache</code>类可以显示的那样。 大多数<code>CacheManager</code>类可以使用<code>org.springframework.cache.support</code>包中的类，如<code>AbstractCacheManager</code>，它负责处理样板代码，只留下实际的映射即可结束工作。我们希望，提供与Spring集成的库能够及时填补这一小的配置缺口。</p><h3 id="5-7-我可以如何设置TTL-TTI-Eviction-policy-XXX特性"><a href="#5-7-我可以如何设置TTL-TTI-Eviction-policy-XXX特性" class="headerlink" title="5.7. 我可以如何设置TTL&#x2F;TTI&#x2F;Eviction policy&#x2F;XXX特性?"></a>5.7. 我可以如何设置TTL&#x2F;TTI&#x2F;Eviction policy&#x2F;XXX特性?</h3><p>直接通过缓存提供程序。 缓存抽象是抽象，而不是缓存实现。 您正在使用的解决方案可能支持不同的数据策略和不同的拓扑结构，而其他解决方案不会这样做(例如，JDK <code>ConcurrentHashMap</code> - 暴露在缓存抽象中将是无用的，因为没有后端支持)。应该通过后端缓存（配置时）或通过其本机API直接控制此类功能。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定时任务</title>
    <link href="/post/5eba1caa-2b0b-423d-9e75-b17d9e3086ba/"/>
    <url>/post/5eba1caa-2b0b-423d-9e75-b17d9e3086ba/</url>
    
    <content type="html"><![CDATA[<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><p>Spring 教程</p><hr><h2 id="6-执行任务和任务计划"><a href="#6-执行任务和任务计划" class="headerlink" title="6. 执行任务和任务计划"></a>6. 执行任务和任务计划</h2><p>Spring框架分别为异步执行、<code>TaskExecutor</code>的任务调度和<code>TaskScheduler</code>接口提供了抽象。Spring还具有支持线程池或委派到应用程序服务器环境CommonJ的接口实现。最终， 在Java SE 5、Java SE 6和Java EE有差异的环境都实现了一套公共的抽象接口。</p><p>Spring还具有集成类，支持使用<code>Timer</code>（JDK自1.3以来的一部分）和Quartz Scheduler（<a href="http://quartz-scheduler.org/">http://quartz-scheduler.org</a>）进行调度。 您可以使用<code>FactoryBean</code>同时分别对<code>Timer</code>或<code>Trigger</code>实例进行可选引用来设置这两个调度程序。 此外，还提供了Quartz Scheduler和 <code>Timer</code>的便捷类，它允许您调用现有目标对象的方法（类似于正常的<code>MethodInvokingFactoryBean</code>操作）。</p><h3 id="6-1-Spring-TaskExecutor-抽象"><a href="#6-1-Spring-TaskExecutor-抽象" class="headerlink" title="6.1. Spring TaskExecutor 抽象"></a>6.1. Spring <code>TaskExecutor</code> 抽象</h3><p>Executors是JDK中使用的线程池的名字，executor意思是无法保证底层的实现实际是一个池，一个executor可以是单线程的或者是同步的。Spring的抽象隐藏了Java SE和Java EE环境之间的实现细节。</p><p>Spring的<code>TaskExecutor</code>接口和<code>java.util.concurrent.Executor</code>接口是相同的。实际上，他存在的主要原因是在使用线程池时对Java 5抽象的程度不同。该接口有一个 (<code>execute(Runnable task)</code>)方法,它根据线程池的语义和配置接受执行任务.</p><p>最初创建<code>TaskExecutor</code>是为了给其他Spring组件提供所需的线程池抽象。诸如<code>ApplicationEventMulticaster</code>，JMS的<code>AbstractMessageListenerContainer</code>和Quartz集成之类的组件都使用 <code>TaskExecutor</code>抽象来池化线程。 但是，如果您的bean需要线程池行为，您也可以根据自己的需要使用此抽象。</p><h4 id="6-1-1-TaskExecutor-类型"><a href="#6-1-1-TaskExecutor-类型" class="headerlink" title="6.1.1. TaskExecutor 类型"></a>6.1.1. <code>TaskExecutor</code> 类型</h4><p>Spring包含许多TaskExecutor的预构建实现。很可能，你永远不需要实现自己的。 Spring提供的变体如下:</p><ul><li><code>SyncTaskExecutor</code>: 此实现不会异步执行调用。 相反，每次调用都发生在调用线程中。 它主要用于不需要多线程的情况，例如在简单的测试用例中。</li><li><code>SimpleAsyncTaskExecutor</code>: 此实现不会重用任何线程。 相反，它为每次调用启动一个新线程。 但是，它确实支持并发限制，该限制会阻止任何超出限制的调用，直到释放一个插槽。 如果您正在寻找真正的池，请参阅此列表中稍后的<code>ThreadPoolTaskExecutor</code>。</li><li><code>ConcurrentTaskExecutor</code>: 此实现是 <code>java.util.concurrent.Executor</code>对象的适配器。有一个可选的<code>ThreadPoolTaskExecutor</code>，它将 <code>Executor</code>配置参数作为bean属性公开。很少需要使用到<code>ConcurrentTaskExecutor</code>，但如果<code>ThreadPoolTaskExecutor</code>不够灵活，那么你就需要<code>ConcurrentTaskExecutor</code>。</li><li><code>ThreadPoolTaskExecutor</code>: 这种实现是最常用的。 它公开了bean属性，用于配置<code>java.util.concurrent.ThreadPoolExecutor</code>并将其包装在<code>TaskExecutor</code>中。 如果您需要适应不同类型的<code>java.util.concurrent.Executor</code>，我们建议您使用<code>ConcurrentTaskExecutor</code>。</li><li><code>WorkManagerTaskExecutor</code>: 此实现使用CommonJ <code>WorkManager</code>作为其后备服务提供程序，并且是在Spring应用程序上下文中在WebLogic或WebSphere上设置基于CommonJ的线程池集成的中心便利类。</li><li><code>DefaultManagedTaskExecutor</code>: 此实现在JSR-236兼容的运行时环境（例如Java EE 7+应用程序服务器）中使用JNDI获取的<code>ManagedExecutorService</code>，为此目的替换CommonJ WorkManager。</li></ul><h4 id="6-1-2-使用-TaskExecutor"><a href="#6-1-2-使用-TaskExecutor" class="headerlink" title="6.1.2. 使用 TaskExecutor"></a>6.1.2. 使用 <code>TaskExecutor</code></h4><p>Spring的 <code>TaskExecutor</code>实现用作简单的JavaBeans。 在下面的示例中，我们定义了一个使用<code>ThreadPoolTaskExecutor</code>异步打印出一组消息的bean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.core.task.TaskExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskExecutorExample</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessagePrinterTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> String message;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessagePrinterTask</span><span class="hljs-params">(String message)</span> &#123;<br>            <span class="hljs-built_in">this</span>.message = message;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(message);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TaskExecutor taskExecutor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskExecutorExample</span><span class="hljs-params">(TaskExecutor taskExecutor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.taskExecutor = taskExecutor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMessages</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br>            taskExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessagePrinterTask</span>(<span class="hljs-string">&quot;Message&quot;</span> + i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如您所见，您可以将<code>Runnable</code>添加到队列中，而不是从池中检索线程并自行执行。 然后，<code>TaskExecutor</code>使用其内部规则来确定任务何时执行。</p><p>要配置<code>TaskExecutor</code>使用的规则，我们公开了简单的bean属性:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskExecutor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;corePoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;queueCapacity&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskExecutorExample&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;TaskExecutorExample&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;taskExecutor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-2-Spring-TaskScheduler-抽象"><a href="#6-2-Spring-TaskScheduler-抽象" class="headerlink" title="6.2. Spring TaskScheduler 抽象"></a>6.2. Spring <code>TaskScheduler</code> 抽象</h3><p>除了<code>TaskExecutor</code>抽象之外，Spring 3.0还引入了一个<code>TaskScheduler</code>，它具有各种方法，可以在将来的某个时刻调度任务。 以下清单显示了<code>TaskScheduler</code>接口定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskScheduler</span> &#123;<br><br>    ScheduledFuture <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable task, Trigger trigger)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable task, Instant startTime)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable task, Date startTime)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleAtFixedRate</span><span class="hljs-params">(Runnable task, Instant startTime, Duration period)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleAtFixedRate</span><span class="hljs-params">(Runnable task, Date startTime, <span class="hljs-type">long</span> period)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleAtFixedRate</span><span class="hljs-params">(Runnable task, Duration period)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleAtFixedRate</span><span class="hljs-params">(Runnable task, <span class="hljs-type">long</span> period)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleWithFixedDelay</span><span class="hljs-params">(Runnable task, Instant startTime, Duration delay)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleWithFixedDelay</span><span class="hljs-params">(Runnable task, Date startTime, <span class="hljs-type">long</span> delay)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleWithFixedDelay</span><span class="hljs-params">(Runnable task, Duration delay)</span>;<br><br>    ScheduledFuture <span class="hljs-title function_">scheduleWithFixedDelay</span><span class="hljs-params">(Runnable task, <span class="hljs-type">long</span> delay)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最简单的方法是一个名为<code>schedule</code>的方法，它只接受<code>Runnable</code>和<code>Date</code>。 这会导致任务在指定时间后运行一次。 所有其他方法都能够安排任务重复运行。 通过这些方法，在简单的周期中需要以固定频率和固定时间间隔方法执行任务是实现的，但接受<code>Trigger</code>会更方便。</p><h4 id="6-2-1-Trigger-接口"><a href="#6-2-1-Trigger-接口" class="headerlink" title="6.2.1. Trigger 接口"></a>6.2.1. <code>Trigger</code> 接口</h4><p><code>Trigger</code>接口基本上受到JSR-236的启发，从Spring 3.0开始，它尚未正式实现。Trigger的基本思想是可以基于过去的执行结果或甚至任意条件来确定执行时间。如果这些确定考虑到了前一次执行的结果， 则该信息在<code>TriggerContext</code>中可用。<code>Trigger</code> 接口本身非常简单：:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Trigger</span> &#123;<br>    Date nextExecutionTime(TriggerContext triggerContext);&#125;<br></code></pre></td></tr></table></figure><p><code>TriggerContext</code>是最重要的部分。 它封装了所有相关数据，如有必要，将来可以进行扩展。 <code>TriggerContext</code>是一个接口（默认情况下使用 <code>SimpleTriggerContext</code>实现）。 以下清单显示了<code>Trigger</code>实现的可用方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">TriggerContext</span> &#123;<br>    <span class="hljs-function">Date <span class="hljs-title">lastScheduledExecutionTime</span>()</span>;<br>    <span class="hljs-function">Date <span class="hljs-title">lastActualExecutionTime</span>()</span>;<br>    <span class="hljs-function">Date <span class="hljs-title">lastCompletionTime</span>()</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-Trigger-实现"><a href="#6-2-2-Trigger-实现" class="headerlink" title="6.2.2. Trigger 实现"></a>6.2.2. <code>Trigger</code> 实现</h4><p>Spring提供了两个<code>Trigger</code>接口的实现 ， 最有趣的是<code>CronTrigger</code>。 它支持基于cron表达式调度任务。例如，以下任务被安排在每小时超过15分钟， 但仅在工作日的早上9时到下午5时”营业时间”内运行:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">scheduler.schedule(<span class="hljs-keyword">task</span>, <span class="hljs-keyword">new</span> CronTrigger(<span class="hljs-string">&quot;0 15 9-17 * * MON-FRI&quot;</span>));<br></code></pre></td></tr></table></figure><p>另一个现成的实现是<code>PeriodicTrigger</code>,它接受一个固定的周期、一个可选的初始延迟值和一个布尔值来指示该期间是否应解释为固定速率或固定延迟。由于<code>TaskScheduler</code>接口已经定义了以固定速率或固定延迟来调度任务的方法，因此应该尽可能直接使用这些方法。 <code>PeriodicTrigger</code>实现的价值在于，它可以在依赖于<code>Trigger</code>抽象的组件中使用。例如，允许周期性触发器、cron-based触发器、甚至是可互换使用的自定义触发器实现，可能会很方便。此类组件可以利用依赖项注入，这样可以在外部配置此类<code>Triggers</code>，因此容易修改或扩展。</p><h4 id="6-2-3-TaskScheduler-实现"><a href="#6-2-3-TaskScheduler-实现" class="headerlink" title="6.2.3. TaskScheduler 实现"></a>6.2.3. <code>TaskScheduler</code> 实现</h4><p>与Spring的<code>TaskExecutor</code>抽象一样， <code>TaskScheduler</code>的主要好处是，依赖于调度行为的代码不必与特定的调度程序实现耦合。当在应用程序服务器环境中运行时，不应由应用程序本身直接创建线程，因此提供的灵活性尤其重要。对于这种情况， Spring提供了一个<code>TimerManagerTaskScheduler</code>，它委托给WebLogic或WebSphere上的CommonJ <code>TimerManager</code>，以及一个委托给Java EE 7+环境中的JSR-236 <code>ManagedScheduledExecutorService</code>的更新的<code>DefaultManagedTaskScheduler</code>。 两者通常都配置有JNDI查找。</p><p>每当外部线程管理不是必需的时候，更简单的替代方案是应用程序中的本地<code>ScheduledExecutorService</code>设置，可以通过Spring的<code>ConcurrentTaskScheduler</code>进行调整。 为方便起见，Spring还提供了一个<code>ThreadPoolTaskScheduler</code>，它在内部委托给<code>ScheduledExecutorService</code>，以提供沿<code>ThreadPoolTaskExecutor</code>行的公共bean样式配置。些变体适用于宽松应用程序服务器环境中的本地嵌入式线程池设置，特别是在Tomcat和Jetty上。</p><h3 id="6-3-对调度和异步执行的注解支持"><a href="#6-3-对调度和异步执行的注解支持" class="headerlink" title="6.3. 对调度和异步执行的注解支持"></a>6.3. 对调度和异步执行的注解支持</h3><p>Spring为任务调度和异步方法执行提供了注解支持</p><h4 id="6-3-1-启用调度注解"><a href="#6-3-1-启用调度注解" class="headerlink" title="6.3.1. 启用调度注解"></a>6.3.1. 启用调度注解</h4><p>要启用对<code>@Scheduled</code>和<code>@Async</code>注解的支持，请将<code>@EnableScheduling</code>和<code>@EnableAsync</code>添加到您的<code>@Configuration</code> 类中。如下例所示：:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@EnableAsync</span><br><br><span class="hljs-variable">@EnableScheduling</span><br><br>public class AppConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>您可以自由选择您的应用程序的相关注解。例如，如果您只需要支持<code>@Scheduled</code>，那么就省略<code>@EnableAsync</code>。对于更多的fine-grained控制，您可以另外实现<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html"><code>SchedulingConfigurer</code></a>和&#x2F;或<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html"><code>AsyncConfigurer</code></a>接口。有关详细信息，请参阅对应的javadocs。</p><p>如果您喜欢XML配置， 请使用<code>&lt;task:annotation-driven&gt;</code> 元素。如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:annotation-driven <span class="hljs-attribute">executor</span>=<span class="hljs-string">&quot;myExecutor&quot;</span> <span class="hljs-attribute">scheduler</span>=<span class="hljs-string">&quot;myScheduler&quot;</span>/&gt;<br><br>&lt;task:executor <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myExecutor&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;<br><br>&lt;task:scheduler <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myScheduler&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>请注意，在上面的XML中，提供了一个执行器引用来处理与<code>@Async</code>注解的方法对应的那些任务，并提供了调度程序引用来管理那些用<code>@Scheduled</code>注解的方法。</p><p>处理<code>@Async</code>注解的默认建议模式是<code>proxy</code>，它允许仅通过代理拦截调用。 同一类中的本地调用不能以这种方式截获。 对于更高级的拦截模式，请考虑结合编译时或加载时编织切换到<code>aspectj</code>模式。</p><h4 id="6-3-2-Scheduled-注解"><a href="#6-3-2-Scheduled-注解" class="headerlink" title="6.3.2. @Scheduled 注解"></a>6.3.2. <code>@Scheduled</code> 注解</h4><p>可以将 <code>@Scheduled</code>注解与触发器元数据一起添加到方法中。例如， 下面的方法每隔5秒调用一次固定的延迟， 这意味着该期间将从每次调用的完成时间计算:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">@Scheduled(fixedDelay=5000)<br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> void doSomething() &#123;<br><br>    // something that should<span class="hljs-built_in"> execute </span>periodically<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要安装固定的速度来执行，只需简单的改变注解中的属性名即可执行。下面可以每5秒执行速度在每个调用开始后：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">@Scheduled(fixedRate=5000)<br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> void doSomething() &#123;<br><br>    // something that should<span class="hljs-built_in"> execute </span>periodically<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于固定延迟和固定速率任务， 可以指定初始延迟， 指示在第一次执行该方法之前等待的毫秒数。如下面的 <code>fixedRate</code>示例所示:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">@Scheduled(initialDelay=1000, fixedRate=5000)<br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> void doSomething() &#123;<br><br>    // something that should<span class="hljs-built_in"> execute </span>periodically<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果简单的周期调度不够表达你的意愿， 则可以提供cron表达式。例如， 以下任务将只在工作日执行。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">@Scheduled(cron=<span class="hljs-string">&quot;*/5 * * * * MON-FRI&quot;</span>)<br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> void doSomething() &#123;<br><br>    // something that should<span class="hljs-built_in"> execute </span>on weekdays only<br><br>&#125;<br></code></pre></td></tr></table></figure><p>你可以使用 <code>zone</code>属性来指定解析cron表达式的时区</p><p>请注意，要计划的方法必须具有void返回，并且不能期望为任何参数。如果该方法需要与应用程序上下文中的其他对象进行交互， 则通常是通过依赖项注入提供的。</p><p>在Spring 4.3框架中， 任何范围的bean都支持<code>@Scheduled</code> 方法。</p><p>请确保在运行时不会在同一个<code>@Scheduled</code>注解类上初始化多个实例，除非您确实希望为每个此类实例都安排回调。与此相关，请确保不要在bean类上使用<code>@Configurable</code>，并将其与容器<code>@Scheduled</code>并注册为常规的Spring bean。如果是这样， 程序将会双重初始化，否则，一旦通过容器，并通过@Configurable切面，每个<code>@Scheduled</code>方法的结果都将被调用两次。</p><h4 id="6-3-3-Async-注解"><a href="#6-3-3-Async-注解" class="headerlink" title="6.3.3. @Async 注解"></a>6.3.3. <code>@Async</code> 注解</h4><p>可以在方法上提供<code>@Async</code>注解，以便发生该方法的异步调用。换言之，调用方将在调用时立即返回，并且该方法的实际执行将发生在已提交到Spring <code>TaskExecutor</code>的任务中。在最简单的情况下，注解可以应用于<code>void</code>返回方法。如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Async</span><br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-comment">// this will be executed asynchronously</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>与使用<code>@Scheduled</code>注解的注解方法不同，这些方法可以有预期参数的，因为调用方将在运行时以“normal”方式调用它们，而不是由容器管理的计划任务。例如，以下是<code>@Async</code>注解的合法应用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Async</span><br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br><br>    <span class="hljs-comment">// this will be executed asynchronously</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>即使返回值的方法也可以异步调用，但是，此类方法需要具有<code>Future</code>类型的返回值。这仍然提供了异步执行的好处，以便调用者可以在调用<code>Future</code>上的<code>get()</code>之前执行其他任务。以下示例显示如何在返回值的方法上使用<code>@Async</code> :</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Async</span><br><br><span class="hljs-title class_">Future</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">returnSomething</span>(<span class="hljs-params">int i</span>) &#123;<br><br>    <span class="hljs-comment">// this will be executed asynchronously</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Async</code>方法不仅可以声明一个常规的<code>java.util.concurrent.Future</code>返回类型，而且还可能是spring的<code>org.springframework.util.concurrent.ListenableFuture</code> 或者如Spring 4.2版本后,存在于JDK8的<code>java.util.concurrent.CompletableFuture</code>。用于与异步任务进行更丰富的交互，以及通过进一步的处理步骤进行组合操作。</p><p><code>@Async</code>不能与生命周期回调(如 <code>@PostConstruct</code>)一起使用。若要异步初始化Spring bean，则当前必须使用单独的初始化Spring bean，然后在目标上调用<code>@Async</code>注解方法。如下:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleBeanImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SampleBean</span> </span>&#123;<br>    <span class="hljs-meta">@Async</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleBeanInitializer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SampleBean bean;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleBeanInitializer</span><span class="hljs-params">(SampleBean bean)</span> </span>&#123;        <span class="hljs-keyword">this</span>.bean = bean;    &#125;<br>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;        bean.doSomething();    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有直接的XML配置等价于<code>@Async</code>，因为这些方法应该首先设计为异步执行，而不是外部得来的。但是，您可以手动设置Spring的<code>AsyncExecutionInterceptor</code>与Spring AOP结合使用自定义切点。</p><h4 id="6-3-4-使用-Async的Executor的条件"><a href="#6-3-4-使用-Async的Executor的条件" class="headerlink" title="6.3.4. 使用 @Async的Executor的条件"></a>6.3.4. 使用 <code>@Async</code>的Executor的条件</h4><p>默认情况下，在方法上指定<code>@Async</code>时，使用的执行程序是 <a href="https://sca.aliyun.com/learn/spring/integration/scheduling/?spm=0.29160081.0.0.51f92e5dCHrGI4#scheduling-enable-annotation-support">启用异步支持时配置</a>的执行程序，例如，如果使用XML或<code>AsyncConfigurer</code>实现（如果有），则为“annotation-driven”元素。但是，当需要指示执行给定方法时，应使用非默认的执行器时，可以使用<code>@Async</code>注解的<code>value</code>属性。以下示例显示了如何执行此操作:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Async</span>(<span class="hljs-string">&quot;otherExecutor&quot;</span>)<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br><br>    <span class="hljs-comment">// this will be executed asynchronously by &quot;otherExecutor&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，<code>&quot;otherExecutor&quot;</code>可以是Spring容器中任何<code>Executor</code> bean的名称，也可以是与任何<code>Executor</code> 关联的限定符的名称（例如，使用<code>&lt;qualifier&gt;</code>元素或Spring的<code>@Qualifier</code>注解指定）</p><h4 id="6-3-5-使用-Async的异常管理"><a href="#6-3-5-使用-Async的异常管理" class="headerlink" title="6.3.5. 使用@Async的异常管理"></a>6.3.5. 使用<code>@Async</code>的异常管理</h4><p>当<code>@Async</code>方法有<code>Future</code>类型的返回值时，可以很容易地管理在方法执行期间引发的异常，因为当调用对<code>Future</code>结果的<code>get</code>时将引发此异常。但是，对于 <code>void</code>返回类型，异常是无法捕获的，无法传输的。对于这些情况，可以提供<code>AsyncUncaughtExceptionHandler</code>来处理此类异常。 以下示例显示了如何执行此操作：:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAsyncUncaughtExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncUncaughtExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handleUncaughtException</span>(<span class="hljs-params">Throwable ex, Method method, <span class="hljs-built_in">Object</span>... params</span>) &#123;        <span class="hljs-comment">// handle exception    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>默认情况下，仅记录异常。 您可以使用<code>AsyncConfigurer</code>或<code>&lt;task:annotation-driven/&gt;</code>XML元素定义自定义<code>AsyncUncaughtExceptionHandler</code>。</p><h3 id="6-4-task-命名空间"><a href="#6-4-task-命名空间" class="headerlink" title="6.4. task 命名空间"></a>6.4. <code>task</code> 命名空间</h3><p>从Spring 3.0开始，有一个用于配置<code>TaskExecutor</code>和<code>TaskScheduler</code>实例的XML命名空间。</p><h4 id="6-4-1-‘scheduler’-元素"><a href="#6-4-1-‘scheduler’-元素" class="headerlink" title="6.4.1. ‘scheduler’ 元素"></a>6.4.1. ‘scheduler’ 元素</h4><p>下面的元素将创建具有指定线程池大小的<code>ThreadPoolTaskScheduler</code> 实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:scheduler <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;scheduler&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>为<code>id</code>属性提供的值将用作池中线程名称的前缀，<code>scheduler</code> 元素相对非常简单。如果不提供<code>pool-size</code> 属性，则默认的线程池将只有一个线程。计划程序再也没有其他配置选项。</p><h4 id="6-4-2-executor-元素"><a href="#6-4-2-executor-元素" class="headerlink" title="6.4.2. executor 元素"></a>6.4.2. <code>executor</code> 元素</h4><p>以下创建一个<code>ThreadPoolTaskExecutor</code> 实例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:executor <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;executor&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>与<a href="https://sca.aliyun.com/learn/spring/integration/scheduling/?spm=0.29160081.0.0.51f92e5dCHrGI4#scheduling-task-namespace-scheduler">上面</a>的调度程序一样，为<code>id</code>属性提供的值将用作池中线程名称的前缀。就池大小而言， <code>executor</code>元素支持比<code>scheduler</code>元素更多的配置选项。首先，<code>ThreadPoolTaskExecutor</code>的线程池本身更具可配置。执行器的线程池可能有不同的核心值和最大大小，，而不仅仅是单个的大小。如果提供了单个值，则执行器将具有固定大小的线程池(核心和最大大小相同)。 但是，<code>executor</code> 元素的<code>pool-size</code> 属性也接受以<code>min-max</code>形式的范围。以下示例将最小值设置为<code>5</code>，最大值设置为<code>25</code>:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:executor<br><br>        <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;executorWithPoolSizeRange&quot;</span><br><br>        <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;5-25&quot;</span><br><br>        <span class="hljs-attribute">queue-capacity</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>从该配置中可以看出，还提供了<code>queue-capacity</code> (队列容量)值。还应根据执行者的队列容量来考虑线程池的配置，有关池大小和队列容量之间关系的详细说明，请参阅<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html"><code>ThreadPoolExecutor</code></a>的文档。 主要的想法是，在提交任务时，如果活动线程的数目当前小于核心大小，执行器将首先尝试使用一个空闲线程。如果已达到核心大小，则只要尚未达到其容量，就会将该任务添加到队列中。只有这样，如果已达到队列的容量，执行器将创建一个超出核心大小的新线程。如果还达到最大大小，，则执行器将拒绝该任务。</p><p>默认情况下，队列是无限制的，但一般不会这样配置，因为当所有池线程都运行时，如果将很多的任务添加到该队列中，则会导致<code>OutOfMemoryErrors</code>。此外，如果队列是无界的，则最大大小根本没有效果。由于执行器总是在创建超出核心大小的新线程之前尝试该队列，因此队列必须具有有限的容量，以使线程池超出核心大小(这就是为什么在使用无界队列时，固定大小池是唯一合理的情况)。</p><p>如上所述，在任务被拒绝时考虑这种情况。默认情况下，当任务被拒绝时，线程池执行程序会抛出<code>TaskRejectedException</code>。但是，拒绝策略实际上是可配置的。使用默认拒绝策略时抛出异常，即<code>AbortPolicy</code>实现。对于可以在高负载下跳过某些任务的应用程序，您可以改为配置<code>DiscardPolicy</code>或<code>DiscardOldestPolicy</code>。另一个适用于需要在高负载下限制提交任务的应用程序的选项是<code>CallerRunsPolicy</code>。该策略不是抛出异常或丢弃任务，而是强制调用submit方法的线程自己运行任务。这个想法是这样的调用者在运行该任务时很忙，并且不能立即提交其他任务。因此，它提供了一种简单的方法来限制传入的负载，同时保持线程池和队列的限制。通常，这允许执行程序“赶上”它正在处理的任务，从而释放队列，池中或两者中的一些容量。您可以从<code>executor</code>元素上的<code>rejection-policy</code>属性的可用值枚举中选择任何这些选项。</p><p>以下示例显示了一个<code>executor</code> 元素，其中包含许多属性以指定各种行为：:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:executor<br><br>        <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;executorWithCallerRunsPolicy&quot;</span><br><br>        <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;5-25&quot;</span><br><br>        <span class="hljs-attribute">queue-capacity</span>=<span class="hljs-string">&quot;100&quot;</span><br><br>        <span class="hljs-attribute">rejection-policy</span>=<span class="hljs-string">&quot;CALLER_RUNS&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>最后, <code>keep-alive</code>设置确定在终止之前线程可能保持空闲的时间限制(以秒为单位)。如果池中当前有多个线程的核心数目，则在等待此时间量后不处理任务，多余的线程将被终止。时间值为零将导致多余的线程在执行任务后立即终止，而不需要在任务队列中保留后续工作。以下示例将<code>keep-alive</code>值设置为两分钟：:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:executor<br><br>        <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;executorWithKeepAlive&quot;</span><br><br>        <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;5-25&quot;</span><br><br>        <span class="hljs-attribute">keep-alive</span>=<span class="hljs-string">&quot;120&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="6-4-3-‘scheduled-tasks’-元素"><a href="#6-4-3-‘scheduled-tasks’-元素" class="headerlink" title="6.4.3. ‘scheduled-tasks’ 元素"></a>6.4.3. ‘scheduled-tasks’ 元素</h4><p>Spring的任务命名空间的最强大功能是支持配置在Spring应用程序上下文中安排的任务。这遵循了类似于Spring中其他“method-invokers”的方法，例如由JMS命名空间提供的用于配置消息驱动的pojo。 基本上， <code>ref</code>属性可以指向任何Spring管理的对象， <code>method</code> 属性提供要在该对象上调用的方法的名称。 以下清单显示了一个简单示例：:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:scheduled-tasks <span class="hljs-attribute">scheduler</span>=<span class="hljs-string">&quot;myScheduler&quot;</span>&gt;    &lt;task:scheduled <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;beanA&quot;</span> <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;methodA&quot;</span> <span class="hljs-attribute">fixed-delay</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;&lt;/task:scheduled-tasks&gt;<br>&lt;task:scheduler <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myScheduler&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>Tscheduler由外部元素引用，每个单独的任务都包括其触发器元数据的配置。在前面的示例中，该元数据定义了一个定期触发器，它具有固定的延迟，表示每个任务执行完成后等待的毫秒数。另一个选项是”<code>fixed-rate</code>”，表示无论以前执行多长时间，方法的执行频率。此外， ，对于<code>fixed-delay</code>和<code>fixed-rate</code>任务，可以指定’initial-delay’参数，指示在第一次执行该方法之前等待的毫秒数。为了获得更多的控制，可以改为提供一个<code>cron</code>属性。下面是一个演示其他选项的示例:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;task:scheduled-tasks <span class="hljs-attribute">scheduler</span>=<span class="hljs-string">&quot;myScheduler&quot;</span>&gt;    &lt;task:scheduled <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;beanA&quot;</span> <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;methodA&quot;</span> <span class="hljs-attribute">fixed-delay</span>=<span class="hljs-string">&quot;5000&quot;</span> <span class="hljs-attribute">initial-delay</span>=<span class="hljs-string">&quot;1000&quot;</span>/&gt;    &lt;task:scheduled <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;beanB&quot;</span> <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;methodB&quot;</span> <span class="hljs-attribute">fixed-rate</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;    &lt;task:scheduled <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;beanC&quot;</span> <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;methodC&quot;</span> <span class="hljs-attribute">cron</span>=<span class="hljs-string">&quot;*/5 * * * * MON-FRI&quot;</span>/&gt;&lt;/task:scheduled-tasks&gt;<br>&lt;task:scheduler <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myScheduler&quot;</span> <span class="hljs-attribute">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="6-5-使用Quartz的Scheduler"><a href="#6-5-使用Quartz的Scheduler" class="headerlink" title="6.5. 使用Quartz的Scheduler"></a>6.5. 使用Quartz的Scheduler</h3><p>Quartz使用<code>Trigger</code>, <code>Job</code>, 和 <code>JobDetail</code>等对象来进行各种类型的任务调度。关于Quartz的基本概念，请参阅<a href="http://quartz-scheduler.org/">http://quartz-scheduler.org</a>。为了让基于Spring的应用程序方便使用，Spring提供了一些类来简化quartz的用法。</p><h4 id="6-5-1-使用JobDetailFactoryBean"><a href="#6-5-1-使用JobDetailFactoryBean" class="headerlink" title="6.5.1. 使用JobDetailFactoryBean"></a>6.5.1. 使用<code>JobDetailFactoryBean</code></h4><p>Quartz <code>JobDetail</code> 对象保存运行一个任务所需的全部信息。Spring提供一个叫作 <code>JobDetailFactoryBean</code>的类让JobDetail能对一些有意义的初始值(从XML配置)进行初始化，让我们来看个例子:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exampleJob&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;example.ExampleJob&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobDataAsMap&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;timeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>job detail 配置拥有所有运行job(<code>ExampleJob</code>)的必要信息。 可以通过job的data map来指定timeout。Job的data map可以通过<code>JobExecutionContext</code>（在运行时传递给你)来得到，但是 <code>JobDetail</code>同时把从job的data map中得到的属性映射到实际job中的属性中去。 所以，如果<code>ExampleJob</code>中包含一个名为 <code>timeout</code>的属性，<code>JobDetail</code>将自动为它赋值:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> example;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleJob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QuartzJobBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> int timeout;<br>    <span class="hljs-comment">/**     * Setter called after the ExampleJob is instantiated     * with the value from the JobDetailFactoryBean (5)     */</span>    public void setTimeout(int timeout) &#123;        <span class="hljs-keyword">this</span>.timeout = timeout;    &#125;<br>    <span class="hljs-keyword">protected</span> void executeInternal(<span class="hljs-type">JobExecutionContext</span> ctx) <span class="hljs-keyword">throws</span> <span class="hljs-type">JobExecutionException</span> &#123;        <span class="hljs-comment">// do the actual work    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>data map中的所有附加属性当然也可以使用的</p><p>使用<code>name</code>和<code>group</code>属性，你可以分别修改job在哪一个组下运行和使用什么名称。默认情况下，job的名称等于<code>JobDetailFactoryBean</code>的名称（在上面的例子中为<code>exampleJob</code>)。</p><h4 id="6-5-2-使用-MethodInvokingJobDetailFactoryBean"><a href="#6-5-2-使用-MethodInvokingJobDetailFactoryBean" class="headerlink" title="6.5.2. 使用 MethodInvokingJobDetailFactoryBean"></a>6.5.2. 使用 <code>MethodInvokingJobDetailFactoryBean</code></h4><p>通常情况下，你只需要调用特定对象上的一个方法即可实现任务调度。你可以使用<code>MethodInvokingJobDetailFactoryBean</code>准确的做到这一点:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;jobDetail&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetObject&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;exampleBusinessObject&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetMethod&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;doIt&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>上面例子将调用<code>exampleBusinessObject</code>中的<code>doIt</code> 方法如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBusinessObject</span> &#123;<br>    <span class="hljs-comment">// properties and collaborators</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span>()</span> &#123;        <span class="hljs-comment">// do the actual work    &#125;&#125;</span><br>&lt;bean id=<span class="hljs-string">&quot;exampleBusinessObject&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;examples.ExampleBusinessObject&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>使用<code>MethodInvokingJobDetailFactoryBean</code>你不需要创建只有一行代码且只调用一个方法的job， 你只需要创建真实的业务对象来包装具体的细节的对象。</p><p>默认情况下，Quartz Jobs是无状态的，可能导致jobs之间互相的影响。如果你为相同的<code>JobDetail</code>指定两个Trigger， 很可能当第一个job完成之前，第二个job就开始了。如果<code>JobDetail</code>对象实现了<code>Stateful</code>接口，就不会发生这样的事情。 第二个job将不会在第一个job完成之前开始。为了使得jobs不并发运行，设置<code>MethodInvokingJobDetailFactoryBean</code>中的<code>concurrent</code>标记为<code>false</code>:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;jobDetail&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetObject&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;exampleBusinessObject&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetMethod&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;doIt&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;concurrent&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;false&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>默认情况下，jobs在并发的方式下运行。</p><h4 id="6-5-3-使用triggers和SchedulerFactoryBean来织入任务"><a href="#6-5-3-使用triggers和SchedulerFactoryBean来织入任务" class="headerlink" title="6.5.3. 使用triggers和SchedulerFactoryBean来织入任务"></a>6.5.3. 使用triggers和<code>SchedulerFactoryBean</code>来织入任务</h4><p>我们已经创建了job details，jobs。我们同时回顾了允许你调用特定对象上某一个方法的便捷的bean。 当然我们仍需要调度这些jobs。这需要使用triggers和<code>SchedulerFactoryBean</code>来完成。 Quartz中提供了几个triggers，Spring提供了两个带有方便默认值的Quartz <code>FactoryBean</code>实现：<code>CronTriggerFactoryBean</code>和<code>SimpleTriggerFactoryBean</code>。</p><p>Triggers也需要被调度。Spring提供<code>SchedulerFactoryBean</code>来公开一些属性来设置triggers。<code>SchedulerFactoryBean</code>负责调度那些实际的triggers</p><p>以下清单使用<code>SimpleTriggerFactoryBean</code>和<code>CronTriggerFactoryBean</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleTrigger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- see the example of method invoking job above --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobDetail&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jobDetail&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 10 seconds --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;startDelay&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- repeat every 50 seconds --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;repeatInterval&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50000&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cronTrigger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobDetail&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;exampleJob&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- run every morning at 6 AM --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cronExpression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0 0 6 * * ?&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们创建了两个triggers，其中一个开始延迟10秒以后每50秒运行一次，另一个每天早上6点钟运行。 我们需要创建一个<code>SchedulerFactoryBean</code>来最终实现上述的一切:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;triggers&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;cronTrigger&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;simpleTrigger&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更多的属性你可以通过<code>SchedulerFactoryBean</code>来设置，例如job details使用的日期， 用来订制Quartz的一些属性以及其它相关信息。 你可以查阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html"><code>SchedulerFactoryBean</code></a>的Javadoc。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>定时ren&#39;w</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Clients</title>
    <link href="/post/efb32359-a119-4f6d-a418-0c879bc6867b/"/>
    <url>/post/efb32359-a119-4f6d-a418-0c879bc6867b/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-Clients"><a href="#Web-Clients" class="headerlink" title="Web Clients"></a>Web Clients</h1><p>Spring 教程</p><hr><h2 id="1-REST-Clients"><a href="#1-REST-Clients" class="headerlink" title="1. REST Clients"></a>1. REST Clients</h2><p>Spring Framework 为调用 REST 端点提供了以下选择：</p><ul><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#rest-webclient">WebClient</a> - 具有非阻塞、响应式的流式 API 客户端。</li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#rest-resttemplate">RestTemplate</a> - 具有 template method API 的同步客户端.</li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#rest-http-interface">HTTP Interface</a> - 具有生成的动态代理实现的注解接口。</li></ul><h3 id="1-1-WebClient"><a href="#1-1-WebClient" class="headerlink" title="1.1. WebClient"></a>1.1. WebClient</h3><p>WebClient 是一个非阻塞的、响应式的客户端，用于执行 HTTP 请求。 它在 5.0 中引入，提供了 RestTemplate 的替代方案，支持同步、异步和流式场景。 WebClient 支持以下内容:</p><ul><li>非阻塞 I&#x2F;O。</li><li>Reactive Streams 背压.</li><li>高并发，硬件资源少。</li><li>利用 Java 8 lambda 的函数式、流式的 API。</li><li>同步和异步交互。</li><li>流式传输到服务器或从服务器进行流式传输。</li></ul><p>参阅 Spring 官方文档 WebClient 章节获取更多细节.</p><h3 id="1-2-RestTemplate"><a href="#1-2-RestTemplate" class="headerlink" title="1.2. RestTemplate"></a>1.2. RestTemplate</h3><p>RestTemplate 在 HTTP 客户端库上提供了更高级别的 API,它使得在一行中调用 REST 端点变得容易. 它暴露了以下重载方法组:</p><blockquote><p>从 5.0 版本开始， RestTemplate 处于维护模式， 以后只有很小的更改和错误请求被接受. 请考虑使用 WebClient API 替代.</p></blockquote><table><thead><tr><th>Method group</th><th>Description</th></tr></thead><tbody><tr><td>getForObject</td><td>通过 GET 获取响应.</td></tr><tr><td>getForEntity</td><td>使用 GET 获取 ResponseEntity (即status, headers和body)</td></tr><tr><td>headForHeaders</td><td>使用 HEAD 获取所有 headers</td></tr><tr><td>postForLocation</td><td>使用 POST 创建新资源,并从响应中返回 Location 请求头.</td></tr><tr><td>postForObject</td><td>使用 POST 创建新资源并从响应中返回表示.</td></tr><tr><td>postForEntity</td><td>使用 POST 创建新资源并从响应中返回表示.</td></tr><tr><td>put</td><td>使用 PUT 创建或更新资源.</td></tr><tr><td>patchForObject</td><td>使用 PATCH 更新资源并从响应中返回表示. 请注意,JDK HttpURLConnection 不支持 PATCH,但Apache HttpComponents 和其他一样.</td></tr><tr><td>delete</td><td>使用 DELETE 删除指定 URI 处的资源.</td></tr><tr><td>optionsForAllow</td><td>使用 ALLOW 检索资源的允许 HTTP 方法.</td></tr><tr><td>exchange</td><td>上述方法的更通用 (且不太固定) 的版本,在需要时提供额外的灵活性. 它接受 RequestEntity (包括 HTTP 方法,URL,headers 和正文作为输入) 并返回 ResponseEntity.</td></tr><tr><td>这些方法允许使用 ParameterizedTypeReference 而不是 Class 来指定具有泛型的响应类型.</td><td></td></tr><tr><td>execute</td><td>执行请求的最通用方式,通过回调接口完全控制请求准备和响应提取.</td></tr></tbody></table><h4 id="1-2-1-初始化"><a href="#1-2-1-初始化" class="headerlink" title="1.2.1. 初始化"></a>1.2.1. 初始化</h4><p>默认构造函数使用 java.net.HttpURLConnection 来执行请求. 您可以使用 ClientHttpRequestFactory 的实现切换到不同的 HTTP 库. 内置支持以下内容:</p><ul><li>Apache HttpComponents</li><li>Netty</li><li>OkHttp</li></ul><p>例如,要切换到 Apache HttpComponents,您可以使用以下命令:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">RestTemplate template = <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">HttpComponentsClientHttpRequestFactory</span>());<br></code></pre></td></tr></table></figure><p>每个 ClientHttpRequestFactory 都暴露特定于底层 HTTP 客户端库的配置选项 - 例如,用于凭据,连接池和其他详细信息.</p><blockquote><p>请注意,HTTP 请求的 java.net 实现在访问表示错误的响应的状态 (例如 401) 时可能引发异常. 如果这是一个问题,请切换到另一个 HTTP 客户端库.</p></blockquote><h5 id="URIs"><a href="#URIs" class="headerlink" title="URIs"></a>URIs</h5><p>许多 RestTemplate 方法都接受 URI 模板和 URI 模板变量， 作为 String 变量参数或 Map&lt;String,String&gt;. 以下示例使用 String 变量参数:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> result = restTemplate.<span class="hljs-built_in">getForObject</span>(<br><br>    <span class="hljs-string">&quot;https://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;&quot;</span>, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);<br></code></pre></td></tr></table></figure><p>以下示例使用 Map&lt;String, String&gt;:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; vars = Collections.singletonMap(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;42&quot;</span>);<br><span class="hljs-built_in">String</span> result = restTemplate.getForObject(    <span class="hljs-string">&quot;https://example.com/hotels/&#123;hotel&#125;/rooms/&#123;hotel&#125;&quot;</span>, <span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>, vars);<br></code></pre></td></tr></table></figure><p>请注意， URI 模板是自动编码的， 如以下示例所示:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">restTemplate.<span class="hljs-built_in">getForObject</span>(<span class="hljs-string">&quot;https://example.com/hotel list&quot;</span>, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);<br><span class="hljs-comment">// Results in request to &quot;https://example.com/hotel%20list&quot;</span><br></code></pre></td></tr></table></figure><p>您可以使用 RestTemplate 的 uriTemplateHandler 属性来自定义 URI 的编码方式. 或者， 您可以创建一个 java.net.URI , 并且使用 RestTemplate 中接受 URI 参数的方法之一. 有关使用和编码 URI 的更多详细信息， 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-uri-building">URI Links</a>.</p><h5 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h5><p>你可以使用 exchange() 方法指定特殊的请求头, 如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> uriTemplate = <span class="hljs-string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>;URI uri = UriComponentsBuilder.<span class="hljs-built_in">fromUriString</span>(uriTemplate).<span class="hljs-built_in">build</span>(<span class="hljs-number">42</span>);<br>RequestEntity&lt;Void&gt; requestEntity = RequestEntity.<span class="hljs-built_in">get</span>(uri).<span class="hljs-built_in">header</span>(<span class="hljs-string">&quot;MyRequestHeader&quot;</span>, <span class="hljs-string">&quot;MyValue&quot;</span>).<span class="hljs-built_in">build</span>();<br>ResponseEntity&lt;<span class="hljs-type">String</span>&gt; response = <span class="hljs-keyword">template</span>.<span class="hljs-built_in">exchange</span>(requestEntity, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);<br><span class="hljs-type">String</span> responseHeader = response.<span class="hljs-built_in">getHeaders</span>().<span class="hljs-built_in">getFirst</span>(<span class="hljs-string">&quot;MyResponseHeader&quot;</span>);<span class="hljs-type">String</span> body = response.<span class="hljs-built_in">getBody</span>();<br></code></pre></td></tr></table></figure><p>您可以通过许多返回 ResponseEntity 的 RestTemplate 方法来获取响应头.</p><h4 id="1-2-2-Body"><a href="#1-2-2-Body" class="headerlink" title="1.2.2. Body"></a>1.2.2. Body</h4><p>在 HttpMessageConverter 的帮助下， 传递到 RestTemplate 方法和从 RestTemplate 方法返回的对象与原始内容进行转换. 在 POST 请求中， 输入对象被序列化到请求主体， 如以下示例所示: URI location &#x3D; template.postForLocation(“<a href="https://example.com/people%E2%80%9D">https://example.com/people”</a>, person); 您无需显式设置请求的 Content-Type 头. 在大多数情况下， 您可以找到基于源对象类型的兼容消息转换器， 并且所选消息转换器会相应地设置内容类型. 如有必要， 可以使用 exchange 方法显式提供 Content-Type 请求头， 从而影响选择哪种消息转换器. 在 GET 上， 响应主体反序列化为输出 Object， 如以下示例所示: Person person &#x3D; restTemplate.getForObject(“<a href="https://example.com/people/%7Bid%7D%E2%80%9D">https://example.com/people/{id}”</a>, Person.class, 42); 不需要显式设置请求的 Accept 头. 在大多数情况下， 可以根据预期的响应类型找到兼容的消息转换器， 这有助于填充 Accept 头. 如有必要， 可以使用 exchange 方法显式提供 Accept 头. 默认情况下， RestTemplate 注册所有内置 <a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#rest-message-conversion">消息转换</a>， 这取决于类路径检查， 这些检查有助于确定存在哪些可选转换库. 您还可以将消息转换器设置为显式使用.</p><h4 id="1-2-3-消息转换"><a href="#1-2-3-消息转换" class="headerlink" title="1.2.3. 消息转换"></a>1.2.3. 消息转换</h4><p>WebFlux spring-web 模块包含 HttpMessageConverter ， 用于通过 InputStream 和 OutputStream 读取和写入 HTTP 请求和响应正文. 在客户端 (例如， 在 RestTemplate 中) 和服务器端 (例如， 在 Spring MVC REST 控制器中) 使用 HttpMessageConverter 实例. 框架中提供了主要的媒体 (MIME) 类型的具体实现， 默认情况下， 这些实现在客户端的 RestTemplate 和服务器的 RequestMappingHandlerAdapter 进行了注册 (请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/rest-clients/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-message-converters">配置消息转换器</a>) . 以下各节介绍了 HttpMessageConverter 的实现. 对于所有转换器， 都使用默认的媒体类型， 但是您可以通过设置 supportedMediaTypes bean 属性来覆盖它. 下表描述了每种实现:</p><table><thead><tr><th>MessageConverter</th><th>Description</th></tr></thead><tbody><tr><td>StringHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以从 HTTP 请求和响应中读取和写入 String 实例. 默认情况下,此转换器支持所有文本媒体类型 (text&#x2F;*) ,并使用 Content-Type 为 text&#x2F;plain 进行写入.</td></tr><tr><td>FormHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以从 HTTP 请求和响应中读取和写入表单数据. 默认情况下,此转换器读取和写入 application&#x2F;x-www-form-urlencoded 媒体类型. 表单数据从 MultiValueMap&lt;String, String&gt; 读取并写入. 转换器还可以将 MultiValueMap&lt;String, String&gt; 写入 (但不能读) multipart 数据, 从 “MultiValueMap&lt;String,Object&gt;” 读取的数据. 默认情况下, multipart&#x2F;form-data 是支持的. 从 Spring Framework 5.2 开始,可以支持其他的多部分子类型. 编写表格数据. 有关更多详细信息,请查阅 Javadoc 中的 FormHttpMessageConverter.</td></tr><tr><td>ByteArrayHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以从 HTTP 请求和响应中读取和写入字节数组. 默认情况下,此转换器支持所有媒体类型 (<strong>&#x2F;</strong>) ,并使用 Content-Type 为 application&#x2F;octet-stream 进行写入. 您可以通过设置 supportedMediaTypes 属性并覆盖 getContentType(byte[]) 来覆盖它.</td></tr><tr><td>MarshallingHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以使用 org.springframework.oxm 包中的 Spring 的 Marshaller 和 Unmarshaller 抽象来读写 XML. 该转换器需要 Marshaller 和 Unmarshaller 才能使用. 您可以通过构造函数或 bean 属性注入这些. 默认情况下,此转换器支持 text&#x2F;xml 和 application&#x2F;xml.</td></tr><tr><td>MappingJackson2HttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以使用 Jackson 的 ObjectMapper 读写JSON. 您可以根据需要通过使用 Jackson 提供的注解来自定义 JSON 映射. 当您需要进一步控制时 (对于需要为特定类型提供自定义 JSON 序列化器&#x2F;反序列化器的情况) ,您可以通过 ObjectMapper 属性注入自定义 ObjectMapper. 默认情况下,此转换器支持 application&#x2F;json.</td></tr><tr><td>MappingJackson2XmlHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以使用 <a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML</a> 扩展的 XmlMapper 读写XML. 您可以根据需要通过使用 JAXB 或 Jackson 提供的注解来自定义XML映射. 当您需要进一步控制时 (对于需要为特定类型提供自定义 XML 序列化器&#x2F;反序列化器的情况) ,您可以通过 ObjectMapper 属性注入自定义 XmlMapper. 默认情况下,此转换器支持 application&#x2F;xml.</td></tr><tr><td>SourceHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以从 HTTP 请求和响应中读取和写入 javax.xml.transform.Source. 仅支持 DOMSource,SAXSource 和 StreamSource. 默认情况下,此转换器支持 text&#x2F;xml 和 application&#x2F;xml.</td></tr><tr><td>BufferedImageHttpMessageConverter</td><td>一个 HttpMessageConverter 实现,可以从 HTTP 请求和响应中读取和写入 java.awt.image.BufferedImage. 此转换器读取和写入 Java I&#x2F;O API 支持的媒体类型.</td></tr></tbody></table><h4 id="1-2-4-Jackson-JSON-Views"><a href="#1-2-4-Jackson-JSON-Views" class="headerlink" title="1.2.4. Jackson JSON Views"></a>1.2.4. Jackson JSON Views</h4><p>您可以指定 <a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson JSON View</a> 来序列化对象属性的一部分， 如以下示例所示:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">MappingJacksonValue value = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MappingJacksonValue</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">User</span>(<span class="hljs-string">&quot;eric&quot;</span>, <span class="hljs-string">&quot;7!jd#h23&quot;</span>));value.<span class="hljs-built_in">setSerializationView</span>(User.WithoutPasswordView.<span class="hljs-keyword">class</span>);<br>RequestEntity&lt;MappingJacksonValue&gt; requestEntity =RequestEntity.<span class="hljs-built_in">post</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">URI</span>(<span class="hljs-string">&quot;https://example.com/user&quot;</span>)).<span class="hljs-built_in">body</span>(value);<br>ResponseEntity&lt;<span class="hljs-type">String</span>&gt; response = <span class="hljs-keyword">template</span>.<span class="hljs-built_in">exchange</span>(requestEntity, <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure><h4 id="1-2-5-Multipart"><a href="#1-2-5-Multipart" class="headerlink" title="1.2.5. Multipart"></a>1.2.5. Multipart</h4><p>要发送 multipart data， 您需要提供一个 MultiValueMap&lt;String, Object&gt;， 其值可能是一个 Object 的部分内容， 一个 Resource 的文件部分， 或一个 HttpEntity 的部分内容的头. 例如:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">MultiValueMap&lt;<span class="hljs-keyword">String</span>, Object&gt; parts = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedMultiValueMap</span>&lt;&gt;();<br>parts.add(<span class="hljs-string">&quot;fieldPart&quot;</span>, <span class="hljs-string">&quot;fieldValue&quot;</span>);parts.add(<span class="hljs-string">&quot;filePart&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">FileSystemResource</span>(<span class="hljs-string">&quot;...logo.png&quot;</span>));parts.add(<span class="hljs-string">&quot;jsonPart&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;Jason&quot;</span>));<br>HttpHeaders headers = <span class="hljs-keyword">new</span> <span class="hljs-type">HttpHeaders</span>();headers.setContentType(MediaType.APPLICATION_XML);parts.add(<span class="hljs-string">&quot;xmlPart&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">HttpEntity</span>&lt;&gt;(myBean, headers));<br></code></pre></td></tr></table></figure><p>在大多数情况下， 您不必为每个部分指定 Content-Type 头. 内容类型是根据选择用于序列化的 HttpMessageConverter 自动确定的， 或者对于基于文件扩展名的 Resource 是自动确定的. 如有必要， 可以为 MediaType 显式提供 HttpEntity 包装器.</p><p>一旦 MultiValueMap 准备就绪， 您可以将其传递给 RestTemplate， 如下所示:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">MultiValueMap&lt;<span class="hljs-type">String</span>, Object&gt; parts = ...;<br><br><span class="hljs-keyword">template</span>.<span class="hljs-built_in">postForObject</span>(<span class="hljs-string">&quot;https://example.com/upload&quot;</span>, parts, Void.<span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure><p>如果 MultiValueMap 包含至少一个非 String 值， 则 FormHttpMessageConverter 将 Content-Type 设置为 multipart&#x2F;form-data. 如果 MultiValueMap 具有字符串值， 则 Content-Type 默认为 application&#x2F;x-www-form-urlencoded. 如有必要， 还可以显式设置 Content-Type.</p><h3 id="1-3-HTTP-Interface"><a href="#1-3-HTTP-Interface" class="headerlink" title="1.3. HTTP Interface"></a>1.3. HTTP Interface</h3><p>Spring 框架允许您将 HTTP 服务定义为带有用于 HTTP exchanges 的注解方法的 Java 接口。 然后，您可以生成一个实现此接口并执行交换的代理。 这有助于简化 HTTP 远程访问，这通常涉及包装使用底层 HTTP 客户端的细节的外观。 首先，用 @HttpExchange 方法声明一个接口：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">RepositoryService</span> &#123;<br>    <span class="hljs-variable">@GetExchange</span>(<span class="hljs-string">&quot;/repos/&#123;owner&#125;/&#123;repo&#125;&quot;</span>)    Repository <span class="hljs-built_in">getRepository</span>(<span class="hljs-variable">@PathVariable</span> String owner, <span class="hljs-variable">@PathVariable</span> String repo);<br>    <span class="hljs-comment">// more HTTP exchange methods...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第二，创建一个将执行声明的 HTTP 交换的代理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">WebClient client <span class="hljs-operator">=</span> WebClient.builder().baseUrl(<span class="hljs-string">&quot;https://api.github.com/&quot;</span>).build()<span class="hljs-comment">;HttpServiceProxyFactory factory = HttpServiceProxyFactory.builder(WebClientAdapter.forClient(client)).build();</span><br>RepositoryService service <span class="hljs-operator">=</span> factory.createClient(RepositoryService.class)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>@HttpExchange 支持在所有的方法上进行注解：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@HttpExchange</span>(url = <span class="hljs-string">&quot;/repos/&#123;owner&#125;/&#123;repo&#125;&quot;</span>, accept = <span class="hljs-string">&quot;application/vnd.github.v3+json&quot;</span>)interface RepositoryService &#123;<br>    <span class="hljs-variable">@GetExchange</span>    Repository <span class="hljs-built_in">getRepository</span>(<span class="hljs-variable">@PathVariable</span> String owner, <span class="hljs-variable">@PathVariable</span> String repo);<br>    <span class="hljs-variable">@PatchExchange</span>(contentType = MediaType.APPLICATION_FORM_URLENCODED_VALUE)    void <span class="hljs-built_in">updateRepository</span>(<span class="hljs-variable">@PathVariable</span> String owner, <span class="hljs-variable">@PathVariable</span> String repo,                          <span class="hljs-variable">@RequestParam</span> String name, <span class="hljs-variable">@RequestParam</span> String description, <span class="hljs-variable">@RequestParam</span> String homepage);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-1-方法参数"><a href="#1-3-1-方法参数" class="headerlink" title="1.3.1. 方法参数"></a>1.3.1. 方法参数</h4><p>带注解的 HTTP 交换方法支持具有以下方法参数：</p><table><thead><tr><th>方法参数</th><th>描述</th></tr></thead><tbody><tr><td>URI</td><td>动态设置请求的 URL，覆盖注解的 url 属性。</td></tr><tr><td>HttpMethod</td><td>动态设置请求的 HTTP 方法，覆盖注解的 method 属性</td></tr><tr><td>@RequestHeader</td><td>添加请求头或多个请求头。参数可以是 Map&lt;String, ?&gt; 或 MultiValueMap&lt;String, ?&gt; （多个请求头）、 Collection&lt;?&gt; 或单个值。 非字符串值支持类型转换。</td></tr><tr><td>@PathVariable</td><td>添加一个变量以扩展请求 URL 中的占位符。 参数可以是具有多个变量或单个值的 Map&lt;String, ?&gt;。 非字符串值支持类型转换。</td></tr><tr><td>@RequestBody</td><td>将请求的主体作为要序列化的对象提供，或者 Reactive Streams Publisher 提供，例如 Mono、Flux 或通过配置的 ReactiveAdapterRegistry 支持的任何其他异步类型。</td></tr><tr><td>@RequestParam</td><td>添加请求参数或多个参数。 参数可以是具有多个参数的 Map&lt;String, ?&gt; or MultiValueMap&lt;String, ?&gt; 、Collection&lt;?&gt; 或单个值。 非字符串值支持类型转换。 当 “content-type” 设置为 “application&#x2F;x-www-form-urlencoded” 时，请求参数在请求体中进行编码。 否则，它们将作为 URL 查询参数添加。</td></tr><tr><td>@RequestPart</td><td>添加请求部分，可以是 String（表单字段）、Resource（文件部分）、Object（要编码的实体，例如 JSON）、HttpEntity（部分内容和标头）、Spring Part 或 Reactive Streams Publisher 以上任何一项。</td></tr><tr><td>@CookieValue</td><td>添加一个 cookie 或多个 cookie。 参数可以是具有多个 cookie 的 Map&lt;String, ?&gt; 或 MultiValueMap&lt;String, ?&gt;、Collection&lt;?&gt; 或单个值。 非字符串值支持类型转换。</td></tr></tbody></table><h4 id="1-3-2-返回值"><a href="#1-3-2-返回值" class="headerlink" title="1.3.2. 返回值"></a>1.3.2. 返回值</h4><p>带注解的 HTTP 交换方法支持以下返回值：:</p><table><thead><tr><th>方法返回值</th><th>描述</th></tr></thead><tbody><tr><td>void, Mono</td><td>执行请求，不返回任何内容</td></tr><tr><td>HttpHeaders, Mono</td><td>执行请求，返回响应头（如果存在）</td></tr><tr><td>, Mono</td><td>执行请求，将响应内容解码为指定类型的流</td></tr><tr><td>, Flux</td><td>执行请求，将响应内容解码为指定类型的流</td></tr><tr><td>ResponseEntity, Mono<ResponseEntity></td><td>执行请求，并返回具有 status 和 headers 的 ResponseEntity。</td></tr><tr><td>ResponseEntity, Mono<ResponseEntity></td><td>执行请求，将响应内容解码为声明的返回类型，并返回具有 status, headers 和解码正文的 ResponseEntity。</td></tr><tr><td>Mono&lt;ResponseEntity<Flux></td><td>执行请求，将响应内容解码为声明元素类型的流，并返回具有 status, headers 和解码的响应正文流的 ResponseEntity。</td></tr></tbody></table><blockquote><p>您还可以使用在 ReactiveAdapterRegistry 中注册的任何其他异步或反应类型。</p></blockquote><h4 id="1-3-3-异常处理"><a href="#1-3-3-异常处理" class="headerlink" title="1.3.3. 异常处理"></a>1.3.3. 异常处理</h4><p>默认情况下，WebClient 为 4xx 和 5xx HTTP 状态代码引发 WebClientResponseException。 要对此进行自定义，您可以注册一个响应状态处理程序，该处理程序适用于通过客户端执行的所有响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">WebClient</span> <span class="hljs-variable">webClient</span> <span class="hljs-operator">=</span> WebClient.builder().defaultStatusHandler(HttpStatusCode::isError, resp -&gt; ...).build();<br><span class="hljs-type">WebClientAdapter</span> <span class="hljs-variable">clientAdapter</span> <span class="hljs-operator">=</span> WebClientAdapter.forClient(webClient);<span class="hljs-type">HttpServiceProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> HttpServiceProxyFactory.builder(clientAdapter).build();<br></code></pre></td></tr></table></figure><p>有关更多详细信息和选项，例如 suppressing 错误状态代码，请参阅 WebClient.Builder 中 defaultStatusHandler 的 Javadoc。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resources 资源</title>
    <link href="/post/f5196226-0df7-4ea9-b4c1-bd505131031f/"/>
    <url>/post/f5196226-0df7-4ea9-b4c1-bd505131031f/</url>
    
    <content type="html"><![CDATA[<h1 id="Resources-资源"><a href="#Resources-资源" class="headerlink" title="Resources 资源"></a>Resources 资源</h1><p>Spring 教程</p><hr><h2 id="4-资源"><a href="#4-资源" class="headerlink" title="4. 资源"></a>4. 资源</h2><p>本章介绍Spring如何处理资源以及如何在Spring中使用资源。 它包括以下主题:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-introduction">简介</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-resource">资源接口</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations">内置资源实现</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-resourceloader"><code>ResourceLoader</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-resourceloaderaware"><code>ResourceLoaderAware</code> 接口</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-as-dependencies">资源依赖</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-app-ctx">应用上下文和资源路径</a></li></ul><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1. 简介"></a>4.1. 简介</h3><p>遗憾的是，Java的标准<code>java.net.URL</code>类和各种 <code>URL</code>前缀的标准处理程序不足以完全访问底层资源。例如，没有标准化的 <code>URL</code>实现可用于访问需要从类路径或相对于 <code>ServletContext</code>获取的资源。 虽然可以为专用 <code>URL</code>前缀注册新的处理程序（类似于<code>http:</code> :)这样的前缀的现有处理程序，但这通常非常复杂，并且<code>URL</code>接口仍然缺少一些理想的功能，例如检查当前资源是否存在的方法。</p><h3 id="4-2-资源接口"><a href="#4-2-资源接口" class="headerlink" title="4.2. 资源接口"></a>4.2. 资源接口</h3><p>Spring的<code>Resource</code>接口的目标是成为一个更强大的接口，用于抽象对底层资源的访问。 以下清单显示了<code>Resource</code>接口定义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function">File <span class="hljs-title">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function">Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>    <span class="hljs-function">String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如<code>Resource</code>接口的定义所示，它扩展了<code>InputStreamSource</code>接口。 以下清单显示了<code>InputStreamSource</code>接口的定义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br>    <span class="hljs-function">InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Resource</code> 接口中一些最重要的方法是：</p><ul><li><code>getInputStream()</code>: 用于定位和打开当前资源, 返回当前资源的<code>InputStream</code> ，预计每一次调用都会返回一个新的<code>InputStream</code>. 因此调用者必须自行关闭当前的输出流.</li><li><code>exists()</code>: 返回<code>boolean</code>值，表示当前资源是否存在。</li><li><code>isOpen()</code>: 返回<code>boolean</code>值，表示当前资源是否有已打开的输入流。如果为 <code>true</code>，那么<code>InputStream</code>不能被多次读取 ，只能在一次读取后即关闭以防止内存泄漏。除了<code>InputStreamResource</code>外，其他常用Resource实现都会返回<code>false</code>。</li><li><code>getDescription()</code>: 返回当前资源的描述，当处理资源出错时，资源的描述会用于输出错误的信息。一般来说，资源的描述是一个完全限定的文件名称，或者是当前资源的真实URL。</li></ul><p>其他方法允许您获取表示资源的实际<code>URL</code>或<code>File</code>对象（如果底层实现兼容并支持该功能）。</p><p>在Spring里， <code>Resource</code>抽象有着相当广泛的使用，例如，当需要某个资源时， <code>Resource</code>可以当作方法签名里的参数类型被使用。在Spring API中，有些方法（例如各种<code>ApplicationContext</code>实现的构造函数） 会直接采用普通格式的<code>String</code>路径来创建合适的<code>Resource</code>，调用者也可以通过在路径里带上指定的前缀来创建特定的<code>Resource</code>实现。</p><p>不但Spring内部和使用Spring的应用都大量地使用了<code>Resource</code>接口,而且开发者在应用代码中将它作为一个通用的工具类也是非常通用的。当你仅需要使用到<code>Resource</code>接口实现时， 可以直接忽略Spring的其余部分.虽然这样会与Spring耦合,但是也只是耦合一部分而已。使用这些<code>Resource</code>实现代替底层的访问是极其美好的。这与开发者引入其他库的目的也是一样的</p><p><code>Resource</code>抽象不会取代功能。 它尽可能地包裹它。 例如，<code>UrlResource</code>包装<code>URL</code>并使用包装的URL来完成其工作。</p><h3 id="4-3-内置的资源实现"><a href="#4-3-内置的资源实现" class="headerlink" title="4.3. 内置的资源实现"></a>4.3. 内置的资源实现</h3><p>Spring包括以下<code>Resource</code>实现:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-urlresource"><code>UrlResource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-classpathresource"><code>ClassPathResource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-filesystemresource"><code>FileSystemResource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-servletcontextresource"><code>ServletContextResource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-inputstreamresource"><code>InputStreamResource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-implementations-bytearrayresource"><code>ByteArrayResource</code></a></li></ul><h4 id="4-3-1-UrlResource"><a href="#4-3-1-UrlResource" class="headerlink" title="4.3.1. UrlResource"></a>4.3.1. <code>UrlResource</code></h4><p><code>UrlResource</code> 封装了<code>java.net.URL</code>用来访问正常URL的任意对象。例如<code>file:</code> ，HTTP目标，FTP目标等。所有的URL都可以用标准化的字符串来表示，例如通过正确的标准化前缀。 可以用来表示当前URL的类型。 这包括<code>file:</code>，用于访问文件系统路径，<code>http:</code> ：用于通过HTTP协议访问资源，<code>ftp:</code>：用于通过FTP访问资源，以及其他。</p><p>通过java代码可以显式地使用<code>UrlResource</code>构造函数来创建<code>UrlResource</code>，但也可以调用API方法来使用代表路径的String参数来隐式创建<code>UrlResource</code>。 对于后一种情况，JavaBeans <code>PropertyEditor</code>最终决定要创建哪种类型的<code>Resource</code>。如果路径字符串包含众所周知的（对于它，那么）前缀（例如 <code>classpath:</code>:)，它会为该前缀创建适当的专用<code>Resource</code>。 但是，如果它无法识别前缀，则假定该字符串是标准URL字符串并创建<code>UrlResource</code>。</p><h4 id="4-3-2-ClassPathResource"><a href="#4-3-2-ClassPathResource" class="headerlink" title="4.3.2. ClassPathResource"></a>4.3.2. <code>ClassPathResource</code></h4><p>ClassPathResource代表从类路径中获取资源，它使用线程上下文加载器，指定类加载器或给定class类来加载资源。</p><p>当类路径上资源存于文件系统中时，<code>ClassPathResource</code>支持使用<code>java.io.File</code>来访问。但是当类路径上的资源位于未解压(没有被Servlet引擎或其他可解压的环境解压）的jar包中时， <code>ClassPathResource</code>就不再支持以<code>java.io.File</code>的形式访问。鉴于此，Spring中各种Resource的实现都支持以<code>java.net.URL</code>的形式访问资源。</p><p>可以显式使用<code>ClassPathResource</code>构造函数来创建<code>ClassPathResource</code>，但是更多情况下，是调用API方法使用的。即使用一个代表路径的<code>String</code>参数来隐式创建<code>ClassPathResource</code>。 对于后一种情况，将会由JavaBeans的<code>PropertyEditor</code>来识别路径中<code>classpath:</code>前缀，并创建<code>ClassPathResource</code>。</p><h4 id="4-3-3-FileSystemResource"><a href="#4-3-3-FileSystemResource" class="headerlink" title="4.3.3. FileSystemResource"></a>4.3.3. <code>FileSystemResource</code></h4><p><code>FileSystemResource</code>是用于处理<code>java.io.File</code>和<code>java.nio.file.Path</code>的实现，显然，它同时能解析作为<code>File</code>和作为<code>URL</code>的资源。</p><h4 id="4-3-4-ServletContextResource"><a href="#4-3-4-ServletContextResource" class="headerlink" title="4.3.4. ServletContextResource"></a>4.3.4. <code>ServletContextResource</code></h4><p>这是<code>ServletContext</code>资源的 <code>Resource</code>实现，用于解释相关Web应用程序根目录中的相对路径。</p><p>ServletContextResource完全支持以流和URL的方式访问资源，但只有当Web项目是解压的（不是以war等压缩包形式存在），而且该ServletContext资源必须位于文件系统中， 它支持以<code>java.io.File</code>的方式访问资源。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）（可以想象）访问，实际上都依赖于Servlet容器。</p><h4 id="4-3-5-InputStreamResource"><a href="#4-3-5-InputStreamResource" class="headerlink" title="4.3.5. InputStreamResource"></a>4.3.5. <code>InputStreamResource</code></h4><p><code>InputStreamResource</code>是针对<code>InputStream</code>提供的<code>Resource</code>实现。在一般情况下，如果确实无法找到合适的<code>Resource</code>实现时，才去使用它。 同时请优先选择<code>ByteArrayResource</code>或其他基于文件的<code>Resource</code>实现，迫不得已的才使用它。</p><p>与其他<code>Resource</code> 实现相比，这是已打开资源的描述符。 因此，它从<code>isOpen()</code>返回<code>true</code>。</p><h4 id="4-3-6-ByteArrayResource"><a href="#4-3-6-ByteArrayResource" class="headerlink" title="4.3.6. ByteArrayResource"></a>4.3.6. <code>ByteArrayResource</code></h4><p>这是给定字节数组的<code>Resource</code>实现。 它为给定的字节数组创建一个<code>ByteArrayInputStream</code>。</p><p>当需要从字节数组加载内容时，ByteArrayResource会是个不错的选择，无需求助于单独使用的<code>InputStreamResource</code>。</p><h3 id="4-4-ResourceLoader"><a href="#4-4-ResourceLoader" class="headerlink" title="4.4.ResourceLoader"></a>4.4.<code>ResourceLoader</code></h3><p><code>ResourceLoader</code>接口用于加载<code>Resource</code>对象，换句话说，就是当一个对象需要获取<code>Resource</code>实例时，可以选择实现<code>ResourceLoader</code>接口，以下清单显示了<code>ResourceLoader</code>接口定义：。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceLoader</span> </span>&#123;<br>    Resource getResource(<span class="hljs-keyword">String</span> location);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有应用程序上下文都实现<code>ResourceLoader</code>接口。 因此，可以使用所有应用程序上下文来获取 <code>Resource</code>实例。</p><p>当在特殊的应用上下文中调用<code>getResource()</code>方法以及指定的路径没有特殊前缀时，将返回适合该特定应用程序上下文的<code>Resource</code>类型。 例如，假设针对<code>ClassPathXmlApplicationContext</code> 实例执行了以下代码片段：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Resource template <span class="hljs-operator">=</span> ctx.getResource(<span class="hljs-string">&quot;some/resource/path/myTemplate.txt&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>针对<code>ClassPathXmlApplicationContext</code>，该代码返回 <code>ClassPathResource</code>。如果对<code>FileSystemXmlApplicationContext</code> 实例执行相同的方法，它将返回<code>FileSystemResource</code>。 对于<code>WebApplicationContext</code>，它将返回<code>ServletContextResource</code>。 它同样会为每个上下文返回适当的对象。</p><p>因此，您可以以适合特定应用程序上下文的方式加载资源。</p><p>另一方面，您可以通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code>，而不管应用程序上下文类型如何，如下例所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Resource template <span class="hljs-operator">=</span> ctx.getResource(<span class="hljs-string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>同样，您可以通过指定任何标准<code>java.net.URL</code>前缀来强制使用<code>UrlResource</code> 。 以下对示例使用<code>file</code> 和 <code>http</code>前缀：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Resource template <span class="hljs-operator">=</span> ctx.getResource(<span class="hljs-string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>)<span class="hljs-comment">;</span><br>Resource template <span class="hljs-operator">=</span> ctx.getResource(<span class="hljs-string">&quot;http://myhost.com/resource/path/myTemplate.txt&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>下表总结了将：<code>String</code>对象转换为<code>Resource</code>对象的策略:</p><p>Table 10.资源字符串</p><table><thead><tr><th>前缀</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>classpath:</td><td><code>classpath:com/myapp/config.xml</code></td><td>从类路径加载</td></tr><tr><td>file:</td><td><a href="file:///data/config.xml">file:&#x2F;&#x2F;&#x2F;data&#x2F;config.xml</a></td><td>从文件系统加载为<code>URL</code>。 另请参见<a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#resources-filesystemresource-caveats"><code>FileSystemResource</code> 警告。</a></td></tr><tr><td>http:</td><td><a href="http://myserver/logo.png">http://myserver/logo.png</a></td><td>作为<code>URL</code>加载。</td></tr><tr><td>(none)</td><td><code>/data/config.xml</code></td><td>取决于底层的<code>ApplicationContext</code>。</td></tr></tbody></table><h3 id="4-5-ResourceLoaderAware-接口"><a href="#4-5-ResourceLoaderAware-接口" class="headerlink" title="4.5. ResourceLoaderAware 接口"></a>4.5. <code>ResourceLoaderAware</code> 接口</h3><p><code>ResourceLoaderAware</code>是一个特殊的标识接口，用来提供<code>ResourceLoader</code>引用的对象。以下清单显示了<code>ResourceLoaderAware</code>接口的定义：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ResourceLoaderAware</span> &#123;<br>    <span class="hljs-built_in">void</span> setResourceLoader(ResourceLoader resourceLoader);&#125;<br></code></pre></td></tr></table></figure><p>当类实现<code>ResourceLoaderAware</code>并部署到应用程序上下文（作为Spring管理的bean）时，它被应用程序上下文识别为<code>ResourceLoaderAware</code>。 然后，应用程序上下文调用<code>setResourceLoader(ResourceLoader)</code>，将其自身作为参数提供（请记住，Spring中的所有应用程序上下文都实现了<code>ResourceLoader</code>接口）。</p><p>由于<code>ApplicationContext</code>实现了<code>ResourceLoader</code>，因此bean还可以实现 <code>ApplicationContextAware</code> 接口并直接使用提供的应用程序上下文来加载资源。 但是，通常情况下，如果您需要，最好使用专用的<code>ResourceLoader</code>接口。 代码只能耦合到资源加载接口（可以被认为是实用程序接口），而不能耦合到整个Spring <code>ApplicationContext</code>接口。</p><p>从Spring 2.5开始，除了实现<code>ResourceLoaderAware</code>接口，还可以采取另外一种替代方案-依赖<code>ResourceLoader</code>的自动装配。 “传统”构造函数和byType <a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#beans-factory-autowire">自动装配</a>模式都支持对<code>ResourceLoader</code>的装配。 前者是以构造参数的形式装配，后者作为setter方法的参数参与装配。如果为了获得更大的灵活性（包括属性注入的能力和多参方法），可以考虑使用基于注解的新型注入方式。 使用注解<code>@Autowired</code>标识<code>ResourceLoader</code>变量，便可将其注入到成员属性、构造参数或方法参数中。这些参数需要ResourceLoader类型。 有关更多信息，请参阅使用<a href="https://sca.aliyun.com/learn/spring/core/resources/?spm=0.29160081.0.0.51f92e5dCHrGI4#beans-autowired-annotation">Using <code>@Autowired</code></a>。</p><h3 id="4-6-资源依赖"><a href="#4-6-资源依赖" class="headerlink" title="4.6. 资源依赖"></a>4.6. 资源依赖</h3><p>如果bean本身要通过某种动态过程来确定和提供资源路径，那么bean使用<code>ResourceLoader</code>接口来加载资源就变得更有意义了。假如需要加载某种类型的模板，其中所需的特定资源取决于用户的角色 。如果资源是静态的，那么完全可以不使用<code>ResourceLoader</code>接口，只需让bean公开它需要的<code>Resource</code>属性，并按照预期注入属性即可。</p><p>是什么使得注入这些属性变得如此简单？是因为所有应用程序上下文注册和使用一个特殊的<code>PropertyEditor</code> JavaBean，它可以将 <code>String</code> paths转换为<code>Resource</code>对象。 因此，如果<code>myBean</code>有一个类型为<code>Resource</code>的模板属性，它可以用一个简单的字符串配置该资源。如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;...&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;template&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;some/resource/path/myTemplate.txt&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>请注意，资源路径没有前缀。 因此，因为应用程序上下文本身将用作<code>ResourceLoader</code>， 所以资源本身通过<code>ClassPathResource</code>，<code>FileSystemResource</code>或<code>ServletContextResource</code>加载，具体取决于上下文的确切类型。</p><p>如果需要强制使用特定的 <code>Resource</code>类型，则可以使用前缀。 以下两个示例显示如何强制<code>ClassPathResource</code>和<code>UrlResource</code>（后者用于访问文件系统文件）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;template&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span>&gt;<br>&lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;template&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="4-7-应用上下文和资源路径"><a href="#4-7-应用上下文和资源路径" class="headerlink" title="4.7. 应用上下文和资源路径"></a>4.7. 应用上下文和资源路径</h3><p>本节介绍如何使用资源创建应用程序上下文，包括使用XML的快捷方式，如何使用通配符以及其他详细信息。</p><h4 id="4-7-1-构造应用上下文"><a href="#4-7-1-构造应用上下文" class="headerlink" title="4.7.1. 构造应用上下文"></a>4.7.1. 构造应用上下文</h4><p>应用程序上下文构造函数（对于特定的应用程序上下文类型）通常将字符串或字符串数组作为资源的位置路径，例如构成上下文定义的XML文件。</p><p>当指定的位置路径没有带前缀时，那么从指定位置路径创建<code>Resource</code>类型（用于后续加载bean定义），具体取决于所使用应用上下文。 例如，请考虑以下示例，该示例创建<code>ClassPathXmlApplicationContext</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext ctx <span class="hljs-operator">=</span> new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;conf/appContext.xml&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>bean定义是从类路径加载的，因为使用了<code>ClassPathResource</code>。 但是，请考虑以下示例，该示例创建 <code>FileSystemXmlApplicationContext</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext ctx <span class="hljs-operator">=</span><br><br>    new FileSystemXmlApplicationContext(<span class="hljs-string">&quot;conf/appContext.xml&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>现在，bean定义是从文件系统位置加载的（在这种情况下，相对于当前工作目录）。</p><p>若位置路径带有classpath前缀或URL前缀，会覆盖默认创建的用于加载bean定义的<code>Resource</code>类型。请考虑以下示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext ctx <span class="hljs-operator">=</span><br><br>    new FileSystemXmlApplicationContext(<span class="hljs-string">&quot;classpath:conf/appContext.xml&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>使用<code>FileSystemXmlApplicationContext</code>从类路径加载bean定义。 但是，它仍然是<code>FileSystemXmlApplicationContext</code>。 如果它随后用作<code>ResourceLoader</code>，则任何未加前缀的路径仍被视为文件系统路径。</p><h5 id="构造ClassPathXmlApplicationContext实例的快捷方式"><a href="#构造ClassPathXmlApplicationContext实例的快捷方式" class="headerlink" title="构造ClassPathXmlApplicationContext实例的快捷方式"></a>构造<code>ClassPathXmlApplicationContext</code>实例的快捷方式</h5><p><code>ClassPathXmlApplicationContext</code>提供了多个构造函数，以利于快捷创建<code>ClassPathXmlApplicationContext</code>的实例。基础的想法是， 使用只包含多个XML文件名（不带路径信息）的字符串数组和一个Class参数的构造器，所省略路径信息<code>ClassPathXmlApplicationContext</code>会从<code>Class</code>参数中获取。</p><p>请考虑以下目录布局:</p><p>com&#x2F; foo&#x2F; services.xml daos.xml MessengerService.class</p><p>以下示例显示如何实例化由名为<code>services.xml</code>和<code>daos.xml</code>（位于类路径中）的文件中定义的bean组成的<code>ClassPathXmlApplicationContext</code>实例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[] &#123;<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>&#125;, MessengerService.<span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure><p>有关各种构造函数的详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>ClassPathXmlApplicationContext</code></a>javadoc。</p><h4 id="4-7-2-使用通配符构造应用上下文"><a href="#4-7-2-使用通配符构造应用上下文" class="headerlink" title="4.7.2. 使用通配符构造应用上下文"></a>4.7.2. 使用通配符构造应用上下文</h4><p>从前文可知，应用上下文构造器的资源路径可以是单一的路径（即一对一地映射到目标资源）。也可以使用高效的通配符。可以包含特殊的”classpath*:“前缀或ant风格的正则表达式（使用Spring的PathMatcher来匹配）。</p><p>通配符机制可用于组装应用程序的组件，应用程序里所有组件都可以在一个公用的位置路径发布自定义的上下文片段，那么最终的应用上下文可使用<code>classpath*:</code>。 在同一路径前缀（前面的公用路径）下创建，这时所有组件上下文的片段都会被自动装配。</p><p>请注意，此通配符特定于在应用程序上下文构造函数中使用资源路径（或直接使用 <code>PathMatcher</code>实用程序类层次结构时），并在构造时解析。 它与资源类型本身无关。 您不能使用<code>classpath*:</code>前缀来构造实际的<code>Resource</code>,，因为资源一次只指向一个资源。</p><h5 id="Ant风格模式"><a href="#Ant风格模式" class="headerlink" title="Ant风格模式"></a>Ant风格模式</h5><p>路径位置可以包含Ant样式模式，如以下示例所示:</p><p>&#x2F;WEB-INF&#x2F;<em>-context.xml com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml file:C:&#x2F;some&#x2F;path&#x2F;</em>-context.xml classpath:com &#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</p><p>当路径位置包含Ant样式模式时，解析程序遵循更复杂的过程来尝试解析通配符。解释器会先从位置路径里获取最靠前的不带通配符的路径片段， 并使用这个路径片段来创建一个<code>Resource</code>，并从中获取一个URL。 如果此URL不是<code>jar:</code>URL或特定于容器的变体（例如，在WebLogic中为<code>zip:</code>，在WebSphere中为<code>wsjar</code>，等等） 则从Resource里获取<code>java.io.File</code>对象，并通过其遍历文件系统。进而解决位置路径里通配符。 对于jar URL，解析器要么从中获取<code>java.net.JarURLConnection</code>， 要么手动解析jar URL，然后遍历jar文件的内容以解析通配符。</p><h6 id="可移植性所带来的影响"><a href="#可移植性所带来的影响" class="headerlink" title="可移植性所带来的影响"></a>可移植性所带来的影响</h6><p>如果指定的路径定为文件URL（不管是显式还是隐式的），首先默认的<code>ResourceLoader</code>就是文件系统，其次通配符使用程序可以完美移植。</p><p>如果指定的路径是类路径位置，则解析器必须通过 <code>Classloader.getResource()</code>方法调用获取最后一个非通配符路径段URL。 因为这只是路径的一个节点（而不是末尾的文件），实际上它是未定义的（在<code>ClassLoader</code> javadoc中），在这种情况下并不能确定返回什么样的URL。 实际上，它始终会使用<code>java.io.File</code>来解析目录，其中类路径资源会解析到文件系统的位置或某种类型的jar URL，其中类路径资源解析为jar包的位置。 但是，这个操作就碰到了可移植的问题了。</p><p>如果获取了最后一个非通配符段的jar包URL，解析器必须能够从中获取<code>java.net.JarURLConnection</code>，或者手动解析jar包的URL，以便能够遍历jar的内容。 并解析通配符，这适用于大多数工作环境，但在某些其他特定环境中将会有问题，最后会导致解析失败，所以强烈建议在特定环境中彻底测试来自jar资源的通配符解析，测试成功之后再对其作依赖使用。</p><h5 id="The-classpath-前缀"><a href="#The-classpath-前缀" class="headerlink" title="The classpath*: 前缀"></a>The <code>classpath*:</code> 前缀</h5><p>当构造基于XML文件的应用上下文时，位置路径可以使用<code>classpath*:</code>前缀。如以下示例所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext ctx <span class="hljs-operator">=</span><br><br>    new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;classpath*:conf/appContext.xml&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>classpath*:</code>的使用表示该类路径下所有匹配文件名称的资源都会被获取（本质上就是调用了<code>ClassLoader.getResources(…)</code>方法，接着将获取到的资源装配成最终的应用上下文。</p><p>通配符类路径依赖于底层类加载器的<code>getResources()</code> 方法。由于现在大多数应用程序服务器都提供自己的类加载器实现，因此行为可能会有所不同，尤其是在处理jar文件时。 要在指定服务器测试<code>classpath*</code> 是否有效，简单点可以使用<code>getClass().getClassLoader().getResources(&quot;&lt;someFileInsideTheJar&gt;&quot;)</code>来加载类路径jar包里的文件。 尝试在两个不同的路径加载相同名称的文件，如果返回的结果不一致，就需要查看一下此服务器中与classloader设置相关的文档。</p><p>您还可以将<code>classpath*:</code> 前缀与位置路径的其余部分中的 <code>PathMatcher</code>模式组合在一起（例如，<code>classpath*:META-INF/*-beans.xml</code>）。 这种情况的解析策略非常简单，取位置路径最靠前的无通配符片段，然后调用<code>ClassLoader.getResources()</code>获取所有匹配到的类层次加载器加载资源，随后将<code>PathMatcher</code>的策略应用于每一个得到的资源。</p><h5 id="通配符的补充说明"><a href="#通配符的补充说明" class="headerlink" title="通配符的补充说明"></a>通配符的补充说明</h5><p>请注意，除非所有目标资源都存在文件系统中，否则<code>classpath*:</code>与Ant样式模式结合，都只能在至少有一个确定了根路径的情况下，才能达到预期的效果。 这意味着<code>classpath*:*.xml</code>等模式可能无法从jar文件的根目录中检索文件，而只能从根目录中的扩展目录中检索文件。</p><p>问题的根源是JDK的<code>ClassLoader.getResources()</code>方法的局限性。当向<code>ClassLoader.getResources()</code>传入空串时（表示搜索潜在的根目录）， 只能获取的文件系统的位置路径，即获取不了jar中文件的位置路径。Spring也会评估<code>URLClassLoader</code>运行时配置和jar文件中的<code>java.class.path</code>清单，但这不能保证导致可移植行为。</p><p>扫描类路径包需要在类路径中存在相应的目录条目。 使用Ant构建JAR时，请不要激活JAR任务的文件开关。 此外，在某些环境中，类路径目录可能不会基于安全策略公开 - 例如，JDK 1.7.0_45及更高版本上的独立应用程序（需要在清单中设置’Trusted-Library’ 。 请参阅<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>)）。</p><p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常按预期工作。 此处强烈建议将资源放入专用目录，避免上述搜索jar文件根级别的可移植性问题。</p><p>如果有多个类路径上都用搜索到的根包，那么使用<code>classpath:</code>和ant风格模式一起指定资源并不保证会找到匹配的资源。请考虑以下资源位置示例：</p><p>com&#x2F;mycompany&#x2F;package1&#x2F;service-context.xml</p><p>现在考虑一个人可能用来尝试查找该文件的Ant风格路径:</p><p>classpath:com &#x2F;mycompany&#x2F;**&#x2F;service-context.xml</p><p>这样的资源可能只在一个位置，但是当使用前面例子之类的路径来尝试解析它时，解析器会处理<code>getResource(&quot;com/mycompany&quot;);</code>返回的（第一个）URL。 当在多个类路径存在基础包节点<code>&quot;com/mycompany&quot;</code>时(如在多个jar存在这个基础节点），解析器就不一定会找到指定资源。因此，这种情况下建议结合使用<code>classpath*:</code> 和ant风格模式，<code>classpath*:</code>会让解析器去搜索所有包含基础包节点的类路径。</p><h4 id="4-7-3-FileSystemResource-的警告"><a href="#4-7-3-FileSystemResource-的警告" class="headerlink" title="4.7.3. FileSystemResource 的警告"></a>4.7.3. <code>FileSystemResource</code> 的警告</h4><p>当<code>FileSystemResource</code>与<code>FileSystemApplicationContext</code>之间没有联系（即，当<code>FileSystemApplicationContext</code>不是实际的<code>ResourceLoader</code>时）时会按预期处理绝对路径和相对路径。 相对路径是相对与当前工作目录而言的，而绝对路径则是相对文件系统的根目录而言的。</p><p>但是，出于向后兼容性（历史）的原因，当<code>FileSystemApplicationContext</code>是<code>ResourceLoader</code>时，这会发生变化。<code>FileSystemApplicationContext</code>强制所有有联系的<code>FileSystemResource</code>实例将所有位置路径视为相对路径， 无论它们是否以’&#x2F;‘开头。 实际上，这意味着以下示例是等效的：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ApplicationContext ctx <span class="hljs-operator">=</span>    new FileSystemXmlApplicationContext(<span class="hljs-string">&quot;conf/context.xml&quot;</span>)<span class="hljs-comment">;</span><br>ApplicationContext ctx <span class="hljs-operator">=</span>    new FileSystemXmlApplicationContext(<span class="hljs-string">&quot;/conf/context.xml&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>以下示例也是等效的（即使它们有所不同，因为一个案例是相对的而另一个案例是绝对的）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FileSystemXmlApplicationContext ctx <span class="hljs-operator">=</span> ...<span class="hljs-comment">;ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);</span><br>FileSystemXmlApplicationContext ctx <span class="hljs-operator">=</span> ...<span class="hljs-comment">;ctx.getResource(&quot;/some/resource/path/myTemplate.txt&quot;);</span><br></code></pre></td></tr></table></figure><p>实际上，如果确实需要使用绝对路径，建议放弃使用<code>FileSystemResource</code>和<code>FileSystemXmlApplicationContext</code>，而强制使用 <code>file:</code>的<code>UrlResource</code>。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">// actual <span class="hljs-keyword">context</span> <span class="hljs-keyword">type</span> doesn<span class="hljs-symbol">&#x27;t</span> matter, the Resource will always be UrlResourcectx.getResource(<span class="hljs-string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>);<br>// <span class="hljs-keyword">force</span> this FileSystemXmlApplicationContext <span class="hljs-keyword">to</span> load its definition via a UrlResourceApplicationContext ctx =    <span class="hljs-keyword">new</span> FileSystemXmlApplicationContext(<span class="hljs-string">&quot;file:///conf/context.xml&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Resources</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web MVC</title>
    <link href="/post/149aa27a-b2cf-4887-9632-da7bc1425bc8/"/>
    <url>/post/149aa27a-b2cf-4887-9632-da7bc1425bc8/</url>
    
    <content type="html"><![CDATA[<h3 id="Web-MVC"><a href="#Web-MVC" class="headerlink" title="Web MVC"></a>Web MVC</h3><p><code>hexo template generate by typora plugin templater</code></p><h1 id="Web-MVC-1"><a href="#Web-MVC-1" class="headerlink" title="Web MVC"></a>Web MVC</h1><p>Spring 教程</p><hr><h2 id="1-Spring-Web-MVC"><a href="#1-Spring-Web-MVC" class="headerlink" title="1. Spring Web MVC"></a>1. Spring Web MVC</h2><p>Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。 正式名称 “Spring Web MVC,” 来自其源模块(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc"><code>spring-webmvc</code></a>)的名称，但它通常被称为“Spring MVC”。</p><p>与Spring Web MVC并行，Spring Framework 5.0引入了一个反应堆栈Web框架，其名称“Spring WebFlux,”也基于其源模块(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux"><code>spring-webflux</code></a>)。 本节介绍Spring Web MVC。 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#spring-web-reactive">下一节</a>将介绍Spring WebFlux。.</p><p>有关基本信息以及与Servlet容器和Java EE版本范围的兼容性，请参阅Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a>。</p><h3 id="1-1-DispatcherServlet"><a href="#1-1-DispatcherServlet" class="headerlink" title="1.1. DispatcherServlet"></a>1.1. DispatcherServlet</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-dispatcher-handler">与Spring WebFlux相同</a></p><p>Spring MVC和许多其他Web框架一样，围绕前端控制器模式设计，其中核心 <code>Servlet``DispatcherServlet</code>为请求处理提供共享算法，而实际工作由可配置委托组件执行。 该模型非常灵活，支持多种工作流程。</p><p><code>DispatcherServlet</code>与任何 <code>Servlet</code>一样，需要使用Java配置或 <code>web.xml</code>根据Servlet规范进行声明和映射。 反过来，<code>DispatcherServlet</code>使用Spring配置来发现请求映射，视图解析，异常处理 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-servlet-special-bean-types">等等</a>所需的委托组件。</p><p>下面的Java配置示例注册并初始化<code>DispatcherServlet</code>，它由Servlet容器自动检测（请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-container-config">Servlet Config</a>）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyWebApplicationInitializer implements WebApplicationInitializer &#123;<br>    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onStartup(ServletContext servletCxt) &#123;<br>        // <span class="hljs-keyword">Load</span> Spring web application <span class="hljs-keyword">configuration</span>        AnnotationConfigWebApplicationContext ac = <span class="hljs-built_in">new</span> AnnotationConfigWebApplicationContext();        ac.register(AppConfig.<span class="hljs-keyword">class</span>);        ac.<span class="hljs-keyword">refresh</span>();<br>        // <span class="hljs-keyword">Create</span> <span class="hljs-keyword">and</span> register the DispatcherServlet        DispatcherServlet servlet = <span class="hljs-built_in">new</span> DispatcherServlet(ac);        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);        registration.setLoadOnStartup(<span class="hljs-number">1</span>);        registration.addMapping(&quot;/app/*&quot;);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>除了直接使用ServletContext API之外，您还可以扩展<code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并覆盖特定方法（请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-servlet-context-hierarchy">Context Hierarchy</a>下的示例）。</p><p>以下<code>web.xml</code>配置示例注册并初始化<code>DispatcherServlet</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring Boot遵循不同的初始化顺序。 Spring Boot使用Spring配置来引导自身和嵌入式Servlet容器，而不是挂钩到Servlet容器的生命周期。 在Spring配置中检测<code>Filter</code> 和<code>Servlet</code>声明，并在Servlet容器中注册。 有关更多详细信息，请参阅[Spring Boot</p><p>documentation](<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container)%E6%96%87%E6%A1%A3%E3%80%82">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container)文档。</a></p><h4 id="1-1-1-上下文层次结构"><a href="#1-1-1-上下文层次结构" class="headerlink" title="1.1.1. 上下文层次结构"></a>1.1.1. 上下文层次结构</h4><p><code>DispatcherServlet</code>需要一个 <code>WebApplicationContext</code>（ApplicationContext的扩展）来配置自己。 <code>WebApplicationContext</code>有一个指向<code>ServletContext</code>的链接以及与之关联的 <code>Servlet</code>。 它还绑定到<code>ServletContext</code>，当需要访问它时，应用程序可以使用<code>RequestContextUtils</code>上的静态方法来查找<code>WebApplicationContext</code>。</p><p>对于许多应用程序，拥有一个简单的 <code>WebApplicationContext</code>已经足够了。它也有一个上下文层次结构，其中根<code>WebApplicationContext</code>在多个 <code>DispatcherServlet</code>（或其他 <code>Servlet</code>）实例之间共享， 每个实例都有自己的子<code>WebApplicationContext</code>配置。 有关上下文层次结构功能的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#context-introduction"><code>ApplicationContext</code>的其他功能</a>。</p><p>根WebApplicationContext通常包含bean基础结构，例如需要跨多个Servlet实例共享的数据存储库和业务服务。 这些bean被有效继承，可以在特定于 <code>Servlet</code>的子<code>WebApplicationContext</code>中重写（即重新声明），它通常包含给定<code>Servlet</code>本地的bean。 下图显示了这种关系：</p><p>![mvc context hierarchy](Web MVC&#x2F;mvc-context-hierarchy.png)</p><p>以下示例配置<code>WebApplicationContext</code>层次结构:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getRootConfigClasses() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>&lt;?&gt;[] &#123; <span class="hljs-type">RootConfig</span>.<span class="hljs-keyword">class</span> &#125;;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getServletConfigClasses() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>&lt;?&gt;[] &#123; <span class="hljs-type">App1Config</span>.<span class="hljs-keyword">class</span> &#125;;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span>[] getServletMappings() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[] &#123; <span class="hljs-string">&quot;/app1/*&quot;</span> &#125;;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果不需要应用程序上下文层次结构，则应用程序可以通过<code>getRootConfigClasses()</code> 返回所有配置，并从<code>getServletConfigClasses()</code>返回<code>null</code>。</p><p>以下示例显示了<code>web.xml</code>配置（和上面效果一样）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app1<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app1/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果不需要应用程序上下文层次结构，则应用程序可以仅配置“root”上下文，并将 <code>contextConfigLocation</code> Servlet参数保留为空。</p><h4 id="1-1-2-特殊的Bean类型"><a href="#1-1-2-特殊的Bean类型" class="headerlink" title="1.1.2. 特殊的Bean类型"></a>1.1.2. 特殊的Bean类型</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-special-bean-types">Same as in Spring WebFlux</a></p><p><code>DispatcherServlet</code> 委托特殊bean处理请求并渲染视图。 “特殊bean”是指实现WebFlux框架的Spring管理的<code>Object</code>实例。 这些通常带有内置联系，但您可以自定义其属性并扩展或替换它们。</p><p>下表列出了<code>DispatcherHandler</code>检测到的特殊bean:</p><table><thead><tr><th>Bean 类型</th><th>说明</th></tr></thead><tbody><tr><td><code>HandlerMapping</code></td><td>将请求映射到处理程序以及用于预处理和后处理的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-handlermapping-interceptor">拦截器</a>列表。 其映射规则基于某些标准，其细节因<code>HandlerMapping</code>实现而异。两个主要的<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code>（它支持<code>@RequestMapping</code>带注解的方法） 和<code>SimpleUrlHandlerMapping</code> （它维护对处理程序的URI路径模式的显式注册）。</td></tr><tr><td><code>HandlerAdapter</code></td><td>无论实际调用处理程序如何，都可以帮助<code>DispatcherServlet</code> 调用映射到请求的处理程序。 例如，调用带有注解的控制器，需要从注解中解析一些信息。 <code>HandlerAdapter</code>的主要目的是保护<code>DispatcherServlet</code>不受此类细节的影响。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></td><td>解决异常的策略，他可以将捕获到的异常映射到处理程序，HTML错误视图或其他目标。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-exceptionhandlers">Exceptions</a>。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-viewresolver"><code>ViewResolver</code></a></td><td>将从处理程序返回的逻辑基于<code>String</code>的视图名称解析为用于呈现给响应的实际<code>View</code>。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-viewresolver">View Resolution</a> and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-view">View Technologies</a>。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver"><code>LocaleResolver</code></a>, <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-timezone">LocaleContextResolver</a></td><td>解析客户端正在使用的 <code>Locale</code>以及可能的时区，以便能够提供国际化视图。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver">Locale</a>。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-themeresolver"><code>ThemeResolver</code></a></td><td>解决Web应用程序可以使用的主题 - 例如，提供个性化布局。 见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-themeresolver">Themes</a>。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart"><code>MultipartResolver</code></a></td><td>解析multi-part的请求（例如：浏览器表单文件上载）。请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart">Multipart Resolver</a>。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-flash-attributes"><code>FlashMapManager</code></a></td><td>存储和检索“input” 和“output”<code>FlashMap</code>，可用于将属性从一个请求传递到另一个请求，通常是通过重定向。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-flash-attributes">Flash Attributes</a>。</td></tr></tbody></table><h4 id="1-1-3-Web-MVC-配置"><a href="#1-1-3-Web-MVC-配置" class="headerlink" title="1.1.3. Web MVC 配置"></a>1.1.3. Web MVC 配置</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-framework-config">Same as in Spring WebFlux</a></p><p>对于每种类型的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-servlet-special-bean-types">特殊bean</a>， <code>DispatcherServlet</code>首先会检查<code>WebApplicationContext</code>。如果没有匹配的bean类型，则会退回检查<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties"><code>DispatcherServlet.properties</code></a>。</p><p>在大多数情况下，<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a>是最佳起点。 它以Java或XML声明所需的bean，并提供更高级别的配置回调API来自定义它。</p><p>Spring Boot依赖于MVC Java配置来配置Spring MVC并提供许多额外的便捷选项。</p><h4 id="1-1-4-Servlet-配置"><a href="#1-1-4-Servlet-配置" class="headerlink" title="1.1.4. Servlet 配置"></a>1.1.4. Servlet 配置</h4><p>在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方法，也可以与<code>web.xml</code>文件结合使用。 以下示例注册<code>DispatcherServlet</code>:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.springframework.web.WebApplicationInitializer;<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebApplicationInitializer</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">WebApplicationInitializer</span></span> </span>&#123;<br>    <span class="hljs-meta">@Override    public void onStartup</span>(ServletContext container) &#123;        XmlWebApplicationContext appContext = <span class="hljs-keyword">new</span> <span class="hljs-type">XmlWebApplicationContext</span>();        appContext.setConfigLocation(<span class="hljs-string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);<br>        ServletRegistration.<span class="hljs-keyword">Dynamic</span> registration = container.addServlet(<span class="hljs-string">&quot;dispatcher&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">DispatcherServlet</span>(appContext));        registration.setLoadOnStartup(<span class="hljs-number">1</span>);        registration.addMapping(<span class="hljs-string">&quot;/&quot;</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p><code>WebApplicationInitializer</code>是Spring MVC提供的一个接口，实现此接口的任何Servlet 3容器都可被检测到并自动初始化。 <code>AbstractDispatcherServletInitializer</code>抽象类实现了<code>WebApplicationInitializer</code>接口，通过重写方法来指定servlet映射和<code>DispatcherServlet</code> 配置的地址， 从而更方便的注册<code>DispatcherServlet</code>。</p><p>对于使用基于Java的Spring配置的应用程序，建议使用此方法，如以下示例所示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getRootConfigClasses() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getServletConfigClasses() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>&lt;?&gt;[] &#123; <span class="hljs-type">MyWebConfig</span>.<span class="hljs-keyword">class</span> &#125;;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span>[] getServletMappings() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[] &#123; <span class="hljs-string">&quot;/&quot;</span> &#125;;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果使用基于XML的Spring配置，则应直接从<code>AbstractDispatcherServletInitializer</code>扩展，如以下示例所示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">WebApplicationContext</span> createRootApplicationContext() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">WebApplicationContext</span> createServletApplicationContext() &#123;        <span class="hljs-type">XmlWebApplicationContext</span> cxt = <span class="hljs-keyword">new</span> <span class="hljs-type">XmlWebApplicationContext</span>();        cxt.setConfigLocation(<span class="hljs-string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);        <span class="hljs-keyword">return</span> cxt;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span>[] getServletMappings() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[] &#123; <span class="hljs-string">&quot;/&quot;</span> &#125;;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractDispatcherServletInitializer</code>还提供了一种便捷的方法来添加<code>Filter</code>实例并将它们自动映射到DispatcherServlet，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Filter</span>[] getServletFilters() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Filter</span>[] &#123;            <span class="hljs-keyword">new</span> <span class="hljs-type">HiddenHttpMethodFilter</span>(), <span class="hljs-keyword">new</span> <span class="hljs-type">CharacterEncodingFilter</span>() &#125;;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>每个过滤器都根据其具体类型添加默认名称，并自动映射到<code>DispatcherServlet</code>。</p><p><code>AbstractDispatcherServletInitializer</code>的protected方法<code>isAsyncSupported</code>提供了一个单独的地址来启用<code>DispatcherServlet</code> 上的异步支持以及映射到它的所有过滤器。 默认情况下，此标志设置为<code>true</code>。</p><p>最后，如果您需要进一步自定义<code>DispatcherServlet</code>本身，则可以覆盖<code>createDispatcherServlet</code>方法。</p><h4 id="1-1-5-处理流程"><a href="#1-1-5-处理流程" class="headerlink" title="1.1.5. 处理流程"></a>1.1.5. 处理流程</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-dispatcher-handler-sequence">Same as in Spring WebFlux</a></p><p><code>DispatcherServlet</code>按如下方式处理请求：</p><ul><li>首先，搜索应用的上下文对象<code>WebApplicationContext</code>，并把它作为一个属性（attribute)绑定到该请求上。以便让控制器和其他组件能使用它。 属性的键名默认为<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>。</li><li>将locale resolver绑定到请求上，并允许其他组件解析处理请求时使用的语言环境（渲染视图，准备数据等）。 如果您不需要区域解析，则不需要locale resolver。</li><li>将theme resolver 绑定到请求，以允许视图等组件确定要使用的themes。 如果您不使用themes，则可以忽略它。</li><li>如果指定multipart 文件处理器，则会检查请求的文件是不是multiparts的， 如果是，请求将包装在<code>MultipartHttpServletRequest</code>中， 以便其他组件进一步处理。 有关<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart">Multipart Resolver</a>的更多信息，请参见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart">Multipart Resolver</a>。</li><li>为该请求查找一个合适的处理器。 如果找到处理程序，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。 或者，对于带注解的控制器，可以显示响应（在 <code>HandlerAdapter</code>中）而不是返回视图。</li><li>如果处理器返回模型，则渲染视图。 如果没有返回模型（可能是由于前处理器或后处理器拦截请求，可能是出于安全原因），则不会渲染任何视图，因为该请求可能已经完成。</li></ul><p>在 <code>WebApplicationContext</code> 中声明的<code>HandlerExceptionResolver</code>用于解决请求处理过程中引发的异常。这些异常解析程序允许使用自定义的逻辑来解决，有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-exceptionhandlers">Exceptions</a> 。</p><p>Spring的 <code>DispatcherServlet</code>也允许处理器返回Servlet API规范中定义的最后修改时间戳（<code>last-modification-date</code>）值。确定请求最后修改时间的方式是直截了当的： <code>DispatcherServlet</code>会先查找合适的处理映射来找到请求对应的处理器，然后检测它是否实现了 <code>LastModified</code> 接口。如果是的话，则调用接口的<code>long getLastModified(request)</code>方法，并将返回的值传回给客户端。</p><p>您可以自定义通过<code>DispatcherServlet</code>的配置。可以在<code>web.xml</code>文件中，声明元素Servlet的上添加Servlet的初始化参数（<code>init-param</code>元素）。 下表列出了支持的参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>contextClass</code></td><td>实现<code>ConfigurableWebApplicationContext</code>的类，由此类通过本地配置来初始化 Servlet实例。 默认情况下，使用<code>XmlWebApplicationContext</code>。</td></tr><tr><td><code>contextConfigLocation</code></td><td>一个指定了上下文配置文件路径的字符串，并传递给上下文实例（由<code>contextClass</code>指定） 。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。 对于具有两次定义的bean的多个上下文位置，最新位置优先（即最后加载的为准）。</td></tr><tr><td><code>namespace</code></td><td><code>WebApplicationContext</code>的命名空间。 默认为<code>[servlet-name]-servlet</code>。</td></tr><tr><td><code>throwExceptionIfNoHandlerFound</code></td><td>当没有找到请求的处理程序时是否抛出 <code>NoHandlerFoundException</code>。 然后可以使用 <code>HandlerExceptionResolver</code>捕获异常（例如，使用<code>@ExceptionHandler</code>控制器方法）并像处理其他任何方法一样处理异常。默认情况下，此参数设置为 <code>false</code>，在这种情况下，<code>DispatcherServlet</code>将响应状态设置为404（NOT_FOUND），而不会引发异常。请注意，如果配置了 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-default-servlet-handler">默认servlet处理</a> ，则始终将未解析的请求转发到默认servlet，并且永远不会引发404。</td></tr></tbody></table><h4 id="1-1-6-Interception"><a href="#1-1-6-Interception" class="headerlink" title="1.1.6. Interception"></a>1.1.6. Interception</h4><p>Spring的处理器映射机制包含了处理器拦截器，，可以实现 <code>HandlerMapping</code>，所有 <code>HandlerMapping</code>实现都支持处理拦截器，这些拦截器在需要为特定类型的请求应用一些功能时可能很有用非常有用， 例如，检查用户身份等，<code>org.springframework.web.servlet</code>包中的 <code>HandlerInterceptor</code>实现了三种方法，提供足够的灵活性来执行各种预处理和后处理：</p><ul><li><code>preHandle(..)</code>: 在执行实际处理程序之前</li><li><code>postHandle(..)</code>: 在执行实际处理程序之后</li><li><code>afterCompletion(..)</code>: 完成请求后</li></ul><p><code>preHandle(..)</code> 方法返回一个布尔值。 您可以使用此方法来中断或继续执行链的处理。 当此方法返回 <code>true</code>时，处理程序执行链继续。 当它返回false时，<code>DispatcherServlet</code>假定拦截器本身已处理请求（例如，呈现适当的视图）并且不继续执行执行链中的其他拦截器和实际处理程序。</p><p>有关如何配置<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-interceptors">Interceptors</a> 的示例，请参阅MVC配置一节中的拦截器。 您还可以使用各个 <code>HandlerMapping</code>实现上的setter方法直接注册它们。</p><p>请注意，在HandlerAdapter和postHandle之前，响应被写入并提交。 <code>postHandle</code>对于<code>@ResponseBody</code>和ResponseEntity方法不太有用， 这意味着对响应进行任何更改都为时已晚，例如添加额外的header。 对于此类方案，您可以实现 <code>ResponseBodyAdvice</code>并将其声明为<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-controller-advice">Controller Advice</a>bean或直接在<code>RequestMappingHandlerAdapter</code>上进行配置。</p><h4 id="1-1-7-异常"><a href="#1-1-7-异常" class="headerlink" title="1.1.7. 异常"></a>1.1.7. 异常</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-dispatcher-exceptions">Same as in Spring WebFlux</a></p><p>如果在请求映射期间发生异常或从请求处理程序（例如 <code>@Controller</code>）抛出异常， 则<code>DispatcherServlet</code>委托给 <code>HandlerExceptionResolver</code> bean来处理并解决异常，这通常是错误响应。</p><p>下表列出了可用的 <code>HandlerExceptionResolver</code> 实现：:</p><p>Table 2. HandlerExceptionResolver 实现 ：</p><table><thead><tr><th><code>HandlerExceptionResolver</code></th><th>Description</th></tr></thead><tbody><tr><td><code>SimpleMappingExceptionResolver</code></td><td>异常类名称和错误视图名称之间的映射。 用于在浏览器应用程序中呈现错误页面。</td></tr><tr><td><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></td><td>解决Spring MVC引发的异常并将它们映射到HTTP状态代码。 另请参阅备用<code>ResponseEntityExceptionHandler</code>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-rest-exceptions">REST API exceptions</a>异常。</td></tr><tr><td><code>ResponseStatusExceptionResolver</code></td><td>使用<code>@ResponseStatus</code>注解解析异常，并根据注解中的值将它们映射到HTTP状态代码。</td></tr><tr><td><code>ExceptionHandlerExceptionResolver</code></td><td>通过在<code>@Controller</code>或 <code>@ControllerAdvice</code>类中调用 <code>@ExceptionHandler</code>方法来解决异常。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-exceptionhandler">@ExceptionHandler methods</a>方法。</td></tr></tbody></table><h5 id="解析链"><a href="#解析链" class="headerlink" title="解析链"></a>解析链</h5><p>您可以通过在Spring配置中声明多个 <code>HandlerExceptionResolver</code> bean并根据需要设置其顺序属性来形成异常解析链。 <code>order</code>属性越高，异常解析器定位的越晚。</p><p><code>HandlerExceptionResolver</code>的约定指定它可以返回:</p><ul><li>一个指向错误视图的 <code>ModelAndView</code>。</li><li>如果在解析程序中处理异常，则为空的<code>ModelAndView</code>。</li><li>如果异常仍未解析，则为 <code>null</code>，以供后续解析器尝试，如果异常保留在最后，则允许冒泡到Servlet容器。.</li></ul><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a>自动声明内置的解析器，用于默认的Spring MVC异常，<code>@ResponseStatus</code> 带注解的异常，以及对<code>@ExceptionHandler</code>方法的支持。 您可以自定义该列表或替换它。</p><h5 id="容器错误页面"><a href="#容器错误页面" class="headerlink" title="容器错误页面"></a>容器错误页面</h5><p>如果任何<code>HandlerExceptionResolver</code>仍未解析异常，并且因此将其传播给servlet容器或者如果响应状态设置为错误状态（即4xx，5xx） ，则Servlet容器可以呈现HTML中的默认错误页面。 要自定义容器的默认错误页面，可以在 <code>web.xml</code>.中声明错误页面映射。 以下示例显示了如何执行此操作：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">&lt;<span class="hljs-keyword">error</span>-<span class="hljs-keyword">page</span>&gt;<br><br>    &lt;location&gt;/<span class="hljs-keyword">error</span>&lt;/location&gt;<br><br>&lt;/<span class="hljs-keyword">error</span>-<span class="hljs-keyword">page</span>&gt;<br></code></pre></td></tr></table></figure><p>根据前面的示例，当异常冒泡或响应具有错误状态时，Servlet容器会在容器内对配置的URL进行ERROR调度（例如，<code>/error</code>）。 然后由<code>DispatcherServlet</code>处理，可能将其映射到 <code>@Controller</code>，可以实现该控件以返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@RestControllerpublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorController</span> &#123;<br>    @RequestMapping(path = <span class="hljs-string">&quot;/error&quot;</span>)    public <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; handle(HttpServletRequest request) &#123;        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt;();        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;status&quot;</span>, request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.status_code&quot;</span>));        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;reason&quot;</span>, request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.message&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>Servlet API没有提供在Java中创建错误页面映射的方法。 但是，您可以同时使用<code>WebApplicationInitializer</code>和最小的 <code>web.xml</code>。</p><h4 id="1-1-8-视图解析"><a href="#1-1-8-视图解析" class="headerlink" title="1.1.8. 视图解析"></a>1.1.8. 视图解析</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-viewresolution">Same as in Spring WebFlux</a></p><p>Spring MVC定义了 <code>ViewResolver</code>和 <code>View</code>接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。 <code>ViewResolver</code>提供视图名称和实际视图之间的映射。 <code>View</code>接口负责准备请求，并将请求的渲染交给某种具体的视图技术实现。</p><p>下表提供了有关<code>ViewResolver</code>层次结构的更多详细信息：:</p><p>Table 3. ViewResolver 实现</p><table><thead><tr><th>ViewResolver</th><th>Description</th></tr></thead><tbody><tr><td><code>AbstractCachingViewResolver</code></td><td><code>AbstractCachingViewResolver</code> 的子类缓存它们解析的视图实例。 缓存可提高某些视图技术的性能。 您可以通过将<code>cache</code>属性设置为 <code>false</code>.来关闭缓存。 此外，如果必须在运行时刷新某个视图（例如，修改FreeMarker模板时），则可以使用<code>removeFromCache(String viewName, Locale loc)</code> 方法。</td></tr><tr><td><code>XmlViewResolver</code></td><td>实现<code>ViewResolver</code>，它必须和Spring的XML bean工厂有相同的DTD以。 默认配置文件是<code>/WEB-INF/views.xml</code>。</td></tr><tr><td><code>ResourceBundleViewResolver</code></td><td><code>ViewResolver</code>的实现，它使用由bundle根路径指定的<code>ResourceBundle</code>中的bean定义作为配置。 对于它应该解析的每个视图，它使用属性<code>[viewname].(class)</code>的值作为视图类， 并使用属性 <code>[viewname].url</code> 的值作为视图URL。 您可以在 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-view">视图技术</a>一章中找到示例。</td></tr><tr><td><code>UrlBasedViewResolver</code></td><td><code>ViewResolver</code>接口的简单实现，它不需要其他任何显式的映射说明，而直接使用URL来解析到逻辑视图名。 如果您的逻辑名称与真正的视图资源的名称匹配，则不需要任何映射。</td></tr><tr><td><code>InternalResourceViewResolver</code></td><td><code>UrlBasedViewResolver</code>的便捷子类，支持 <code>InternalResourceView</code>（实际上是Servlet和JSP）和子类，如<code>JstlView</code> 和 <code>TilesView</code>。 您可以使用<code>setViewClass(..)</code>为此解析程序生成的所有视图指定视图类。 有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/UrlBasedViewResolver.html"><code>UrlBasedViewResolver</code></a>javadoc。</td></tr><tr><td><code>FreeMarkerViewResolver</code></td><td><code>UrlBasedViewResolver</code> 的便捷子类，支持 <code>FreeMarkerView</code>及其自定义子类。</td></tr><tr><td><code>ContentNegotiatingViewResolver</code></td><td>实现 <code>ViewResolver</code> 接口，该接口根据请求文件名或Accept头解析视图。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multiple-representations">Content Negotiation</a>。</td></tr></tbody></table><h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-viewresolution-handling">Same as in Spring WebFlux</a></p><p>您可以在视图解析器链中声明多个视图解析器，并在必要时通过设置 <code>order</code>属性来指定排序。 请记住，order属性越高，视图解析器在链中的位置越晚。 .</p><p><code>ViewResolver</code> 可以返回null以指示无法找到该视图。 但是，对于JSP和<code>InternalResourceViewResolver</code>, 确定JSP是否存在的唯一方法是通过<code>RequestDispatcher</code>执行调度。 因此，您必须始终将<code>InternalResourceViewResolver</code>配置为视图解析器的整体顺序中的最后一个。</p><p>配置视图解析就像将<code>ViewResolver</code> bean添加到Spring配置一样简单。<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a>为<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-view-resolvers">View Resolvers</a>提供专用配置API，并添加无逻辑视图控制器（<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-view-controller">View Controllers</a> ），这些控制器对于没有控制器逻辑的HTML模板渲染非常有用。</p><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-redirecting-redirect-prefix">Same as in Spring WebFlux</a></p><p>您可以在视图中使用<code>redirect:</code>前缀来执行重定向。<code>UrlBasedViewResolver</code>（及其子类）将此识别为需要重定向的指令。 视图名称的其余部分是重定向URL。</p><p>控制器本身可以根据逻辑视图名称进行操作。 逻辑视图名称（例如<code>redirect:/myapp/some/resource</code>）相对于当前Servlet上下文重定向，而名称如<code>redirect:http://myhost.com/some/arbitrary/path</code>重定向到绝对URL。</p><p>请注意，如果使用<code>@ResponseStatus</code>注解控制器方法，则注解值优先于 <code>RedirectView</code>设置的响应状态。</p><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>你也可以在视图名称中使用<code>forward:</code>前缀，来作为 <code>UrlBasedViewResolver</code>和其子类最终解析的视图名称。 这将创建一个 <code>InternalResourceView</code>，它执行<code>RequestDispatcher.forward()</code>。 因此，此前缀对于 <code>InternalResourceViewResolver</code>和<code>InternalResourceView</code>（对于JSP）没有用，但如果您使用其他视图技术时仍希望强制Servlet&#x2F;JSP引擎处理资源的转发，则它可能会有所帮助。 请注意，您也可以链接多个视图解析器。</p><h5 id="Content-Negotiation"><a href="#Content-Negotiation" class="headerlink" title="Content Negotiation"></a>Content Negotiation</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-multiple-representations">Same as in Spring WebFlux</a></p><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html"><code>ContentNegotiatingViewResolver</code></a>本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示的视图。 可以从<code>Accept</code>头或查询参数（例如， <code>&quot;/path?format=pdf&quot;</code>）确定表示。</p><p><code>ContentNegotiatingViewResolver</code>通过将请求的媒体类型与其每个ViewResolvers关联的View支持的媒体类型（也称为<code>Content-Type</code>）进行比较，选择适当的 <code>View</code>来处理请求。列表中具有兼容Content-Type的第一个<code>View</code>将表示返回给客户端。 如果 <code>ViewResolver</code>链无法提供兼容视图，则会查询通过<code>DefaultViews</code> 属性指定的视图列表。 后一个选项适用于单个视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。 <code>Accept</code>头可以包含通配符（例如<code>text/*</code>），在这种情况下，<code>Content-Type</code>为<code>text/xml</code>的View是兼容匹配。</p><p>有关配置详细信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a> 下的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-view-resolvers">View Resolvers</a> 。</p><h4 id="1-1-9-Locale"><a href="#1-1-9-Locale" class="headerlink" title="1.1.9. Locale"></a>1.1.9. Locale</h4><p>正如Spring Web MVC框架所做的那样，Spring架构的大多数部分都支持国际化。 <code>DispatcherServlet</code>允许您使用客户端的语言环境自动解析消息。 这是通过<code>LocaleResolver</code>对象完成的。</p><p>当请求进入时，<code>DispatcherServlet</code> 会查找当前语言环境解析器，如果找到，则会尝试使用它来设置语言环境。 您可以通过使用<code>RequestContext.getLocale()</code>方法，来获取由区域解析器解析到的结果。</p><p>除了自动解析语言环境之外，您还可以在处理程序时添加拦截器（有关拦截器的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-handlermapping-interceptor">Interception</a> ），以便于在特定情况下更改语言环境。例如（通过请求中的参数来改变语言环境）</p><p>区域解析器和拦截器在 <code>org.springframework.web.servlet.i18n</code>包中定义，并以正常方式在应用程序上下文中进行配置。 Spring中包含以下选择的语言环境解析器。</p><ul><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-timezone">Time Zone</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver-acceptheader">Header Resolver</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver-cookie">Cookie Resolver</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver-session">Session Resolver</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-localeresolver-interceptor">Locale Interceptor</a></li></ul><h5 id="Time-Zone"><a href="#Time-Zone" class="headerlink" title="Time Zone"></a>Time Zone</h5><p>除了获取客户端的区域设置外，了解其时区通常也很有用。 <code>LocaleContextResolver</code> 接口提供了<code>LocaleResolver</code>的扩展，它允许解析器提供更丰富的 <code>LocaleContext</code>，其中可能包含时区信息。</p><p>当此解析器可用时，可以使用<code>RequestContext.getTimeZone()</code>方法获取用户的<code>TimeZone</code>。 时区信息由Spring的<code>ConversionService</code>注册的任何Date&#x2F;Time <code>Converter</code>和<code>Formatter</code> 对象自动使用。</p><h5 id="Header-Resolver"><a href="#Header-Resolver" class="headerlink" title="Header Resolver"></a>Header Resolver</h5><p>此区域解析器检查客户端（例如，Web浏览器）发送的请求头中的<code>accept-language</code>。 通常，此字段包含客户端操作系统的区域设置。 请注意，此解析器不支持时区信息。</p><h5 id="Cookie-Resolver"><a href="#Cookie-Resolver" class="headerlink" title="Cookie Resolver"></a>Cookie Resolver</h5><p>此区域解析器检查客户端上可能存在的 <code>Cookie</code>，以查看是否指定了<code>Locale</code>或<code>TimeZone</code>。 如果是，则使用指定的详细信息。 通过使用此区域解析器的属性，您可以指定cookie的名称以及失效时间。 以下示例定义<code>CookieLocaleResolver</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cookieName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;clientlanguage&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cookieMaxAge&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100000&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下表描述了 <code>CookieLocaleResolver</code>的属性：</p><p>Table 4. CookieLocaleResolver properties:</p><table><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>cookieName</code></td><td>classname + LOCALE</td><td>cookie的名字</td></tr><tr><td><code>cookieMaxAge</code></td><td>Servlet container default</td><td>Cookie在客户端上持续存在的最长时间。 如果指定<code>-1</code>，则不会保留cookie。 它仅在客户端关闭浏览器之前可用。</td></tr><tr><td><code>cookiePath</code></td><td>&#x2F;</td><td>限制cookie对您网站某个部分的可见性。 当指定了 <code>cookiePath</code>时，cookie仅对该路径及其下方的路径可见。</td></tr></tbody></table><h5 id="Session-Resolver"><a href="#Session-Resolver" class="headerlink" title="Session Resolver"></a>Session Resolver</h5><p>您可以使用 <code>SessionLocaleResolver</code>从与用户请求关联的Session中获取<code>Locale</code> 和<code>TimeZone</code>。 与<code>CookieLocaleResolver</code>相比，此策略将本地选择的区域设置存储在Servlet容器的 <code>HttpSession</code>中。 因此，这些设置对于每个会话都是临时的，这些设置在会话结束时会丢失。</p><p>请注意，与外部会话管理机制没有直接关系，例如Spring Session项目。 此<code>SessionLocaleResolver</code> 根据当前的<code>HttpServletRequest</code>评估和修改相应的<code>HttpSession</code>属性。</p><h5 id="Locale-Interceptor"><a href="#Locale-Interceptor" class="headerlink" title="Locale Interceptor"></a>Locale Interceptor</h5><p>您可以通过将<code>LocaleChangeInterceptor</code>添加到其中一个 <code>HandlerMapping</code>定义来启用语言环境的更改。 它会检测请求中的参数并相应地更改语言环境，在程序的应用程序上下文中调用 <code>LocaleResolver</code> 上的<code>setLocale</code>方法。 下一个示例显示，当调用包含名为 <code>siteLanguage</code>的参数的所有<code>*.view</code>资源时更改了区域设置。 例如，对URL的请求 <code>[http://www.sf.net/home.view?siteLanguage=nl](https://www.sf.net/home.view?siteLanguage=nl)</code>将网站语言更改为荷兰语。 以下示例显示如何拦截区域设置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeChangeInterceptor&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;paramName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;siteLanguage&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;urlMapping&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptors&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;localeChangeInterceptor&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mappings&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/**/*.view=someController<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-1-10-主题"><a href="#1-1-10-主题" class="headerlink" title="1.1.10. 主题"></a>1.1.10. 主题</h4><p>您可以使用Spring Web MVC框架自带的主题来设置应用程序的整体外观，从而增强用户体验。 主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉样式。</p><h5 id="定义一个主题"><a href="#定义一个主题" class="headerlink" title="定义一个主题"></a>定义一个主题</h5><p>要在Web应用程序中使用主题，必须设置 <code>org.springframework.ui.context.ThemeSource</code>接口的实现。 <code>WebApplicationContext</code>接口扩展了 <code>ThemeSource</code>， 但将其职责委托给专用实现。 默认情况下，委托是 <code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>的实现。它从类路径的根目录加载属性文件。 要使用自定义 <code>ThemeSource</code>实现或配置 <code>ResourceBundleThemeSource</code>的名称前缀，可以在应用程序上下文中使用保留名称<code>themeSource</code>注册bean。 Web应用程序上下文自动检测具有该名称的bean并使用它。</p><p>使用 <code>ResourceBundleThemeSource</code>时，主题在简单属性文件中定义。 属性文件列出构成主题的资源，如以下示例所示：</p><p>styleSheet&#x3D;&#x2F;themes&#x2F;cool&#x2F;style.css background&#x3D;&#x2F;themes&#x2F;cool&#x2F;img&#x2F;coolBg.jpg</p><p>属性的键是从视图代码引用主题元素的名称。 对于JSP，通常使用<code>spring:theme</code> 自定义标签执行此操作，该标记与<code>spring:message</code>标签非常相似。 以下JSP片段使用上一示例中定义的主题来自定义外观：</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="language-xml">&lt;%</span><span class="language-ruby">@ taglib prefix=<span class="hljs-string">&quot;spring&quot;</span> uri=<span class="hljs-string">&quot;http://www.springframework.org/tags&quot;</span></span><span class="language-xml">%&gt;</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;spring:theme code=&#x27;styleSheet&#x27;/&gt;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background=&lt;spring:theme code=&#x27;background&#x27;/&gt;&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        ...</span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>默认情况下，<code>ResourceBundleThemeSource</code>使用空的名称前缀。 因此，从类路径的根加载属性文件。 因此，您可以将<code>cool.properties</code>主题定义放在类路径根目录的目录中（例如，在 <code>/WEB-INF/classes</code>中）。 <code>ResourceBundleThemeSource</code>使用标准的Java资源包加载机制，从而使主题也具有国际化。 例如，我们可以有一个<code>/WEB-INF/classes/cool_nl.properties</code>，它引用一个带有荷兰文本的特殊背景图像。</p><h5 id="解析主题"><a href="#解析主题" class="headerlink" title="解析主题"></a>解析主题</h5><p>定义主题后，<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-themeresolver-defining">如上一节所述</a>，您可以决定使用哪个主题。 <code>DispatcherServlet</code>查找名为<code>themeResolver</code>的bean，以找出要使用的<code>ThemeResolver</code>实现。 主题解析器的工作方式与<code>LocaleResolver</code>的工作方式大致相同。 它检测用于特定请求的主题，还可以更改请求的主题。 下表描述了Spring提供的主题解析器：</p><p>Table 5. ThemeResolver implementations :</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><code>FixedThemeResolver</code></td><td>选择使用<code>defaultThemeName</code></td></tr><tr><td><code>SessionThemeResolver</code></td><td>主题在用户的HTTP会话中维护。 它只需要为每个会话设置一次，但不会在会话之间保留。</td></tr><tr><td><code>CookieThemeResolver</code></td><td>所选主题存储在客户端的cookie中。</td></tr></tbody></table><p>Spring还提供了一个<code>ThemeChangeInterceptor</code>，它允许通过简单的请求参数对每个请求进行主题更改。</p><h4 id="1-1-11-Multipart-解析器"><a href="#1-1-11-Multipart-解析器" class="headerlink" title="1.1.11. Multipart 解析器"></a>1.1.11. Multipart 解析器</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-multipart">Same as in Spring WebFlux</a></p><p><code>org.springframework.web.multipart</code> 包中的 <code>MultipartResolver</code>是一种用于解析包括文件上传在内的多部分请求的策略。 他包含了一个<a href="https://jakarta.apache.org/commons/fileupload">Commons FileUpload</a> 的实现，另一个基于Servlet 3.0多部分请求解析。</p><p>要启用多部分处理，Spring的配置文件中，在 <code>DispatcherServlet</code> 配置名称为<code>multipartResolver</code>的<code>MultipartResolver</code> bean。 <code>DispatcherServlet</code>会自动检测并将其应用于请求中。 当收到内容类型为<code>multipart/form-data</code>的POST请求时，解析器会解析内容并将当前的<code>HttpServletRequest</code>包装为 <code>MultipartHttpServletRequest</code>，以提供对已解析部分的访问，并将其作为请求参数公开。</p><h5 id="Apache-Commons-FileUpload"><a href="#Apache-Commons-FileUpload" class="headerlink" title="Apache Commons FileUpload"></a>Apache Commons <code>FileUpload</code></h5><p>要使用Apache Commons <code>FileUpload</code>，您可以配置名为 <code>multipartResolver</code>的<code>CommonsMultipartResolver</code>r类型的bean。 您还需要添加<code>commons-fileupload</code>依赖。</p><h5 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h5><p>需要通过Servlet容器配置启用Servlet 3.0多部分解析:</p><ul><li>在Java中，在注册Servlet时设置 <code>MultipartConfigElement</code>。</li><li>在<code>web.xml</code>中，将“<code>&quot;&lt;multipart-config&gt;&quot;</code>”部分添加到servlet声明中。</li></ul><p>以下示例显示如何在注册Servlet时设置 <code>MultipartConfigElement</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void customizeRegistration(<span class="hljs-type">ServletRegistration</span>.<span class="hljs-type">Dynamic</span> registration) &#123;<br>        <span class="hljs-comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold        registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp&quot;));    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一旦您配置好Servlet 3.0，您就可以添加名为<code>multipartResolver</code>的<code>StandardServletMultipartResolver</code>类型的bean。</p><h4 id="1-1-12-日志"><a href="#1-1-12-日志" class="headerlink" title="1.1.12. 日志"></a>1.1.12. 日志</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-logging">Same as in Spring WebFlux</a></p><p>Spring MVC中的DEBUG级别日志记录旨在实现紧凑，简约和人性化。 它侧重于那些一次又一次使用的高价值信息，其他的只有在调试特定问题时才有用。</p><p>TRACE级日志记录通常遵循与DEBUG相同的原则（例如，不应该是fire hose），但可以用于调试任何问题。 此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。</p><p>良好的日志记录来自使用日志的经验。 如果您发现任何不符合既定目标的事件，请告知我们。</p><h5 id="敏感数据"><a href="#敏感数据" class="headerlink" title="敏感数据"></a>敏感数据</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-logging-sensitive-data">Same as in Spring WebFlux</a></p><p>DEBUG和TRACE日志记录可能会记录敏感信息。 这就是默认情况下屏蔽请求参数和请求头的原因，并且必须通过 <code>DispatcherServlet</code>上的 <code>enableLoggingRequestDetails</code>属性显式启用它们的完整日志记录。</p><p>以下示例说明如何使用Java配置执行此操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInitializer</span>        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getRootConfigClasses() &#123;        <span class="hljs-keyword">return</span> ... ;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt;[] getServletConfigClasses() &#123;        <span class="hljs-keyword">return</span> ... ;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span>[] getServletMappings() &#123;        <span class="hljs-keyword">return</span> ... ;    &#125;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void customizeRegistration(<span class="hljs-type">Dynamic</span> registration) &#123;        registration.setInitParameter(<span class="hljs-string">&quot;enableLoggingRequestDetails&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-过滤器"><a href="#1-2-过滤器" class="headerlink" title="1.2. 过滤器"></a>1.2. 过滤器</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-filters">Same as in Spring WebFlux</a></p><p><code>spring-web</code>模块提供了一些有用的过滤器:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-http-put">Form Data（表单数据）</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-forwarded-headers">Forwarded Headers（转发请求头）</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-shallow-etag">Shallow ETag（）</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-cors">CORS</a></li></ul><h4 id="1-2-1-表单数据"><a href="#1-2-1-表单数据" class="headerlink" title="1.2.1. 表单数据"></a>1.2.1. 表单数据</h4><p>浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE提交表单数据。 Servlet API要求<code>ServletRequest.getParameter*()</code>方法仅支持HTTP POST的表单字段访问。.</p><p><code>spring-web</code>模块提供 <code>FormContentFilter</code>过滤器来拦截HTTP PUT，PATCH和DELETE请求，请求类型为 <code>application/x-www-form-urlencoded</code>， <code>FormContentFilter</code>从请求中读取表单数据， 并包装 <code>ServletRequest</code>，然后可以通过 <code>ServletRequest.getParameter*()</code>系列方法提供表单数据。</p><h4 id="1-2-2-Forwarded-Headers（转发请求头）"><a href="#1-2-2-Forwarded-Headers（转发请求头）" class="headerlink" title="1.2.2. Forwarded Headers（转发请求头）"></a>1.2.2. Forwarded Headers（转发请求头）</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-forwarded-headers">Same as in Spring WebFlux</a></p><p>当通过代理主机或者端口或者其他方案请求时（例如，负载均衡），这是，从客户端角度看，创建正确的主机，端口或者其他方案成为一项挑战，</p><p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> RFC 7239定义了代理可以用来提供有关原始请求信息的转发HTTP头。 还有其他非标准头文件，包括<code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, 和 <code>X-Forwarded-Prefix</code>。</p><p><code>ForwardedHeaderFilter</code>是一个Servlet过滤器，它根据 <code>Forwarded</code> 头部信息修改请求的主机，端口和方案，然后删除请求头。</p><p>当转发请求头时需要注意的安全事项，因为应用程序无法知道请求头是代理按我们想的那样添加还是由客户端恶意添加，这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的转发请求头。 您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderFilter</code>，在这种情况下，它会删除但不使用标头。</p><h4 id="1-2-3-Shallow-ETag"><a href="#1-2-3-Shallow-ETag" class="headerlink" title="1.2.3. Shallow ETag"></a>1.2.3. Shallow ETag</h4><p><code>ShallowEtagHeaderFilter</code>过滤器通过缓存写入响应的内容并从中计算MD5哈希来创建 “shallow”ETag。 客户端下次发送时， 它会执行相同操作，但它也会将计算值与<code>If-None-Match</code>请求头进行比较，如果两者相等，则返回304（NOT_MODIFIED）。</p><p>此策略可以节省网络带宽，但不能节省CPU，因为必须为每个请求计算完整响应。 前面描述的控制器级别的其他策略可以避免计算。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching">HTTP Caching</a>。</p><p>此过滤器具有<code>writeWeakETag</code>参数，该参数将过滤器配置为写入弱ETag，类似于以下内容：<code>W/&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code>（如<a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232 Section 2.3</a>）。</p><h4 id="1-2-4-CORS"><a href="#1-2-4-CORS" class="headerlink" title="1.2.4. CORS"></a>1.2.4. CORS</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-filters-cors">Same as in Spring WebFlux</a></p><p>Spring MVC通过控制器上的注解为CORS配置提供细粒度的支持。 但是，当与Spring Security一起使用时，我们建议依赖于必须在Spring Security的过滤器链之前配置的内置<code>CorsFilter</code>。</p><p>有关更多详细信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-cors">CORS</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-cors-filter">CORS Filter</a> 过滤器部分。</p><h3 id="1-3-注解控制器"><a href="#1-3-注解控制器" class="headerlink" title="1.3. 注解控制器"></a>1.3. 注解控制器</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-controller">Same as in Spring WebFlux</a></p><p>Spring MVC提供了基于注解的编程模型，其中<code>@Controller</code> 和 <code>@RestController</code> 组件使用注解来表示请求映射、请求输入、异常处理等。被注解的控制器拥有灵活的方法签名，并且无需扩展基类或实现特定的接口。以下示例显示了由注解定义的控制器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span>    <span class="hljs-keyword">public</span> String handle(Model model) &#123;        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中，该方法接受<code>Model</code>并将视图名称作为String返回，但是存在许多其他选项，本章稍后将对其进行说明。</p><p>有关<a href="https://spring.io/guides">spring.io</a>的指南和教程，请使用本节中介绍的基于注解的编程模型。</p><h4 id="1-3-1-声明"><a href="#1-3-1-声明" class="headerlink" title="1.3.1. 声明"></a>1.3.1. 声明</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-controller">Same as in Spring WebFlux</a></p><p>您可以在Servlet的<code>WebApplicationContext</code>中使用标准的Spring bean定义来定义控制器bean。<code>@Controller</code>模板允许自动检测， 与Spring支持检测类路径中的<code>@Component</code>类一样，并会自动注册bean定义。它还充当注解类的模板，表示它充当的是Web组件的角色。</p><p>要启用<code>@Controller</code> bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">&quot;org.example.web&quot;</span>)public class WebConfig &#123;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了与前面示例等效的XML配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.web&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>@RestController</code> 是一个<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#beans-meta-annotations">组合注解</a> ，它本身由<code>@Controller</code> 和 <code>@ResponseBody</code>元注解组成。 其每个方法都继承类型级别（type-level）的 <code>@ResponseBody</code>注解，因此，直接写入响应主体与视图渲染和使用HTML模板。</p><h5 id="AOP-代理"><a href="#AOP-代理" class="headerlink" title="AOP 代理"></a>AOP 代理</h5><p>在某些情况下，您需要在运行时使用AOP代理装饰控制器。 例如，如果您想在控制器上直接使用<code>@Transactional</code>注解。 在这种情况下，对于控制器而言，我们建议使用基于类的代理。 这通常也是控制器的默认选择。 但是，如果控制器没有实现Spring Context回调的接口 （例如<code>InitializingBean</code>, <code>*Aware</code>等）， 则可能需要显式配置基于类的代理。 例如，使用 <code>&lt;tx:annotation-driven/&gt;</code>，您可以更改为<code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code>。</p><h4 id="1-3-2-Request-Mapping"><a href="#1-3-2-Request-Mapping" class="headerlink" title="1.3.2. Request Mapping"></a>1.3.2. Request Mapping</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping">Same as in Spring WebFlux</a></p><p><code>@RequestMapping</code>注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL、HTTP方法、请求参数、请求头参数（headers）和媒体类型进行匹配。 可以在类级别使用它来表示共享映射，或在方法级别上用于缩小到特定的端点映射范围。</p><p>还有<code>@RequestMapping</code>的HTTP方法特定的缩写变量:</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><p>这些简洁的注解是<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-composed">自定义注解</a>，因为，大多数的控制器方法应该映射到HTTP方法而不是使用<code>@RequestMapping</code>。默认情况下， <code>@RequestMapping</code>和所有HTTP方法匹配。在类上定义的仍然需要<code>@RequestMapping</code> 来表示共享映射。</p><p>以下示例具有类型和方法级别映射:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/persons&quot;</span>)class PersonController &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public Person <span class="hljs-built_in">getPerson</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>    <span class="hljs-variable">@PostMapping</span>    <span class="hljs-variable">@ResponseStatus</span>(HttpStatus.CREATED)    public void <span class="hljs-built_in">add</span>(<span class="hljs-variable">@RequestBody</span> Person person) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="URI-模式匹配"><a href="#URI-模式匹配" class="headerlink" title="URI 模式匹配"></a>URI 模式匹配</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-uri-templates">Same as in Spring WebFlux</a></p><p>你可以使用glob模式和通配符来映射请求:</p><ul><li><code>?</code> 匹配一个字符</li><li><code>*</code> 匹配路径段一个或多个字符</li><li><code>**</code> 匹配0个或多个路径段</li></ul><p>您还可以使用 <code>@PathVariable</code>声明URI变量并访问它们的值，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;</span>)<br><br>public Pet <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@PathVariable</span> Long ownerId, <span class="hljs-variable">@PathVariable</span> Long petId) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>您可以在类和方法级别声明URI变量，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;&quot;</span>)public class OwnerController &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/pets/&#123;petId&#125;&quot;</span>)    public Pet <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@PathVariable</span> Long ownerId, <span class="hljs-variable">@PathVariable</span> Long petId) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>URI变量会自动转换为适当的类型，或者引发 <code>TypeMismatchException</code>。 默认情况下支持简单类型（<code>int</code>, <code>long</code>, <code>Date</code>等），您也可以注册对任何其他数据类型的支持。 请参见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-typeconversion">Type Conversion</a> and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-initbinder"><code>DataBinder</code></a>。</p><p>你可以显示命名URI 变量(例如, <code>@PathVariable(&quot;customId&quot;)</code>),但是如果名称是相同的，并且代码是使用调试信息编译的，或者在Java 8中使用<code>-parameters</code> 编译器标记。 则可以保留该详细信息。</p><p>语法<code>&#123;varName:regex&#125;</code>声明一个具有正则表达式的URI变量，其语法为<code>&#123;varName:regex&#125;</code>。例如，给定URL<code>&quot;/spring-web-3.0.5 .jar&quot;</code>，以下方法提取名称，版本和文件扩展名:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;&quot;</span>)<br><br>public void <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@PathVariable</span> String version, <span class="hljs-variable">@PathVariable</span> String ext) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>URI路径模式还可以嵌入<code>$&#123;…&#125;</code>，在启动时通过<code>PropertyPlaceHolderConfigurer</code>解析本地、系统、环境和其他属性源时解析的占位符。例如，这种模式可以使用基于某些外部配置对基URL进行参数化</p><p>Spring MVC使用 <code>PathMatcher</code>联系和 <code>AntPathMatcher</code>实现位于<code>spring-core</code> URI路径匹配。</p><h5 id="模式比较"><a href="#模式比较" class="headerlink" title="模式比较"></a>模式比较</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-pattern-comparison">Same as in Spring WebFlux</a></p><p>当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。 这是通过使用 <code>AntPathMatcher.getPatternComparator(String path)</code>来完成的，它会查找更具体的模式。</p><p>如果URI变量的数量较少且单个通配符计为1且双通配符计为2，那么模式就不那么具体了。如果模式得到的分数相等，那么会选择较长的模式匹配。如果分数和长度都相同，则会选择拥有比通配符更多的URI变量的模式。</p><p>默认映射模式（<code>/**</code>）从评分中排除，并始终排在最后。 此外，前缀模式（例如<code>/public/**</code>）被认为比没有双通配符的其他模式更不具体。</p><p>有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html"><code>AntPathMatcher</code></a> 中的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html"><code>AntPatternComparator</code></a>。 您可以自定义<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html"><code>PathMatcher</code></a> 的实现. 请参阅 配置中的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-path-matching">Path Matching</a></p><h5 id="后缀匹配"><a href="#后缀匹配" class="headerlink" title="后缀匹配"></a>后缀匹配</h5><p>默认情况下,默认情况下，Spring MVC执行<code>.*</code> 后缀模式匹配，以便映射到 <code>/person</code>的控制器也隐式映射到 <code>/person.*</code>。这里使用文件扩展名来解释用于响应的请求内容类型（即，而不是 <code>Accept</code>请求头） - 例如，<code>/person.pdf</code>，<code>/person.xml</code>等。</p><p>当浏览器用于发送难以持续交互的<code>Accept</code>头时，必须以这种方式使用文件扩展名。目前，这不再是必需的，判断 <code>Accept</code>头应该是首选。</p><p>随着时间的推移，文件扩展名的使用已经证明有多种方式存在问题。 当使用URI变量，路径参数和URI编码进行覆盖时，它可能会导致歧义。 有关基于URL的授权和安全性的推理（有关更多详细信息，请参阅下一节）也变得更加困难。</p><p>要完全禁用文件扩展名，必须同时设置以下两项:</p><ul><li><code>useSuffixPatternMatching(false)</code>, see <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-path-matching">PathMatchConfigurer</a></li><li><code>favorPathExtension(false)</code>, see <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></li></ul><p>基于URL的内容协商仍然有用（例如，在浏览器中键入URL时）。 为此，我们建议使用基于查询参数的策略来避免文件扩展名带来的大多数问题。 或者，如果必须使用文件扩展名，请考虑通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>的<code>mediaTypes</code>属性将它们限制为显式注册的扩展名列表。</p><h5 id="后缀匹配和RFD"><a href="#后缀匹配和RFD" class="headerlink" title="后缀匹配和RFD"></a>后缀匹配和RFD</h5><p>反射文件下载（Reflected file download）攻击与XSS类似，因为它依赖请求输入，例如查询参数、URI变量，并且在响应中被反射。但是，RFD攻击不是将JavaScript插入HTML，而是依赖浏览器切换来执行下载，进而在之后的双击时将响应作为可执行脚本处理。</p><p>在Spring MVC中，<code>@ResponseBody</code>和 <code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展来请求。 禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险，但不足以防止RFD攻击。</p><p>为了防止RFD攻击，在呈现响应主体之前，需要在Spring MVC添加 <code>Content-Disposition:inline;filename=f.txt</code>头用于提供固定和安全的下载文件。只有在URL路径包含的文件扩展名中既不包含白名单，也没有为内容协商显式注册以时，才需要这样做。 但是，在浏览器直接键入URL时，可能会产生副作用。</p><p>默认情况下，有许多常见的路径扩展白名单。具有自定义<code>HttpMessageConverter</code>实现的应用程序可以显式注册内容协商的文件扩展名，以避免为这些扩展添加<code>Content-Disposition</code> 头。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-content-negotiation">Content Types</a></p><p>有关RFD的其他建议，请参阅<a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a>。</p><h5 id="消费者媒体类型"><a href="#消费者媒体类型" class="headerlink" title="消费者媒体类型"></a>消费者媒体类型</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-consumes">Same as in Spring WebFlux</a></p><p>您可以根据请求的<code>Content-Type</code>缩小请求映射范围，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(path = <span class="hljs-string">&quot;/pets&quot;</span>, consumes = <span class="hljs-string">&quot;application/json&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public void <span class="hljs-built_in">addPet</span>(<span class="hljs-variable">@RequestBody</span> Pet pet) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、使用 <code>consumes</code>属性来缩小内容类型的映射。</p><p><code>consumes</code>属性还支持否定表达式 - 例如，<code>!text/plain</code>表示除 <code>text/plain</code>之外的任何内容类型。</p><p>您可以在类级别声明共享 <code>consumes</code>属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会 <code>consumes</code> 属性覆盖而不是扩展类级别声明。</p><p><code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>。</p><h5 id="生产者媒体类型"><a href="#生产者媒体类型" class="headerlink" title="生产者媒体类型"></a>生产者媒体类型</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-produces">Same as in Spring WebFlux</a></p><p>您可以根据<code>Accept</code>请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(path = <span class="hljs-string">&quot;/pets/&#123;petId&#125;&quot;</span>, produces = <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>) (<span class="hljs-number">1</span>)<br><br><span class="hljs-variable">@ResponseBody</span><br><br>public Pet <span class="hljs-built_in">getPet</span>(<span class="hljs-variable">@PathVariable</span> String petId) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong></p><p>使用<code>produces</code>属性来缩小内容类型的映射。</p><p>媒体类型可以指定字符集。 支持否定表达式 - 例如， <code>!text/plain</code>表示”text&#x2F;plain”以外的任何内容类型。</p><p>对于JSON内容类型，即使 <a href="https://tools.ietf.org/html/rfc7159#section-11">RFC7159</a>明确声明“没有为此注册定义charset参数”，也应指定UTF-8字符集，因为某些浏览器要求它正确解释UTF-8特殊字符。</p><p>您可以在类级别声明共享的<code>produces</code>属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会生成属性覆盖，而不是扩展类级别声明。</p><p><code>MediaType</code>为常用媒体类型提供常量，例如<code>APPLICATION_JSON_UTF8_VALUE</code> and <code>APPLICATION_XML_VALUE</code>。</p><h5 id="参数-请求头"><a href="#参数-请求头" class="headerlink" title="参数, 请求头"></a>参数, 请求头</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-params-and-headers">Same as in Spring WebFlux</a></p><p>您可以根据请求参数条件缩小请求映射。 您可以测试是否存在请求参数（<code>myParam</code>），缺少一个（<code>!myParam</code>）或特定值（<code>myParam=myValue</code>）。 以下示例显示如何测试特定值：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(path = <span class="hljs-string">&quot;/pets/&#123;petId&#125;&quot;</span>, params = <span class="hljs-string">&quot;myParam=myValue&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public void <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@PathVariable</span> String petId) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、测试<code>myParam</code>是否等于<code>myValue</code>。</p><p>您还可以将其与请求头条件一起使用，如以下示例所示：:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(path = <span class="hljs-string">&quot;/pets&quot;</span>, headers = <span class="hljs-string">&quot;myHeader=myValue&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public void <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@PathVariable</span> String petId) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Testing whether <code>myHeader</code> equals <code>myValue</code> 。.</p><p>您可以将 <code>Content-Type</code>和 <code>Accept</code> 与headers条件匹配，但最好使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-consumes">consumes</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-produces">produces</a>替代。</p><h5 id="HTTP-HEAD-OPTIONS"><a href="#HTTP-HEAD-OPTIONS" class="headerlink" title="HTTP HEAD, OPTIONS"></a>HTTP HEAD, OPTIONS</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-head-options">Same as in Spring WebFlux</a></p><p><code>@GetMapping</code> (和 <code>@RequestMapping(method=HttpMethod.GET)</code>)一样，为了请求映射的目的，透明地支持HTTP HEAD以进行请求映射。控制器方法无需更改。 在<code>javax.servlet.http.HttpServlet</code>中应用的响应包确保有<code>Content-Length</code>标头并且设置为写入的字节数，但实际上不会写入响应。</p><p><code>@GetMapping</code> (and <code>@RequestMapping(method=HttpMethod.GET)</code>)一样，为了请求映射的目的，被隐式映射到并支持HTTP HEAD，处理HTTP HEAD请求就像它是HTTP GET一样，但不是写入正文，而是计算字节数并设置 <code>Content-Length</code>头。</p><p>默认情况下，HTTP OPTIONS通过设置<code>Allow</code>响应头来为所有具有匹配URL模式的@RequestMapping方法中列出的HTTP方法列表来处理HTTP选项。</p><p>对于没有HTTP方法声明的<code>@RequestMapping</code>，Allow请求头可以设置为 <code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。 控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：<code>@GetMapping</code>, <code>@PostMapping</code>等）。</p><p>您可以将 <code>@RequestMapping</code> 方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。</p><h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#mvc-ann-requestmapping-head-options">Same as in Spring WebFlux</a></p><p>Spring MVC支持使用 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#beans-meta-annotations">组合注解</a>进行请求映射。 这些注解本身是使用 <code>@RequestMapping</code>进行元注解的，并且用于重新声明具有更窄，更具体目的的 <code>@RequestMapping</code>属性的子集（或全部）。</p><p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, 和 <code>@PatchMapping</code> 就是组合注解最好的示例， 提供它们是因为，可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code>，默认情况下，它与所有HTTP方法匹配。 如果您需要组合注解的示例，请查看如何声明这些注解。</p><p>Spring MVC还支持使用自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承<code>RequestMappingHandlerMapping</code> 并覆盖<code>getCustomMethodCondition</code> 方法， 您可以在其中检查自定义属性并返回自己的<code>RequestCondition</code>。</p><h5 id="显式注册"><a href="#显式注册" class="headerlink" title="显式注册"></a>显式注册</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestmapping-registration">Same as in Spring WebFlux</a></p><p>您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。 以下示例注册处理程序方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Configurationpublic <span class="hljs-keyword">class</span> MyConfig &#123;<br>    @Autowired    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setHandlerMapping(RequestMappingHandlerMapping <span class="hljs-keyword">mapping</span>, UserHandler <span class="hljs-keyword">handler</span>) (<span class="hljs-number">1</span>)            throws NoSuchMethodException &#123;<br>        RequestMappingInfo <span class="hljs-keyword">info</span> = RequestMappingInfo                .paths(&quot;/user/&#123;id&#125;&quot;).methods(RequestMethod.<span class="hljs-keyword">GET</span>).build(); (<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span> = UserHandler.<span class="hljs-keyword">class</span>.getMethod(&quot;getUser&quot;, Long.<span class="hljs-keyword">class</span>); (<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">mapping</span>.registerMapping(<span class="hljs-keyword">info</span>, <span class="hljs-keyword">handler</span>, <span class="hljs-keyword">method</span>); (<span class="hljs-number">4</span>)    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、为控制器注入目标处理程序和处理程序映射</p><p><strong>2</strong>、准备映射元数据的请求。</p><p><strong>3</strong>、获取处理程序方法。</p><p><strong>4</strong>、添加注册。</p><h4 id="1-3-3-程序处理方法"><a href="#1-3-3-程序处理方法" class="headerlink" title="1.3.3. 程序处理方法"></a>1.3.3. 程序处理方法</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-methods">Same as in Spring WebFlux</a></p><p><code>@RequestMapping</code> 处理程序方法具有灵活的签名,可以从一系列受支持的控制器方法参数和返回值中进行选择.</p><h5 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-arguments">Same as in Spring WebFlux</a></p><p>下表显示了受支持的控制器方法参数，任何参数都不支持响应式(Reactive)类型。</p><p>JDK 8’s <code>java.util.Optional</code> 作为方法参数来支持的，它与具有必需属性的注解(例如<code>@RequestParam</code>, <code>@RequestHeader</code>等相结合)。 并且等同于<code>required=false</code>。</p><table><thead><tr><th>控制器方法参数</th><th>描述</th></tr></thead><tbody><tr><td><code>WebRequest</code>, <code>NativeWebRequest</code></td><td>无需直接使用Servlet API即可访问请求参数以及request和session属性。</td></tr><tr><td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td>选择任何特定的请求或响应类型 - 例如，<code>ServletRequest</code>, <code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>。</td></tr><tr><td><code>javax.servlet.http.HttpSession</code></td><td>强制进行会话。 因此，此类参数永远不可能为<code>null</code>. 请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为true。</td></tr><tr><td><code>javax.servlet.http.PushBuilder</code></td><td>Spring4.0 push生成器API用于编程HTTP&#x2F;2资源推送， 请注意，根据Servlet规范，如果客户端不支持该HTTP&#x2F;2功能，则注入的<code>PushBuilder</code>实例可以为null。</td></tr><tr><td><code>java.security.Principal</code></td><td>当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code>实现类。</td></tr><tr><td><code>HttpMethod</code></td><td>请求的HTTP方法。</td></tr><tr><td><code>java.util.Locale</code></td><td>当前请求区域设置，由最可用的<code>LocaleResolver</code>（实际上是已配置的 <code>LocaleResolver</code>或<code>LocaleContextResolver</code>）确定。</td></tr><tr><td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td><td>与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问Servlet API公开的原始请求主体。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问Servlet API公开的原始响应主体。</td></tr><tr><td><code>@PathVariable</code></td><td>用于访问URI模板变量。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-uri-templates">URI模式</a>。</td></tr><tr><td><code>@MatrixVariable</code></td><td>用于访问URI路径段中的名称 - 值对。 请参见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-matrix-variables">矩阵变量</a>。</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问Servlet请求参数，包括多部分文件。 参数值将转换为声明的方法参数类型。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestparam"><code>@RequestParam</code></a>以及<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart-forms">Multipart</a>。 请注意，对于简单的参数值，使用<code>@RequestParam</code>是可选的。 请参阅本表末尾的“任何其他参数”。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求头。 头的值将转换为声明的方法参数类型。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestheader"><code>@RequestHeader</code></a>。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问cookie。 Cookie值将转换为声明的方法参数类型。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-cookievalue"><code>@CookieValue</code></a>。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问HTTP请求正文。 通过使用<code>HttpMessageConverter</code>实现将正文内容转换为声明的方法参数类型。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestbody"><code>@RequestBody</code></a>。</td></tr><tr><td><code>HttpEntity&lt;B&gt;</code></td><td>用于访问请求标头和正文。 使用<code>HttpMessageConverter</code>转换正文。 见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-httpentity">HttpEntity</a>。</td></tr><tr><td><code>@RequestPart</code></td><td>要访问<code>multipart/form-data</code>请求中的部件，请使用<code>HttpMessageConverter</code>转换部件的主体。 见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-multipart-forms">Multipart</a>。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>用于访问HTML控制器中使用的模型，并将其作为视图呈现的一部分暴露给模板。</td></tr><tr><td><code>RedirectAttributes</code></td><td>指定在重定向（即，要附加到查询字符串）时使用的属性，以及临时存储的flash属性，直到重定向后的请求为止。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-redirecting-passing-data">重定向属性</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-flash-attributes">Flash属性</a>。</td></tr><tr><td><code>@ModelAttribute</code></td><td>用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> 以及<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-methods">Model</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-initbinder"><code>DataBinder</code></a>。请注意，使用<code>@ModelAttribute</code> 是可选的（例如，设置其属性）。 请参阅本表末尾的“任何其他参数”。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>用于访问来自命令对象的验证和数据绑定的错误（即 <code>@ModelAttribute</code>参数）或来自验证 <code>@RequestBody</code>或 <code>@RequestPart</code> 参数的错误。 您必须在经过验证的方法参数后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td></tr><tr><td><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td><td>用于标记表单处理完成，从而触发通过类级别<code>@SessionAttributes</code>注解声明的会话属性的清除。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>。</td></tr><tr><td><code>UriComponentsBuilder</code></td><td>用于准备相对于当前请求的主机，端口，方案，上下文路径和servlet映射的文字部分的URL。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-uri-building">URI Links</a>。</td></tr><tr><td><code>@SessionAttribute</code></td><td>用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明的结束形成对比。 有关更多详细信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>。</td></tr><tr><td><code>@RequestAttribute</code></td><td>用于访问请求属性。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>。</td></tr><tr><td>Any other argument</td><td>如果方法参数与此表中的任何值不匹配，并且它是一个简单类型（由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定， 则它被解析为 <code>@RequestParam</code>。否则，它将被解析为<code>@ModelAttribute</code>。</td></tr></tbody></table><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-return-types">Same as in Spring WebFlux</a></p><p>下表描述了支持的控制器方法返回值。 所有返回值都支持响应式类型。</p><table><thead><tr><th>控制器方法返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>@ResponseBody</code></td><td>返回值通过<code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-responsebody"><code>@ResponseBody</code></a>。</td></tr><tr><td><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td>指定完整响应（包括HTTP头和主体）的返回值将通过 <code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-responseentity">ResponseEntity</a>。</td></tr><tr><td><code>HttpHeaders</code></td><td>用于返回带头部信息且没有正文的响应。</td></tr><tr><td><code>String</code></td><td>要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 <code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明 <code>Model</code>参数以编程方式丰富模型（请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-registration">显式注册</a>）。</td></tr><tr><td><code>View</code></td><td>用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-registration">显式注册</a>）。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td>要添加到隐式模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。</td></tr><tr><td><code>@ModelAttribute</code></td><td>要添加到模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。请注意，<code>@ModelAttribute</code>是可选的。 请参阅本表末尾的“任何其他返回值”。</td></tr><tr><td><code>ModelAndView</code> object</td><td>要使用的视图和模型属性，以及（可选）响应状态。</td></tr><tr><td><code>void</code></td><td>如果具有<code>void</code>返回类型（或返回值为 <code>null</code> ）的方法，如果它还具有<code>ServletResponse</code>，<code>OutputStream</code>参数或<code>@ResponseStatus</code>注解， 则认为已完全处理该响应。 如果控制器已进行正<code>ETag</code>或<code>lastModified</code> 时间戳检查，则也是如此（有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching-etag-lastmodified">Controllers</a>）。如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</td></tr><tr><td><code>DeferredResult&lt;V&gt;</code></td><td>从任何线程异步生成任何前面的返回值 - 例如，由于某些事件或回调。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">Asynchronous Requests</a> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>.</td></tr><tr><td><code>Callable&lt;V&gt;</code></td><td>在Spring MVC管理的线程中异步生成上述任何返回值。 请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">Asynchronous Requests</a> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-callable"><code>Callable</code></a>.</td></tr><tr><td><code>ListenableFuture&lt;V&gt;</code>, <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>, <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td><td>作为替代<code>DeferredResult</code>的便捷操作（例如，当底层服务返回其中一个时）。</td></tr><tr><td><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td><td>使用<code>HttpMessageConverter</code>实现以异步方式发送对象流以写入响应。 还支持<code>ResponseEntity</code>的主体。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">Asynchronous Requests</a> and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr><tr><td><code>StreamingResponseBody</code></td><td>异步写入响应<code>OutputStream</code>。 还支持<code>ResponseEntity</code>的主体。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">Asynchronous Requests</a> and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr><tr><td>Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td><td>使用multi-value流（例如，<code>Flux</code>, <code>Observable</code>）替代<code>DeferredResult</code>收集到<code>List</code>中。对于流式场景(例如, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> 和 <code>ResponseBodyEmitter</code> 使用的是在Spring MVC 管理的线程上执行<code>ServletOutputStream</code>阻塞I&#x2F;O，这是 针对每一个Write的。请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">Asynchronous Requests</a> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">Reactive Types</a>.</td></tr><tr><td>Any other return value</td><td>任何与此表中任何早期值不匹配且返回值为<code>String</code> 或<code>void</code>的返回值都被视为视图名称（通过<code>RequestToViewNameTranslator</code>应用默认视图名称选择）， 前提是它不是简单类型，由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定，简单类型的值仍未解决。</td></tr></tbody></table><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-typeconversion">Same as in Spring WebFlux</a></p><p>如果参数声明为String以外的其他参数，则表示某些带注解的控制器方法参数（例如<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, 和 <code>@CookieValue</code>）可能需要进行类型转换。</p><p>对于此类情况，将根据配置的转换器自动应用类型转换。 默认情况下，支持简单类型（<code>int</code>, <code>long</code>, <code>Date</code>和其他）。 您可以通过<code>WebDataBinder</code>（请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-initbinder"><code>DataBinder</code></a>）或使用<code>FormattingConversionService</code>注册<code>Formatters</code>来自定义类型转换。 请参见 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#format">Spring Field Formatting</a>。</p><h5 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-matrix-variables">Same as in Spring WebFlux</a></p><p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的携带键值对。 在Spring MVC中，我们将那些基于Tim Berners-Lee的 <a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“old post”</a> 称为“矩阵变量”，但它们也可以称为URI路径参数。</p><p>矩阵变量可以在任意路径段落中出现，每对矩阵变量之间使用分号隔开，多个值可以用逗号隔开（例如，<code>/cars;color=red,green;year=2012</code>）， 也可以通过重复的变量名称指定多个值（例如，<code>color=red;color=green;color=blue</code>）。</p><p>如果URL有可能会包含矩阵变量，那么在请求路径的映射配置上就需要使用URI模板来体现。这样才能确保请求可以被正确地映射，而不管矩阵变量在URI中是否出现、出现的次序是怎样的等。以下示例使用矩阵变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// GET /pets/42;q=11;r=22</span><br><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/pets/&#123;petId&#125;&quot;</span>)public void <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@PathVariable</span> String petId, <span class="hljs-variable">@MatrixVariable</span> int q) &#123;<br>    <span class="hljs-comment">// petId == 42    // q == 11&#125;</span><br></code></pre></td></tr></table></figure><p>由于任意路径段落中都可以含有矩阵变量，在某些场景下，开发者需要用更精确的信息来指定矩阵变量的位置。以下示例说明如何执行此操作：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// GET /owners/42;q=11/pets/21;q=22</span><br><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;</span>)public void <span class="hljs-built_in">findPet</span>(        <span class="hljs-variable">@MatrixVariable</span>(name=<span class="hljs-string">&quot;q&quot;</span>, pathVar=<span class="hljs-string">&quot;ownerId&quot;</span>) int q1,        <span class="hljs-variable">@MatrixVariable</span>(name=<span class="hljs-string">&quot;q&quot;</span>, pathVar=<span class="hljs-string">&quot;petId&quot;</span>) int q2) &#123;<br>    <span class="hljs-comment">// q1 == 11    // q2 == 22&#125;</span><br></code></pre></td></tr></table></figure><p>矩阵变量可以定义为可选，并指定默认值，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// GET /pets/42</span><br><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/pets/&#123;petId&#125;&quot;</span>)public void <span class="hljs-built_in">findPet</span>(<span class="hljs-variable">@MatrixVariable</span>(required=false, defaultValue=<span class="hljs-string">&quot;1&quot;</span>) int q) &#123;<br>    <span class="hljs-comment">// q == 1&#125;</span><br></code></pre></td></tr></table></figure><p>要获取所有矩阵变量，可以使用<code>MultiValueMap</code>，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span><br><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;</span>)public void <span class="hljs-built_in">findPet</span>(        <span class="hljs-variable">@MatrixVariable</span> MultiValueMap&lt;String, String&gt; matrixVars,        <span class="hljs-variable">@MatrixVariable</span>(pathVar=<span class="hljs-string">&quot;petId&quot;</span>) MultiValueMap&lt;String, String&gt; petMatrixVars) &#123;<br>    <span class="hljs-comment">// matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]    // petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]&#125;</span><br></code></pre></td></tr></table></figure><p>请注意，您需要启用矩阵变量的使用。 在MVC Java配置中，您需要通过 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-path-matching">路径匹配</a>将<code>removeSemicolonContent=false</code> 设置为<code>UrlPathHelper</code>。 在MVC XML命名空间中，您可以设置<code>&lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</code>。</p><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><code>@RequestParam</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestparam">Same as in Spring WebFlux</a></p><p>您可以使用<code>@RequestParam</code>注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p>以下示例显示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/pets&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EditPetForm</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-keyword">public</span> String setupForm(<span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;petId&quot;</span>)</span> int petId, Model model) &#123; (<span class="hljs-number">1</span>)        Pet pet = <span class="hljs-keyword">this</span>.clinic.loadPet(petId);        model.addAttribute(<span class="hljs-string">&quot;pet&quot;</span>, pet);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;petForm&quot;</span>;    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、使用 <code>@RequestParam</code>绑定<code>petId</code>。</p><p>若参数使用了该注解，则该参数默认是必须提供的.但您可以通过将<code>@RequestParam</code>注解的<code>required</code>属性设置为false或通过使用 <code>java.util.Optional</code>包装器声明参数来指定方法参数是可选的。</p><p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-typeconversion">类型转换</a>。</p><p>将参数类型声明为数组或列表允许为同一参数名称解析多个参数值。</p><p>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, String&gt;</code> 或<code>MultiValueMap&lt;String, String&gt;</code>时， 如果注解中未指定参数名称，则会使用每个给定参数名称的请求参数值填充映射。</p><p>请注意，使用<code>@RequestParam</code>是可选的（例如，设置其属性）。 默认情况下， 任何属于简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定）并且未被任何其他参数解析器解析，都被视为使用<code>@RequestParam</code>进行注解。</p><h5 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><code>@RequestHeader</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestheader">Same as in Spring WebFlux</a></p><p>您可以使用<code>@RequestHeader</code>注解将请求标头绑定到控制器中的方法参数。</p><p>考虑以下请求，请求头为:</p><p>Host localhost:8080 Accept text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9 Accept-Language fr,en-gb;q&#x3D;0.7,en;q&#x3D;0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.7 Keep-Alive 300</p><p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code> 头的值：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/demo&quot;</span>)<br><br>public void <span class="hljs-built_in">handle</span>(<br><br>        <span class="hljs-variable">@RequestHeader</span>(<span class="hljs-string">&quot;Accept-Encoding&quot;</span>) String encoding, (<span class="hljs-number">1</span>)<br><br>        <span class="hljs-variable">@RequestHeader</span>(<span class="hljs-string">&quot;Keep-Alive&quot;</span>) long keepAlive) &#123; (<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">//...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、获取 <code>Accept-Encoding</code> 头部信息.</p><p><strong>2</strong>、获取 <code>Keep-Alive</code> 头部信息.</p><p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-typeconversion">类型转换</a>。</p><p>在<code>Map&lt;String, String&gt;</code>，<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用 <code>@RequestHeader</code>注解时，将使用所有请求头值填充映射。</p><p>内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。 例如，使用 <code>@RequestHeader(&quot;Accept&quot;)</code> 注解的方法参数可以是<code>String</code>类型，也可以是<code>String[]</code>或<code>List&lt;String&gt;</code>。</p><h5 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><code>@CookieValue</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-cookievalue">Same as in Spring WebFlux</a></p><p>您可以使用<code>@CookieValue</code>注解将HTTP cookie的值绑定到控制器中的方法参数。</p><p>考虑使用以下cookie的请求:</p><p>JSESSIONID&#x3D;415A4AC178C59DACE0B2C9CA727CDD84</p><p>以下示例显示了如何获取cookie值：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/demo&quot;</span>)<br><br>public void <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@CookieValue</span>(<span class="hljs-string">&quot;JSESSIONID&quot;</span>) String cookie) &#123; (<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">//...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、获取<code>JSESSIONID</code> cookie的值</p><p>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-typeconversion">类型转换</a>。</p><h5 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><code>@ModelAttribute</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-modelattrib-method-args">Same as in Spring WebFlux</a></p><p>您可以在方法参数上使用<code>@ModelAttribute</code>注解来从模型访问属性，或者如果不存在则将其实例化。 model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数的值。 这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。 以下示例显示了如何执行此操作：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;</span>)<br><br>public String <span class="hljs-built_in">processSubmit</span>(<span class="hljs-variable">@ModelAttribute</span> Pet pet) &#123; &#125; (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、绑定一个<code>Pet</code>的实例。</p><p>上面的<code>Pet</code>实例解析如下：:</p><ul><li>它可能来自已经添加的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-methods">Model</a>.</li><li>它可能因为<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>注解的使用已经存在在model中.</li><li>它可能是由URI模板变量和<code>转换</code>中取得的（下面会详细讲解）.</li><li>它可能是调用了自身的默认构造器被实例化出来的.</li><li>他可能从调用具有与Servlet请求参数匹配的参数的“primary constructor”。 参数名称通过JavaBeans<code>@ConstructorProperties</code>或字节码中的运行时保留参数名称确定。</li></ul><p>虽然通常使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-methods">Model</a>来使用属性填充模型，但另一种替代方法是依赖于<code>Converter&lt;String, T&gt;</code>和URI路径变量。 在以下示例中，model属性名称<code>account</code>匹配URI路径变量 <code>account</code>，并通过将String字符串传递到已注册的<code>Converter&lt;String, Account&gt;</code>转换器来加载<code>Account</code> ：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;/accounts/&#123;account&#125;&quot;</span>)<br><br>public String <span class="hljs-built_in">save</span>(<span class="hljs-variable">@ModelAttribute</span>(<span class="hljs-string">&quot;account&quot;</span>) Account account) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>下一步就是数据的绑定，<code>WebDataBinder</code>类能将请求参数，包括字符串的查询参数和表单字段等，通过名称匹配到model的属性上。成功匹配的字段在需要的时候会进行一次类型转换（从String类型到目标字段的类型），然后被填充到model对应的属性中， 有关数据绑定（和验证）的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#validation">Validation</a>。 有关自定义数据绑定的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-initbinder"><code>DataBinder</code></a>。</p><p>数据绑定可能导致错误。 默认情况下，会引发<code>BindException</code> 。 但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加一个<code>BindingResult</code>参数，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">processSubmit</span>(<span class="hljs-params"><span class="hljs-meta">@ModelAttribute</span>(<span class="hljs-string">&quot;pet&quot;</span>) Pet pet, BindingResult result</span>) &#123; (<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-title function_">hasErrors</span>()) &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;petForm&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、在<code>@ModelAttribute</code>旁边添加 <code>BindingResult</code>。</p><p>在某些情况下，您可能希望在没有数据绑定的情况下访问model属性。对于这种情况，您可以将model注入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code>，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ModelAttributepublic</span> AccountForm <span class="hljs-built_in">setUpForm</span>() &#123;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">AccountForm</span>();&#125;<br>@<span class="hljs-selector-tag">ModelAttributepublic</span> <span class="hljs-selector-tag">Account</span> <span class="hljs-selector-tag">findAccount</span>(<span class="hljs-variable">@PathVariable</span> String accountId) &#123;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">accountRepository</span><span class="hljs-selector-class">.findOne</span>(accountId);&#125;<br>@<span class="hljs-selector-tag">PostMapping</span>(<span class="hljs-string">&quot;update&quot;</span>)<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">update</span>(<span class="hljs-variable">@Valid</span> AccountUpdateForm form, BindingResult result,        <span class="hljs-variable">@ModelAttribute</span>(binding=false) Account account) &#123; (<span class="hljs-number">1</span>)    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、设置 <code>@ModelAttribute(binding=false)</code>.</p><p>通过添加<code>javax.validation.Valid</code>注解或Spring的<code>@Validated</code>注解（<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#validation-beanvalidation">Bean validation</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#validation">Spring validation</a>），您可以在数据绑定后自动应用验证。 以下示例显示了如何执行此操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">processSubmit</span>(<span class="hljs-params"><span class="hljs-meta">@Valid</span> <span class="hljs-meta">@ModelAttribute</span>(<span class="hljs-string">&quot;pet&quot;</span>) Pet pet, BindingResult result</span>) &#123; (<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-title function_">hasErrors</span>()) &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;petForm&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、验证 <code>Pet</code> 实例.</p><p>请注意，使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。 默认情况下，任何非简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定）并且未被任何其他参数解析器解析，都被视为使用<code>@ModelAttribute</code>进行注解。</p><h5 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a><code>@SessionAttributes</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-sessionattributes">Same as in Spring WebFlux</a></p><p><code>@SessionAttributes</code>用于在请求之间的HTTP Servlet会话中存储model属性。 它是一个类型级别的注解，用于声明特定控制器使用的会话属性。 这通常列出model属性的名称或model属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。</p><p>以下示例使用<code>@SessionAttributes</code>注解:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><br><br><span class="hljs-variable">@SessionAttributes</span>(<span class="hljs-string">&quot;pet&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public class EditPetForm &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using the <code>@SessionAttributes</code> annotation.</p><p>在第一个请求中，当名称为<code>pet</code>的model属性添加到模型中时，他会自动保存到HTTP Servlet会话中，并保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><span class="hljs-variable">@SessionAttributes</span>(<span class="hljs-string">&quot;pet&quot;</span>) (<span class="hljs-number">1</span>)public class EditPetForm &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/pets/&#123;id&#125;&quot;</span>)    public String <span class="hljs-built_in">handle</span>(Pet pet, BindingResult errors, SessionStatus status) &#123;        <span class="hljs-selector-tag">if</span> (errors.hasErrors) &#123;            <span class="hljs-comment">// ...        &#125;            status.setComplete(); (2)            // ...        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、在Servlet会话中存储<code>Pet</code>值。</p><p><strong>2</strong>、在Servlet会话中清除<code>Pet</code>值。</p><h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a><code>@SessionAttribute</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-sessionattribute">Same as in Spring WebFlux</a></p><p>如果需要访问已存在的被全局session属性，例如在控制器之外（如通过过滤器）的（可有可无），请在方法参数上使用<code>@SessionAttribute</code>注解：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)<br><br>public String <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@SessionAttribute</span> User user) &#123; (<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using a <code>@SessionAttribute</code> annotation.</p><p>对于需要添加或删除会话属性的用例，请考虑将<code>org.springframework.web.context.request.WebRequest</code>或<code>javax.servlet.http.HttpSession</code>注入控制器方法。</p><p>作为控制器工作流的一部分，在会话中临时存储模型属性的方法可以使用<code>@SessionAttributes</code>，详情请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>。</p><h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a><code>@RequestAttribute</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestattrib">Same as in Spring WebFlux</a></p><p>与<code>@SessionAttribute</code>类似，<code>@RequestAttribute</code>注解可用于访问由过滤器（<code>Filter</code>）或拦截器（<code>HandlerInterceptor</code>）创建的已存在的请求属性:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)<br><br>public String <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@RequestAttribute</span> Client client) &#123; (<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、Using the <code>@RequestAttribute</code> annotation.</p><h5 id="Redirect-属性"><a href="#Redirect-属性" class="headerlink" title="Redirect 属性"></a>Redirect 属性</h5><p>默认情况下，所有模型属性都被视为在重定向URL中公开为URI模板变量。 在其余属性中，原始类型或集合或基本类型数组的属性将自动附加为查询参数。</p><p>如果专门为重定向准备了模型实例，期望的结果则是将原始类型属性作为查询参数。 但是，在带注解的控制器中，为了渲染目的，模型可以包含其他属性（例如，下拉字段值）。 为了避免在URL中出现此类属性的可能性，<code>@RequestMapping</code>方法可以声明<code>RedirectAttributes</code>类型的参数， 并使用它来指定可供<code>RedirectView</code>使用的确切属性。 如果方法重定向，则使用<code>RedirectAttributes</code>的内容。 否则，使用模型的内容。</p><p><code>RequestMappingHandlerAdapter</code>提供了一个名为<code>ignoreDefaultModelOnRedirect</code>的标志，您可以使用该标志指示如果控制器方法重定向，则永远不应使用默认模型的内容。 相反，控制器方法应声明<code>RedirectAttributes</code>类型的属性，如果不这样做，则不应将任何属性传递给<code>RedirectView</code>。 MVC命名空间和MVC Java配置都将此标志设置为<code>false</code>，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为<code>true</code>。</p><p>请注意，扩展重定向URL时，当前请求中的URI模板变量会自动可用，您需要通过 <code>Model</code>或<code>RedirectAttributes</code>显式添加它们。 以下示例显示如何定义重定向：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/files/&#123;path&#125;&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">...</span>) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:files/&#123;path&#125;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将数据传递到重定向目标的另一种方法是使用flash属性。 与其他重定向属性不同，Flash属性保存在HTTP会话中（因此，不会出现在URL中）。 有关更多信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-flash-attributes">Flash 属性</a>。</p><h5 id="Flash-属性"><a href="#Flash-属性" class="headerlink" title="Flash 属性"></a>Flash 属性</h5><p>Flash属性（flash attributes）提供了一个请求为另一个请求存储有用属性的方法。这在重定向的时候最常使用，比如常见的POST&#x2F;REDIRECT&#x2F;GET模式。 Flash属性会在重定向前被暂时地保存起来（通常是保存在session中），重定向后会重新被下一个请求取用并立即从原保存地移除。</p><p>为支持flash属性，Spring MVC提供了两个抽象。 <code>FlashMap</code>被用来存储flash属性，而用<code>FlashMapManager</code>来存储、取回、管理<code>FlashMap</code>的实例。</p><p>对flash属性的支持默认是启用“on” 的，并不需要显式声明，不过没用到它时它绝不会主动地去创建HTTP会话（session）。对于每个请求，框架都会“input” 一个<code>FlashMap</code>，里面存储了从上个请求（如果有）保存下来的属性；同时，每个请求也会“output”<code>FlashMap</code>，里面保存了要给下个请求使用的属性。 两个<code>FlashMap</code>实例在Spring MVC应用中的任何地点都可以通过<code>RequestContextUtils</code>工具类的静态方法取得。</p><p>控制器通常不需要直接接触<code>FlashMap</code>。一般是通过<code>@RequestMapping</code>方法去接受<code>RedirectAttributes</code>类型的参数，然后直接地往其中添加flash属性。 通过<code>RedirectAttributes</code>对象添加进去的flash属性会自动被填充到请求的“output”<code>FlashMap</code>对象中去。类似地，重定向后“input”的<code>FlashMap</code>属性也会自动被添加到服务重定向URL的控制器参数Model中去</p><p>匹配请求所使用的flash属性</p><p>flash属性的概念在其他许多的Web框架中也存在，并且实践证明有时可能会导致并发上的问题。这是因为从定义上讲，flash属性保存的时间是到下个请求接收到之前。 问题在于，“next”请求不一定刚好就是需要重定向到的那个请求，它有可能是其他的异步请求（比如polling请求或者资源请求等）。这会导致flash属性在到达真正的目标请求前就被移除了。</p><p>为了减少这个问题发生的可能性，重定向视图<code>RedirectView</code>会自动为一个<code>FlashMap</code>实例记录其目标重定向URL的路径和查询参数。然后，默认的<code>FlashMapManager</code>会在为请求查找其该“input”的<code>FlashMap</code>时，匹配这些信息。</p><p>这并不能完全解决重定向的并发问题，但极大程度地减少了这种可能性，因为它可以从重定向URL已有的信息中来做匹配。因此，一般只有在重定向的场景下，才推荐使用flash属性。</p><h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-multipart-forms">Same as in Spring WebFlux</a></p><p>启用<code>MultipartResolver</code>后，将解析具有<code>multipart/form-data</code>的POST请求的内容，并将其作为常规请求参数进行访问。 以下示例访问一个常规表单字段和一个上载文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/form&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">handleFormUpload</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-built_in">String</span> name,            <span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;file&quot;</span>) MultipartFile file</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!file.<span class="hljs-title function_">isEmpty</span>()) &#123;            byte[] bytes = file.<span class="hljs-title function_">getBytes</span>();            <span class="hljs-comment">// store the bytes somewhere            return &quot;redirect:uploadSuccess&quot;;        &#125;        return &quot;redirect:uploadFailure&quot;;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>将参数类型声明为<code>List&lt;MultipartFile&gt;</code>允许为同一参数名称解析多个文件。</p><p>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, MultipartFile&gt;</code>或<code>MultiValueMap&lt;String, MultipartFile&gt;</code>时，如果注解中未指定参数名称，则会使用每个给定参数名称的多部分文件填充map。</p><p>使用Servlet 3.0多部分解析，您也可以将 <code>javax.servlet.http.Part</code>而不是Spring的<code>MultipartFile</code>声明为方法参数或集合值类型。</p><p>您还可以将多部分内容用作绑定到<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-method-args">命令对象</a>的数据的一部分。 例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyForm</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MultipartFile</span> file;<br>    <span class="hljs-regexp">//</span> ...&#125;<br><span class="hljs-variable">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileUploadController</span> &#123;<br>    <span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/form&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> handleFormUpload(<span class="hljs-title class_">MyForm</span> form, <span class="hljs-title class_">BindingResult</span> errors) &#123;        <span class="hljs-keyword">if</span> (!form.getFile().isEmpty()) &#123;            byte[] bytes = form.getFile().getBytes();            <span class="hljs-regexp">//</span> store the bytes somewhere            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:uploadSuccess&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:uploadFailure&quot;</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">POST /someUrlContent-<span class="hljs-keyword">Type</span>: multipart/mixed<br>--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;meta-data&quot;</span>Content-<span class="hljs-keyword">Type</span>: application/json; charset=UTF-<span class="hljs-number">8</span>Content-<span class="hljs-built_in">Transfer</span>-Encoding: <span class="hljs-number">8</span>bit<br>&#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7VpContent-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;file-data&quot;</span>; filename=<span class="hljs-string">&quot;file.properties&quot;</span>Content-<span class="hljs-keyword">Type</span>: text/xmlContent-<span class="hljs-built_in">Transfer</span>-Encoding: <span class="hljs-number">8</span>bit... <span class="hljs-keyword">File</span> <span class="hljs-keyword">Data</span> ...<br></code></pre></td></tr></table></figure><p>对于名称为”meta-data” 的部分，可以通过控制器方法上的<code>@RequestParam</code>String metadata参数来获得。但对于那部分请求体中为JSON格式数据的请求， 可能更想通过接受一个对应的强类型对象，就像<code>@RequestBody</code>通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/integration.html#rest-message-conversion">HttpMessageConverter</a>将一般请求的请求体转换成一个对象一样。使用<code>@RequestPart</code>注解访问多部分：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)<br><br>public String <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@RequestPart</span>(<span class="hljs-string">&quot;meta-data&quot;</span>) MetaData metadata,<br><br>        <span class="hljs-variable">@RequestPart</span>(<span class="hljs-string">&quot;file-data&quot;</span>) MultipartFile file) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>您可以将<code>@RequestPart</code>与<code>javax.validation.Valid</code>结合使用，或使用Spring的<code>@Validated</code>注解，这两种注解都会导致应用标准Bean验证。 默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>， 并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过<code>Errors</code> 或<code>BindingResult</code> 参数在控制器内本地处理验证错误，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)<br><br>public String <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@Valid</span> <span class="hljs-variable">@RequestPart</span>(<span class="hljs-string">&quot;meta-data&quot;</span>) MetaData metadata,<br><br>        BindingResult result) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><code>@RequestBody</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-requestbody">Same as in Spring WebFlux</a></p><p>您可以使用<code>@RequestBody</code>注解通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>将请求主体读取并反序列化为<code>Object</code>。 以下示例使用<code>@RequestBody</code>参数:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/accounts&quot;</span>)<br><br>public void <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@RequestBody</span> Account account) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>您可以使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a> 的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-message-converters">Message Converters</a>选项来配置或自定义消息转换。</p><p>您可以将<code>@RequestBody</code>与<code>javax.validation.Valid</code>或Spring的<code>@Validated</code> 注解结合使用，这两种注解都会导致应用标准Bean验证。 默认情况下，验证错误会导致 <code>MethodArgumentNotValidException</code>，并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/accounts&quot;</span>)<br><br>public void <span class="hljs-built_in">handle</span>(<span class="hljs-variable">@Valid</span> <span class="hljs-variable">@RequestBody</span> Account account, BindingResult result) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="HttpEntity"><a href="#HttpEntity" class="headerlink" title="HttpEntity"></a>HttpEntity</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-httpentity">Same as in Spring WebFlux</a></p><p><code>HttpEntity</code>与使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestbody"><code>@RequestBody</code></a>或多或少有些类似，但它基于一个公开请求头和正文的容器对象。 以下清单显示了一个示例:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/accounts&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">HttpEntity&lt;Account&gt; entity</span>) &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><code>@ResponseBody</code></h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-responsebody">Same as in Spring WebFlux</a></p><p>您可以在方法上使用<code>@ResponseBody</code>注解，以通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/integration.html#rest-message-conversion">HttpMessageConverter</a>将返回序列化到响应主体。 以下清单显示了一个示例:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/accounts/&#123;id&#125;&quot;</span>)<br><br><span class="hljs-variable">@ResponseBody</span><br><br>public Account <span class="hljs-built_in">handle</span>() &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>类级别也支持<code>@ResponseBody</code> ，在这种情况下，它由所有控制器方法继承。 例如<code>@RestController</code>的效果，它只不过是一个用<code>@Controller</code>和<code>@ResponseBody</code>标记的元注解。</p><p>您可以将<code>@ResponseBody</code>与reactive类型一起使用。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async">异步请求</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">Reactive 类型</a>。</p><p>您可以使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config">MVC Config</a>的 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-message-converters">Message Converters</a>选项来配置或自定义消息转换。</p><p>您可以将<code>@ResponseBody</code>方法与JSON序列化视图结合使用。 有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-jackson">Jackson JSON</a>。</p><h5 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-responseentity">Same as in Spring WebFlux</a></p><p><code>ResponseEntity</code>与 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-responsebody"><code>@ResponseBody</code></a> 类似，但具有状态和响应头。 例如:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@GetMapping(<span class="hljs-string">&quot;/something&quot;</span>)<br><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">handle</span>() &#123;<br><br>    <span class="hljs-built_in">String</span> body = <span class="hljs-params">...</span> ;<br><br>    <span class="hljs-built_in">String</span> etag = <span class="hljs-params">...</span> ;<br><br>    <span class="hljs-keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Spring MVC支持使用单值<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">reactive type</a>异步生成 <code>ResponseEntity</code>，and&#x2F;or 主体的单值和多值reactive类型。</p><h5 id="Jackson-JSON"><a href="#Jackson-JSON" class="headerlink" title="Jackson JSON"></a>Jackson JSON</h5><p>Spring为Jackson JSON库提供支持。</p><h6 id="Jackson-序列化视图"><a href="#Jackson-序列化视图" class="headerlink" title="Jackson 序列化视图"></a>Jackson 序列化视图</h6><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-jsonview">Same as in Spring WebFlux</a></p><p>Spring MVC为<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson的序列化视图</a>提供内置支持，允许仅渲染Object中所有字段的子集。 为了与<code>@ResponseBody</code>控制器方法或者返回<code>ResponseEntity</code>的控制器方法一起使用，可以简单地将<code>@JsonView</code>注解放在参数上，指定需要使用的视图类或接口即可。如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/user&quot;</span>)</span>    <span class="hljs-meta">@JsonView(User.WithoutPasswordView.class)</span>    <span class="hljs-keyword">public</span> User getUser() &#123;        <span class="hljs-keyword">return</span> new User(<span class="hljs-string">&quot;eric&quot;</span>, <span class="hljs-string">&quot;7!jd#h23&quot;</span>);    &#125;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithoutPasswordView</span> &#123;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithPasswordView</span> <span class="hljs-title">extends</span> <span class="hljs-title">WithoutPasswordView</span> &#123;&#125;;<br>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">public</span> User() &#123;    &#125;<br>    <span class="hljs-keyword">public</span> User(String username, String password) &#123;        <span class="hljs-keyword">this</span>.username = username;        <span class="hljs-keyword">this</span>.password = password;    &#125;<br>    <span class="hljs-meta">@JsonView(WithoutPasswordView.class)</span>    <span class="hljs-keyword">public</span> String getUsername() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.username;    &#125;<br>    <span class="hljs-meta">@JsonView(WithPasswordView.class)</span>    <span class="hljs-keyword">public</span> String getPassword() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.password;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><code>@JsonView</code>允许一组视图类，但每个控制器方法只能指定一个。 如果需要激活多个视图，可以使用复合接口。</p><p>对于依赖视图的控制器，只需将序列化视图类添加到model中即可。如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/user&quot;</span>)    public <span class="hljs-type">String</span> getUser(<span class="hljs-type">Model</span> model) &#123;        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(<span class="hljs-string">&quot;eric&quot;</span>, <span class="hljs-string">&quot;7!jd#h23&quot;</span>));        model.addAttribute(<span class="hljs-type">JsonView</span>.<span class="hljs-keyword">class</span>.getName(), <span class="hljs-type">User</span>.<span class="hljs-type">WithoutPasswordView</span>.<span class="hljs-keyword">class</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;userView&quot;</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4-Model"><a href="#1-3-4-Model" class="headerlink" title="1.3.4. Model"></a>1.3.4. Model</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-modelattrib-methods">Same as in Spring WebFlux</a></p><p>您可以使用<code>@ModelAttribute</code> 注解：</p><ul><li>在<code>@RequestMapping</code>方法中的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-modelattrib-method-args">方法参数</a>方法参数，用于从model创建或访问Object并通过<code>WebDataBinder</code>将其绑定到请求。</li><li>作为 <code>@Controller</code>或<code>@ControllerAdvice</code> 类中的方法级注解，有助于在任何 <code>@RequestMapping</code>方法调用之前初始化模型。</li><li>在<code>@RequestMapping</code>方法上标记其返回值是一个模型属性。</li></ul><p>本节讨论<code>@ModelAttribute</code>注解可被应用在方法或方法参数上 - 前面列表中的第二项。控制器可以包含任意数量的 <code>@ModelAttribute</code>方法。 在同一控制器中的<code>@RequestMapping</code>方法之前调用所有这些方法。 <code>@ModelAttribute</code>方法也可以通过<code>@ControllerAdvice</code>在控制器之间共享。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-controller-advice">控制器上的通知</a> 部分。</p><p><code>@ModelAttribute</code>方法具有灵活的方法签名。 除了与<code>@ModelAttribute</code>本身或请求体相关的任何内容外，它们支持许多与<code>@RequestMapping</code>方法相同的参数。</p><p>以下示例显示了<code>@ModelAttribute</code> 方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ModelAttribute</span><br><br>public void <span class="hljs-built_in">populateModel</span>(<span class="hljs-variable">@RequestParam</span> String number, Model model) &#123;<br><br>    <span class="hljs-selector-tag">model</span><span class="hljs-selector-class">.addAttribute</span>(accountRepository.<span class="hljs-built_in">findAccount</span>(number));<br><br>    <span class="hljs-comment">// add more ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>以下示例仅添加一个属性:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ModelAttribute</span><br><br>public Account <span class="hljs-built_in">addAccount</span>(<span class="hljs-variable">@RequestParam</span> String number) &#123;<br><br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">accountRepository</span><span class="hljs-selector-class">.findAccount</span>(number);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果未明确指定名称，框架将根据属性的类型给予一个默认名称，如<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a>的javadoc中所述。 你可以通过设置<code>@ModelAttribute</code>注解的值来改变默认值。当向Model中直接添加属性时，请使用合适的重载方法<code>addAttribute</code>。</p><p><code>@ModelAttribute</code> 注解也可以被用在<code>@RequestMapping</code>方法上，这种情况下，<code>@RequestMapping</code>方法的返回值将会被解释为model的一个属性，而非一个视图名。 此时视图名将以视图命名约定来方式来决议，与返回值为void的方法所采用的处理方法类似。<code>@ModelAttribute</code> 还可以自定义模型属性名称，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/accounts/&#123;id&#125;&quot;</span>)<br><br><span class="hljs-variable">@ModelAttribute</span>(<span class="hljs-string">&quot;myAccount&quot;</span>)<br><br>public Account <span class="hljs-built_in">handle</span>() &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">account</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-5-数据绑定"><a href="#1-3-5-数据绑定" class="headerlink" title="1.3.5. 数据绑定"></a>1.3.5. <code>数据绑定</code></h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-initbinder">Same as in Spring WebFlux</a></p><p><code>@Controller</code>或<code>@ControllerAdvice</code>类可以使用<code>@InitBinder</code> 方法初始化<code>WebDataBinder</code>的实例，而这些方法又可以：</p><ul><li>将请求参数（即表单或查询数据）绑定到模型对象。</li><li>将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为目标类型的控制器方法参数。</li><li>在呈现HTML表单时将模型对象值格式化为<code>String</code>值。</li></ul><p><code>@InitBinder</code>方法可以注册特定于控制器的<code>java.bean.PropertyEditor</code>或Spring <code>Converter</code>和<code>Formatter</code>组件。 此外，您可以使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-conversion">MVC config</a>在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>类型。</p><p><code>@InitBinder</code> 方法支持许多与<code>@RequestMapping</code>方法相同的参数，但<code>@ModelAttribute</code>（命令对象）参数除外。 通常，它们使用<code>WebDataBinder</code>参数（用于注册）和void返回值进行声明。 以下清单显示了一个示例:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormController</span> &#123;<br>    <span class="hljs-meta">@InitBinder</span> (<span class="hljs-number">1</span>)    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initBinder</span>(<span class="hljs-params">WebDataBinder binder</span>) &#123;        <span class="hljs-title class_">SimpleDateFormat</span> dateFormat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);        dateFormat.<span class="hljs-title function_">setLenient</span>(<span class="hljs-literal">false</span>);        binder.<span class="hljs-title function_">registerCustomEditor</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDateEditor</span>(dateFormat, <span class="hljs-literal">false</span>));    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Defining an <code>@InitBinder</code> method.</p><p>或者，当使用基于Formatter的设置时，您可以通过共享的<code>FormattingConversionService</code>重复使用相同的方法并注册特定于控制器的 <code>Formatter</code> 实现，如以下示例所示:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormController</span> &#123;<br>    <span class="hljs-meta">@InitBinder</span> (<span class="hljs-number">1</span>)    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initBinder</span>(<span class="hljs-params">WebDataBinder binder</span>) &#123;        binder.<span class="hljs-title function_">addCustomFormatter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateFormatter</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Defining an <code>@InitBinder</code> method on a custom formatter.</p><h4 id="1-3-6-异常"><a href="#1-3-6-异常" class="headerlink" title="1.3.6. 异常"></a>1.3.6. 异常</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-controller-exceptions">Same as in Spring WebFlux</a></p><p><code>@Controller</code> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-controller-advice">@ControllerAdvice</a>可以使用<code>@ExceptionHandler</code>方法来处理来自控制器方法的异常，如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleController</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@ExceptionHandler</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">handle</span>(<span class="hljs-params">IOException ex</span>) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>该异常可能与顶级异常（即抛出直接<code>IOException</code>）或顶级包装器中的异常（例如，包含在 <code>IllegalStateException</code>内的<code>IOException</code>）相匹配。</p><p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根(root)异常匹配通常优先于原因(cause )异常匹配。 更具体地说，<code>ExceptionDepthComparator</code> 用于根据抛出的异常类型的深度对异常进行排序。</p><p>注解声明可以缩小要匹配的异常类型，如以下示例所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">ExceptionHandler</span>(&#123;FileSystemException.<span class="hljs-keyword">class</span>, RemoteException.<span class="hljs-keyword">class</span>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-title">handle</span><span class="hljs-params">(IOException ex)</span> </span>&#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>您甚至可以使用特定异常类型列表中的非常通用的参数签名，如以下示例所示：:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-built_in">ExceptionHandler</span>(&#123;FileSystemException.<span class="hljs-keyword">class</span>, RemoteException.<span class="hljs-keyword">class</span>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-title">handle</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>根(root)和原因(cause )异常匹配之间的区别可能是令人惊讶的。</p><p>在前面显示的<code>IOException</code>变体中，通常使用实际的<code>FileSystemException</code>或<code>RemoteException</code>实例作为参数调用该方法，因为它们都是从<code>IOException</code>扩展的。 但是，如果任何此类异常在包装器内传播，而该异常本身就是<code>IOException</code>，则传入的异常实例就是包装器异常。</p><p>在<code>handle(Exception)</code>变体中，行为更简单。 这总是在包装场景中使用包装器异常调用，在这种情况下可以通过 <code>ex.getCause()</code>找到实际匹配的异常。 传入的异常仅在实际的<code>FileSystemException</code>或<code>RemoteException</code>实例被抛出为顶级异常时才会发生。</p><p>我们通常建议您在参数签名中尽可能具体，减少root和cause异常类型之间不匹配的可能性。 考虑将多匹配方法分解为单独的<code>@ExceptionHandler</code>方法，每个方法通过其签名匹配单个特定异常类型。</p><p>在具有多个<code>@ControllerAdvice</code>组成中，我们建议在<code>@ControllerAdvice</code>上声明根异常映射，并使用相应的顺序进行优先级排序。 虽然根异常匹配优先于某个原因，但这是在给定控制器或 <code>@ControllerAdvice</code>类的方法中定义的。 这意味着优先级较高的 <code>@ControllerAdvice</code> bean上的原因匹配优先于较低优先级的 <code>@ControllerAdvice</code> bean上的任何匹配（例如，root）。</p><p>最后但同样重要的是， 可以通过<code>@ExceptionHandler</code>方法的实现，讲异常以原始的形式重新抛出，并提供给特定的异常实例。 这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用。 重新抛出的异常通过后续的解析链传播，就好像给定的<code>@ExceptionHandler</code>方法首先不匹配一样。</p><p>Spring MVC中对<code>@ExceptionHandler</code>方法的支持是基于<code>DispatcherServlet</code>级别的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-exceptionhandlers">HandlerExceptionResolver</a>机制构建的。</p><h5 id="方法参数-1"><a href="#方法参数-1" class="headerlink" title="方法参数"></a>方法参数</h5><p><code>@ExceptionHandler</code> 方法支持以下参数：</p><table><thead><tr><th>方法 参数</th><th>描述</th></tr></thead><tbody><tr><td>Exception type</td><td>用于访问引发的异常。</td></tr><tr><td><code>HandlerMethod</code></td><td>访问控制器方法引发的异常</td></tr><tr><td><code>WebRequest</code>, <code>NativeWebRequest</code></td><td>无需直接使用Servlet API即可访问请求参数以及请求和会话属性。</td></tr><tr><td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td>选择任何特定的请求或响应类型（例如，<code>ServletRequest</code> or <code>HttpServletRequest</code> or or Spring’s <code>MultipartRequest</code> or <code>MultipartHttpServletRequest</code>).</td></tr><tr><td><code>javax.servlet.http.HttpSession</code></td><td>强制进行会话。 因此，这样的结果永远不会是<code>null</code>的。请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为<code>true</code>。</td></tr><tr><td><code>java.security.Principal</code></td><td>当前经过身份验证的用户 - 如果已知，可能是特定的 <code>Principal</code>实现类。</td></tr><tr><td><code>HttpMethod</code></td><td>请求的HTTP方法。</td></tr><tr><td><code>java.util.Locale</code></td><td>当前请求区域设置，由最可用的 <code>LocaleResolver</code>（实际上是已配置的 <code>LocaleResolver</code>或<code>LocaleContextResolver</code>）确定。</td></tr><tr><td><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></td><td>与当前请求关联的时区，由<code>LocaleContextResolver</code>确定。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问Servlet API公开的原始响应主体。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>用于访问模型以获取错误响应。 总是为空.</td></tr><tr><td><code>RedirectAttributes</code></td><td>指定在重定向的情况下使用的属性 - （将附加到查询字符串）和临时存储的flash属性，直到重定向后的请求为止。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-redirecting-passing-data">Redirect 属性</a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-flash-attributes">Flash 属性</a>。</td></tr><tr><td><code>@SessionAttribute</code></td><td>用于访问任何会话属性，与由于类级别<code>@SessionAttributes</code>声明的结束形成对比。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>。</td></tr><tr><td><code>@RequestAttribute</code></td><td>用于访问请求属性。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>。</td></tr></tbody></table><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p><code>@ExceptionHandler</code>方法支持以下返回值:</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>@ResponseBody</code></td><td>返回值通过<code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-responsebody"><code>@ResponseBody</code></a>。</td></tr><tr><td><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td>指定完整响应（包括HTTP头和主体）的返回值将通过 <code>HttpMessageConverter</code>实现转换并写入响应。 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-responseentity">ResponseEntity</a>。</td></tr><tr><td><code>String</code></td><td>要使用<code>ViewResolver</code>实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 <code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明 <code>Model</code>参数以编程方式丰富模型（请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-registration">显式注册</a>）。</td></tr><tr><td><code>View</code></td><td>用于与隐式模型一起呈现的<code>View</code>实例 - 通过命令对象和<code>@ModelAttribute</code>方法确定。 处理程序方法还可以通过声明<code>Model</code>参数以编程方式丰富模型（请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-registration">显式注册</a>）。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td>要添加到隐式模型的属性，通过<code>RequestToViewNameTranslator</code>隐式确定视图名称。</td></tr><tr><td><code>@ModelAttribute</code></td><td>要添加到模型的属性，通过隐式确定视图名称。请注意，<code>@ModelAttribute</code>是可选的。 请参阅本表末尾的“任何其他返回值”。</td></tr><tr><td><code>ModelAndView</code> object</td><td>要使用的视图和模型属性，以及（可选）响应状态。</td></tr><tr><td><code>void</code></td><td>如果具有<code>void</code>返回类型（或返回值为 <code>null</code> ）的方法，如果它还具有<code>ServletResponse</code>，<code>OutputStream</code>参数或<code>@ResponseStatus</code>注解， 则认为已完全处理该响应。 如果控制器已进行正<code>ETag</code>或<code>lastModified</code> 时间戳检查，则也是如此（有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching-etag-lastmodified">Controllers</a>）。 如果以上都不是真的，则<code>void</code>返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。</td></tr><tr><td>Any other return value</td><td>任何与此表中任何早期值不匹配且返回值为<code>String</code> 或<code>void</code>的返回值都被视为视图名称（通过<code>RequestToViewNameTranslator</code>应用默认视图名称选择）， 前提是它不是简单类型，由 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>确定，简单类型的值仍未解决。</td></tr></tbody></table><h5 id="REST-API-异常"><a href="#REST-API-异常" class="headerlink" title="REST API 异常"></a>REST API 异常</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-rest-exceptions">Same as in Spring WebFlux</a></p><p>REST服务的一个常见要求是在响应正文中包含错误详细信息。 Spring Framework不会自动执行此操作，因为响应正文中的错误详细信息的表示是特定于应用程序的。 但是，<code>@RestController</code>可以使用带有ResponseEntity返回值的<code>@ExceptionHandler</code>方法来设置响应的状态和正文。 这些方法也可以在<code>@ControllerAdvice</code>类中声明，以全局应用它们。</p><p>在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html"><code>ResponseEntityExceptionHandler</code></a>， 它提供对Spring MVC引发的异常的处理，并提供钩子来定制响应主体。要使用它，请创建<code>ResponseEntityExceptionHandler</code>的子类，使用<code>@ControllerAdvice</code>注解它，覆盖必要的方法，并将其声明为Spring bean。</p><h4 id="1-3-7-控制器通知"><a href="#1-3-7-控制器通知" class="headerlink" title="1.3.7. 控制器通知"></a>1.3.7. 控制器通知</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-ann-controller-advice">Same as in Spring WebFlux</a></p><p>通常，在<code>@Controller</code>类上声明<code>@ExceptionHandler</code>, <code>@InitBinder</code>, 和 <code>@ModelAttribute</code>注解。 如果您希望此类方法更全局地应用（跨控制器），则可以在标有<code>@ControllerAdvice</code> 或 <code>@RestControllerAdvice</code>的类中声明它们。</p><p><code>@ControllerAdvice``@Component</code>标记，这意味着可以通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#beans-java-instantiating-container-scan">组件扫描</a>将这些类注册为Spring bean。 <code>@RestControllerAdvice</code>也是一个用<code>@ControllerAdvice</code>和<code>@ResponseBody</code>标记的元注解，这实际上意味着 <code>@ExceptionHandler</code> 方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。</p><p>在启动时， <code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法的基础结构类检测 <code>@ControllerAdvice</code> 类型的Spring bean，然后在运行时应用它们的方法。 全局<code>@ExceptionHandler</code>方法（来自<code>@ControllerAdvice</code>）在本地方法之后（来自 <code>@Controller</code>）应用。 相比之下，全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法在本地方法之前应用。</p><p>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但您可以通过使用注解上的属性将其缩小到控制器的子集，如以下示例所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// Target <span class="hljs-keyword">all</span> Controllers annotated <span class="hljs-keyword">with</span> @RestController@ControllerAdvice(annotations = RestController.<span class="hljs-keyword">class</span>)<span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ExampleAdvice1 &#123;&#125;<br>// Target <span class="hljs-keyword">all</span> Controllers <span class="hljs-keyword">within</span> specific packages@ControllerAdvice(&quot;org.example.controllers&quot;)<span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ExampleAdvice2 &#123;&#125;<br>// Target <span class="hljs-keyword">all</span> Controllers assignable <span class="hljs-keyword">to</span> specific classes@ControllerAdvice(assignableTypes = &#123;ControllerInterface.<span class="hljs-keyword">class</span>, AbstractController.<span class="hljs-keyword">class</span>&#125;)<span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ExampleAdvice3 &#123;&#125;<br></code></pre></td></tr></table></figure><p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。 有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a> javadoc 。</p><h3 id="1-4-URI-链接"><a href="#1-4-URI-链接" class="headerlink" title="1.4. URI 链接"></a>1.4. URI 链接</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-uri-building">Same as in Spring WebFlux</a></p><p>本节介绍Spring Framework中可用于处理URI的各种选项。</p><h4 id="1-4-1-UriComponents"><a href="#1-4-1-UriComponents" class="headerlink" title="1.4.1. UriComponents"></a>1.4.1. UriComponents</h4><p>Spring MVC和Spring WebFlux</p><p><code>UriComponentsBuilder</code> 有助于从URI模板变量构建URI。 如下例所示:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UriComponents</span> uriComponents = UriComponentsBuilder        .fromUriString(<span class="hljs-string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)  (<span class="hljs-number">1</span>)        .queryParam(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)  (<span class="hljs-number">2</span>)        .encode() (<span class="hljs-number">3</span>)        .build(); (<span class="hljs-number">4</span>)<br><span class="hljs-attribute">URI</span> uri = uriComponents.expand(<span class="hljs-string">&quot;Westin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>).toUri();  (<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>1</strong>、带有URI模板的静态工厂方法。</p><p><strong>2</strong>、添加或替换URI组件。</p><p><strong>3</strong>、请求编码URI模板和URI变量。</p><p><strong>4</strong>、构建一个<code>UriComponents</code>.</p><p><strong>5</strong>、暴露变量并获取<code>URI</code>.</p><p>前面的示例可以合并到一个链中，并使用<code>buildAndExpand</code>缩短，如下例所示:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">URI uri = UriComponentsBuilder<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .fromUriString</span>(<span class="hljs-string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .queryParam</span>(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .encode</span>()<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .buildAndExpand</span>(<span class="hljs-string">&quot;Westin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .toUri</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如下例所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">URI uri = UriComponentsBuilder<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .fromUriString</span>(<span class="hljs-string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .queryParam</span>(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .build</span>(<span class="hljs-string">&quot;Westin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>您使用完整的URI模板进一步缩短它，如下例所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">URI uri = UriComponentsBuilder<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .fromUriString</span>(<span class="hljs-string">&quot;http://example.com/hotels/&#123;hotel&#125;?q=&#123;q&#125;&quot;</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">        .build</span>(<span class="hljs-string">&quot;Westin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-2-UriBuilder"><a href="#1-4-2-UriBuilder" class="headerlink" title="1.4.2. UriBuilder"></a>1.4.2. UriBuilder</h4><p>Spring MVC和Spring WebFlux</p><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#web-uricomponents"><code>UriComponentsBuilder</code></a> 实现了 <code>UriBuilder</code>。 您可以使用<code>UriBuilderFactory</code>创建一个 <code>UriBuilder</code>。 <code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p><p>您可以使用UriBuilderFactory配置<code>RestTemplate</code>和<code>WebClient</code>。为自定义URI做准备。<code>DefaultUriBuilderFactory</code> 是<code>UriBuilderFactory</code> 的默认实现，它在内部使用<code>UriComponentsBuilder</code>并公开共享配置选项。</p><p>以下示例显示如何配置<code>RestTemplate</code>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="hljs-built_in">String</span> baseUrl = <span class="hljs-string">&quot;http://example.org&quot;</span>;DefaultUriBuilderFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl);<span class="hljs-keyword">factory</span>.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);<br>RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();restTemplate.setUriTemplateHandler(<span class="hljs-keyword">factory</span>);<br></code></pre></td></tr></table></figure><p>以下示例配置<code>WebClient</code>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="hljs-built_in">String</span> baseUrl = <span class="hljs-string">&quot;http://example.org&quot;</span>;DefaultUriBuilderFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> DefaultUriBuilderFactory(baseUrl);<span class="hljs-keyword">factory</span>.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);<br>WebClient client = WebClient.builder().uriBuilderFactory(<span class="hljs-keyword">factory</span>).build();<br></code></pre></td></tr></table></figure><p>此外，您还可以直接使用 <code>DefaultUriBuilderFactory</code> 。 它类似于使用<code>UriComponentsBuilder</code> ，但它不是静态工厂方法，而是一个保存配置和首选项的实际实例，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">baseUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://example.com&quot;</span>;<span class="hljs-type">DefaultUriBuilderFactory</span> <span class="hljs-variable">uriBuilderFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultUriBuilderFactory</span>(baseUrl);<br><span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uriBuilderFactory.uriString(<span class="hljs-string">&quot;/hotels/&#123;hotel&#125;&quot;</span>)        .queryParam(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)        .build(<span class="hljs-string">&quot;Westin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-4-3-URI-编码"><a href="#1-4-3-URI-编码" class="headerlink" title="1.4.3. URI 编码"></a>1.4.3. URI 编码</h4><p>Spring MVC 和 Spring WebFlux</p><p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>: 首先对URI模板进行预编码，然后在扩展时严格编码URI变量。.</li><li><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>: 扩展URI变量后对URI组件进行编码。</li></ul><p>这两个选项都使用转义的八位字节替换非ASCII和非法字符。 但是，第一个选项还会替换出现在URI变量中的保留含义的字符。</p><p>考虑”;“，这在路径中是合法的但具有保留意义。第一个选项取代”;“在URI变量中使用”%3B”但在URI模板中没有。 相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p><p>对于大多数情况，第一个选项可能会给出预期结果，因为它将URI变量视为完全编码的不透明数据，而选项2仅在URI变量故意包含保留字符时才有用。</p><p>以下示例使用第一个选项:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">URI uri = UriComponentsBuilder.fromPath(<span class="hljs-string">&quot;/hotel list/&#123;city&#125;&quot;</span>)            .queryParam(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)            .encode()            .buildAndExpand(<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;foo+bar&quot;</span>)            .toUri();<br>    <span class="hljs-regexp">//</span> Result is <span class="hljs-string">&quot;/hotel%20list/New%20York?q=foo%2Bbar&quot;</span><br></code></pre></td></tr></table></figure><p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">URI uri = UriComponentsBuilder<span class="hljs-selector-class">.fromPath</span>(<span class="hljs-string">&quot;/hotel list/&#123;city&#125;&quot;</span>)<br><br>            <span class="hljs-selector-class">.queryParam</span>(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&#123;q&#125;&quot;</span>)<br><br>            <span class="hljs-selector-class">.build</span>(<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;foo+bar&quot;</span>)<br></code></pre></td></tr></table></figure><p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">URI uri = UriComponentsBuilder<span class="hljs-selector-class">.fromPath</span>(<span class="hljs-string">&quot;/hotel list/&#123;city&#125;?q=&#123;q&#125;&quot;</span>)<br><br>            <span class="hljs-selector-class">.build</span>(<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;foo+bar&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>WebClient</code>和<code>RestTemplate</code>通过 <code>UriBuilderFactory</code>策略在内部展开和编码URI模板。 两者都可以配置自定义策略。 如下例所示：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">String baseUrl = <span class="hljs-string">&quot;http://example.com&quot;</span>;DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory<span class="hljs-params">(baseUrl)</span>factory.<span class="hljs-keyword">set</span>EncodingMode<span class="hljs-params">(EncodingMode.TEMPLATE_AND_VALUES)</span>;<br><span class="hljs-string">//</span> Customize the RestTemplate.<span class="hljs-string">.RestTemplate</span> restTemplate = new RestTemplate<span class="hljs-params">()</span>;restTemplate.<span class="hljs-keyword">set</span>UriTemplateHandler<span class="hljs-params">(factory)</span>;<br><span class="hljs-string">//</span> Customize the WebClient.<span class="hljs-string">.WebClient</span> client = WebClient.builder<span class="hljs-params">()</span><span class="hljs-string">.uriBuilderFactory</span><span class="hljs-params">(factory)</span><span class="hljs-string">.build</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><code>DefaultUriBuilderFactory</code>实现在内部使用<code>UriComponentsBuilder</code>来展开和编码URI模板。 作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p><ul><li><code>TEMPLATE_AND_VALUES</code>: 使用<code>UriComponentsBuilder#encode()</code>（对应于前面列表中的第一个选项）对URI模板进行预编码，并在展开时严格编码URI变量。</li><li><code>VALUES_ONLY</code>: 不对URI模板进行编码，而是在将URI变量展开到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对URI变量严格编码。</li><li><code>URI_COMPONENTS</code>: 使用<code>UriComponents#encode()</code>（对应于前面列表中的第二个选项），在URI变量展开后对URI组件值进行编码。</li><li><code>NONE</code>: 没有应用编码。</li></ul><p>出于历史原因和向后兼容性，<code>RestTemplate</code>设置为 <code>EncodingMode.URI_COMPONENTS</code>。<code>WebClient</code> 依赖于<code>DefaultUriBuilderFactory</code>中的默认值， 该值已从5.0.x中的 <code>EncodingMode.URI_COMPONENTS</code>更改为5.1中的 <code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p><h4 id="1-4-4-相对请求"><a href="#1-4-4-相对请求" class="headerlink" title="1.4.4. 相对请求"></a>1.4.4. 相对请求</h4><p>您可以使用<code>ServletUriComponentsBuilder</code>创建相对于当前请求的URI，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-comment">// Re-uses host, scheme, port, path and query string...</span><br><span class="hljs-type">ServletUriComponentsBuilder</span> <span class="hljs-variable">ucb</span> <span class="hljs-operator">=</span> ServletUriComponentsBuilder.fromRequest(request)        .replaceQueryParam(<span class="hljs-string">&quot;accountId&quot;</span>, <span class="hljs-string">&quot;&#123;id&#125;&quot;</span>).build()        .expand(<span class="hljs-string">&quot;123&quot;</span>)        .encode();<br></code></pre></td></tr></table></figure><p>您可以创建相对于上下文路径的URI，如以下示例所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Re-uses host, port and context path...</span><br>ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder<span class="hljs-selector-class">.fromContextPath</span>(request)        <span class="hljs-selector-class">.path</span>(<span class="hljs-string">&quot;/accounts&quot;</span>)<span class="hljs-selector-class">.build</span>()<br></code></pre></td></tr></table></figure><p>您可以创建相对于Servlet的URI（例如，<code>/main/*</code>），如以下示例所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Re-uses host, port, context path, and Servlet prefix...</span><br>ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder<span class="hljs-selector-class">.fromServletMapping</span>(request)        <span class="hljs-selector-class">.path</span>(<span class="hljs-string">&quot;/accounts&quot;</span>)<span class="hljs-selector-class">.build</span>()<br></code></pre></td></tr></table></figure><p>从5.1开始，<code>ServletUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>头部的信息，这些头部信息指定了客户端发起的地址。 考虑使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-forwarded-headers"><code>ForwardedHeaderFilter</code></a>来提取和使用或丢弃此类请求头。</p><h4 id="1-4-5-控制器链接"><a href="#1-4-5-控制器链接" class="headerlink" title="1.4.5. 控制器链接"></a>1.4.5. 控制器链接</h4><p>Spring MVC也提供了构造指定控制器方法链接的机制。 例如，以下MVC控制器允许创建链接：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/hotels/&#123;hotel&#125;&quot;</span>)public class BookingController &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/bookings/&#123;booking&#125;&quot;</span>)    public ModelAndView <span class="hljs-built_in">getBooking</span>(<span class="hljs-variable">@PathVariable</span> Long booking) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>您可以通过引用方法名字的办法来准备一个链接，如以下示例所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UriComponents</span> uriComponents = MvcUriComponentsBuilder    .fromMethodName(BookingController.class, <span class="hljs-string">&quot;getBooking&quot;</span>, <span class="hljs-number">21</span>).buildAndExpand(<span class="hljs-number">42</span>);<br><span class="hljs-attribute">URI</span> uri = uriComponents.encode().toUri();<br></code></pre></td></tr></table></figure><p>在前面的示例中，为方法参数准备了填充值（在本例中，long值： <code>21</code>），以用于填充路径变量并插入到URL中。此外，我们提供了值42，来填充任何剩余的URI变量，比如从类层级的请求映射中继承来的hotel变量。 如果方法还有更多的参数，你可以为那些不需要参与URL构造的变量赋予null值。 通常，只有<code>@PathVariable</code>和<code>@RequestParam</code>参数与构造URL相关。</p><p>还有其他方法可以使用<code>MvcUriComponentsBuilder</code>。 例如，例如可以通过类似mock掉测试对象的方法，用代理来避免直接通过名字引用一个控制，如以下示例所示（该示例假设静态导入<code>MvcUriComponentsBuilder.on</code>）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UriComponents uriComponents <span class="hljs-operator">=</span> MvcUriComponentsBuilder    .fromMethodCall(on(BookingController.class).getBooking(<span class="hljs-number">21</span>)).buildAndExpand(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span><br>URI uri <span class="hljs-operator">=</span> uriComponents.encode().toUri()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Controller method signatures are limited in their design when they are supposed to be usable for link creation with <code>fromMethodCall</code>. Aside from needing a proper parameter signature, there is a technical limitation on the return type (namely, generating a runtime proxy for link builder invocations), so the return type must not be <code>final</code>. In particular, the common <code>String</code> return type for view names does not work here. You should use <code>ModelAndView</code> or even plain <code>Object</code> (with a <code>String</code> return value) instead.</p><p>上面的代码例子中使用了<code>MvcUriComponentsBuilder</code>类的静态方法，内部实现中，它依赖于<code>ServletUriComponentsBuilder</code>来从当前请求中抽取schema、主机名、端口号、context路径和Servlet路径， 并准备一个基本URL。大多数情况下它能良好工作，但有时还不行，比如，在准备链接时你可能在当前请求的上下文（context）之外（比如，执行一个准备链接links的批处理），或你可能需要为路径插入一个前缀（比如一个地区性前缀，它从请求中被移除，然后又重新被插入到链接中去）。</p><p>对于上面所提的场景，开发者可以使用重载过的静态方法<code>fromXxx</code>，它接收一个<code>UriComponentsBuilder</code>参数，然后从中获取基本URL以便使用，或你也可以使用一个基本URL创建一个<code>MvcUriComponentsBuilder</code>对象， 然后使用实例对象的<code>withXxx</code>方法。以下列表使用 <code>withMethodCall</code>:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UriComponentsBuilder base <span class="hljs-operator">=</span> ServletUriComponentsBuilder.fromCurrentContextPath().path(<span class="hljs-string">&quot;/en&quot;</span>)<span class="hljs-comment">;MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);</span><br>URI uri <span class="hljs-operator">=</span> uriComponents.encode().toUri()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从5.1开始，<code>MvcUriComponentsBuilder</code>忽略来自<code>Forwarded</code> 和<code>X-Forwarded-*</code>头的信息，这些头指定了客户端发起的地址。 考虑使用ForwardedHeaderFilter来提取和使用或丢弃此类标头。</p><h4 id="1-4-6-视图链接"><a href="#1-4-6-视图链接" class="headerlink" title="1.4.6. 视图链接"></a>1.4.6. 视图链接</h4><p>在Thymeleaf，FreeMarker或JSP等视图中，您可以通过引用每个请求映射的隐式或显式指定名称来构建指向带注解控制器的链接。</p><p>请考虑以下示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/people/&#123;id&#125;/addresses&quot;</span>)public class PersonAddressController &#123;<br>    <span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/&#123;country&#125;&quot;</span>)    public HttpEntity <span class="hljs-built_in">getAddress</span>(<span class="hljs-variable">@PathVariable</span> String country) &#123; ... &#125;&#125;<br></code></pre></td></tr></table></figure><p>给定前面的控制器，可以按照以下方式准备来自JSP的链接，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;%@ taglib uri=<span class="hljs-string">&quot;http://www.springframework.org/tags&quot;</span> prefix=<span class="hljs-string">&quot;s&quot;</span> %&gt;<br><br>...<br><br>&lt;a href=<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;s:mvcUrl(<span class="hljs-string">&#x27;PAC#getAddress&#x27;</span>).arg(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;US&#x27;</span>).buildAndExpand(<span class="hljs-string">&#x27;123&#x27;</span>)&#125;</span>&quot;</span>&gt;Get Address&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>前面的示例依赖于Spring标签库中声明的<code>mvcUrl</code>函数（即 META-INF&#x2F;spring.tld），但可以很容易地定义自定义函数或使用自定义标记文件。</p><p>这是如何工作的，在启动时，每个<code>@RequestMapping</code> 都通过<code>HandlerMethodMappingNamingStrategy</code>分配一个默认名称，其默认实现使用类的大写字母和方法名称（例如， <code>ThingController</code>中的<code>getThing</code>方法变为”TC#getThing”）。如果存在名称冲突，则可以使用<code>@RequestMapping(name=&quot;..&quot;)</code>分配显式名称或实现自己的<code>HandlerMethodMappingNamingStrategy</code>。</p><h3 id="1-5-异步请求"><a href="#1-5-异步请求" class="headerlink" title="1.5. 异步请求"></a>1.5. 异步请求</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p><p>Spring MVC与Servlet 3.0异步请求<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-processing">处理</a>有广泛的集成：</p><ul><li>在控制器方法中返回<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-callable"><code>Callable</code></a>，并为单个异步返回值提供基本支持。</li><li>控制器可以<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-http-streaming">stream</a>多个值，包括<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-sse">SSE</a> 和<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-output-stream">raw data</a>。</li><li>控制器可以使用reactive clients 并返回<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">reactive types</a>以进行响应处理。</li></ul><h4 id="1-5-1-DeferredResult"><a href="#1-5-1-DeferredResult" class="headerlink" title="1.5.1. DeferredResult"></a>1.5.1. <code>DeferredResult</code></h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p><p>一旦在Servlet容器中<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-configuration">启用</a> 了异步请求处理功能，控制器方法就可以使用 <code>DeferredResult</code>包装任何支持的控制器方法返回值，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/quotes&quot;</span>)<span class="hljs-meta">@ResponseBodypublic</span> <span class="hljs-title class_">DeferredResult</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">quotes</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">DeferredResult</span>&lt;<span class="hljs-title class_">String</span>&gt; deferredResult = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeferredResult</span>&lt;<span class="hljs-title class_">String</span>&gt;();    <span class="hljs-comment">// Save the deferredResult somewhere..    return deferredResult;&#125;</span><br><span class="hljs-comment">// From some other thread...deferredResult.setResult(data);</span><br></code></pre></td></tr></table></figure><p>控制器可以从不同的线程异步生成返回值 - 例如，响应外部事件（JMS消息），计划任务或其他事件。</p><h4 id="1-5-2-Callable"><a href="#1-5-2-Callable" class="headerlink" title="1.5.2. Callable"></a>1.5.2. <code>Callable</code></h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p><p>控制器可以使用 <code>java.util.concurrent.Callable</code>包装任何支持的返回值，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMappingpublic</span> <span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">processUpload</span>(<span class="hljs-params">final MultipartFile file</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">call</span>() throws <span class="hljs-title class_">Exception</span> &#123;            <span class="hljs-comment">// ...            return &quot;someView&quot;;        &#125;    &#125;;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后可以通过配置的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-configuration-spring-mvc">configured</a> <code>TaskExecutor</code>运行给定任务来获取返回值。</p><h4 id="1-5-3-处理过程"><a href="#1-5-3-处理过程" class="headerlink" title="1.5.3. 处理过程"></a>1.5.3. 处理过程</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p><p>以下是Servlet异步请求处理的简要概述:</p><ul><li>Servlet请求<code>ServletRequest</code>可以通过调用 <code>request.startAsync()</code>方法而进入异步模式。这样做的主要结果就是该Servlet以及所有的过滤器都可以结束，但其响应（response）会留待异步处理结束后再返回调用。</li><li><code>request.startAsync()</code> 方法会返回一个<code>AsyncContext</code>对象 ，可用它对异步处理进行进一步的控制和操作。比如说它也提供了一个与转向（forward）很相似的<code>dispatch</code>方法，只不过它允许应用恢复Servlet容器的请求处理进程。</li><li><code>ServletRequest</code> 提供了获取当前<code>DispatcherType</code>的方式，后者可以用来区别当前处理的是原始请求、异步分发请求、转向、或是其他类型的请求分发类型。</li></ul><p><code>DeferredResult</code> 处理的工作方式如下：</p><ul><li>控制器先返回一个<code>DeferredResult</code>对象，并把它存取在内存（队列或列表等）中以便存取。</li><li>Spring MVC调用<code>request.startAsync()</code>方法，开始进行异步处理。</li><li><code>DispatcherServlet</code>和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。</li><li>由处理该请求的线程对<code>DeferredResult</code>进行设值，然后SpringM VC会重新把请求分派回Servlet容器，恢复处理。</li><li><code>DispatcherServlet</code>再次被调用, 恢复对该异步返回结果的处理。</li></ul><p><code>Callable</code>处理的工作方式如下：</p><ul><li>控制器先返回一个<code>Callable</code>对象.</li><li>Spring MVC调用 <code>request.startAsync()</code>方法，开始进行异步处理，并把该<code>Callable</code>对象提交给另一个独立线程的执行器 <code>TaskExecutor</code>处理。</li><li><code>DispatcherServlet</code>和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。</li><li><code>Callable</code>对象最终产生一个返回结果，此时Spring MVC会重新把请求分派回Servlet容器，恢复处理。</li><li><code>DispatcherServlet</code>再次被调用,恢复对<code>Callable</code>异步处理所返回结果的处理。</li></ul><p>关于引入异步请求处理的背景和原因，以及什么时候使用它，为什么使用异步请求处理等问题。可以阅读这个系列的<a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">博客文章</a> 。</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>若方法返回的是一个<code>DeferredResult</code>对象，你可以选择调Exception实例的<code>setResult</code>方法还是<code>setErrorResult</code>方法。在这两种情况下，Spring MVC都会将请求发送回Servlet容器以完成处理。 然后将其视为控制器方法返回给定值或者就好像它产生了给定的异常一样。 然后异常通过常规异常处理机制（例如，调用<code>@ExceptionHandler</code>方法）。更具体地说呢，当Callable抛出异常时，Spring MVC会把一个Exception对象分派给Servlet容器进行处理，而不是正常返回方法的返回值，然后容器恢复对此异步请求异常的处理。</p><p>当您使用<code>Callable</code>时，会出现类似的处理逻辑，主要区别在于从<code>Callable</code>返回结果，或者由它引发异常。</p><h5 id="拦截异步请求"><a href="#拦截异步请求" class="headerlink" title="拦截异步请求"></a>拦截异步请求</h5><p>处理器拦截器<code>HandlerInterceptor</code>可以实现<code>AsyncHandlerInterceptor</code>接口拦截异步请求，因为在异步请求开始时，被调用的回调方法是该接口的<code>afterConcurrentHandlingStarted</code>方法，而非一般的<code>postHandle</code>和<code>afterCompletion</code>方法。</p><p>如果需要与异步请求处理的生命流程有更深入的集成，比如需要处理timeout的事件等。则<code>HandlerInterceptor</code>需要注册<code>CallableProcessingInterceptor</code>或<code>DeferredResultProcessingInterceptor</code>拦截器， 具体的细节可以参考 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html"><code>AsyncHandlerInterceptor</code></a>类的Java文档</p><p><code>DeferredResult</code>类还提供了<code>onTimeout(Runnable)</code> 和 <code>onCompletion(Runnable)</code> 等回调， 具体的细节可以参考<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html"><code>DeferredResult</code></a>类的Java文档 <code>Callable</code>可以替代<code>WebAsyncTask</code>，它公开了超时和完成回调的其他方法。</p><h5 id="Compared-to-WebFlux"><a href="#Compared-to-WebFlux" class="headerlink" title="Compared to WebFlux"></a>Compared to WebFlux</h5><p>The Servlet API was originally built for making a single pass through the Filter-Servlet chain. Asynchronous request processing, added in Servlet 3.0, lets applications exit the Filter-Servlet chain but leave the response open for further processing. The Spring MVC asynchronous support is built around that mechanism. When a controller returns a <code>DeferredResult</code>, the Filter-Servlet chain is exited, and the Servlet container thread is released. Later, when the <code>DeferredResult</code> is set, an <code>ASYNC</code> dispatch (to the same URL) is made, during which the controller is mapped again but, rather than invoking it, the <code>DeferredResult</code> value is used (as if the controller returned it) to resume processing.</p><p>By contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an asynchronous request processing feature, because it is asynchronous by design. Asynchronous handling is built into all framework contracts and is intrinsically supported through all stages of request processing.</p><p>From a programming model perspective, both Spring MVC and Spring WebFlux support asynchronous and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">Reactive Types</a> as return values in controller methods. Spring MVC even supports streaming, including reactive back pressure. However, individual writes to the response remain blocking (and are performed on a separate thread), unlike WebFlux, which relies on non-blocking I&#x2F;O and does not need an extra thread for each write.</p><p>Another fundamental difference is that Spring MVC does not support asynchronous or reactive types in controller method arguments (for example, <code>@RequestBody</code>, <code>@RequestPart</code>, and others), nor does it have any explicit support for asynchronous and reactive types as model attributes. Spring WebFlux does support all that.</p><h4 id="1-5-4-HTTP-流"><a href="#1-5-4-HTTP-流" class="headerlink" title="1.5.4. HTTP 流"></a>1.5.4. HTTP 流</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p><p>您可以将<code>DeferredResult</code>和<code>Callable</code>用于单个异步返回值。 如果要生成多个异步值并将其写入响应，该怎么办？ 本节介绍如何执行此操作。</p><h5 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h5><p>您可以使用<code>ResponseBodyEmitter</code>返回值来生成对象流，其中每个对象都使用 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>进行序列化并写入响应，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/events&quot;)</span><span class="hljs-keyword">public</span> ResponseBodyEmitter <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">ResponseBodyEmitter</span> <span class="hljs-variable">emitter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseBodyEmitter</span>();    <span class="hljs-comment">// Save the emitter somewhere..    return emitter;&#125;</span><br><span class="hljs-comment">// In some other threademitter.send(&quot;Hello once&quot;);</span><br><span class="hljs-comment">// and again later onemitter.send(&quot;Hello again&quot;);</span><br><span class="hljs-comment">// and done at some pointemitter.complete();</span><br></code></pre></td></tr></table></figure><p><code>ResponseBodyEmitter</code>也可以被放到<code>ResponseEntity</code>体里面使用，这可以对响应状态和响应头做一些定制。</p><p>当<code>emitter</code> 抛出<code>IOException</code>时（例如，如果远程客户端消失），应用程序不负责清理连接，不应调用<code>emitter.complete</code>或<code>emitter.completeWithError</code>。 相反，servlet容器会自动启动<code>AsyncListener</code> 错误通知，其中Spring MVC进行 <code>completeWithError</code>调用。 反过来，此调用会对应用程序执行一次最终<code>ASYNC</code> 调度，在此期间，Spring MVC将调用已配置的异常解析程序并完成请求。</p><h5 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h5><p><code>SseEmitter</code> （<code>ResponseBodyEmitter</code>的子类）为<a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a>,提供支持，其中从服务器发送的事件根据W3C SSE规范进行格式化。 要从控制器生成SSE流，请返回<code>SseEmitter</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(path=&quot;/events&quot;, produces=MediaType.TEXT_EVENT_STREAM_VALUE)</span><span class="hljs-keyword">public</span> SseEmitter <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SseEmitter</span> <span class="hljs-variable">emitter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SseEmitter</span>();    <span class="hljs-comment">// Save the emitter somewhere..    return emitter;&#125;</span><br><span class="hljs-comment">// In some other threademitter.send(&quot;Hello once&quot;);</span><br><span class="hljs-comment">// and again later onemitter.send(&quot;Hello again&quot;);</span><br><span class="hljs-comment">// and done at some pointemitter.complete();</span><br></code></pre></td></tr></table></figure><p>虽然SSE是流式传输到浏览器的主要选项，但请注意Internet Explorer不支持Server-Sent Events。 考虑将Spring的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#websocket">WebSocket messaging</a>传递与针对各种浏览器的 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#websocket-fallback">SockJS fallback</a> 传输（包括SSE）一起使用。</p><p>有关异常处理的说明，另请参见<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-objects">上一节</a> 。</p><h5 id="Raw-Data"><a href="#Raw-Data" class="headerlink" title="Raw Data"></a>Raw Data</h5><p>有时，跳过消息转换的阶段，直接把数据写回响应的输出流<code>OutputStream</code>可能更有效，比如文件下载这样的场景，这可以通过返回一个<code>StreamingResponseBody</code>类型的对象来实现，如以下示例所示：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/download&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function">StreamingResponseBody <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamingResponseBody() &#123;<br><br>        <span class="hljs-meta">@Override</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeTo</span><span class="hljs-params">(OutputStream outputStream)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>            <span class="hljs-comment">// write...</span><br><br>        &#125;<br><br>    &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>StreamingResponseBody</code>也可以被放到<code>ResponseEntity</code> 体里面使用，这可以对响应状态和响应头做一些定制。</p><h4 id="1-5-5-Reactive-Types（响应式类型）"><a href="#1-5-5-Reactive-Types（响应式类型）" class="headerlink" title="1.5.5. Reactive Types（响应式类型）"></a>1.5.5. Reactive Types（响应式类型）</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p><p>如果使用<code>spring-webflux</code>中的响应式<code>WebClient</code>，或其他客户端（也可以阅读WebFlux部分中的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-reactive-libraries">Reactive Libraries</a>），又或者是带响应式支持的数据存储，开发者可以直接从Spring MVC控制器方法返回响应式类型。 p&gt;</p><p>Reactive 返回值的处理方式如下:</p><ul><li>如果返回类型有single-value流的语义，如Reactor<code>Mono</code>或RxJava <code>Single</code>，那么它是适配并等效于 <code>DeferredResult</code>。</li><li>如果返回类型有multi-value流的语义，如Reactor <code>Flux</code>或RxJava <code>Observable</code>，并且如果媒体类型也表示为流，（例如，<code>application/stream+json</code>或<code>text/event-stream</code>）。 则它是适配并等效于使用<code>ResponseBodyEmitter</code>或 <code>SseEmitter</code>。还可以返回<code>Flux&lt;ServerSentEvent&gt;</code>或 <code>Observable&lt;ServerSentEvent&gt;</code>。</li><li>如果返回类型multi-value流的语义，但媒体类型并不表示为流。例如<code>application/json</code>，则它是适配并等效于使用<code>DeferredResult&lt;List&lt;?&gt;&gt;</code>。</li></ul><p>Spring MVC对使用中的响应式库进行了适配 – 例如，预计有多少值，这是在<code>spring-core</code>包的<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a> 的帮助下完成的。 它为响应式和异步类型提供可插拔的支持。注册表内置了对RxJava的支持，但其他可以注册。</p><p>对于流式传输到响应，支持响应式响应，但是对响应的写入仍然是阻塞的，并且通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-configuration-spring-mvc">配置</a> 的<code>TaskExecutor</code>在单独的线程上执行， 以避免阻塞上游源（例如从<code>WebClient</code>返回的<code>Flux</code>）。 默认情况下，<code>SimpleAsyncTaskExecutor</code>用于阻塞写入，但在加载时不适用。 如果计划使用响应类型进行流式处理，则应使用MVC配置来配置任务执行程序。</p><h4 id="1-5-6-断开"><a href="#1-5-6-断开" class="headerlink" title="1.5.6. 断开"></a>1.5.6. 断开</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-codecs-streaming">Same as in Spring WebFlux</a></p><p>当远程客户端消失时，Servlet API不提供任何通知。 因此，在通过stream传输到响应时，无论是通过<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-sse">SseEmitter</a>还是&lt;&lt;mvc-ann-async-reactive-types,reactive types&gt;，定期发送数据都很重要， 因为如果客户端断开连接，写入将失败。 发送可以采用空（仅限注解）SSE事件或另一方必须解释为心跳并忽略的任何其他数据的形式。</p><p>或者，考虑使用具有内置心跳机制的Web消息传递解决方案（例如基于WebSocket的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#websocket-stomp">STOMP</a>或具有<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#websocket-fallback">SockJS</a>的WebSocket）。</p><h4 id="1-5-7-配置"><a href="#1-5-7-配置" class="headerlink" title="1.5.7. 配置"></a>1.5.7. 配置</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-vs-webflux">Compared to WebFlux</a></p><p>必须在Servlet容器级别启用异步请求处理功能。 MVC配置还公开了异步请求的几个选项。</p><h5 id="Servlet-容器"><a href="#Servlet-容器" class="headerlink" title="Servlet 容器"></a>Servlet 容器</h5><p>Filter和Servlet声明具有<code>asyncSupported</code>标志，需要将其设置为<code>true</code>以启用异步请求处理。 此外，应声明Filter映射以处理<code>ASYNC</code> <code>javax.servlet.DispatchType</code>。</p><p>在Java配置中，当您使用<code>AbstractAnnotationConfigDispatcherServletInitializer</code>初始化Servlet容器时，这将自动完成。</p><p>在<code>web.xml</code> 配置中，您可以将<code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code> 添加到<code>DispatcherServlet</code>和<code>Filter</code>声明，并添加<code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code>以过滤映射。</p><h5 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h5><p>MVC配置公开以下与异步请求处理相关的选项：</p><ul><li>Java configuration:在<code>WebMvcConfigurer</code>上使用<code>configureAsyncSupport</code>回调。</li><li>XML namespace:使用 <code>&lt;mvc:annotation-driven&gt;</code>下的<code>&lt;async-support&gt;</code>元素。</li></ul><p>您可以配置以下内容：</p><ul><li>异步请求的默认超时值（如果未设置）取决于底层Servlet容器（例如，Tomcat上的10秒）。</li><li><code>AsyncTaskExecutor</code>用于在使用<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-async-reactive-types">Reactive Types</a>进行流式处理时阻止写入，以及用于执行从控制器方法返回的<code>Callable</code>实例。 如果您使用reactive types进行流式传输或者具有返回<code>Callable</code>的控制器方法， 我们强烈建议您配置此属性，因为默认情况下，它是<code>SimpleAsyncTaskExecutor</code>。</li><li><code>DeferredResultProcessingInterceptor</code>实现和<code>CallableProcessingInterceptor</code>实现。</li></ul><p>请注意，您还可以在<code>DeferredResult</code>， <code>ResponseBodyEmitter</code>和<code>SseEmitter</code>上设置默认超时值。 对于<code>Callable</code>，您可以使用<code>WebAsyncTask</code> 来提供超时值。</p><h3 id="1-6-CORS"><a href="#1-6-CORS" class="headerlink" title="1.6. CORS"></a>1.6. CORS</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors">Same as in Spring WebFlux</a></p><p>Spring MVC允许您处理CORS（跨源资源共享）。 本节介绍如何执行此操作。</p><h4 id="1-6-1-简介"><a href="#1-6-1-简介" class="headerlink" title="1.6.1. 简介"></a>1.6.1. 简介</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-intro">Same as in Spring WebFlux</a></p><p>出于安全原因，浏览器禁止对当前源外的资源进行AJAX调用。 例如，您可以将您的银行帐户放在一个标签页中，将evil.com放在另一个标签页中。 来自evil.com的脚本不应该使用您的凭据向您的银行API发出AJAX请求 - 例如从您的帐户中提取资金！</p><p>Cross-Origin Resource Sharing (CORS) 是<a href="https://caniuse.com/#feat=cors">大多数浏览器</a> 实现的<a href="https://www.w3.org/TR/cors/">W3C规范</a>，它允许以灵活的方式指定哪些类型的跨域请求被授权， 而不是使用一些安全程度较低、功能较差的实现(如IFRAME或JSONP)。</p><h4 id="1-6-2-处理"><a href="#1-6-2-处理" class="headerlink" title="1.6.2. 处理"></a>1.6.2. 处理</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-processing">Same as in Spring WebFlux</a></p><p>CORS规范区分了预检查，简单和实际请求。 要了解CORS的工作原理，您可以<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">&gt;阅读本文</a>以及其他许多内容，或者查看规范以获取更多详细信息。</p><p>Spring MVC <code>HandlerMapping</code>为实现CORS提供内置支持。成功将请求映射到处理程序后，<code>HandlerMapping</code> 实现检查给定请求和处理程序的CORS配置并采取进一步操作。 直接处理预检查请求，同时拦截，验证简单和实际的CORS请求，并设置所需的CORS响应头。</p><p>为了启用跨源请求（即，存在<code>Origin</code>头并且与请求的主机不同），您需要具有一些显式声明的CORS配置。 如果未找到匹配的CORS配置，则拒绝预检请求。 没有CORS头添加到简单和实际CORS请求的响应中，因此浏览器拒绝它们。</p><p>可以使用基于URL模式的<code>CorsConfiguration</code>映射单独 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a>每个<code>HandlerMapping</code>。 在大多数情况下，应用程序使用MVC Java配置或XML命名空间来声明此类映射，这会导致将单个全局映射传递给所有<code>HandlerMappping</code> 实例。</p><p>您可以将<code>HandlerMapping</code>级别的全局CORS配置与更细粒度的处理程序级CORS配置相结合。 例如，带注解的控制器可以使用类或方法级别的<code>@CrossOrigin</code>注解（其他处理程序可以实现<code>CorsConfigurationSource</code>）。</p><p>组合全局和本地配置的规则通常是附加的 - 例如，所有全局和所有本地源。 对于只能接受单个值的属性（例如 <code>allowCredentials</code> 和 <code>maxAge</code>）， 本地会覆盖全局值。 有关详细信息，请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>。</p><p>要从source中了解更多信息或进行高级自定义，请查看后面的代码:</p><ul><li><code>CorsConfiguration</code></li><li><code>CorsProcessor</code>, <code>DefaultCorsProcessor</code></li><li><code>AbstractHandlerMapping</code></li></ul><h4 id="1-6-3-CrossOrigin"><a href="#1-6-3-CrossOrigin" class="headerlink" title="1.6.3. @CrossOrigin"></a>1.6.3. <code>@CrossOrigin</code></h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-controller">Same as in Spring WebFlux</a></p><p>在带注解的控制器方法上使用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注解启用跨源请求，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/account&quot;</span>)public class AccountController &#123;<br>    <span class="hljs-variable">@CrossOrigin</span>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public Account <span class="hljs-built_in">retrieve</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>    <span class="hljs-variable">@DeleteMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public void <span class="hljs-built_in">remove</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>默认情况下，<code>@CrossOrigin</code>允许：</p><ul><li>All origins.</li><li>All headers.</li><li>All HTTP methods（可以映射到控制器的方法）</li></ul><p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p><p><code>maxAge</code> 设置为30 分钟.</p><p><code>@CrossOrigin</code>在类级别也受支持，并且由所有方法继承，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@CrossOrigin</span>(origins = <span class="hljs-string">&quot;http://domain2.com&quot;</span>, maxAge = <span class="hljs-number">3600</span>)<span class="hljs-variable">@RestController</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/account&quot;</span>)public class AccountController &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public Account <span class="hljs-built_in">retrieve</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>    <span class="hljs-variable">@DeleteMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public void <span class="hljs-built_in">remove</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>您可以在类级别和方法级别使用<code>@CrossOrigin</code> ，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@CrossOrigin</span>(maxAge = <span class="hljs-number">3600</span>)<span class="hljs-variable">@RestController</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/account&quot;</span>)public class AccountController &#123;<br>    <span class="hljs-variable">@CrossOrigin</span>(<span class="hljs-string">&quot;http://domain2.com&quot;</span>)    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public Account <span class="hljs-built_in">retrieve</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>    <span class="hljs-variable">@DeleteMapping</span>(<span class="hljs-string">&quot;/&#123;id&#125;&quot;</span>)    public void <span class="hljs-built_in">remove</span>(<span class="hljs-variable">@PathVariable</span> Long id) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-4-全局配置"><a href="#1-6-4-全局配置" class="headerlink" title="1.6.4. 全局配置"></a>1.6.4. 全局配置</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-global">Same as in Spring WebFlux</a></p><p>除了细粒度，基于注解的配置以外，您可能还希望定义一些全局CORS配置。您可以在任何<code>HandlerMapping</code>上单独设置基于URL的 <code>CorsConfiguration</code>映射。 但是，大多数应用程序使用MVC Java配置或MVC XNM命名空间来执行此操作。</p><p>默认情况下，全局配置启用以下内容：</p><ul><li>All origins.</li><li>All headers.</li><li><code>GET</code>, <code>HEAD</code>, and <code>POST</code> methods.</li></ul><p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个信任级别，该信任级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且只应在适当的地方使用。</p><p><code>maxAge</code> 设置为30分钟.</p><h5 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-global">Same as in Spring WebFlux</a></p><p>要在MVC Java配置中启用CORS，可以使用<code>CorsRegistry</code>回调，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addCorsMappings</span>(CorsRegistry registry) &#123;<br>        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addMapping</span>(<span class="hljs-string">&quot;/api/**&quot;</span>)            <span class="hljs-selector-class">.allowedOrigins</span>(<span class="hljs-string">&quot;http://domain2.com&quot;</span>)            <span class="hljs-selector-class">.allowedMethods</span>(<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>)            <span class="hljs-selector-class">.allowedHeaders</span>(<span class="hljs-string">&quot;header1&quot;</span>, <span class="hljs-string">&quot;header2&quot;</span>, <span class="hljs-string">&quot;header3&quot;</span>)            <span class="hljs-selector-class">.exposedHeaders</span>(<span class="hljs-string">&quot;header1&quot;</span>, <span class="hljs-string">&quot;header2&quot;</span>)            <span class="hljs-selector-class">.allowCredentials</span>(true)<span class="hljs-selector-class">.maxAge</span>(<span class="hljs-number">3600</span>);<br>        <span class="hljs-comment">// Add more mappings...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="XML-配置"><a href="#XML-配置" class="headerlink" title="XML 配置"></a>XML 配置</h5><p>要在XML命名空间中启用CORS，可以使用<code>&lt;mvc:cors&gt;</code>元素，如以下示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:cors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/api/**&quot;</span>        <span class="hljs-attr">allowed-origins</span>=<span class="hljs-string">&quot;http://domain1.com, http://domain2.com&quot;</span>        <span class="hljs-attr">allowed-methods</span>=<span class="hljs-string">&quot;GET, PUT&quot;</span>        <span class="hljs-attr">allowed-headers</span>=<span class="hljs-string">&quot;header1, header2, header3&quot;</span>        <span class="hljs-attr">exposed-headers</span>=<span class="hljs-string">&quot;header1, header2&quot;</span> <span class="hljs-attr">allow-credentials</span>=<span class="hljs-string">&quot;true&quot;</span>        <span class="hljs-attr">max-age</span>=<span class="hljs-string">&quot;123&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/resources/**&quot;</span>        <span class="hljs-attr">allowed-origins</span>=<span class="hljs-string">&quot;http://domain1.com&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:cors</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-5-CORS-过滤器"><a href="#1-6-5-CORS-过滤器" class="headerlink" title="1.6.5. CORS 过滤器"></a>1.6.5. CORS 过滤器</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-cors-webfilter">Same as in Spring WebFlux</a></p><p>您可以通过内置的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/filter/CorsFilter.html"><code>CorsFilter</code></a>应用CORS支持。</p><p>如果您尝试将<code>CorsFilter</code> 与Spring Security一起使用，请记住Spring Security<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">内置了对CORS的支持</a>。</p><p>要配置过滤器，请将<code>CorsConfigurationSource</code>传递给其构造函数，如以下示例所示:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">CorsConfiguration config = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CorsConfiguration</span>();<br><span class="hljs-comment">// Possibly...// config.applyPermitDefaultValues()</span><br>config.<span class="hljs-built_in">setAllowCredentials</span>(<span class="hljs-literal">true</span>);config.<span class="hljs-built_in">addAllowedOrigin</span>(<span class="hljs-string">&quot;http://domain1.com&quot;</span>);config.<span class="hljs-built_in">addAllowedHeader</span>(<span class="hljs-string">&quot;*&quot;</span>);config.<span class="hljs-built_in">addAllowedMethod</span>(<span class="hljs-string">&quot;*&quot;</span>);<br>UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UrlBasedCorsConfigurationSource</span>();source.<span class="hljs-built_in">registerCorsConfiguration</span>(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>CorsFilter filter = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CorsFilter</span>(source);<br></code></pre></td></tr></table></figure><h3 id="1-7-Web-安全"><a href="#1-7-Web-安全" class="headerlink" title="1.7. Web 安全"></a>1.7. Web 安全</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-web-security">Same as in Spring WebFlux</a></p><p>Spring Security项目为保护Web应用程序免受恶意攻击提供支持。 请参阅<a href="https://projects.spring.io/spring-security/">Spring Security</a>参考文档，包括：</p><ul><li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC Security</a></li><li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC Test Support</a></li><li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF protection</a></li><li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">Security Response Headers</a></li></ul><p><a href="http://hdiv.org/">HDIV</a> 是另一个与Spring MVC集成的Web安全框架。</p><h3 id="1-8-HTTP-缓存"><a href="#1-8-HTTP-缓存" class="headerlink" title="1.8. HTTP 缓存"></a>1.8. HTTP 缓存</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-caching">Same as in Spring WebFlux</a></p><p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕 <code>Cache-Control</code> 响应头，随后是条件请求头（例如<code>Last-Modified</code>和<code>ETag</code>）。 HTTP的响应头<code>Cache-Control</code>主要帮助私有缓存（比如浏览器端缓存）和公共缓存（比如代理端缓存）了解它们应该如果缓存HTTP响应。如果内容未更改，则<code>ETag</code>头用于生成条件请求， 该条件请求可能导致304（NOT_MODIFIED）没有正文。可以认为它是<code>Last-Modified</code>头的一个更精细的后续版本。</p><p>本节介绍Spring Web MVC中可用的与HTTP缓存相关的选项。</p><h4 id="1-8-1-CacheControl"><a href="#1-8-1-CacheControl" class="headerlink" title="1.8.1. CacheControl"></a>1.8.1. <code>CacheControl</code></h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-caching-cachecontrol">Same as in Spring WebFlux</a></p><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>支持配置与<code>Cache-Control</code>标头相关的设置，并在许多地方被接受为参数：</p><ul><li><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/WebContentInterceptor.html"><code>WebContentInterceptor</code></a></li><li><a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/support/WebContentGenerator.html"><code>WebContentGenerator</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching-etag-lastmodified">Controllers</a></li><li><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching-static-resources">Static Resources</a></li></ul><p>虽然<a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用面向用例的方法，该方法侧重于常见场景：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> Cache for an hour - <span class="hljs-string">&quot;Cache-Control: max-age=3600&quot;</span>CacheControl ccCacheOneHour = CacheControl.maxAge<span class="hljs-params">(1, TimeUnit.HOURS)</span>;<br><span class="hljs-string">//</span> Prevent caching - <span class="hljs-string">&quot;Cache-Control: no-store&quot;</span>CacheControl ccNoStore = CacheControl.noStore<span class="hljs-params">()</span>;<br><span class="hljs-string">//</span> Cache for ten days in public and private caches,<span class="hljs-string">//</span> public caches should not transform the response// <span class="hljs-string">&quot;Cache-Control: max-age=864000, public, no-transform&quot;</span>CacheControl ccCustom = CacheControl.maxAge<span class="hljs-params">(10, TimeUnit.DAYS)</span><span class="hljs-string">.noTransform</span><span class="hljs-params">()</span><span class="hljs-string">.cachePublic</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><code>WebContentGenerator</code>还接受一个更简单的<code>cachePeriod</code>属性（以秒为单位定义），其工作方式如下：</p><ul><li>A <code>-1</code> 值不会生成<code>Cache-Control</code> 的响应头。</li><li>A <code>0</code>值将防止缓存使用<code>&#39;Cache-Control: no-store&#39;</code> 指令.</li><li>An <code>n &gt; 0</code> 一个大于0的值将缓存给定的响应在<code>n</code>秒使用<code>&#39;Cache-Control: max-age=n&#39;</code></li></ul><h4 id="1-8-2-Controllers"><a href="#1-8-2-Controllers" class="headerlink" title="1.8.2. Controllers"></a>1.8.2. Controllers</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-caching-etag-lastmodified">Same as in Spring WebFlux</a></p><p>控制器可以添加对HTTP缓存的显式支持。 我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>值需要先计算才能与条件请求头进行比较。 控制器可以向<code>ResponseEntity</code>添加<code>ETag</code>头和<code>Cache-Control</code>设置，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/book/&#123;id&#125;&quot;)</span><span class="hljs-keyword">public</span> ResponseEntity&lt;Book&gt; <span class="hljs-title function_">showBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> findBook(id);    <span class="hljs-type">String</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> book.getVersion();<br>    <span class="hljs-keyword">return</span> ResponseEntity            .ok()            .cacheControl(CacheControl.maxAge(<span class="hljs-number">30</span>, TimeUnit.DAYS))            .eTag(version) <span class="hljs-comment">// lastModified is also available            .body(book);&#125;</span><br></code></pre></td></tr></table></figure><p>如果与条件请求头的比较表明内容未更改，则前面的示例发送带有空响应体的304（NOT_MODIFIED）响应。 否则，<code>ETag</code> 和<code>Cache-Control</code>标头将添加到响应中。</p><p>您还可以对控制器中的条件请求头进行检查，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMappingpublic</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">myHandleMethod</span>(<span class="hljs-params">WebRequest webRequest, Model model</span>) &#123;<br>    long eTag = ... (<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> (request.<span class="hljs-title function_">checkNotModified</span>(eTag)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; (<span class="hljs-number">2</span>)    &#125;<br>    model.<span class="hljs-title function_">addAttribute</span>(...); (<span class="hljs-number">3</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;myViewName&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、特定于应用的计算。</p><p><strong>2</strong>、响应已设置为304（NOT_MODIFIED） - 无需进一步处理。</p><p><strong>3</strong>、继续请求处理。</p><p>有三种变体可用于检查针对<code>eTag</code>值，<code>lastModified</code>值或两者的条件请求。 对于条件<code>GET</code>和<code>HEAD</code>请求， 您可以将响应设置为304（NOT_MODIFIED）。对于<code>POST</code>, <code>PUT</code>, and <code>DELETE</code>，您可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p><h4 id="1-8-3-静态资源"><a href="#1-8-3-静态资源" class="headerlink" title="1.8.3. 静态资源"></a>1.8.3. 静态资源</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-caching-static-resources">Same as in Spring WebFlux</a></p><p>您应该使用<code>Cache-Control</code> 和条件响应头来提供静态资源，以获得最佳性能。 请参阅有关配置<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-static-resources">静态资源</a>的部分。</p><h4 id="1-8-4-ETag-过滤器"><a href="#1-8-4-ETag-过滤器" class="headerlink" title="1.8.4. ETag 过滤器"></a>1.8.4. <code>ETag</code> 过滤器</h4><p>您可以使用<code>ShallowEtagHeaderFilter</code>添加从响应内容计算的“shallow” eTag值，从而节省带宽但不节省CPU时间。 见 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#filters-shallow-etag">Shallow ETag</a>。</p><h3 id="1-9-视图技术"><a href="#1-9-视图技术" class="headerlink" title="1.9. 视图技术"></a>1.9. 视图技术</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view">Same as in Spring WebFlux</a></p><p>无论您决定使用Thymeleaf，Groovy标记模板，JSP还是其他技术，Spring MVC中视图技术的使用都是可插拔的， 主要是配置更改的问题。 本章介绍了与Spring MVC集成的视图技术。 我们假设您已经熟悉<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-viewresolver">解析视图</a>。</p><h4 id="1-9-1-Thymeleaf"><a href="#1-9-1-Thymeleaf" class="headerlink" title="1.9.1. Thymeleaf"></a>1.9.1. Thymeleaf</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-thymeleaf">Same as in Spring WebFlux</a></p><p>Thymeleaf是一个现代服务器端Java模板引擎，它强调可以通过双击在浏览器中预览的自然HTML模板，这对于UI模板的独立工作（例如，由设计人员）非常有用，而无需运行服务器。 如果您想要替换JSP，Thymeleaf提供了一组最广泛的功能，使这种转换更容易。 Thymeleaf积极开发和维护。 有关更完整的介绍，请参阅<a href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p><p>Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。 配置涉及一些bean声明， 例如<code>ServletContextTemplateResolver</code>, <code>SpringTemplateEngine</code>, 和 <code>ThymeleafViewResolver</code>.。 有关详细信息，请参阅<a href="http://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a>。</p><h4 id="1-9-2-FreeMarker"><a href="#1-9-2-FreeMarker" class="headerlink" title="1.9.2. FreeMarker"></a>1.9.2. FreeMarker</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-freemarker">Same as in Spring WebFlux</a></p><p><a href="http://www.freemarker.org/">Apache FreeMarker</a> 是一个模板引擎，用于生成从HTML到电子邮件和其他的任何类型的文本输出。 Spring Framework有一个内置的集成，可以将Spring MVC与FreeMarker模板结合使用。</p><h5 id="视图配置"><a href="#视图配置" class="headerlink" title="视图配置"></a>视图配置</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-freemarker-contextconfig">Same as in Spring WebFlux</a></p><p>以下示例显示如何将FreeMarker配置为视图技术：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configureViewResolvers</span>(<span class="hljs-params">ViewResolverRegistry registry</span>) &#123;        registry.<span class="hljs-title function_">freemarker</span>();    &#125;<br>    <span class="hljs-comment">// Configure FreeMarker...</span><br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">FreeMarkerConfigurer</span> <span class="hljs-title function_">freeMarkerConfigurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">FreeMarkerConfigurer</span> configurer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FreeMarkerConfigurer</span>();        configurer.<span class="hljs-title function_">setTemplateLoaderPath</span>(<span class="hljs-string">&quot;/WEB-INF/freemarker&quot;</span>);        <span class="hljs-keyword">return</span> configurer;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中配置相同的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Configure FreeMarker... --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:template-loader-path</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/WEB-INF/freemarker&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者，您也可以声明<code>FreeMarkerConfigurer</code> bean以完全控制所有属性，如以下示例所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;freemarkerConfig&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;templateLoaderPath&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;/WEB-INF/freemarker/&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>模板需要存储在上面所示的FreeMarkerConfigurer指定的目录中，根据前面的配置，如果您的控制器返回<code>welcome</code>视图名称，解析器将查找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。</p><h5 id="FreeMarker-配置"><a href="#FreeMarker-配置" class="headerlink" title="FreeMarker 配置"></a>FreeMarker 配置</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-views-freemarker">Same as in Spring WebFlux</a></p><p>通过设置<code>FreeMarkerConfigurer</code> bean可以将FreeMarker的’Settings’ 和 ‘SharedVariables’ 值直接传递Spring管理的FreeMarker对象。 <code>freemarkerSettings</code>属性需要<code>java.util.Properties</code>对象。 而<code>freemarkerVariables</code>属性需要<code>java.util.Map</code>。以下示例显示了如何执行此操作：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;freemarkerConfig&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;templateLoaderPath&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;/WEB-INF/freemarker/&quot;</span>/&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;freemarkerVariables&quot;</span>&gt;        &lt;map&gt;            &lt;entry key<span class="hljs-operator">=</span><span class="hljs-string">&quot;xml_escape&quot;</span> value-ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;fmXmlEscape&quot;</span>/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;<br>&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;fmXmlEscape&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;freemarker.template.utility.XmlEscape&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>有关更多的Configuration内容的<code>设置</code>和变量可以查看FreeMarker文档</p><h5 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h5><p>Spring本身提供了用于JSP的标签库，其中包含（当然还有很多）<code>&lt;spring:bind/&gt;</code>标签，这个标签用来展示从Web上的<code>验证器</code>或业务层抛出的失败验证表单。 Spring还支持FreeMarker中的相同功能，并提供了方便的宏来生成表单输入元素。</p><h6 id="绑定宏命令"><a href="#绑定宏命令" class="headerlink" title="绑定宏命令"></a>绑定宏命令</h6><p><code>spring-webmvc.jar</code> 包文件包含Velocity和FreeMarker的一组标准宏，因此两者都适用。</p><p>Spring库中定义的某些宏被认为是内部的(私有的），但在宏定义中不存在这样的范围，其实所有宏都可以在调用代码和用户模板时看到。以下各节仅集中于需要从模板中直接调用的宏， 如果希望直接查看宏代码， 那么可以看文件<code>spring.ftl</code>，定义在<code>org.springframework.web.servlet.view.freemarker</code>包中。</p><h6 id="简单的绑定"><a href="#简单的绑定" class="headerlink" title="简单的绑定"></a>简单的绑定</h6><p>HTML表单(vm或ftl模板),充当了Spring MVC控制器的表单视图,可以使用类似下面的代码绑定字段值,也可以类似JSP那样在每个输入字段后面添加错误信息. 以下示例显示了之前配置的personForm视图：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- freemarker macros have to be imported into a namespace. We strongly</span></span><br><span class="hljs-comment"><span class="language-xml"></span></span><br><span class="hljs-comment"><span class="language-xml">recommend sticking to &#x27;spring&#x27; --&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">&lt;#import &quot;/spring.ftl&quot; as spring/&gt;</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    ...</span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        Name:</span><br><span class="language-xml"></span><br><span class="language-xml">        &lt;@spring.bind &quot;myModelObject.name&quot;/&gt;</span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml"></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;spring.status.expression&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml"></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;spring.status.value?html&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        &lt;#list spring.status.errorMessages as error&gt; <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;error&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> &lt;/#list&gt;</span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        ...</span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    ...</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>&lt;@spring.bind&gt;</code>需要一个包含命令对象的 ‘path’ 参数（默认是’command’,除非在<code>FormController</code>属性中被改变了），后面跟着写需要绑定到命令对象上的字段名. 可以使用嵌套字段,例如 <code>command.address.street</code>,绑定宏可以在<code>web.xml</code>中设置ServletContext的参数<code>defaultHtmlEscape</code>，用于定义HTML的转义行为。</p><p><code>&lt;@spring.bindEscaped&gt;</code> 宏命令是可选的，它接收第二个参数并显式地指定是否应在状态错误消息或值中使用HTML转义。按需设置为<code>true</code>或<code>false</code>，还有很多其它的宏，它们将在下一节中介绍。</p><h6 id="输入宏命令"><a href="#输入宏命令" class="headerlink" title="输入宏命令"></a>输入宏命令</h6><p>Velocity和FreeMarker都使用宏简化了绑定和表单的生成（包括验证错误的显示），没有必要使用这些宏来生成表单输入字段，实际上他们都可以直接绑定在简单的HTML中，并且可混合使用。</p><p>下表中的可用宏显示了FTL定义和每个参数列表：</p><p>Table 6. 宏命令定义表</p><table><thead><tr><th>宏命令</th><th>FTL 定义表</th></tr></thead><tbody><tr><td><code>message</code>（根据代码参数从资源包中输出字符串）</td><td>&lt;@spring.message code&#x2F;&gt;</td></tr><tr><td><code>messageText</code> （根据代码参数从资源包中输出一个字符串，失败则使用默认参数的值）</td><td>&lt;@spring.messageText code, text&#x2F;&gt;</td></tr><tr><td><code>url</code>（使用应用程序的上下文根作为相对URL的前缀）</td><td>&lt;@spring.url relativeUrl&#x2F;&gt;</td></tr><tr><td><code>formInput</code> (标准输入域用户收集用户信息)</td><td>&lt;@spring.formInput path, attributes, fieldType&#x2F;&gt;</td></tr><tr><td><code>formHiddenInput</code> (用于提交肥输入域的隐藏字段)</td><td>&lt;@spring.formHiddenInput path, attributes&#x2F;&gt;</td></tr><tr><td><code>formPasswordInput</code> (用户收集密码的标准输入字段，请注意，此类型的字段中不会填充任何值)</td><td>&lt;@spring.formPasswordInput path, attributes&#x2F;&gt;</td></tr><tr><td><code>formTextarea</code> (大文本域，用于收集大而自由的文本输入)</td><td>&lt;@spring.formTextarea path, attributes&#x2F;&gt;</td></tr><tr><td><code>formSingleSelect</code> (下拉选项框，可以选择一个必需的值)</td><td>&lt;@spring.formSingleSelect path, options, attributes&#x2F;&gt;</td></tr><tr><td><code>formMultiSelect</code> (一个选项列表框，允许用户选择0或更多值)</td><td>&lt;@spring.formMultiSelect path, options, attributes&#x2F;&gt;</td></tr><tr><td><code>formRadioButtons</code> (单选按钮，可以从可用选项中进行单个选择)</td><td>&lt;@spring.formRadioButtons path, options separator, attributes&#x2F;&gt;</td></tr><tr><td><code>formCheckboxes</code> (一组允许选择0或更多值的复选框)</td><td>&lt;@spring.formCheckboxes path, options, separator, attributes&#x2F;&gt;</td></tr><tr><td><code>formCheckbox</code> (单个复选框)</td><td>&lt;@spring.formCheckbox path, attributes&#x2F;&gt;</td></tr><tr><td><code>showErrors</code> (简化绑定字段的验证错误显示)</td><td>&lt;@spring.showErrors separator, classOrStyle&#x2F;&gt;</td></tr></tbody></table><ul><li>在FTL（FreeMarker）中, <code>formHiddenInput</code> 和 <code>formPasswordInput</code> 这两个宏实际上并不需要，因为可以使用普通的 <code>formInput</code>宏。将<code>hidden</code> 或 <code>password</code>指定为<code>fieldType</code> 参数的值</li></ul><p>上述任何宏的参数都具有一致的含义</p><ul><li><code>路径</code>: 要绑定到的字段的名称（例如 “command.name”）</li><li><code>选项</code>: 可从输入字段中选择的所有可用值的映射，map的键表示从表单POST后得到的对象的值（已绑定的），Map对象保存这些键用于返回值后能在表单上显示出来。 通常这样map由控制器提供数据，任何map都可以实现按需使用，可以使用<code>SortedMap</code>，例如 <code>TreeMap</code>和适当的<code>Comparator</code>为所有的值排序，使用来自<code>commons-collections</code>包中的 <code>LinkedHashMap</code> 或 <code>LinkedMap</code>也是相同的原理。</li><li><code>分隔符</code>:多个选项可以作为元素（单选按钮或复选框）可以使用标签对字符序列进行分隔（例如<code>&lt;br&gt;</code>）。</li><li><code>属性</code>: HTML标签本身中可以包含任意标签或文本的附加字符串。字符串与上面的宏分别对应，例如，在一个文本字段提供属性’rows&#x3D;“5” cols&#x3D;“60“‘字段， 也可以添加css，例如’style&#x3D;“border:1px solid silver”‘。</li><li><code>classOrStyle</code>: 对于<code>showErrors</code> 宏, 可以使用<code>span</code>标签包装每个错误的CSS类的名称。如果未提供任何信息 (或该值为空），则错误将包含在<code>&lt;b&gt;&lt;/b&gt;</code> 标签中</li></ul><p>以下部分概述了宏的示例（一些在FTL中，一些在VTL中）。 如果两种语言之间存在使用差异，则会在说明中对其进行说明。</p><p>输入域</p><p><code>formInput</code>宏采用 <code>path</code> 参数（<code>command.name</code>）和附加属性参数（在下一个示例中为空）。宏与所有其他表单生成宏一起在path参数上执行隐式Spring绑定。在出现新绑定之前， 前一个绑定仍然有效，因此<code>showErrors</code> 宏不需要再次传递path参数，它只对上次为其创建绑定的任何字段进行操作。</p><p><code>showErrors</code>宏采用分隔符参数(将用于分隔给定字段上的多个错误的字符，同时还接受第二个参数：类名或样式属性。请注意，FreeMarker能够为属性参数指定默认值，这与Velocity不同， 以下示例显示如何使用 <code>formInput</code>和 <code>showWErrors</code>宏：：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">&lt;<span class="hljs-meta">@spring</span>.formInput <span class="hljs-string">&quot;command.name&quot;</span>/&gt;<br><br>&lt;<span class="hljs-meta">@spring</span>.showErrors <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>下一个示例显示表单片段的输出，生成名称字段并在提交表单后在字段中没有值时显示验证错误。 验证通过Spring的验证框架进行。</p><p>生成的HTML类似于以下示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">Name:<br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>required<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>formTextarea</code> 宏类似于<code>formInput</code>宏，连接收的参数都是相同的。通常，第二个参数（属性）将被使用用于传递格式信息或<code>rows</code>和<code>cols</code> 的属性。</p><p>选择字段</p><p>有四个字段宏可以用于生产HTML表单中的公共UI值作为选择的输入：</p><ul><li><code>formSingleSelect</code></li><li><code>formMultiSelect</code></li><li><code>formRadioButtons</code></li><li><code>formCheckboxes</code></li></ul><p>这四个宏都可以从表单字段中接收<code>Map</code>，其实需要的就是标签的值。当然值和标签是可以取相同的名。</p><p>下一个例子是FTL中的单选按钮。表单使用’London’作为这个字段的默认值，因此不需用进行验证。当渲染表单时，要选择的整个城市列表都在’cityMap’中，cityMap是数据模型。以下清单显示了该示例：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">...<br><br>Town:<br><br>&lt;<span class="hljs-title">@spring.formRadioButtons</span> <span class="hljs-string">&quot;command.address.town&quot;</span><span class="hljs-punctuation">,</span> cityMap<span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;&quot;</span>/&gt;&lt;<span class="hljs-keyword">br</span>&gt;&lt;<span class="hljs-keyword">br</span>&gt;<br></code></pre></td></tr></table></figure><p>前面的列表呈现一行单选按钮，一个用于<code>cityMap</code>中的每个值，并使用分隔符<code>&quot;&quot;</code>。没有提供其他属性（缺少宏的最后一个参数）。cityMap对Map中的每个键值对使用相同的<code>String</code>。 映射的键是表单实际提交为POSTed请求参数的键。 map值是用户看到的标签。 在前面的示例中，给定一个包含三个众所周知的城市的列表以及表单支持对象中的默认值，HTML类似于以下内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">Town:<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;London&quot;</span>&gt;London&lt;/<span class="hljs-built_in">input</span>&gt;<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;Paris&quot;</span> checked=<span class="hljs-string">&quot;checked&quot;</span>&gt;Paris&lt;/<span class="hljs-built_in">input</span>&gt;<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;New York&quot;</span>&gt;New York&lt;/<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>如果您的应用程序希望通过内部代码来处理城市，可以写一个name为cityMap的Map传递给模板，如下面的例子：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; referenceData(HttpServletRequest request) throws Exception &#123;    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; cityMap = <span class="hljs-literal">new</span> LinkedHashMap&lt;&gt;();    cityMap.put(<span class="hljs-string">&quot;LDN&quot;</span>, <span class="hljs-string">&quot;London&quot;</span>);    cityMap.put(<span class="hljs-string">&quot;PRS&quot;</span>, <span class="hljs-string">&quot;Paris&quot;</span>);    cityMap.put(<span class="hljs-string">&quot;NYC&quot;</span>, <span class="hljs-string">&quot;New York&quot;</span>);<br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; model = <span class="hljs-literal">new</span> HashMap&lt;&gt;();    model.put(<span class="hljs-string">&quot;cityMap&quot;</span>, cityMap);    <span class="hljs-keyword">return</span> model;&#125;<br></code></pre></td></tr></table></figure><p>代码将按你的设置输出，可以看到更多的城市名字。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">Town:<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;LDN&quot;</span>&gt;London&lt;/<span class="hljs-built_in">input</span>&gt;<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;PRS&quot;</span> checked=<span class="hljs-string">&quot;checked&quot;</span>&gt;Paris&lt;/<span class="hljs-built_in">input</span>&gt;<br><br>&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;address.town&quot;</span> value=<span class="hljs-string">&quot;NYC&quot;</span>&gt;New York&lt;/<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><h6 id="HTML-转义"><a href="#HTML-转义" class="headerlink" title="HTML 转义"></a>HTML 转义</h6><p>由于HTML的版本问题，上面的表单宏在HTML的4.01版本中需要使用到转义，转义可以在<code>web.xml</code>中通过Spring的绑定来定义。为了使标签遵守XHTML的规定以及覆盖默认的HTML转义值， 可以在模板中定义两个变量（或者使你的模型设置为模板可见形式）。在模板中指定的优点是：它们可以在模板处理后更改为不同的值，以便为表单中的不同字段提供不同的行为。</p><p>要切换为标记的XHTML合规性，请为名为<code>xhtmlCompliant</code>的模型或上下文变量指定值<code>true</code> ，如以下示例所示：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">&lt;#-- for FreeMarker --&gt;<br><br>&lt;#assign xhtmlCompliant = true&gt;<br></code></pre></td></tr></table></figure><p>处理完该指令后，Spring宏生成的任何元素现在都符合XHTML标准。</p><p>以类似的方式，您可以指定每个字段的HTML转义，如以下示例所示：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">&lt;#-- <span class="hljs-function"><span class="hljs-title">until</span> this point, default HTML escaping <span class="hljs-keyword">is</span> used --&gt;</span><br>&lt;#<span class="hljs-function"><span class="hljs-title">assign</span> htmlEscape = <span class="hljs-literal">true</span>&gt;&lt;#-- next field will use HTML escaping --&gt;</span>&lt;@spring.formInput <span class="hljs-string">&quot;command.name&quot;</span>/&gt;<br>&lt;#<span class="hljs-function"><span class="hljs-title">assign</span> htmlEscape = <span class="hljs-literal">false</span> <span class="hljs-built_in">in</span> spring&gt;&lt;#-- all future fields will be bound <span class="hljs-keyword">with</span> HTML escaping off --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-9-3-Groovy-Markup"><a href="#1-9-3-Groovy-Markup" class="headerlink" title="1.9.3. Groovy Markup"></a>1.9.3. Groovy Markup</h4><p><a href="http://groovy-lang.org/templating.html#_the_markuptemplateengine">Groovy标记模板引擎</a>主要用于生成类似XML的标记（XML，XHTML，HTML5等），但您可以使用它来生成任何基于文本的内容。 Spring Framework有一个内置的集成，可以将Spring MVC与Groovy Markup结合使用。</p><p>目前要求使用Groovy 2.3.1+的版本.</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>以下示例显示如何配置Groovy标记模板引擎：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configureViewResolvers</span>(<span class="hljs-params">ViewResolverRegistry registry</span>) &#123;        registry.<span class="hljs-title function_">groovy</span>();    &#125;<br>    <span class="hljs-comment">// Configure the Groovy Markup Template Engine...</span><br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">GroovyMarkupConfigurer</span> <span class="hljs-title function_">groovyMarkupConfigurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">GroovyMarkupConfigurer</span> configurer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroovyMarkupConfigurer</span>();        configurer.<span class="hljs-title function_">setResourceLoaderPath</span>(<span class="hljs-string">&quot;/WEB-INF/&quot;</span>);        <span class="hljs-keyword">return</span> configurer;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中配置相同的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:groovy</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Configure the Groovy Markup Template Engine... --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:groovy-configurer</span> <span class="hljs-attr">resource-loader-path</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>与传统的模板引擎不同，Groovy是依赖于使用生成器语法的DSL。 以下示例显示了HTML页面的示例模板：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">yieldUnescaped</span> <span class="hljs-string">&#x27;&lt;!DOCTYPE html&gt;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">html</span>(<span class="hljs-variable">lang</span>:<span class="hljs-string">&#x27;en&#x27;</span>) &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-variable">head</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">meta</span>(<span class="hljs-string">&#x27;http-equiv&#x27;</span>:<span class="hljs-string">&#x27;&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&#x27;</span>)</span><br><br>        <span class="hljs-function"><span class="hljs-title">title</span>(<span class="hljs-string">&#x27;My page&#x27;</span>)</span><br><br>    &#125;<br><br>    <span class="hljs-variable">body</span> &#123;<br><br>        <span class="hljs-function"><span class="hljs-title">p</span>(<span class="hljs-string">&#x27;This is an example of HTML contents&#x27;</span>)</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-9-4-脚本视图"><a href="#1-9-4-脚本视图" class="headerlink" title="1.9.4. 脚本视图"></a>1.9.4. 脚本视图</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-script">Same as in Spring WebFlux</a></p><p>Spring Framework有一个内置的集成，可以将Spring MVC与任何可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的模板库一起使用。 我们在不同的脚本引擎上测试了以下模板库：:</p><p>Scripting Library</p><p>Scripting Engine</p><p><a href="http://handlebarsjs.com/">Handlebars</a></p><p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p><p><a href="https://mustache.github.io/">Mustache</a></p><p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p><p><a href="https://facebook.github.io/react/">React</a></p><p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p><p><a href="http://www.embeddedjs.com/">EJS</a></p><p><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p><p><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p><p><a href="http://jruby.org/">JRuby</a></p><p><a href="https://docs.python.org/2/library/string.html#template-strings">String templates</a></p><p><a href="http://www.jython.org/">Jython</a></p><p><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></p><p><a href="https://kotlinlang.org/">Kotlin</a></p><p>集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code> 和<code>Invocable</code> 接口。</p><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-script-dependencies">Same as in Spring WebFlux</a></p><p>您需要在类路径上安装脚本引擎，其详细信息因脚本引擎而异:</p><ul><li>The <a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> Javascript引擎提供了内置的Java 8+。强烈建议使用最新的可用更新版本。</li><li>为了获得<a href="http://jruby.org/">JRuby</a> 支持，应添加JRuby依赖性</li><li>为了获得<a href="http://www.jython.org/">Jython</a>支持，应添加Jython依赖性。</li><li><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和包含在 <code>META-INF/services/javax.script.ScriptEngineFactory</code>文件里的<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>行应添加到Kotlin脚本支持中。 有关详细信息，请参阅<a href="https://github.com/sdeleuze/kotlin-script-templating">此示例</a>。</li></ul><p>还需要为基于脚本的模板引擎添加依赖项。例如，对于javascript，可以使用<a href="http://www.webjars.org/">WebJars</a>。</p><h5 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-script-integrate">Same as in Spring WebFlux</a></p><p>您可以声明<code>ScriptTemplateConfigurer</code>bean以指定要使用的脚本引擎，要加载的脚本文件，要调用以呈现模板的函数，等等。 以下示例使用Mustache模板和Nashorn JavaScript引擎：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configureViewResolvers</span>(<span class="hljs-params">ViewResolverRegistry registry</span>) &#123;        registry.<span class="hljs-title function_">scriptTemplate</span>();    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ScriptTemplateConfigurer</span> <span class="hljs-title function_">configurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">ScriptTemplateConfigurer</span> configurer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptTemplateConfigurer</span>();        configurer.<span class="hljs-title function_">setEngineName</span>(<span class="hljs-string">&quot;nashorn&quot;</span>);        configurer.<span class="hljs-title function_">setScripts</span>(<span class="hljs-string">&quot;mustache.js&quot;</span>);        configurer.<span class="hljs-title function_">setRenderObject</span>(<span class="hljs-string">&quot;Mustache&quot;</span>);        configurer.<span class="hljs-title function_">setRenderFunction</span>(<span class="hljs-string">&quot;render&quot;</span>);        <span class="hljs-keyword">return</span> configurer;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示了XML中的相同排列：:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;mvc:annotation-driven/&gt;<br>&lt;mvc:<span class="hljs-keyword">view</span>-resolvers&gt;    &lt;mvc:script-<span class="hljs-keyword">template</span>/&gt;&lt;/mvc:<span class="hljs-keyword">view</span>-resolvers&gt;<br>&lt;mvc:script-<span class="hljs-keyword">template</span>-configurer engine-<span class="hljs-type">name</span>=&quot;nashorn&quot; render-<span class="hljs-keyword">object</span>=&quot;Mustache&quot; render-<span class="hljs-keyword">function</span>=&quot;render&quot;&gt;    &lt;mvc:script <span class="hljs-keyword">location</span>=&quot;mustache.js&quot;/&gt;&lt;/mvc:script-<span class="hljs-keyword">template</span>-configurer&gt;<br></code></pre></td></tr></table></figure><p>对于Java和XML配置，控制器看起来没有什么不同，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/sample&quot;</span>)</span>    <span class="hljs-keyword">public</span> String test(Model model) &#123;        model.addObject(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Sample title&quot;</span>);        model.addObject(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">&quot;Sample body&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;template&quot;</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示了Mustache模板：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">body</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>使用以下参数调用render函数：</p><ul><li><code>String template</code>: 模板内容</li><li><code>Map model</code>: 视图模型</li><li><code>RenderingContext renderingContext</code>: <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>，提供对应用程序上下文，区域设置，模板加载器和URL的访问（自5.0起）。</li></ul><p><code>Mustache.render()</code> 方法会与本地兼容，因此可以直接调用。</p><p>如果模板化技术需要自定义，则可以提供实现自定义渲染函数的脚本。例如，<a href="http://handlebarsjs.com/">Handlerbars</a>需要在使用模板之前进行编译，并且需要使用 <a href="https://en.wikipedia.org/wiki/Polyfill">polyfill</a>以模拟服务器端脚本引擎中不可用的某些浏览器功能。</p><p>以下示例显示了如何执行此操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configureViewResolvers</span>(<span class="hljs-params">ViewResolverRegistry registry</span>) &#123;        registry.<span class="hljs-title function_">scriptTemplate</span>();    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ScriptTemplateConfigurer</span> <span class="hljs-title function_">configurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">ScriptTemplateConfigurer</span> configurer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptTemplateConfigurer</span>();        configurer.<span class="hljs-title function_">setEngineName</span>(<span class="hljs-string">&quot;nashorn&quot;</span>);        configurer.<span class="hljs-title function_">setScripts</span>(<span class="hljs-string">&quot;polyfill.js&quot;</span>, <span class="hljs-string">&quot;handlebars.js&quot;</span>, <span class="hljs-string">&quot;render.js&quot;</span>);        configurer.<span class="hljs-title function_">setRenderFunction</span>(<span class="hljs-string">&quot;render&quot;</span>);        configurer.<span class="hljs-title function_">setSharedEngine</span>(<span class="hljs-literal">false</span>);        <span class="hljs-keyword">return</span> configurer;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>当要求非线程安全地使用脚本引擎时，需要将<code>sharedEngine</code>的属性设置为 <code>false</code> ，因为模板库不是为了并发而设计的，具体可以看运行在Nashorn上的Handlerbars或react。据此，需要Java 8u60+的版本来修复这个 <a href="https://bugs.openjdk.java.net/browse/JDK-8076099">bug</a>。</p><p><code>polyfill.js</code> 只需定义一个window对象，就可以被Handlerbars运行，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var window <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>脚本<code>render.js</code>会在使用该模板之前被编译，一个好的产品应当保存和重用模板（使用缓存的方法），这样高效些。这可以在脚本中完成，并且可以自定义它(例如管理模板引擎配置。以下示例显示了如何执行此操作：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">template</span>, <span class="hljs-params">model</span>) &#123;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-variable">compiledTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Handlebars</span>.<span class="hljs-property">compile</span>(<span class="hljs-variable">template</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">compiledTemplate</span>(<span class="hljs-variable">model</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>有关更多配置示例，请查看Spring Framework单元测试，<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script">resources</a>。</p><h4 id="1-9-5-JSP-和-JSTL"><a href="#1-9-5-JSP-和-JSTL" class="headerlink" title="1.9.5. JSP 和 JSTL"></a>1.9.5. JSP 和 JSTL</h4><p>Spring为JSP和JSTL视图提供了一些现成的解决方案</p><h5 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h5><p>使用JSP进行开发时，可以声明<code>InternalResourceViewResolver</code>或<code>ResourceBundleViewResolver</code> bean。</p><p><code>ResourceBundleViewResolver</code>依赖于属性文件来定义映射到类和URL的视图名称。使用<code>ResourceBundleViewResolver</code>，您可以通过仅使用一个解析器来混合不同类型的视图，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- the ResourceBundleViewResolver --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;views&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br># And a sample properties file is uses (views.properties in WEB-INF/classes):welcome.(class)=org.springframework.web.servlet.view.JstlViewwelcome.url=/WEB-INF/jsp/welcome.jsp<br>productList.(class)=org.springframework.web.servlet.view.JstlViewproductList.url=/WEB-INF/jsp/productlist.jsp<br></code></pre></td></tr></table></figure><p><code>InternalResourceBundleViewResolver</code>也可用于JSP。 作为最佳实践，我们强烈建议将JSP文件放在<code>&#39;WEB-INF&#39;</code>目录下的目录中，以便客户端无法直接访问。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;viewResolver&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;viewClass&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;prefix&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;suffix&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;.jsp&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="JSPs-和-JSTL"><a href="#JSPs-和-JSTL" class="headerlink" title="JSPs 和 JSTL"></a>JSPs 和 JSTL</h5><p>当使用Java标准标记库时，必须使用特殊的视图类<code>JstlView</code>，因为JSTL需要一些准备工作，例如I18N功能。</p><h5 id="Spring的JSP标签库"><a href="#Spring的JSP标签库" class="headerlink" title="Spring的JSP标签库"></a>Spring的JSP标签库</h5><p>Spring提供了请求参数与命令对象的数据绑定，如前面章节所述。为了方便开发JSP页面，结合这些数据绑定功能，Spring提供了一些使事情变得更容易的标记。所有的Spring标记都haveHTML转义功能以启用或禁用字符转义。</p><p>标签库描述符(TLD) 在<code>spring-webmvc.jar</code>包中。更多的信息，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description">API参考</a>或查看标签库说明。</p><h5 id="Spring的表单标签库"><a href="#Spring的表单标签库" class="headerlink" title="Spring的表单标签库"></a>Spring的表单标签库</h5><p>从2.0版本开始, Spring在使用JSP和Spring Web MVC时为处理表单元素提供了一套完整的数据绑定识别标签。每个标签都支持其相应的HTML标签对应的属性集，使标签熟悉和直观地使用，标签生成的HTML 4.01&#x2F;XHTML 1.0兼容。</p><p>不同于其他的表单或输入标签库，Spring的表单标签库是集成在Spring Web MVC中，标签可以使用控制器处理的命令对象和引用数据。因此在下面的例子中将会看到，表单标签使得JSP更加方便开发、阅读和维护。</p><p>让我们浏览一下表单标签，看看如何使用每个标签的例子。其中已经包括了生成的HTML片段，而某些标签需要进一步的讨论。</p><h6 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h6><p>表单标签库捆绑在<code>spring-webmvc.jar</code>中. 库描述符名字为<code>spring-form.tld</code>.</p><p>如果需要使用到这些标签，在JSP页面的头部必须添加对应的标签库</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span>@ taglib prefix=<span class="hljs-string">&quot;form&quot;</span> uri=<span class="hljs-string">&quot;http://www.springframework.org/tags/form&quot;</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure><p>其中 <code>form</code>是后面引用标签的前缀。</p><h6 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h6><p>标签’form’绑定了引用库的内部标签，可以被HTML解析。它将命令对象放在<code>PageContext</code>中，以便可以通过内部标记访问命令对象。此库中的所有其他标记都是<code>form</code>标记的嵌套标记。</p><p>假设我们有一个名为 <code>User</code>的域对象。 它是一个JavaBean，具有<code>firstName</code>和<code>lastName</code>等属性。我们将使用它作为表单控制器的形式支持对象，输出给 <code>form.jsp</code>。以下示例显示了form.jsp的显示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>firstName</code>和<code>lastName</code> 值会从页面控制器放置在<code>PageContext</code>的命令对象中查找。更多复杂的例子都是这样延伸的，重点就是内部标签是如何与表单标签一起使用的。</p><p>以下清单显示了生成的HTML，它看起来像标准格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Harry&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Potter&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之前的JSP假设表单的变量名是<code>command</code>。如果对象已经封装到另一个名称中了，表单也支持从自定义名称中绑定变量（这是最佳实践）。如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span> <span class="hljs-attr">modelAttribute</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="输入标签"><a href="#输入标签" class="headerlink" title="输入标签"></a>输入标签</h6><p>这个标签其实就是HTML的<code>input</code>标签（当然是解析后的），此标签或默认绑定值和 <code>type=&#39;text&#39;</code>属性。有关此的示例，请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-view-jsp-formtaglib-formtag">表单标签</a>。 您还可以使用特定于HTML5的类型，例如<code>email</code>, <code>tel</code>, <code>date</code>等。</p><h6 id="复选框标签"><a href="#复选框标签" class="headerlink" title="复选框标签"></a>复选框标签</h6><p>复选框也会解析成HTML的输入标签。</p><p>假设<code>User</code>对象拥有新闻订阅和爱好列表属性，显示了<code>Preferences</code>类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Preferences</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> receiveNewsletter;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span>[] interests;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> favouriteWord;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isReceiveNewsletter</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> receiveNewsletter;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setReceiveNewsletter</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> receiveNewsletter</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">receiveNewsletter</span> = receiveNewsletter;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span>[] <span class="hljs-title function_">getInterests</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> interests;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setInterests</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] interests</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">interests</span> = interests;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getFavouriteWord</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> favouriteWord;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setFavouriteWord</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> favouriteWord</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">favouriteWord</span> = favouriteWord;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>相应的<code>form.jsp</code> 可能类似于以下内容：</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Subscribe to newsletter?:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            </span><span class="language-vbscript">&lt;%-- Approach <span class="hljs-number">1</span>: <span class="hljs-keyword">Property</span> <span class="hljs-keyword">is</span> of type java.lang.Boolean --%&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.receiveNewsletter&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Interests:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            </span><span class="language-vbscript">&lt;%-- Approach <span class="hljs-number">2</span>: <span class="hljs-keyword">Property</span> <span class="hljs-keyword">is</span> of an array <span class="hljs-keyword">or</span> of type java.util.Collection --%&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>                Quidditch: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.interests&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Quidditch&quot;</span>/&gt;</span>                Herbology: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.interests&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Herbology&quot;</span>/&gt;</span>                Defence Against the Dark Arts: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.interests&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Defence Against the Dark Arts&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Favourite Word:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            </span><span class="language-vbscript">&lt;%-- Approach <span class="hljs-number">3</span>: <span class="hljs-keyword">Property</span> <span class="hljs-keyword">is</span> of type java.lang.Object --%&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>                Magic: <span class="hljs-tag">&lt;<span class="hljs-name">form:checkbox</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.favouriteWord&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Magic&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>checkbox标签有三种方法，可满足您的所有复选框需求。</p><ul><li>方法一: 当绑定值为<code>java.lang.Boolean</code>,如果绑定值为 <code>true</code>。则<code>input(checkbox)</code>被标记为<code>checked</code> 。value属性对应于<code>setValue(Object)</code>的值（当然是解析后的）。</li><li>方法二: 当绑定值是<code>array</code> 或<code>java.util.Collection</code>,如果绑定集合中存在已配置的 <code>setValue(Object)</code> 则输入（复选框）将标记为已选中。。</li><li>方法三: 对于任何其他绑定值类型, 如果配置的<code>setValue(Object)</code>等于绑定值，则<code>input(checkbox)</code>被标记为已选中。</li></ul><p>请注意，无论采用何种方法，都会生成相同的HTML结构。 以下HTML代码段定义了一些复选框：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;tr&gt;<br><br>    &lt;td&gt;Interests:&lt;/td&gt;<br><br>    &lt;td&gt;<br><br>        Quidditch: &lt;<span class="hljs-keyword">input</span> <span class="hljs-type">name</span>=&quot;preferences.interests&quot; <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-keyword">value</span>=&quot;Quidditch&quot;/&gt;<br><br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-keyword">value</span>=&quot;1&quot; <span class="hljs-type">name</span>=&quot;_preferences.interests&quot;/&gt;<br><br>        Herbology: &lt;<span class="hljs-keyword">input</span> <span class="hljs-type">name</span>=&quot;preferences.interests&quot; <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-keyword">value</span>=&quot;Herbology&quot;/&gt;<br><br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-keyword">value</span>=&quot;1&quot; <span class="hljs-type">name</span>=&quot;_preferences.interests&quot;/&gt;<br><br>        Defence Against the Dark Arts: &lt;<span class="hljs-keyword">input</span> <span class="hljs-type">name</span>=&quot;preferences.interests&quot; <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-keyword">value</span>=&quot;Defence Against the Dark Arts&quot;/&gt;<br><br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-keyword">value</span>=&quot;1&quot; <span class="hljs-type">name</span>=&quot;_preferences.interests&quot;/&gt;<br><br>    &lt;/td&gt;<br><br>&lt;/tr&gt;<br></code></pre></td></tr></table></figure><p>可能不希望看到的是每个复选框后都附加隐藏域，如果html页中的复选框一个都没有选中，则在提交表单后，它的值将不会作为HTTP请求参数的一部分发送到服务器，因此为了使Spring表单数据绑定工作。 需要在html中使用此奇怪的变通方法。复选框标记遵循现有的Spring约定，其中包括每个复选框都以下划线<code>_</code>为前缀的隐藏参数。通过这样做，可以有效地告诉Spring”该复选框在表单中是可见的,并且希望将表单数据绑定到其上的对象能够反映复选框的状态”.</p><h6 id="复选框标签-1"><a href="#复选框标签-1" class="headerlink" title="复选框标签"></a>复选框标签</h6><p>checkbox标签相当于多个HTML的input标签</p><p>上一个例子展示了复选框标签的生成。有时候，不希望在JSP页面中列出User的所有爱好。你更希望在运行提供可选的列表，并传递给复选框标签。这是复选框标记的用途。 可以传入一个数组、 一个列表或一个包含<code>items</code>属性中的可用选项的Map。绑定属性通常是一个集合，因此它可以保存用户选择的多个值。下面是使用此标签的JSP示例</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Interests:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">                </span><span class="language-vbscript">&lt;%-- <span class="hljs-keyword">Property</span> <span class="hljs-keyword">is</span> of an array <span class="hljs-keyword">or</span> of type java.util.Collection --%&gt;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">form:checkboxes</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;preferences.interests&quot;</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;interestList&#125;&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>本实例假定<code>interestList</code>是一个模型的属性<code>List</code>，包含需要的字符串值。在使用MAP的情况下，Map的key将用作值，map的value将用作要显示的标签。还可以使用自定义对象，可以使用<code>itemValue</code>和使用<code>itemLabel</code>的标签作为该值提供属性名称。</p><h6 id="单选框标签"><a href="#单选框标签" class="headerlink" title="单选框标签"></a>单选框标签</h6><p>还有一个可以解析成HTMLinput标签的是radio标签</p><p>radio很简单，提供多个值，但是一次只能选其中一个。如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Sex:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        Male: <span class="hljs-tag">&lt;<span class="hljs-name">form:radiobutton</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;M&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>        Female: <span class="hljs-tag">&lt;<span class="hljs-name">form:radiobutton</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;F&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="单选标签-radiobuttons"><a href="#单选标签-radiobuttons" class="headerlink" title="单选标签 radiobuttons"></a>单选标签 <code>radiobuttons</code></h6><p>这个形式的<code>radio</code>也可以解析成HTML的<code>input</code>标签，只是它是多个单选。</p><p>就像上面的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-view-jsp-formtaglib-checkboxestag"><code>checkboxes</code> 标签</a>一样，可能希望将可用选项作为运行时变量传入。对于此用法，可以使用单选标签。可以传入一个数组、一个列表或一个包含 <code>items</code>属性的Map。如果使用map，map的key将使用作为值并且map的值将使用作为标签来显示。还可以使用自定义对象，可以使用<code>itemValue</code>和使用<code>itemLabel</code>的标签作为该值提供属性名称。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Sex:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:radiobuttons</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sexOptions&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h6 id="密码框标签"><a href="#密码框标签" class="headerlink" title="密码框标签"></a>密码框标签</h6><p><code>password</code> 标签页会解析成HTML的<code>input</code>标签 只是它有自己的特性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form:password</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请注意，密码值是不可见的。如果希望密码值可见，需要设置<code>showPassword</code>属性为<code>true</code>，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Password:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form:password</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;^76525bvHGq&quot;</span> <span class="hljs-attr">showPassword</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="选择标签"><a href="#选择标签" class="headerlink" title="选择标签"></a>选择标签</h6><p>T这个标签就是HTML的select元素。支持单层选项或嵌套选项的选择，数据利用项来绑定。</p><p>让我们假设<code>User</code>，他有一个技能列表如下:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Skills:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;skills&quot;</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;skills&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果User选中的技能是Herbology，那么这个Skills的HTML源代码是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Skills:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skills&quot;</span> <span class="hljs-attr">multiple</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Potions&quot;</span>&gt;</span>Potions<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Herbology&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>Herbology<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Quidditch&quot;</span>&gt;</span>Quidditch<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="选项标签"><a href="#选项标签" class="headerlink" title="选项标签"></a>选项标签</h6><p>这个标签就是HTML的option(配合select中）元素。它会对被绑定的值设置属性为selected，以下HTML显示了它的典型输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>House:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;house&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Gryffindor&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hufflepuff&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Ravenclaw&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Slytherin&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form:select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果User的家是在Gryffindor，那么House的HTML源代码长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>House:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;house&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Gryffindor&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>Gryffindor<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> (1)<br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hufflepuff&quot;</span>&gt;</span>Hufflepuff<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Ravenclaw&quot;</span>&gt;</span>Ravenclaw<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Slytherin&quot;</span>&gt;</span>Slytherin<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、请注意添加所选属性。</p><h6 id="选项标签-1"><a href="#选项标签-1" class="headerlink" title="选项标签"></a>选项标签</h6><p>这个标签就是HTML的option(配合select中)元素,但是它处理的是一个列表，它会对被绑定的值设置属性为selected，如下所示：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Country:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">form:select</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">form:option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;--Please Select&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">form:options</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;countryList&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">itemValue</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">itemLabel</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">form:select</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果User住在UK，那么Country的HTML源代码长这这样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Country:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-&quot;</span>&gt;</span>--Please Select<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;AT&quot;</span>&gt;</span>Austria<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UK&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>United Kingdom<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span> (1)<br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;US&quot;</span>&gt;</span>United States<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、Note the addition of a <code>selected</code> attribute.</p><p>看上面的两个例子， <code>option</code>和<code>options</code>标签都生成了相同的标准的HTML，但允许你在JSP中显式地按需显示属性值，例如默认的字符串在例子中是”— Please Select”（就是默认的，选择为空的那个，这个很有用）。</p><p><code>items</code>属性通常使用项对象的集合或数组填充， <code>itemValue</code>和<code>itemLabel</code>就是对应指定bean对象的属性，如果没有指定，对象将被转成字符串。或者， 可以定义一个Map的items，<code>Map</code>的key对应选项值，value对应选项标签。如果如果<code>itemValue</code>和<code>itemLabel</code>都被指定了，那么item值属性对应key，item标签属性对应value。</p><h6 id="文本框标签"><a href="#文本框标签" class="headerlink" title="文本框标签"></a>文本框标签</h6><p>这个标签解析成HTML中的<code>textarea</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Notes:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:textarea</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;notes&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;notes&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="隐藏标签"><a href="#隐藏标签" class="headerlink" title="隐藏标签"></a>隐藏标签</h6><p><code>hidden</code>标签解析为HTML的<code>hidden</code>，用在<code>input</code> 标签中用于暗中绑定值，目的很明显就是隐藏，如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;form:hidden <span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;house&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>如果我们选择<code>house</code>值作为隐藏域提交, HTML长这样:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;house&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;Gryffindor&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h6 id="错误标签"><a href="#错误标签" class="headerlink" title="错误标签"></a>错误标签</h6><p>这个标签会在HTML的 <code>span</code>标签中展示错误，它提供对在控制器中创建的错误的访问，或对与控制器关联的任何验证程序创建的出错信息进行显示。</p><p>假设我们希望在提交表单后显示 <code>firstName</code> 和 <code>lastName</code>字段的所有错误信息，我们有一个验证器的实例的 <code>User</code> 类称为<code>UserValidator</code>。如下例所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UserValidator implements <span class="hljs-keyword">Validator</span> &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> supports(<span class="hljs-keyword">Class</span> candidate) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>.isAssignableFrom(candidate);    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">validate</span>(<span class="hljs-keyword">Object</span> obj, Errors errors) &#123;        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;firstName&quot;, &quot;required&quot;, &quot;Field is required.&quot;);        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;lastName&quot;, &quot;required&quot;, &quot;Field is required.&quot;);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>form.jsp</code>看起来是这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            &lt;%-- Show errors for firstName field --%&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            &lt;%-- Show errors for lastName field --%&gt;            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们将<code>firstName</code> 和 <code>lastName</code>的域设置空值并提交，则html看起来是这样的:</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            </span><span class="language-vbscript">&lt;%-- Associated errors <span class="hljs-keyword">to</span> firstName field displayed --%&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstName.errors&quot;</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            </span><span class="language-vbscript">&lt;%-- Associated errors <span class="hljs-keyword">to</span> lastName field displayed --%&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName.errors&quot;</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果我们要显示给定页面的整个错误列表，该怎么办？下面的示例显示了错误标记还支持一些基本的通用功能</p><ul><li><code>path=&quot;*&quot;</code>: 展示所有的错误.</li><li><code>path=&quot;lastName&quot;</code>: 展示<code>lastName</code>域的所有错误</li><li>如果 <code>path</code> 被省略，只会显示当前对象的错误。</li></ul><p>下面的示例将显示页面顶部的错误列表，后跟字段旁边的特定于字段的错误：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form:form</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">cssClass</span>=<span class="hljs-string">&quot;errorBox&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;firstName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:input</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form:errors</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;lastName&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">form:form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>html看起来是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*.errors&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;errorBox&quot;</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>First Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstName.errors&quot;</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Last Name:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName.errors&quot;</span>&gt;</span>Field is required.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save Changes&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The <code>spring-form.tld</code> tag library descriptor (TLD) is included in the <code>spring-webmvc.jar</code>. For a comprehensive reference on individual tags, browse the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description">API reference</a> or see the tag library description.</p><h6 id="HTTP方法转换"><a href="#HTTP方法转换" class="headerlink" title="HTTP方法转换"></a>HTTP方法转换</h6><p>REST的一个关键原则是使用统一的接口。这意味着所有资源(URL)都可以使用相同的四种HTTP方法进行操作GET, PUT, POST,和 DELETE。对于每个方法，HTTP规范都定义了精确的语义。例如， GET应该始终是一个安全的操作，这意味着它对服务器的数据没有任何影响。而PUT或DELETE应该是幂等的，这意味着可以反复重复这些操作，其最终结果应该是相同的。虽然HTTP定义了这四种方法，但是HTML只支持两个：GET和POST， 幸运的是，有两种可能的解决方法：1，可以使用JavaScript来执行PUT或DELETE。或者2，简单地用“real”的方式作为附加参数(作为HTML表单中的隐藏输入字段)进行POST。后者是使用Spring的<code>HiddenHttpMethodFilter</code>做的。 这个过滤器是一个简单的Servlet过滤器，因此它可以与任何Web框架(不仅仅是Spring MVC)结合使用，只需将此筛选器添加到 web.xml,并将具有隐藏域<code>_method</code>参数转换为相应的HTTP方法请求。</p><p>为了支持HTTP方法转换，Spring MVC表单标签被重新设计来支持设置HTTP方法。例如，更新后的Petclinic示例有以下判断：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;form:form method=<span class="hljs-string">&quot;delete&quot;</span>&gt;<br><br>    &lt;p <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">submit</span>&quot;&gt;&lt;<span class="hljs-symbol">input</span> <span class="hljs-symbol">type</span>=&quot;<span class="hljs-symbol">submit</span>&quot; <span class="hljs-symbol">value</span>=&quot;<span class="hljs-symbol">Delete</span> <span class="hljs-symbol">Pet</span>&quot;/&gt;&lt;/<span class="hljs-symbol">p</span>&gt;<br><br>&lt;/<span class="hljs-symbol">form:<span class="hljs-symbol">form</span></span>&gt;<br></code></pre></td></tr></table></figure><p>实际上它就是一个HTTP POST，DELETE方法只是隐藏在请求参数中的假正经方法而已，这个DELETE将被定义在web.xml的 <code>HiddenHttpMethodFilter</code>来处理,如以下示例所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">filter</span>&gt;    &lt;<span class="hljs-keyword">filter</span>-<span class="hljs-type">name</span>&gt;httpMethodFilter&lt;/<span class="hljs-keyword">filter</span>-<span class="hljs-type">name</span>&gt;    &lt;<span class="hljs-keyword">filter</span>-<span class="hljs-keyword">class</span>&gt;org.springframework.web.<span class="hljs-keyword">filter</span>.HiddenHttpMethodFilter&lt;/<span class="hljs-keyword">filter</span>-<span class="hljs-keyword">class</span>&gt;&lt;/<span class="hljs-keyword">filter</span>&gt;<br>&lt;<span class="hljs-keyword">filter</span>-<span class="hljs-keyword">mapping</span>&gt;    &lt;<span class="hljs-keyword">filter</span>-<span class="hljs-type">name</span>&gt;httpMethodFilter&lt;/<span class="hljs-keyword">filter</span>-<span class="hljs-type">name</span>&gt;    &lt;servlet-<span class="hljs-type">name</span>&gt;petclinic&lt;/servlet-<span class="hljs-type">name</span>&gt;&lt;/<span class="hljs-keyword">filter</span>-<span class="hljs-keyword">mapping</span>&gt;<br></code></pre></td></tr></table></figure><p>以下示例显示了相应的<code>@Controller</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(method = RequestMethod.DELETE)</span><br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">deletePet</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> ownerId, <span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> petId)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.clinic.deletePet(petId);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/owners/&quot;</span> + ownerId;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="HTML5标签"><a href="#HTML5标签" class="headerlink" title="HTML5标签"></a>HTML5标签</h6><p>表单标签库允许输入动态属性，这意味着您可以输入任何HTML5的特定属性。</p><p>表单<code>input</code>标签支持输入文本以外的类型属性。 他允许HTML5定义输入类型，例如<code>email</code>, <code>date</code>,<code>range</code>等。 请注意，因为text是默认类型，因此不需要输入<code>type=&#39;text&#39;</code></p><h4 id="1-9-6-Tiles"><a href="#1-9-6-Tiles" class="headerlink" title="1.9.6. Tiles"></a>1.9.6. Tiles</h4><p>Spring Web应用还可以集成Tiles，就像其它视图技术一样。下面将描述怎样集成。</p><p>本节重点介绍Spring在<code>org.springframework.web.servlet.view.tiles3</code>包中对Tiles版本3的支持。</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>为了能够使用Tiles，您必须在Tiles 3.0.1或更高版本上添加依赖项及其对项目的<a href="https://tiles.apache.org/framework/dependency-management.html">传递依赖性</a>。</p><h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><p>为了能够使用Tiles，您必须使用包含定义的文件对其进行配置（有关定义和其他Tiles概念的基本信息，请参阅<a href="https://tiles.apache.org/">http://tiles.apache.org</a>）。 在Spring中，这是通过使用 <code>TilesConfigurer</code>完成的。 以下示例<code>ApplicationContext</code>配置显示了如何执行此操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tilesConfigurer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;definitions&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/general.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/widgets.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/administrator.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/customer.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/templates.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的Tiles定义了五个文件，都位于<code>WEB-INF/defs</code> 文件夹中。在初始化<code>WebApplicationContext</code>时 ，文件将被加载，定义工厂将被初始化。完成此操作之后，在Spring Web应用程序中，定义文件中包含的Tiles可以用作视图。 之后Spring使用Tiles与使用其他视图是一样的：通过<code>ViewResolver</code>解析，<code>ViewResolver</code>可以选择<code>UrlBasedViewResolver</code>或<code>ResourceBundleViewResolver</code>。</p><p>您可以通过添加下划线然后添加区域设置来指定特定于区域设置的Tiles定义，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tilesConfigurer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;definitions&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/tiles.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/tiles_fr_FR.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用上述配置，<code>tiles_fr_FR.xml</code>用于具有 <code>fr_FR</code>语言环境的请求，默认情况下使用<code>tiles.xml</code>。</p><p>由于下划线用于表示区域设置，因此我们建议不要在Tiles定义的文件名中使用它们。</p><h6 id="UrlBasedViewResolver"><a href="#UrlBasedViewResolver" class="headerlink" title="UrlBasedViewResolver"></a><code>UrlBasedViewResolver</code></h6><p><code>UrlBasedViewResolver</code>对给定的<code>viewClass</code>进行实例化，即会解析所有的视图。 以下bean定义了<code>UrlBasedViewResolver</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;viewResolver&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;viewClass&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.web.servlet.view.tiles3.TilesView&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h6 id="ResourceBundleViewResolver"><a href="#ResourceBundleViewResolver" class="headerlink" title="ResourceBundleViewResolver"></a><code>ResourceBundleViewResolver</code></h6><p><code>ResourceBundleViewResolver</code>必须提供一个包含viewnames和viewclasses的属性文件。以下示例显示了<code>ResourceBundleViewResolver</code>的bean定义以及相应的视图名称和视图类（取自Pet Clinic示例）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;bean id=<span class="hljs-string">&quot;viewResolver&quot;</span> class=<span class="hljs-string">&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;</span>&gt;    &lt;property name=<span class="hljs-string">&quot;basename&quot;</span> value=<span class="hljs-string">&quot;views&quot;</span>/&gt;&lt;/bean&gt;<br>..<span class="hljs-selector-class">.welcomeView</span>.(class)=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.tiles3</span><span class="hljs-selector-class">.TilesViewwelcomeView</span>.url=welcome (this is the name of <span class="hljs-selector-tag">a</span> Tiles definition)<br>vetsView.(class)=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.tiles3</span><span class="hljs-selector-class">.TilesViewvetsView</span>.url=vetsView (again, this is the name of <span class="hljs-selector-tag">a</span> Tiles definition)<br>findOwnersForm.(class)=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.JstlViewfindOwnersForm</span>.url=/WEB-INF/jsp/findOwners<span class="hljs-selector-class">.jsp</span>...<br></code></pre></td></tr></table></figure><p>使用<code>ResourceBundleViewResolver</code>时，可以轻松混合使用不同的视图技术。</p><p>请注意， <code>TilesView</code> 类支持JSTL（JSP标准标记库）。</p><h6 id="SimpleSpringPreparerFactory-和-SpringBeanPreparerFactory"><a href="#SimpleSpringPreparerFactory-和-SpringBeanPreparerFactory" class="headerlink" title="SimpleSpringPreparerFactory 和 SpringBeanPreparerFactory"></a><code>SimpleSpringPreparerFactory</code> 和 <code>SpringBeanPreparerFactory</code></h6><p>作为一个高级功能，Spring还支持两个特殊的Tiles <code>PreparerFactory</code>实现，有关如何在Tiles定义文件中使用<code>ViewPreparer</code>引用的详细信息，请参阅Tiles文档。</p><p>您可以指定SimpleSpringPreparerFactory以基于指定的preparer类自动装配ViewPreparer实例，应用Spring的容器回调以及应用已配置的Spring BeanPostProcessors。 如果已激活Spring的上下文范围注释配置，则会自动检测并应用ViewPreparer类中的注释。 请注意，这需要Tiles定义文件中的preparer类，作为默认的PreparerFactory。</p><p>您可以指定<code>SpringBeanPreparerFactory</code>来操作指定的preparer名称（而不是类），从DispatcherServlet的应用程序上下文中获取相应的Spring bean。在这种情况下，完整的bean创建过程控制着Spring应用程序上下文，允许使用显式依赖项注入配置，作用域bean等。 请注意，您需要为每个preparer名称定义一个Spring bean定义（在Tiles定义中使用）。 以下示例显示如何在<code>TilesConfigurer</code>上定义一个 <code>SpringBeanPreparerFactory</code>属性集：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tilesConfigurer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;definitions&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/general.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/widgets.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/administrator.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/customer.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/WEB-INF/defs/templates.xml<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- resolving preparer names as Spring bean definition names --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;preparerFactoryClass&quot;</span>            <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-9-7-RSS-和-Atom"><a href="#1-9-7-RSS-和-Atom" class="headerlink" title="1.9.7. RSS 和 Atom"></a>1.9.7. RSS 和 Atom</h4><p><code>AbstractAtomFeedView</code>和<code>AbstractRssFeedView</code>都继承自<code>AbstractFeedView</code>基类，分别用于提供Atom和RSS Feed视图。 它们基于java.net的<a href="https://rome.dev.java.net/">ROME</a>项目，位于<code>org.springframework.web.servlet.view.feed</code>包中。</p><p><code>AbstractAtomFeedView</code> 要求实现<code>buildFeedEntries()</code> 方法，并可选择重写 <code>buildFeedMetadata()</code> 方法(默认实现为空).以下示例显示了如何执行此操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleContentAtomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAtomFeedView</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void buildFeedMetadata(<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Object</span>&gt; model,            <span class="hljs-type">Feed</span> feed, <span class="hljs-type">HttpServletRequest</span> request) &#123;        <span class="hljs-comment">// implementation omitted    &#125;</span><br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">Entry</span>&gt; buildFeedEntries(<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Object</span>&gt; model,            <span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        <span class="hljs-comment">// implementation omitted    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似的要求适用于实现<code>AbstractRssFeedView</code>，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleContentAtomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRssFeedView</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void buildFeedMetadata(<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Object</span>&gt; model,            <span class="hljs-type">Channel</span> feed, <span class="hljs-type">HttpServletRequest</span> request) &#123;        <span class="hljs-comment">// implementation omitted    &#125;</span><br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">Item</span>&gt; buildFeedItems(<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Object</span>&gt; model,            <span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        <span class="hljs-comment">// implementation omitted    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p><code>buildFeedItems()</code> 和 <code>buildFeedEntries()</code>方法在HTTP请求中传递，以防需要访问区域设置。仅为cookie或其他http头的设置传递http响应。该feed将在方法返回后自动写入响应对象。</p><p>有关创建Atom视图的示例，请参阅Alef Arendsen的Spring Team Blog <a href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">条目</a>.</p><h4 id="1-9-8-PDF-和-Excel"><a href="#1-9-8-PDF-和-Excel" class="headerlink" title="1.9.8. PDF 和 Excel"></a>1.9.8. PDF 和 Excel</h4><p>Spring提供了返回HTML以外的输出的方法，包括PDF和Excel电子表格。 本节介绍如何使用这些功能。</p><h5 id="文档视图简介"><a href="#文档视图简介" class="headerlink" title="文档视图简介"></a>文档视图简介</h5><p>返回HTML页并不总是用户查看模型输出的最佳方式，Spring让开发者可以从模型数据动态生成PDF文档或Excel电子表格。该文档是视图，将从具有正确内容类型的服务器流式传输到HTML，使客户端PC能够运行其电子表格或PDF查看器应用程序以进行响应。</p><p>要使用Excel视图，需要将Apache POI库添加到类路径中。对于PDF生成，您需要添加（最好）OpenPDF库。</p><p>如果可能，您应该使用最新版本的基础文档生成库。 特别是，我们强烈建议使用OpenPDF（例如，OpenPDF 1.0.5）而不是过时的原始iText 2.1.7，因为OpenPDF是主动维护的，并修复了不受信任的PDF内容的重要漏洞。</p><h5 id="PDF-视图"><a href="#PDF-视图" class="headerlink" title="PDF 视图"></a>PDF 视图</h5><p>单词列表的简单PDF视图可以扩展<code>org.springframework.web.servlet.view.document.AbstractPdfView</code>并实现<code>buildPdfDocument()</code> 方法，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PdfWordList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPdfView</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> void buildPdfDocument(<span class="hljs-type">Map</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Object</span>&gt; model, <span class="hljs-type">Document</span> doc, <span class="hljs-type">PdfWriter</span> writer,            <span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; words = (<span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt;) model.get(<span class="hljs-string">&quot;wordList&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> word : words) &#123;            doc.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Paragraph</span>(word));        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>控制器可以从外部视图定义（通过名称引用它）返回这样的视图，也可以从处理程序方法返回<code>View</code>实例。</p><h5 id="Excel-视图"><a href="#Excel-视图" class="headerlink" title="Excel 视图"></a>Excel 视图</h5><p>从Spring Framework 4.2开始，<code>org.springframework.web.servlet.view.document.AbstractXlsView</code> 作为Excel视图的基类提供。 它基于Apache POI，具有专门的子类（<code>AbstractXlsxStreamingView</code>和<code>AbstractExcelView</code>），取代了过时的<code>AbstractXlsxView</code>类。</p><p>编程模型类似于 <code>AbstractPdfView</code>，<code>buildExcelDocument()</code>作为核心模板方法，控制器能够从外部定义（通过名称）返回这样的视图，或者从处理程序方法返回<code>View</code>实例。</p><h4 id="1-9-9-Jackson"><a href="#1-9-9-Jackson" class="headerlink" title="1.9.9. Jackson"></a>1.9.9. Jackson</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p><p>Spring为Jackson JSON库提供支持。</p><h5 id="基于Jackson-的JSON-视图"><a href="#基于Jackson-的JSON-视图" class="headerlink" title="基于Jackson 的JSON 视图"></a>基于Jackson 的JSON 视图</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p><p><code>MappingJackson2JsonView</code>使用Jackson库的<code>ObjectMapper</code>将响应内容呈现为JSON。 默认情况下，模型映射的全部内容（特定于框架的类除外）都编码为JSON。 对于需要过滤Map内容的情况，您可以使用<code>modelKeys</code>属性指定要编码的特定模型属性集。 您还可以使用 <code>extractValueFromSingleKeyModel</code>属性将single-key模型中的值直接提取和序列化，而不是作为模型属性的映射。</p><p>您可以使用Jackson提供的注解根据需要自定义JSON映射。 当您需要进一步控制时，可以通过 <code>ObjectMapper</code>属性注入自定义<code>ObjectMapper</code>，以用于需要为特定类型提供自定义JSON序列化程序和反序列化程序的情况。</p><h5 id="基于Jackson的XML视图"><a href="#基于Jackson的XML视图" class="headerlink" title="基于Jackson的XML视图"></a>基于Jackson的XML视图</h5><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-view-httpmessagewriter">Same as in Spring WebFlux</a></p><p><code>MappingJackson2XmlView</code>使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML扩展的</a> <code>XmlMapper</code>将响应内容呈现为XML。 如果模型包含多个条目，则应使用<code>modelKey</code>bean属性显式设置要序列化的对象。 如果模型包含单个条目，则会自动序列化。</p><p>您可以使用JAXB或Jackson提供的注解根据需要自定义XML映射。 当您需要进一步控制时，可以通过<code>ObjectMapper</code>属性注入自定义<code>XmlMapper</code>，以便自定义XML需要为特定类型提供序列化程序和反序列化程序。</p><h4 id="1-9-10-XML编组"><a href="#1-9-10-XML编组" class="headerlink" title="1.9.10. XML编组"></a>1.9.10. XML编组</h4><p><code>MarshallingView</code>使用XML <code>Marshaller</code>（在<code>org.springframework.oxm</code>包中定义）将响应内容呈现为XML。 您可以使用 <code>MarshallingView</code> 实例的 <code>modelKey</code> bean属性显式设置要编组的对象。 或者，视图会迭代所有模型属性，并封送<code>Marshaller</code>支持的第一种类型。 有关<code>org.springframework.oxm</code>包中功能的更多信息，请参阅使用 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/data-access.html#oxm">Marshalling XML using O&#x2F;X Mappers</a>。</p><h4 id="1-9-11-XSLT视图"><a href="#1-9-11-XSLT视图" class="headerlink" title="1.9.11. XSLT视图"></a>1.9.11. XSLT视图</h4><p>XSLT是一个用于转换XML的语言,能够在web的视图技术中使用.如果应用需要处理XML（或者将模型转换为XML），那么XSLT是一个很适合的视图技术。以下部分显示如何将XML文档生成为模型数据，并在Spring Web MVC应用程序中使用XSLT进行转换。</p><p>这个例子是一个简单的Spring应用程序，它在Controller中创建一个单词列表并将它们添加到模型映射中。该映射与使用的XSLT视图名称一起返回。有关Spring Web MVC控制器接口的详细信息， 请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-controller">带注解的控制器</a>。 XSLT控制器将单词列表转换为准备转换的简单XML文档。</p><h5 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h5><p>Configuration配置是Spring应用程序的标配，MVC配置必须定义<code>XsltViewResolver</code> bean和常规MVC注解配置，以下示例显示了如何执行此操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@ComponentScan</span><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> XsltViewResolver <span class="hljs-title function_">xsltViewResolver</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">XsltViewResolver</span> <span class="hljs-variable">viewResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XsltViewResolver</span>();        viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/xsl/&quot;</span>);        viewResolver.setSuffix(<span class="hljs-string">&quot;.xslt&quot;</span>);        <span class="hljs-keyword">return</span> viewResolver;    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>并且我们需要一个控制器，用来处理单词的生成逻辑。</p><p>控制器逻辑封装在<code>@Controller</code> 类中，处理程序方法定义如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XsltController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/&quot;</span>)    public <span class="hljs-built_in">String</span> home(Model model) throws Exception &#123;        Document <span class="hljs-built_in">document</span> = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();        <span class="hljs-built_in">Element</span> root = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;wordList&quot;</span>);<br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; words = Arrays.asList(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Spring&quot;</span>, <span class="hljs-string">&quot;Framework&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> word : words) &#123;            <span class="hljs-built_in">Element</span> wordNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;word&quot;</span>);            Text textNode = <span class="hljs-built_in">document</span>.createTextNode(word);            wordNode.appendChild(textNode);            root.appendChild(wordNode);        &#125;<br>        model.addAttribute(<span class="hljs-string">&quot;wordList&quot;</span>, root);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>到目前为止，我们只创建了一个DOM文档并将其添加到模型映射中。 请注意，您还可以将XML文件作为<code>Resource</code> 加载，并使用它而不是自定义DOM文档。</p><p>当然，有软件包可以自动 ‘domify’对象图，在Spring中，您可以完全灵活地以您选择的任何方式从模型中创建DOM。这可以防止XML在模型数据的结构中扮演太大的角色，这在使用工具管理DOM化过程时是一种危险。。</p><h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>最后, <code>XsltViewResolver</code> 将解析“home” XSLT 模板文件，并将DOM文档合并到其中以生成所需视图。例如<code>XsltViewResolver</code>配置所示，XSLT模板在<code>WEB-INF/xsl</code>目录中的<code>war</code>文件中， 并以<code>xslt</code>文件扩展名结束。</p><p>以下示例显示了XSLT转换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">xsl:stylesheet</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span> <span class="hljs-attr">xmlns:xsl</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:output</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;html&quot;</span> <span class="hljs-attr">omit-xml-declaration</span>=<span class="hljs-string">&quot;yes&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:template</span> <span class="hljs-attr">match</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My First Words<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:apply-templates</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xsl:template</span> <span class="hljs-attr">match</span>=<span class="hljs-string">&quot;word&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">xsl:value-of</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;.&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">xsl:template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xsl:stylesheet</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述转换呈现为以下HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">META</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My First Words<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Spring<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Framework<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-10-MVC-配置"><a href="#1-10-MVC-配置" class="headerlink" title="1.10. MVC 配置"></a>1.10. MVC 配置</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config">Same as in Spring WebFlux</a></p><p>MVC Java配置和MVC命名空间提供了适用于大多数应用程序的默认配置以及配置API来对其进行自定义。</p><p>有关配置API中没有的高级自定义设置请参阅<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-advanced-java">高级 Java 配置</a> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-config-advanced-xml">高级 XML 配置</a>.</p><p>您无需了解MVC Java配置和MVC命名空间创建的基础bean。 如果您想了解更多信息，请参阅特殊Bean类型和Web MVC配置。<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-servlet-special-bean-types">特殊Bean类型</a> 和 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-servlet-config">Web MVC配置</a>.</p><h4 id="1-10-1-启用-MVC-配置"><a href="#1-10-1-启用-MVC-配置" class="headerlink" title="1.10.1. 启用 MVC 配置"></a>1.10.1. 启用 MVC 配置</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-enable">Same as in Spring WebFlux</a></p><p>在Java配置中，您可以使用<code>@EnableWebMvc</code> 注解启用MVC配置，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@EnableWebMvc</span><br><br>public class WebConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在XML配置中，您可以使用<code>&lt;mvc:annotation-driven&gt;</code> 元素来启用MVC配置，如以下示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>前面的示例注册了许多Spring MVC基础结构bean，并适应类路径上可用的依赖项（例如，JSON，XML等的有效负载转换器）。</p><h4 id="1-10-2-MVC-配置-API"><a href="#1-10-2-MVC-配置-API" class="headerlink" title="1.10.2. MVC 配置 API"></a>1.10.2. MVC 配置 API</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-customize">Same as in Spring WebFlux</a></p><p>在Java配置中，您可以实现<code>WebMvcConfigurer</code>接口，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-comment">// Implement configuration methods...&#125;</span><br></code></pre></td></tr></table></figure><p>在XML中，您可以检查<code>&lt;mvc:annotation-driven/&gt;</code>的属性和子元素。 您可以查看<a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a> 或使用IDE的代码完成功能来发现可用的属性和子元素。</p><h4 id="1-10-3-类型转换"><a href="#1-10-3-类型转换" class="headerlink" title="1.10.3. 类型转换"></a>1.10.3. 类型转换</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-conversion">Same as in Spring WebFlux</a></p><p>数字的 <code>Number</code>类型和日期<code>Date</code> 类型的格式化是默认安装了的，包括<code>@NumberFormat</code>注解和<code>@DateTimeFormat</code>注解，如果类路径中存在Joda-Time，则还会安装对Joda-Time格式库的完全支持。</p><p>在Java配置中，您可以注册自定义格式化程序和转换器，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addFormatters</span>(FormatterRegistry registry) &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">&quot;conversionService&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span>            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.MyConverter&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;formatters&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.MyFormatter&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.MyAnnotationFormatterFactory&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;formatterRegistrars&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.MyFormatterRegistrar&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有关何时使用FormatterRegistrar实现的更多信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和 <code>FormattingConversionServiceFactoryBean</code>。</p><h4 id="1-10-4-验证"><a href="#1-10-4-验证" class="headerlink" title="1.10.4. 验证"></a>1.10.4. 验证</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-validation">Same as in Spring WebFlux</a></p><p>默认情况下，如果类路径上存在<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#validation-beanvalidation-overview">Bean Validation</a>(例如Hibernate Validator），则 <code>LocalValidatorFactoryBean</code>将注册为全局<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/core.html#validator">Validator</a> 。 以便与 <code>@Valid</code> 和 <code>Validated</code> 一起使用并在控制器方法参数上进行验证。</p><p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public Validator <span class="hljs-built_in">getValidator</span>(); &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">validator</span>=<span class="hljs-string">&quot;globalValidator&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请注意，您还可以在本地注册<code>Validator</code>实现，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controllerpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-meta">@InitBinder</span>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initBinder</span>(<span class="hljs-params">WebDataBinder binder</span>) &#123;        binder.<span class="hljs-title function_">addValidators</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FooValidator</span>());    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在某处注入<code>LocalValidatorFactoryBean</code>，请创建一个bean并使用<code>@Primary</code>标记它，以避免与MVC配置中声明的那个冲突。</p><h4 id="1-10-5-拦截器"><a href="#1-10-5-拦截器" class="headerlink" title="1.10.5. 拦截器"></a>1.10.5. 拦截器</h4><p>在Java配置中，注册拦截器应用于传入的请求。如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addInterceptors</span>(InterceptorRegistry registry) &#123;        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addInterceptor</span>(new <span class="hljs-built_in">LocaleChangeInterceptor</span>());        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addInterceptor</span>(new <span class="hljs-built_in">ThemeChangeInterceptor</span>())<span class="hljs-selector-class">.addPathPatterns</span>(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-selector-class">.excludePathPatterns</span>(<span class="hljs-string">&quot;/admin/**&quot;</span>);        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addInterceptor</span>(new <span class="hljs-built_in">SecurityInterceptor</span>())<span class="hljs-selector-class">.addPathPatterns</span>(<span class="hljs-string">&quot;/secure/*&quot;</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/admin/**&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.theme.ThemeChangeInterceptor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/secure/*&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.SecurityInterceptor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-10-6-内容类型"><a href="#1-10-6-内容类型" class="headerlink" title="1.10.6. 内容类型"></a>1.10.6. 内容类型</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-content-negotiation">Same as in Spring WebFlux</a></p><p>您可以配置Spring MVC如何根据请求确定所请求的媒体类型（例如，<code>Accept</code>头，URL路径扩展，查询参数等）。</p><p>默认情况下，首先检查URL路径扩展 - 将 <code>json</code>, <code>xml</code>, <code>rss</code>, 和 <code>atom</code>注册为已知扩展（取决于类路径依赖性）。 第二个检查 <code>Accept</code>头。</p><p>将这些默认值更改为只接受<code>Accept</code>头，并且如果必须使用基于内容类型解析，请考虑路径扩展上的查询参数策略。 有关更多详细信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a> and <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-requestmapping-rfd">后缀匹配以及RFD</a>。</p><p>在Java配置中，您可以自定义请求的内容类型解析，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">configureContentNegotiation</span>(ContentNegotiationConfigurer configurer) &#123;        <span class="hljs-selector-tag">configurer</span><span class="hljs-selector-class">.mediaType</span>(<span class="hljs-string">&quot;json&quot;</span>, MediaType.APPLICATION_JSON);        <span class="hljs-selector-tag">configurer</span><span class="hljs-selector-class">.mediaType</span>(<span class="hljs-string">&quot;xml&quot;</span>, MediaType.APPLICATION_XML);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">content-negotiation-manager</span>=<span class="hljs-string">&quot;contentNegotiationManager&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;contentNegotiationManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mediaTypes&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>            json=application/json            xml=application/xml        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-10-7-消息转换"><a href="#1-10-7-消息转换" class="headerlink" title="1.10.7. 消息转换"></a>1.10.7. 消息转换</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-message-codecs">Same as in Spring WebFlux</a></p><p>使用MVC Java编程配置方式时，如果想替换Spring MVC提供的默认转换器，完全定制自己的<code>HttpMessageConverter</code> ，这可以通过覆写<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-"><code>configureMessageConverters()</code></a>方法来实现。 如果只是想自定义，或者想在默认转换器之外再添加其他的转换器，那么可以通过覆写<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-"><code>extendMessageConverters()</code></a>方法来实现。</p><p>以下示例使用自定义的<code>ObjectMapper</code>而不是默认的<code>ObjectMapper</code>添加XML和Jackson JSON转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;        <span class="hljs-type">Jackson2ObjectMapperBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2ObjectMapperBuilder</span>()                .indentOutput(<span class="hljs-literal">true</span>)                .dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>))                .modulesToInstall(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterNamesModule</span>());        converters.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>(builder.build()));        converters.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2XmlHttpMessageConverter</span>(builder.createXmlMapper(<span class="hljs-literal">true</span>).build()));    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a> 用于为 <code>MappingJackson2HttpMessageConverter</code> 和<code>MappingJackson2XmlHttpMessageConverter</code> 转换器创建公共的配置，比如启用tab缩进、定制的日期格式，并注册了模块 <a href="https://github.com/FasterXML/jackson-module-parameter-names"><code>jackson-module-parameter-names</code></a>用于获取参数名（Java 8新增的特性）。</p><p>该builder会使用以下的默认属性对Jackson进行配置</p><ul><li><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</li><li><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</li></ul><p>同时，如果检测到在classpath路径下存在这些模块，该builder也会自动地注册它们。</p><ul><li><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>: Support for Java 7 types, such as <code>java.nio.file.Path</code>.</li><li><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>: Support for Joda-Time types.</li><li><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>: Support for Java 8 Date and Time API types.</li><li><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>: Support for other Java 8 types, such as <code>Optional</code>.</li></ul><p>除了<a href="https://search.maven.org/#search|ga|1|a%3A%22jackson-dataformat-xml%22"><code>jackson-dataformat-xml</code></a> 之外，要启用Jackson XML的tab缩进还需要[<code>woodstox-core-asl</code>](<a href="https://search.maven.org/#search|gav|1|g%3A%22org.codehaus.woodstox">https://search.maven.org/#search|gav|1|g%3A&quot;org.codehaus.woodstox</a>“ AND a%3A”woodstox-core-asl”)依赖。</p><p>还有其他有用的Jackson模块可以使用</p><ul><li><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a>: 提供了对<code>javax.money</code> 类型的支持（非官方模块）</li><li><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a>:提供了Hibernate相关的类型和属性支持（包含懒加载aspects）</li></ul><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;xmlMapper&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;objectMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>      <span class="hljs-attr">p:indentOutput</span>=<span class="hljs-string">&quot;true&quot;</span>      <span class="hljs-attr">p:simpleDateFormat</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>      <span class="hljs-attr">p:modulesToInstall</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.module.paramnames.ParameterNamesModule&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xmlMapper&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;objectMapper&quot;</span> <span class="hljs-attr">p:createXmlMapper</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-10-8-视图控制器"><a href="#1-10-8-视图控制器" class="headerlink" title="1.10.8. 视图控制器"></a>1.10.8. 视图控制器</h4><p>以下的一段代码相当于定义<code>ParameterizableViewController</code> 视图控制器的快捷方式，该控制器会立即将请求转发（forwards）给视图。请确保仅在以下情景下才使用这个类：当控制器除了将视图渲染到响应中外不需要执行任何逻辑时。</p><p>以下Java配置示例将对 <code>/</code>的请求转发给名为<code>home</code>的视图:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addViewControllers</span>(ViewControllerRegistry registry) &#123;        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addViewController</span>(<span class="hljs-string">&quot;/&quot;</span>)<span class="hljs-selector-class">.setViewName</span>(<span class="hljs-string">&quot;home&quot;</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例与前面的示例实现相同的功能，但使用XML，通过使用<code>&lt;mvc:view-controller&gt;</code>元素:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;mvc:<span class="hljs-keyword">view</span>-controller <span class="hljs-type">path</span>=&quot;/&quot; <span class="hljs-keyword">view</span>-<span class="hljs-type">name</span>=&quot;home&quot;/&gt;<br></code></pre></td></tr></table></figure><h4 id="1-10-9-视图解析器"><a href="#1-10-9-视图解析器" class="headerlink" title="1.10.9. 视图解析器"></a>1.10.9. 视图解析器</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-view-resolvers">Same as in Spring WebFlux</a></p><p>MVC提供的配置简化了视图解析器的注册工作</p><p>以下Java配置示例使用JSP和Jackson作为JSON呈现的默认视图来配置内容协商视图解析：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">configureViewResolvers</span>(ViewResolverRegistry registry) &#123;        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.enableContentNegotiation</span>(new <span class="hljs-built_in">MappingJackson2JsonView</span>());        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.jsp</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-negotiation</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-views</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:default-views</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:content-negotiation</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:jsp</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但请注意，FreeMarker，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。</p><p>MVC名称空间提供专用元素。 以下示例适用于FreeMarker：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-views</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:default-views</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:content-negotiation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:template-loader-path</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/freemarker&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:freemarker-configurer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Java配置中，您可以添加相应的<code>Configurer</code> bean，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configureViewResolvers</span>(<span class="hljs-params">ViewResolverRegistry registry</span>) &#123;        registry.<span class="hljs-title function_">enableContentNegotiation</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2JsonView</span>());        registry.<span class="hljs-title function_">freeMarker</span>().<span class="hljs-title function_">cache</span>(<span class="hljs-literal">false</span>);    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">FreeMarkerConfigurer</span> <span class="hljs-title function_">freeMarkerConfigurer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">FreeMarkerConfigurer</span> configurer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FreeMarkerConfigurer</span>();        configurer.<span class="hljs-title function_">setTemplateLoaderPath</span>(<span class="hljs-string">&quot;/freemarker&quot;</span>);        <span class="hljs-keyword">return</span> configurer;    &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-10-10-静态资源"><a href="#1-10-10-静态资源" class="headerlink" title="1.10.10. 静态资源"></a>1.10.10. 静态资源</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-static-resources">Same as in Spring WebFlux</a></p><p>此选项提供了一种从 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>资源</code></a>库位置列表中使用静态资源的便捷方法</p><p>在下面的示例中，给定以 <code>/resources</code>开头的请求，相对路径用于在Web应用程序根目录下或在或在<code>/static</code>下的类路径上查找和提供相对于<code>/public</code>的静态资源。 资源的有效期为1年，以确保最大程度地使用浏览器缓存，并减少浏览器发出的HTTP请求。如果返回 <code>304</code>状态代码，<code>Last-Modified</code> 头也会计算到。</p><p>以下清单显示了如何使用Java配置执行此操作:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addResourceHandlers</span>(ResourceHandlerRegistry registry) &#123;        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addResourceHandler</span>(<span class="hljs-string">&quot;/resources/**&quot;</span>)            <span class="hljs-selector-class">.addResourceLocations</span>(<span class="hljs-string">&quot;/public&quot;</span>, <span class="hljs-string">&quot;classpath:/static/&quot;</span>)            <span class="hljs-selector-class">.setCachePeriod</span>(<span class="hljs-number">31556926</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mvc:resources <span class="hljs-attribute">mapping</span>=<span class="hljs-string">&quot;/resources/**&quot;</span><br><br>    <span class="hljs-attribute">location</span>=<span class="hljs-string">&quot;/public, classpath:/static/&quot;</span><br><br>    <span class="hljs-attribute">cache-period</span>=<span class="hljs-string">&quot;31556926&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>查看 <a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-caching-static-resources">静态资源的HTTP缓存支持</a>.</p><p>资源处理还支持一系列 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html"><code>ResourceResolver</code></a> 实现 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a> 实现, 可用于创建用于使用优化资源的工具</p><p><code>VersionResourceResolver</code>可用于基于内容、固定应用程序版本或其他的MD5哈希计算的版本化资源url。<code>ContentVersionStrategy</code>(MD5 hash)方法是一个很好的选择， 有一些值得注意的例外，例如与模块加载器一起使用的JavaScript资源。</p><p>以下示例显示如何在Java配置中使用 <code>VersionResourceResolver</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">addResourceHandlers</span>(ResourceHandlerRegistry registry) &#123;        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addResourceHandler</span>(<span class="hljs-string">&quot;/resources/**&quot;</span>)                <span class="hljs-selector-class">.addResourceLocations</span>(<span class="hljs-string">&quot;/public/&quot;</span>)                <span class="hljs-selector-class">.resourceChain</span>(true)                <span class="hljs-selector-class">.addResolver</span>(new <span class="hljs-built_in">VersionResourceResolver</span>().<span class="hljs-built_in">addContentVersionStrategy</span>(<span class="hljs-string">&quot;/**&quot;</span>));    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/resources/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/public/&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resource-chain</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resource-cache</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resolvers</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mvc:version-resolver</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mvc:content-version-strategy</span> <span class="hljs-attr">patterns</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:version-resolver</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resolvers</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resource-chain</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>您可以使用<code>ResourceUrlProvider</code>来重写URL并应用完整的解析器和转换器链，例如插入版本。MVC配置提供了 <code>ResourceUrlProvider</code> bean，因此可以将其注入到其他用户。 您还可以使用<code>ResourceUrlEncodingFilter</code> 的Thymeleaf、jsp、FreeMarker和其他依赖于<code>HttpServletResponse#encodeURL</code>的URL标记来做重写转换。</p><p>请注意，当同时使用<code>EncodedResourceResolver</code>（例如，用于提供gzipped或brotli编码的资源）和<code>VersionedResourceResolver</code>时，必须按此顺序注册它们。 这可确保始终基于未编码的文件可靠地计算基于内容的版本。</p><p><a href="http://www.webjars.org/documentation">WebJars</a>也支持使用<code>WebJarsResourceResolver</code>和自动注册，当 <code>org.webjars:webjars-locator</code>存在于类路径中时。解析器可以重写URL来包含jar的版本，也可以与传入的URL匹配，而不需要版本 。 例如， <code>/jquery/jquery.min.js</code> 到 <code>/jquery/1.2.0/jquery.min.js</code>。</p><h4 id="1-10-11-默认-Servlet"><a href="#1-10-11-默认-Servlet" class="headerlink" title="1.10.11. 默认 Servlet"></a>1.10.11. 默认 Servlet</h4><p>这些配置允许将<code>DispatcherServlet</code>映射到<code>/</code>路径（也即覆盖了容器默认Servlet的映射），但依然保留容器默认的Servlet以处理静态资源的请求。这可以通过配置一个URL映射到 <code>/**</code> 的处理器<code>DefaultServletHttpRequestHandler</code>来实现，并且该处理器在其他所有URL映射关系中优先级应该是最低的。</p><p>该处理器会将所有请求转发（forward）到默认的Servlet，因此需要保证它在所有URL处理器映射<code>HandlerMappings</code>的最后。如果你是通过<code>&lt;mvc:annotation-driven&gt;</code>的方式进行配置， 或自定义 <code>HandlerMapping</code> 实例，那么需要确保该处理器<code>order</code>属性的值比<code>DefaultServletHttpRequestHandler</code>的次序值<code>Integer.MAX_VALUE</code>小。</p><p>以下示例显示如何使用默认设置启用该功能：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">configureDefaultServletHandling</span>(DefaultServletHandlerConfigurer configurer) &#123;        <span class="hljs-selector-tag">configurer</span><span class="hljs-selector-class">.enable</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">&lt;mvc:<span class="hljs-keyword">default</span>-servlet-<span class="hljs-keyword">handler</span>/&gt;<br></code></pre></td></tr></table></figure><p>不过需要注意，覆写了<code>/</code>的Servlet映射后，默认Servlet的<code>RequestDispatcher</code>就必须通过名字而非路径来取得了。 <code>DefaultServletHttpRequestHandler</code>会尝试在容器初始化的时候自动检测默认Servlet， 这里它使用的是一份主流Servlet容器（包括Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere）已知的名称列表。如果默认Servlet被配置了一个其他的名字，或者使用了一个列表里未提供默认Servlet名称的容器，那么默认Servlet的名称必须被显式指定，正如下面代码所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableWebMvcpublic</span> class WebConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public void <span class="hljs-built_in">configureDefaultServletHandling</span>(DefaultServletHandlerConfigurer configurer) &#123;        <span class="hljs-selector-tag">configurer</span><span class="hljs-selector-class">.enable</span>(<span class="hljs-string">&quot;myCustomDefaultServlet&quot;</span>);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;mvc:<span class="hljs-keyword">default</span>-servlet-<span class="hljs-keyword">handler</span> <span class="hljs-keyword">default</span>-servlet-<span class="hljs-type">name</span>=&quot;myCustomDefaultServlet&quot;/&gt;<br></code></pre></td></tr></table></figure><h4 id="1-10-12-路径匹配"><a href="#1-10-12-路径匹配" class="headerlink" title="1.10.12. 路径匹配"></a>1.10.12. 路径匹配</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-path-matching">Same as in Spring WebFlux</a></p><p>您可以自定义与路径匹配和URL处理相关的选项。 有关各个选项的详细信息，请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc.</p><p>以下示例显示如何在Java配置中自定义路径匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebMvcpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">configurePathMatch</span>(<span class="hljs-params">PathMatchConfigurer configurer</span>) &#123;        configurer            .<span class="hljs-title function_">setUseSuffixPatternMatch</span>(<span class="hljs-literal">true</span>)            .<span class="hljs-title function_">setUseTrailingSlashMatch</span>(<span class="hljs-literal">false</span>)            .<span class="hljs-title function_">setUseRegisteredSuffixPatternMatch</span>(<span class="hljs-literal">true</span>)            .<span class="hljs-title function_">setPathMatcher</span>(<span class="hljs-title function_">antPathMatcher</span>())            .<span class="hljs-title function_">setUrlPathHelper</span>(<span class="hljs-title function_">urlPathHelper</span>())            .<span class="hljs-title function_">addPathPrefix</span>(<span class="hljs-string">&quot;/api&quot;</span>,                    <span class="hljs-title class_">HandlerTypePredicate</span>.<span class="hljs-title function_">forAnnotation</span>(<span class="hljs-title class_">RestController</span>.<span class="hljs-property">class</span>));    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UrlPathHelper</span> <span class="hljs-title function_">urlPathHelper</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">//...    &#125;</span><br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">PathMatcher</span> <span class="hljs-title function_">antPathMatcher</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">//...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示如何在XML中实现相同的配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;mvc:annotation-driven&gt;    &lt;mvc:path-matching        <span class="hljs-attribute">suffix-pattern</span>=<span class="hljs-string">&quot;true&quot;</span>        <span class="hljs-attribute">trailing-slash</span>=<span class="hljs-string">&quot;false&quot;</span>        <span class="hljs-attribute">registered-suffixes-only</span>=<span class="hljs-string">&quot;true&quot;</span>        <span class="hljs-attribute">path-helper</span>=<span class="hljs-string">&quot;pathHelper&quot;</span>        <span class="hljs-attribute">path-matcher</span>=<span class="hljs-string">&quot;pathMatcher&quot;</span>/&gt;&lt;/mvc:annotation-driven&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;pathHelper&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.example.app.MyPathHelper&quot;</span>/&gt;&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;pathMatcher&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.example.app.MyPathMatcher&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="1-10-13-高级-Java-配置"><a href="#1-10-13-高级-Java-配置" class="headerlink" title="1.10.13. 高级 Java 配置"></a>1.10.13. 高级 Java 配置</h4><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-config-advanced-java">Same as in Spring WebFlux</a></p><p><code>@EnableWebMvc</code> 导入 <code>DelegatingWebMvcConfiguration</code>, 其中:</p><ul><li>为Spring MVC应用程序提供了默认的Spring配置</li><li>检测到并委派到<code>WebMvcConfigurer</code>的自定义该配置</li></ul><p>对于高级模式，请删除<code>@EnableWebMvc</code>并直接从 <code>DelegatingWebMvcConfiguration</code>继承 ，而不是实现<code>WebMvcConfigurer</code>，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在<code>WebConfig</code>中保留现有的方法，但现在也可以重写基类中的bean声明，并且在类路径上仍然可以有任意数量的其他<code>WebMvcConfigurer</code> 。</p><h4 id="1-10-14-高级-XML-配置"><a href="#1-10-14-高级-XML-配置" class="headerlink" title="1.10.14. 高级 XML 配置"></a>1.10.14. 高级 XML 配置</h4><p>MVC命名空间没有高级模式，如果需要自定义无法更改的bean上的属性，可以使用 <code>ApplicationContext</code>的<code>BeanPostProcessor</code>生命周期挂钩，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> name) throws <span class="hljs-title class_">BeansException</span> &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>请注意，<code>MyPostProcessor</code>需要用XML显式声明为bean，或通过 <code>&lt;component-scan/&gt;</code>声明检测。</p><h3 id="1-11-HTTP-2"><a href="#1-11-HTTP-2" class="headerlink" title="1.11. HTTP&#x2F;2"></a>1.11. HTTP&#x2F;2</h3><p><a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/web-reactive.html#webflux-http2">Same as in Spring WebFlux</a></p><p>Servlet 4容器需要支持HTTP&#x2F;2，Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要特定的任何操作。 但是，存在与服务器配置相关的注意事项。 有关更多详细信息，请参阅 <a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP&#x2F;2 wiki 页面。</a></p><p>Servlet API确实公开了一个与HTTP&#x2F;2相关的构造。 您可以使用<code>javax.servlet.http.PushBuilder</code> 主动将资源推送到客户端，并且它被支持作为 <code>@RequestMapping</code>方法的<a href="https://sca.aliyun.com/learn/spring/web-servlet/mvc/?spm=0.29160081.0.0.51f92e5dCHrGI4#mvc-ann-arguments">方法参数</a>。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>web</tag>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP编程 (下)</title>
    <link href="/post/cd1cf2a8-69fa-49fb-a09a-5fb5fa406040/"/>
    <url>/post/cd1cf2a8-69fa-49fb-a09a-5fb5fa406040/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP-编程-下"><a href="#AOP-编程-下" class="headerlink" title="AOP 编程(下)"></a>AOP 编程(下)</h1><p>Spring 教程</p><hr><h2 id="3-Spring-AOP-APIs"><a href="#3-Spring-AOP-APIs" class="headerlink" title="3. Spring AOP APIs"></a>3. Spring AOP APIs</h2><p>前一章介绍了Spring使用@AspectJ和基于schema的切面定义对AOP的支持。 在本章中，将讨论Spring 1.2应用程序中使用的较底层的Spring AOP API和AOP支持。 对于新的应用程序，推荐使用前一章中介绍的Spring 2.0和更高版本的AOP支持，但是在使用现有应用程序或阅读书籍和文章时，您可能会遇到Spring 1.2方式的示例. Spring 5仍然向后兼容了Spring 1.2。本章中描述的所有内容在Spring 5中都得到了完全支持。</p><h3 id="3-1-Spring中的切点API"><a href="#3-1-Spring中的切点API" class="headerlink" title="3.1. Spring中的切点API"></a>3.1. Spring中的切点API</h3><p>本节描述了Spring如何处理切点的关键概念。</p><h4 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1. 概念"></a>3.1.1. 概念</h4><p>Spring的切点模式能够让切点独立于通知类型。针对不同的通知使用相同的切点是可能的。</p><p><code>org.springframework.aop.Pointcut</code> 接口是切点的主要接口，用于特定类和方法的目标通知。完整的接口如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Pointcut</span> &#123;<br>    <span class="hljs-function">ClassFilter <span class="hljs-title">getClassFilter</span>()</span>;<br>    <span class="hljs-function">MethodMatcher <span class="hljs-title">getMethodMatcher</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>Pointcut</code>接口分成两部分，允许重用类和方法匹配部分，以及细粒度的组合操作（例如与另一个方法匹配器执行“union”）。</p><p><code>ClassFilter</code>接口是用来限制切点的一组给定的目标类。如果<code>matches()</code>方法总是返回true，那么表示所有的目标类都将匹配。以下清单显示了<code>ClassFilter</code>接口定义:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ClassFilter</span> &#123;<br>    <span class="hljs-built_in">bool</span>ean matches(Class clazz);&#125;<br></code></pre></td></tr></table></figure><p><code>MethodMatcher</code> 接口通常更重要。完整的接口如下所示:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> interface MethodMatcher &#123;<br>    <span class="hljs-type">boolean</span> matches(<span class="hljs-keyword">Method</span> m, <span class="hljs-keyword">Class</span> targetClass);<br>    <span class="hljs-type">boolean</span> isRuntime();<br>    <span class="hljs-type">boolean</span> matches(<span class="hljs-keyword">Method</span> m, <span class="hljs-keyword">Class</span> targetClass, <span class="hljs-keyword">Object</span>[] args);&#125;<br></code></pre></td></tr></table></figure><p><code>matches(Method, Class)</code>方法用于测试此切点是否曾经匹配到目标类上的给定方法。在创建AOP代理时可以执行此评估，以避免需要对每个方法调用进行测试。 如果对于给定方法，这个双参数 <code>matches</code>方法返回<code>true</code>，并且MethodMatcher的 <code>isRuntime()</code>方法也返回true。 则在每次方法调用时都会调用三参数<code>matches</code>方法。这使切点能够在目标通知执行之前，查看传递给方法调用的参数。</p><p>大多数<code>MethodMatcher</code>实现都是静态的，这意味着它们的 <code>isRuntime()</code>方法返回<code>false</code>。 在这种情况下，永远不会调用三参数<code>matches</code>方法。</p><p>如果可以，请尝试将切点设为静态的，从而允许AOP框架在创建AOP代理时缓存对切点评估的结果。</p><h4 id="3-1-2-切点的操作"><a href="#3-1-2-切点的操作" class="headerlink" title="3.1.2. 切点的操作"></a>3.1.2. 切点的操作</h4><p>Spring支持对切点的各种操作，特别是并集和交集</p><p>并集意味着这个方法只要有一个切点匹配，交集意味着这个方法需要所有的切点都匹配。 并集使用得更广，您可以使用<code>org.springframework.aop.support.Pointcuts</code>类中的静态方法或在同一个包中使用<code>ComposablePointcut</code>类来组合切 点。但是，使用AspectJ的切点表达式往往是更简单的方式。</p><h4 id="3-1-3-AspectJ切点表达式"><a href="#3-1-3-AspectJ切点表达式" class="headerlink" title="3.1.3. AspectJ切点表达式"></a>3.1.3. AspectJ切点表达式</h4><p>自 2.0以来, ，Spring使用的最重要的切点类型是<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个使用AspectJ提供的库来解析AspectJ切点表达式字符串的切点。</p><p>有关支持的AspectJ切点语义的讨论， <a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop">请参见上一章</a></p><h4 id="3-1-4-方便的切点实现"><a href="#3-1-4-方便的切点实现" class="headerlink" title="3.1.4.方便的切点实现"></a>3.1.4.方便的切点实现</h4><p>Spring提供了几个方便的切点实现，您可以直接使用其中一些。其他的目的是在特定于应用程序的切点中进行子类化。 Others are intended to be subclassed in application-specific pointcuts.</p><h5 id="静态切点"><a href="#静态切点" class="headerlink" title="静态切点"></a>静态切点</h5><p>静态切点是基于方法和目标类的，而且无法考虑该方法的参数。静态切点在大多数的使用上是充分的、最好的。在第一次调用一个方法时， Spring可能只计算一次静态切点，在这之后，无需在使用每个方法调用时都评估切点。</p><p>本节的其余部分描述了Spring中包含的一些静态切点实现。</p><h6 id="正则表达式切点"><a href="#正则表达式切点" class="headerlink" title="正则表达式切点"></a>正则表达式切点</h6><p>指定静态切入点的一个显而易见的实现是正则表达式，几个基于Spring的AOP框架让这成为可能。 <code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是一个通用的正则表达式切点，它使用JDK中的正则表达式支持。</p><p>使用<code>JdkRegexpMethodPointcut</code>类，可以提供一个匹配的Strings列表。如果其中任意一个都是匹配的，则切点将计算将为true（因此，结果实际上是这些切点的并集）。</p><p>以下示例显示如何使用<code>JdkRegexpMethodPointcut</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;settersAndAbsquatulatePointcut&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;patterns&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*set.*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*absquatulate<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring提供了一个方便使用的类 -<code>RegexpMethodPointcutAdvisor</code>。 它允许引用<code>Advice</code>（记住<code>Advice</code>可能是一个拦截器、前置通知、异常通知等等）。 而在这个类的后面，Spring也是使用<code>JdkRegexpMethodPointcut</code>类的。使用<code>RegexpMethodPointcutAdvisor</code>来简化织入，用作bean封装的切点和通知。如下例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;settersAndAbsquatulateAdvisor&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;advice&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;beanNameOfAopAllianceInterceptor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;patterns&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*set.*<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>.*absquatulate<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>您可以将<code>RegexpMethodPointcutAdvisor</code> 与任何<code>Advice</code>类型一起使用。</p><h6 id="基于属性的切点"><a href="#基于属性的切点" class="headerlink" title="基于属性的切点"></a>基于属性的切点</h6><p>静态切点的一个重要特征是元数据驱动的切点。它将使用元数据属性的值，通常是使用源等级的元数据。</p><h5 id="动态的切点"><a href="#动态的切点" class="headerlink" title="动态的切点"></a>动态的切点</h5><p>与静态切点相比，动态切点的评估成本更高。它们考虑了方法参数和静态信息。 这意味着必须使用每个方法调用来评估它们，并且不能缓存结果，因为参数会有所不同。</p><p>主要的例子是<code>control flow</code> 切点</p><h6 id="控制流切点"><a href="#控制流切点" class="headerlink" title="控制流切点"></a>控制流切点</h6><p>Spring控制流切点在概念上类似于AspectJ的<code>cflow</code>切点，虽然功能不够它的强大 （目前没有办法指定切点在另一个切点匹配的连接点下面执行）。 控制流切点与当前调用的栈相匹配。例如，如果连接点是由<code>com.mycompany.web</code>包中的方法或<code>SomeCaller</code>类调用的，则可能会触发它。 使用 <code>org.springframework.aop.support.ControlFlowPointcut</code>类指定控制流切点。</p><p>在运行时评估控制流切点的成本远远高于其他动态切点。 在Java 1.4中，成本大约是其他动态切入点的五倍。</p><h4 id="3-1-5-切点超类"><a href="#3-1-5-切点超类" class="headerlink" title="3.1.5. 切点超类"></a>3.1.5. 切点超类</h4><p>Spring提供了相当有用的切点超类,帮助开发者实现自定义切点.</p><p>因为静态切点最有用,所以可能会继承<code>StaticMethodMatcherPointcut</code>.编写子类。 这需要只实现一个抽象方法（尽管您可以覆盖其他方法来自定义行为）。 以下示例显示如何子类化 <code>StaticMethodMatcherPointcut</code>:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStaticPointcut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StaticMethodMatcherPointcut</span> </span>&#123;<br>    public boolean matches(<span class="hljs-type">Method</span> m, <span class="hljs-type">Class</span> targetClass) &#123;        <span class="hljs-comment">// return true if custom criteria match    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这也是动态切点的超类</p><p>您可以在Spring 1.0 RC2及更高版本中使用任何通知类型的自定义切点。</p><h4 id="3-1-6-自定义切点"><a href="#3-1-6-自定义切点" class="headerlink" title="3.1.6.自定义切点"></a>3.1.6.自定义切点</h4><p>由于Spring AOP中的切点是Java类,而不是语言功能(如AspectJ),因此可以声明自定义切点,无论是静态的还是动态的.Spring中的自定义切点可以是任意复杂的。 但是,尽量建议使用AspectJ切点表达式语言。</p><p>Later versions of Spring may offer support for “semantic pointcuts” as offered by JAC — for example, “all methods that change instance variables in the target object.”</p><h3 id="3-2-Spring的通知API"><a href="#3-2-Spring的通知API" class="headerlink" title="3.2. Spring的通知API"></a>3.2. Spring的通知API</h3><p>接下来介绍Spring AOP是怎么样处理通知的</p><h4 id="3-2-1-通知的生命周期"><a href="#3-2-1-通知的生命周期" class="headerlink" title="3.2.1. 通知的生命周期"></a>3.2.1. 通知的生命周期</h4><p>每个通知都是Spring bean.通知实例可以在所有通知对象之间共享，或者对每个通知对象都是唯一的。 这对应于每个类或每个实例的通知。</p><p>单类（Per-class) 通知是最常用的。它适用于诸如事务通知者之类的一般性通知。它不依赖于代理对象的状态或添加新状态，它们只是对方法和参数产生作用.</p><p>单实例（Per-instance）的通知适合于引入,以支持混合使用.在这种情况下,通知将状态添加到代理对象中。</p><p>在同一个AOP代理中，可以使用混合共享的和单实例的通知。</p><h4 id="3-2-2-Spring中的通知类型"><a href="#3-2-2-Spring中的通知类型" class="headerlink" title="3.2.2. Spring中的通知类型"></a>3.2.2. Spring中的通知类型</h4><p>Spring提供了几种通知类型，并且可以扩展以支持任意通知类型。 本节介绍基本概念和标准通知类型。</p><h5 id="拦截环绕通知"><a href="#拦截环绕通知" class="headerlink" title="拦截环绕通知"></a>拦截环绕通知</h5><p>在Spring中,最基础的通知类型是拦截环绕通知.</p><p>Spring使用方法拦截来满足AOP<code>Alliance</code> 接口的要求. <code>MethodInterceptor</code>实现环绕通知应该实现以下接口:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">MethodInterceptor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Interceptor</span> &#123;<br>    Object invoke(MethodInvocation invocation) throws Throwable;&#125;<br></code></pre></td></tr></table></figure><p><code>invoke()</code> 方法的参数<code>MethodInvocation</code> 公开了将要被触发的方法,目标连接点,AOP代理,以及方法的参数。<code>invoke()</code> 方法应该返回调用的结果：连接点的返回值。</p><p>以下示例显示了一个简单的<code>MethodInterceptor</code>实现:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DebugInterceptor implements MethodInterceptor &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> invoke(MethodInvocation invocation) throws Throwable &#123;        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Before: invocation=[&quot; + invocation + &quot;]&quot;);        <span class="hljs-keyword">Object</span> rval = invocation.proceed();        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Invocation returned&quot;);        <span class="hljs-keyword">return</span> rval;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>请注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。proceed从拦截器链上进入连接点。大多数拦截器调用此方法并返回其返回值。但是， 与任意的环绕通知一样， <code>MethodInterceptor</code>可以返回不同的值或引发异常，而不是调用proceed方法。但是，如果没有充分的理由，您不希望这样做。</p><p><code>MethodInterceptor</code> 提供与其他AOP Alliance兼容的AOP实现。本节其余部分讨论的其他通知类型实现了常见的AOP概念，但这特定于使用Spring的方式。 尽管使用最具体的通知类型切面总是有优势的，但如果希望在另一个AOP框架中运行该切面面，，则应坚持使用<code>MethodInterceptor</code>的通知。请注意，目前切点不会在框架之间进行交互操作， 并且目前的AOP Alliance并没有定义切点接口。</p><h5 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h5><p>前置通知是一种简单的通知，它并不需要<code>MethodInvocation</code>对象，因为它只会在执行方法前调用。</p><p>前置通知的主要优势就是它没有必要去触发<code>proceed()</code>方法，因此当拦截器链失败时对它是没有影响的。</p><p>以下清单显示了<code>MethodBeforeAdvice</code>接口:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodBeforeAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeforeAdvice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method m, Object[] args, Object <span class="hljs-keyword">target</span>)</span> <span class="hljs-keyword">throws</span> Throwable</span>;&#125;<br></code></pre></td></tr></table></figure><p>(Spring的API设计允许前置通知使用在域上，尽管通常是适用于字段拦截的，而 Spring也不可能实现它）。</p><p>注意before方法的返回类型是<code>void</code>的。前置通知可以在连接点执行之前插入自定义行为，但不能更改返回值。如果前置通知抛出了异常， 将会中止拦截器链的进一步执行，该异常将会传回给拦截器链。如果它标记了unchecked，或者是在触发方法的签名上，那么它将直接传递给客户端。否则，它由AOP代理包装在未经检查的异常中。</p><p>以下示例显示了Spring中的前置通知，该通知计算所有方法调用:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingBeforeAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method m, Object[] args, Object <span class="hljs-keyword">target</span>)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        ++count;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>前置通知可以用在任意的切点上</p><h5 id="异常通知"><a href="#异常通知" class="headerlink" title="异常通知"></a>异常通知</h5><p>异常通知是在连接点返回后触发的，前提是连接点抛出了异常。Spring提供了类型化的抛出通知。请注意，这意味着<code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。 它只是标识给定对象实现一个或多个类型化异常通知方法的标识接口,这些应该是以下形式:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">afterThrowing([<span class="hljs-keyword">Method</span>, <span class="hljs-title function_">args</span>, <span class="hljs-title function_">target</span>], <span class="hljs-title function_">subclassOfThrowable</span>)<br></code></pre></td></tr></table></figure><p>这个方法只有最后一个参数是必需的。方法签名可以有一个或四个参数，具体取决于通知方法是否对方法和参数有影响。 接下来的两个列表显示了作为异常通知示例的类。.</p><p>如果抛出<code>RemoteException</code>（包括子类），则调用以下通知:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">RemoteThrowsAdvice</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">ThrowsAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> afterThrowing(RemoteException ex) throws Throwable &#123;        <span class="hljs-comment">// Do something with remote exception    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>与前面的通知不同，下一个示例声明了四个参数，以便它可以访问被调用的方法，方法参数和目标对象。 如果抛出<code>ServletException</code>，则调用以下通知：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletThrowsAdviceWithArguments</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThrowsAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">afterThrowing</span>(<span class="hljs-params">Method m, <span class="hljs-built_in">Object</span>[] args, <span class="hljs-built_in">Object</span> target, ServletException ex</span>) &#123;        <span class="hljs-comment">// Do something with all arguments    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>最后的示例演示了如何在单个类中使用这两种方法,它能处理<code>RemoteException</code>和<code>ServletException</code>异常。任何数量的异常通知方法都可以在单个类中进行组合。以下清单显示了最后一个示例:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> CombinedThrowsAdvice <span class="hljs-keyword">implements</span> ThrowsAdvice <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    public void afterThrowing(RemoteException ex) throws Throwable &#123;        // Do something with remote exception    &#125;</span><br>    <span class="hljs-keyword">public</span> void afterThrowing(<span class="hljs-keyword">Method</span> <span class="hljs-title function_">m</span>, <span class="hljs-title function_">Object</span>[] <span class="hljs-title function_">args</span>, <span class="hljs-title function_">Object</span> <span class="hljs-title function_">target</span>, <span class="hljs-title function_">ServletException</span> <span class="hljs-title function_">ex</span>) <span class="hljs-comment">&#123;        // Do something with all arguments    &#125;</span>&#125;<br></code></pre></td></tr></table></figure><p>如果异常通知方法引发了异常，那么它将会重写原始的异常（即更改为向用户抛出异常）。覆盖异常通常是RuntimeException，它与任何方法签名兼容。 但是，如果异常通知方法引发了checked异常，那么它必须与目标方法的已声明的异常相匹配，因此在某种程度上耦合到特定的目标方法签名。不要抛出与目标方法签名不兼容的未声明的checked异常！</p><p>异常通知可以被用在任意切点上</p><h5 id="后置返回通知"><a href="#后置返回通知" class="headerlink" title="后置返回通知"></a>后置返回通知</h5><p>Spring中使用后置返回通知必需实现<code>org.springframework.aop.AfterReturningAdvice</code> 接口, 如下所示:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AfterReturningAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Advice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method m, Object[] args, Object <span class="hljs-keyword">target</span>)</span>            <span class="hljs-keyword">throws</span> Throwable</span>;&#125;<br></code></pre></td></tr></table></figure><p>后置返回通知可以访问返回值（不能修改）、调用的方法、方法参数和目标。</p><p>下面例子的后置返回通知会统计所有成功的、不引发异常的方法调用次数:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingAfterReturningAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method m, Object[] args, Object <span class="hljs-keyword">target</span>)</span>            <span class="hljs-keyword">throws</span> Throwable </span>&#123;        ++count;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>此通知不会更改执行路径，如果抛出异常，将抛出拦截器链而不是返回值。</p><p>后置返回通知能被任何切点使用</p><h5 id="引入通知"><a href="#引入通知" class="headerlink" title="引入通知"></a>引入通知</h5><p>Spring将引入通知看作是一种特殊的拦截器通知</p><p>引入通知需要<code>IntroductionAdvisor</code> 和<code>IntroductionInterceptor</code>，他们都实现了下面的接口:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IntroductionInterceptor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">MethodInterceptor</span> &#123;<br>    <span class="hljs-built_in">bool</span>ean implementsInterface(Class <span class="hljs-built_in">int</span>f);&#125;<br></code></pre></td></tr></table></figure><p>从AOP Alliance <code>MethodInterceptor</code>接口继承的<code>invoke()</code>方法也都必须实现引入。即如果invoked方法是一个引入接口， 引入拦截器将会负责处理这个方法的调用-它无法触发<code>proceed()</code>。</p><p>引入通知不能与任何切点一起使用，因为它只适用于类级别，而不是方法级别。开发者只能使用<code>IntroductionAdvisor</code>的引入通知，它具有以下方法:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IntroductionAdvisor</span> <span class="hljs-title">extends</span> <span class="hljs-title">Advisor</span>, <span class="hljs-title">IntroductionInfo</span> &#123;<br>    <span class="hljs-function">ClassFilter <span class="hljs-title">getClassFilter</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validateInterfaces</span>() throws IllegalArgumentException</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IntroductionInfo</span> &#123;<br>    <span class="hljs-function">Class[] <span class="hljs-title">getInterfaces</span>()</span>;&#125;<br></code></pre></td></tr></table></figure><p>在这里如果没有与<code>MethodMatcher</code> 相关的引入通知类。也就不会有<code>Pointcut</code> 。此时，只有filtering类是符合逻辑的。</p><p><code>getInterfaces()</code>方法返回通知者的引入接口</p><p><code>validateInterfaces()</code>方法在内部使用，可以查看引入接口是否可以由配置的 <code>IntroductionInterceptor</code>实现。</p><p>考虑Spring测试套件中的一个示例，并假设我们要将以下接口引入一个或多个对象:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Lockable</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br><br>    <span class="hljs-function">boolean <span class="hljs-title">locked</span>()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个说明是混合型的。我们希望可以将无论是什么类型的通知对象都转成<code>Lockable</code>,这样可以调用它的lock和unlock方法。如果调用的是<code>lock()</code>方法，希望所有的setter方法都抛出LockedException异常。 因此，可以添加一个切面，它提供了对象不可变的能力，而不需要对它有任何了解。AOP的一个很好的例子t: a good example of AOP.</p><p>首先，我们需要一个可以完成繁重工作的<code>IntroductionInterceptor</code>。在这种情况下，我们扩展了<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>类更方便。 我们可以直接实现<code>IntroductionInterceptor</code>，但使用<code>DelegatingIntroductionInterceptor</code>最适合大多数情况。</p><p><code>DelegatingIntroductionInterceptor</code> 设计是为了将引入委托让给引入接口真正的实现类，从而隐藏了拦截器去做这个事。可以使用构造函数参数将委托设置为任何对象。 默认委托（当使用无参数构造函数时）时是 <code>this</code>的。 因此，在下面的示例中， 委托是<code>DelegatingIntroductionInterceptor</code> 中的<code>LockMixin</code>子类。 给定一个委托 (默认是它本身）， <code>DelegatingIntroductionInterceptor</code>实例将查找委托(非<code>IntroductionInterceptor</code>）实现的所有接口，并支持对其中任何一个的引入。子类(如 <code>LockMixin</code>）可以调用 <code>suppressInterface(Class intf)</code>方法来控制不应该公开的接口。 但是，无论 <code>IntroductionInterceptor</code>准备支持多少接口，使用<code>IntroductionAdvisor</code>都可以控制实际公开的接口。引入接口将隐藏目标对同一接口的任何实现。</p><p>因此， <code>LockMixin</code> 扩展了<code>DelegatingIntroductionInterceptor</code>并实现了<code>Lockable</code> 本身。 超类自动选择可以支持<code>Lockable</code> 引入，因此我们不需要指定。 我们可以用这种方式引入任意数量的接口。</p><p>请注意使用<code>locked</code> 实例变量，这有效地将附加状态添加到目标对象中。</p><p>以下示例显示了示例<code>LockMixin</code>类:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockMixin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingIntroductionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lockable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> locked;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.locked = <span class="hljs-keyword">true</span>;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.locked = <span class="hljs-keyword">false</span>;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">locked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.locked;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">if</span> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class="hljs-string">&quot;set&quot;</span>) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedException();        &#125;        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">invoke</span><span class="hljs-params">(invocation)</span></span>;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，您不需要覆盖<code>invoke()</code>方法。 <code>DelegatingIntroductionInterceptor</code>实现（如果引入方法则调用<code>delegate</code>方法，否则就对连接点进行操作）通常就足够了。 在本例中，我们需要添加一个检查：如果处于锁定模式，则不能调用setter方法。</p><p>引入通知者是非常简单的，它需要做的所有事情就是持有一个独特的<code>LockMixin</code>实例，并指定引入接口 。 在例子中就是 <code>Lockable</code>。 一个更复杂的示例可能会引用引入拦截器 （被定义为原型），在这种情况下，没有与<code>LockMixin</code>相关的配置，因此我们使用<code>new</code>创建它。 以下示例显示了我们的<code>LockMixinAdvisor</code>类:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockMixinAdvisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultIntroductionAdvisor</span> </span>&#123;<br>    public <span class="hljs-type">LockMixinAdvisor</span>() &#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">LockMixin</span>(), <span class="hljs-type">Lockable</span>.<span class="hljs-keyword">class</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>我们可以非常简单地应用这个通知者，因为它不需要配置。（但是，没有<code>IntroductionAdvisor</code>就不可能使用<code>IntroductionInterceptor</code>。）与通常的引入一样， 通知者必须是个单实例（per-instance），因为它是有状态的。需要为每个通知的对象创建每一个不同的<code>LockMixinAdvisor</code>实例和<code>LockMixin</code>。通知者也包括通知对象状态的一部分</p><p>可以使用 <code>Advised.addAdvisor()</code>方法或在在XML配置中（推荐此法）编写通知者，这与其他任何的通知者一样。下面讨论的所有代理创建选项， 包括自动代理创建，都正确处理了引入和有状态的mixin。</p><h3 id="3-3-Spring中通知者的API"><a href="#3-3-Spring中通知者的API" class="headerlink" title="3.3.Spring中通知者的API"></a>3.3.Spring中通知者的API</h3><p>在Spring中，一个通知者就是一个切面，一个仅包含与单个通知对象关联的切点表达式。</p><p>除了引入是一个特殊的例子外，通知者能够用于所有的通知上。<code>org.springframework.aop.support.DefaultPointcutAdvisor</code>类是最常使用的通知者类。 它可以与<code>MethodInterceptor</code>, <code>BeforeAdvice</code>或<code>ThrowsAdvice</code>一起使用。</p><p>在同一个AOP代理中，可以在Spring中混合使用通知者和通知类型。例如，可以在一个代理配置中同时使用环绕通知、异常通知和前置通知。Spring自动创建必要的拦截链。</p><h3 id="3-4-使用ProxyFactoryBean来创建AOP代理"><a href="#3-4-使用ProxyFactoryBean来创建AOP代理" class="headerlink" title="3.4. 使用ProxyFactoryBean来创建AOP代理"></a>3.4. 使用<code>ProxyFactoryBean</code>来创建AOP代理</h3><p>如果你为业务对象使用Spring IoC容器（一个 <code>ApplicationContext</code> 或 <code>BeanFactory</code>）（同时也应该这么做！）， 那么可能希望用到其中一个Spring的AOP <code>FactoryBean</code>。 （请记住，工厂bean引入了一个间接层，让它创建一个不同类型的对象。）</p><p>Spring AOP支持也使用到了工厂bean</p><p>在Spring中创建AOP代理的基本方法是使用<code>org.springframework.aop.framework.ProxyFactoryBean</code>. 这将完全控制切点和应用的通知及顺序。 但是，如果不需要这样的控制，可以有更简单的选项。</p><h4 id="3-4-1-基础设置"><a href="#3-4-1-基础设置" class="headerlink" title="3.4.1. 基础设置"></a>3.4.1. 基础设置</h4><p><code>ProxyFactoryBean</code>与其他Spring <code>FactoryBean</code> 的实现一样，引入了一个间接层。如果定义了一个名为<code>foo</code>的<code>ProxyFactoryBean</code>， 那么引用<code>foo</code>的对象不是<code>ProxyFactoryBean</code>实例本身，而是由<code>ProxyFactoryBean</code> 实现的<code>getObject()</code> 方法创建的对象。此方法将创建一个用于包装目标对象的AOP代理</p><p>使用<code>ProxyFactoryBean</code>或另一个IoC识别类来创建AOP代理的最重要的好处之一是，它意味着建议和切点也可以由IoC容器管理。这是一个强大的功能，能够实现其他AOP框架无法实现的方法。 例如，通知本身可以引用应用程序对象（除了目标，它应该在任何AOP框架中可用），这得益于依赖注入提供的所有可插入功能。</p><h4 id="3-4-2-JavaBean-属性"><a href="#3-4-2-JavaBean-属性" class="headerlink" title="3.4.2. JavaBean 属性"></a>3.4.2. JavaBean 属性</h4><p>与Spring提供的大多数<code>FactoryBean</code> 实现一样，<code>ProxyFactoryBean</code>类本身就是一个JavaBean。 其属性用于:</p><ul><li>指定需要代理的目标</li><li>指定是否使用CGLIB（稍后介绍，另请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a>）。</li></ul><p>一些关键属性继承自<code>org.springframework.aop.framework.ProxyConfig</code>（Spring中所有AOP代理工厂的超类）。 这些关键属性包括以下内容：</p><ul><li><code>proxyTargetClass</code>: 如果目标类需要代理，而不是目标类的接口时，则为<code>true</code>。如果此属性值设置为true，则会创建CGLIB代理（但另请参阅 <a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a>）。</li><li><code>optimize</code>:控制是否将进一步优化使用CGLIB创建的代理。除非完全了解相关的AOP代理如何处理优化，否则不应草率地使用此设置。目前这只用于CGLIB代理，它对JDK动态代理不起作用。</li><li><code>frozen</code>: 如果代理配置被<code>frozen</code>,则不再允许对配置进行更改。这既可以作为一种轻微的优化，也适用于当不希望调用方在创建代理后能够操作代理（通过<code>Advised</code>接口） 的情况。 此属性的默认值为 <code>false</code>，因此如果允许添加其他的通知的话可以更改。</li><li><code>exposeProxy</code>: 确定当前代理是否应在<code>ThreadLocal</code>中公开，以便目标可以访问它。如果目标需要获取代理，并且<code>exposeProxy</code>属性设置为<code>true</code>。 则目标可以使用<code>AopContext.currentProxy()</code>方法。</li></ul><p><code>ProxyFactoryBean</code>特有的其他属性包括以下内容:</p><ul><li><p><code>proxyInterfaces</code>:字符串接口名称的数组。如果未提供此项，将使用目标类的CGLIB代理（ <a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a>）。</p></li><li><p><code>interceptorNames</code>:要提供的通知者、拦截器或其他通知名称的字符串数组。在先到先得的服务基础上，Ordering（顺序）是重要的。也就是说， 列表中的第一个拦截器将首先拦截调用。</p><p>这些名称是当前工厂中的bean名称，包括来自上级工厂的bean名称。不能在这里提及bean的引用，因为这样做会导致<code>ProxyFactoryBean</code>忽略通知的单例。</p><p>可以追加一个带有星号(<code>*</code>)的拦截器名称。这将导致应用程序中的所有被*匹配的通知者bean的名称都会被匹配上。 您可以在<a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-global-advisors">使用全局通知者</a>中找到使用此功能的示例。</p></li><li><p>singleton:工厂强制返回单个对象，无论调用<code>getObject()</code> 方法多少次。几个<code>FactoryBean</code>的实现都提供了这样的方法。默认值是<code>true</code>。 如果想使用有状态的通知。例如，对于有状态的mixins - 使用原型建议以及单例值<code>false</code>。</p></li></ul><h4 id="3-4-3-基于JDK和基于CGLIB的代理"><a href="#3-4-3-基于JDK和基于CGLIB的代理" class="headerlink" title="3.4.3. 基于JDK和基于CGLIB的代理"></a>3.4.3. 基于JDK和基于CGLIB的代理</h4><p>本节是关于<code>ProxyFactoryBean</code>如何为特定目标对象（即将被代理）选择创建基于JDK或CGLIB的代理的权威性文档。</p><p><code>ProxyFactoryBean</code>关于创建基于JDK或CGLIB的代理的行为在Spring的1.2.x和2.0版本之间发生了变化。 现在， <code>ProxyFactoryBean</code>在自动检测接口方面表现出与 <code>TransactionProxyFactoryBean</code>类相似的语义。</p><p>如果要代理的目标对象的类（以下简称为目标类）未实现任何接口，则创建基于CGLIB的代理。这是最简单的方案，因为JDK代理是基于接口的，没有接口意味着甚至不可能进行JDK代理。 一个简单的例子是插入目标bean，并通过<code>interceptorNames</code>属性指定拦截器列表。请注意，即使<code>ProxyFactoryBean</code>的 <code>proxyTargetClass</code>属性被设置为<code>false</code>，也会创建CGLIB的代理。 （显然，这个false是没有意义的，最好从bean定义中删除，因为它充其量是冗余的，而且是最容易产生混乱）。</p><p>如果目标类实现了一个（或多个）接口，那么所创建代理的类型取决于 <code>ProxyFactoryBean</code>的配置。</p><p>如果<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性已设置为<code>true</code>，则会创建基于CGLIB的代理。这是有道理的，并且符合最少惊喜的原则。 即使<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性已设置为一个或多个完全限定的接口名称，<code>proxyTargetClass</code>属性设置为<code>true</code>这一事实也会导致基于CGLIB的代理生效。</p><p>如果<code>ProxyFactoryBean</code>的 <code>proxyInterfaces</code>属性已设置为一个或多个完全限定的接口名称，则会创建基于JDK的代理。创建的代理实现<code>proxyInterfaces</code>属性中指定的所有接口。 如果目标类恰好实现了比<code>proxyInterfaces</code>属性中指定的更多的接口，那么这一切都很好，但是这些附加接口将不会由返回的代理实现。</p><p>如果<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code>属性具有没有被设置，而目标类确实实现一个或多个接口，则 <code>ProxyFactoryBean</code>将自动检测选择，当目标类实际上至少实现一个接口。 将创建JDK代理。实际上代理的接口将是目标类实现的所有接口。事实上，这与简单地提供了目标类实现到 <code>proxyInterfaces</code> 属性的每个接口的列表相同。但是，这明显减轻了负担，还避免配置错误。</p><h4 id="3-4-4-代理接口"><a href="#3-4-4-代理接口" class="headerlink" title="3.4.4. 代理接口"></a>3.4.4. 代理接口</h4><p>首先看一下<code>ProxyFactoryBean</code> 简单的例子，这个例子包含:</p><ul><li>将被代理的目标bean，下面示例中的 <code>personTarget</code> bean定义</li><li>一个通知者和一个拦截器，用于提供通知.</li><li>指定目标对象( <code>personTarget</code> bean)的AOP代理bean和要代理的接口，以及要应用的通知。</li></ul><p>以下清单显示了该示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personTarget&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tony&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;51&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Custom string property value&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span>    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyInterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mycompany.Person&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;personTarget&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myAdvisor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>debugInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意<code>interceptorNames</code>属性是一个<code>String</code>列表，放拦截器bean的名字或在当前工厂中的通知者。通知者、拦截器、前置、后置返回和异常通知的对象可以被使用。通知者是按顺序排列。</p><p>您可能想知道为什么列表不包含bean引用？理由是如果<code>ProxyFactoryBean</code>的单例属性被设置为<code>false</code>，它必须能够返回独立的代理实例。如果任意的通知者本身是原型的， 那么就需要返回一个独立的实例，所以有必要从工厂获得原型实例。 只保存一个引用是不够的。</p><p>前面显示的<code>person</code> bean定义可以用来代替<code>Person</code>实现，如下所示:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Person person <span class="hljs-operator">=</span> (Person) factory.getBean(<span class="hljs-string">&quot;person&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>与普通Java对象一样，同一IoC上下文中的其他bean可以表达对它的强类型依赖。 以下示例显示了如何执行此操作:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;personUser&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.mycompany.PersonUser&quot;</span>&gt;<br><br>    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;person&quot;</span>&gt;&lt;<span class="hljs-keyword">ref</span> bean=<span class="hljs-string">&quot;person&quot;</span>/&gt;&lt;/<span class="hljs-keyword">property</span>&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>此示例中的<code>PersonUser</code>类将公开类型为 <code>Person</code>的属性。就它而言，可以透明地使用AOP代理来代替“real”的person实现。但是，它的类将是动态代理类。 可以将其转换为<code>Advised</code>的接口（如下所述）：</p><p>通过使用匿名内部bean可以隐藏目标和代理之前的区别，只有<code>ProxyFactoryBean</code>的定义是不同的，包含通知只是考虑到完整性。以下示例显示如何使用匿名内部bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyAdvisor&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Custom string property value&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugInterceptor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyInterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mycompany.Person&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- Use inner bean, not local reference to target --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.PersonImpl&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tony&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;51&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myAdvisor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>debugInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样做的好处是只有一个<code>Person</code>类型的对象，如果想阻止应用程序上下文的用户获得对un-advised对象的引用，或者需要避免使用Spring IoC自动装配的任何含糊不清的情况， 那么这个对象就很有用。<code>ProxyFactoryBean</code>定义是自包含的，这也是一个好处。但是，有时能够从工厂获得un-advised目标可能是一个优势（例如，在某些测试场景中）。。</p><h4 id="3-4-5-代理类"><a href="#3-4-5-代理类" class="headerlink" title="3.4.5. 代理类"></a>3.4.5. 代理类</h4><p>如果需要代理一个类而不是一个或多个接口，又该怎么办?</p><p>考虑上面的例子，没有<code>Person</code>接口，需要给一个没有实现任何业务接口的<code>Person</code>类提供通知。在这种情况下，您可以将Spring配置为使用CGLIB代理而不是动态代理。 简单设置<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code>属性为<code>true</code>。尽管最佳实践是面向接口编程，不是类。但在处理遗留代码时， 通知不实现接口的类的能力可能会非常有用（一般来说，Spring不是规定性的。虽然它可以很容易地应用好的实践，但它避免强制使用特定的方法）。</p><p>如果你愿意，即使有接口，也可以强制使用CGLIB代理。</p><p>CGLIB代理的原理是在运行时生成目标类的子类。Spring配置这个生成的子类用了委托的方法来调用原始的对象，在通知的编织中，子类被用于实现装饰者模式。</p><p>CGLIB代理通常对于用户应当是透明的，然而还有需考虑一些问题：</p><ul><li><code>Final</code>方法不能被advised，因为它们不能被覆盖。</li><li>无需添加CGLIB到项目的类路径中，从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于CGLIB的AOP“开箱即用”，JDK动态代理也是如此。</li></ul><p>CGLIB代理和动态代理之间几乎没有性能差异。 从Spring 1.0开始，动态代理略快一些。 但是，这可能会在未来发生变化。 在这种情况下，性能不应该是决定性的考虑因素。</p><h4 id="3-4-6-使用全局的通知者"><a href="#3-4-6-使用全局的通知者" class="headerlink" title="3.4.6. 使用全局的通知者"></a>3.4.6. 使用全局的通知者</h4><p>通过将星号追加到拦截器名称上，所有与星号前面部分匹配的bean名称的通知者都将添加到通知者链中。如果需要添加一组标准的全局（ “global”）通知者，这可能会派上用场。以下示例定义了两个全局的通知者程序：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;proxy&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;target&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;service&quot;</span>/&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;        &lt;<span class="hljs-built_in">list</span>&gt;            &lt;value&gt;<span class="hljs-keyword">global</span>*&lt;/value&gt;        &lt;/<span class="hljs-built_in">list</span>&gt;    &lt;/<span class="hljs-keyword">property</span>&gt;&lt;/bean&gt;<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;global_debug&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;</span>/&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;global_performance&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.springframework.aop.interceptor.PerformanceMonitorInterceptor&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="3-5-简明的代理定义"><a href="#3-5-简明的代理定义" class="headerlink" title="3.5. 简明的代理定义"></a>3.5. 简明的代理定义</h3><p>特别是在定义事务代理时，最终可能会定义了许多类似的代理。使用父级和子级bean定义以及内部bean定义可以使代理定义变得更简洁和更简明。</p><p>首先为代理创建一个父级的、模板的bean定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionAttributes&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它本身是永远不会被实例化的，因此它实际上可能是不完整的。然后，每个需要创建的代理都是只是一个子级的bean定义，它将代理的目标包装为内部bean定义，因为目标永远不会单独使用。以下示例显示了这样的子bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.MyServiceImpl&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>您可以覆盖父模板中的属性。 在以下示例中，事务传播设置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mySpecialService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;txProxyTemplate&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.MySpecialServiceImpl&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionAttributes&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;get*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;find*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;load*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;store*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请注意，在上面的例子中，通过使用<code>abstract</code>属性显式地将父级的bean定义标记为抽象的（<code>abstract</code>），<a href="https://sca.aliyun.com/learn/spring/core/aop-api/?spm=0.29160081.0.0.51f92e5dCHrGI4#beans-child-bean-definitions">如前所述</a>，这样它就不会被实例化。应用程序上下文（但不是简单的bean工厂）将默认提前实例化所有的单例。 因此，重要的是（至少对于单例bean），如果有一个（父级）bean定义，只打算将它用作模板，而这个定义指定一个类，必须确保将抽象（<code>abstract</code>）属性设置为<code>true</code>， 否则应用程序上下文将实际尝试提前实例化它。</p><h3 id="3-6-使用ProxyFactory编程创建AOP代理"><a href="#3-6-使用ProxyFactory编程创建AOP代理" class="headerlink" title="3.6. 使用ProxyFactory编程创建AOP代理"></a>3.6. 使用<code>ProxyFactory</code>编程创建AOP代理</h3><p>使用Spring以编程的方式创建AOP代理是很容易的。这样允许在不依赖于Spring IoC的情况下使用Spring AOP。</p><p>目标对象实现的接口将自动代理。下面的代码显示了使用一个拦截器和一个通知者创建目标对象的代理的过程：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ProxyFactory factory <span class="hljs-operator">=</span> new ProxyFactory(myBusinessInterfaceImpl)<span class="hljs-comment">;</span><br><br>factory.addAdvice(myMethodInterceptor)<span class="hljs-comment">;</span><br><br>factory.addAdvisor(myAdvisor)<span class="hljs-comment">;</span><br><br>MyBusinessInterface tb <span class="hljs-operator">=</span> (MyBusinessInterface) factory.getProxy()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>第一步是构建一个类型为<code>org.springframework.aop.framework.ProxyFactory</code>的对象。可以使用目标对象创建此对象。 如前面的示例所示，或者在指定的接口中进行代理而不是构造器。</p><p>开发者可以添加通知（使用拦截器作为一种专用的通知）和&#x2F;或通知者，并在<code>ProxyFactory</code>的生命周期中进行操作。如果添加<code>IntroductionInterceptionAroundAdvisor</code>，则可以使代理实现其他接口。</p><p><code>ProxyFactory</code>上还有一些便捷的方法（从<code>AdvisedSupport</code>类继承的），允许开发者添加其他通知类型，例如前置和异常通知。<code>AdvisedSupport</code>是<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>的超类</p><p>将AOP代理创建与IoC框架集成是多数应用程序的最佳实践，因此强烈建议从Java代码中外部配置使用AOP。</p><h3 id="3-7-处理被通知对象"><a href="#3-7-处理被通知对象" class="headerlink" title="3.7.处理被通知对象"></a>3.7.处理被通知对象</h3><p><code>org.springframework.aop.framework.Advised</code>接口对它们进行操作。任何AOP代理都可以转换到这个接口，无论它实现了哪个接口。此接口包括以下方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">Advisor[] getAdvisors();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAdvice</span><span class="hljs-params">(Advice advice)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAdvice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, Advice advice)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAdvisor</span><span class="hljs-params">(Advisor advisor)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAdvisor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, Advisor advisor)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Advisor advisor)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAdvisor</span><span class="hljs-params">(Advisor advisor)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAdvisor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replaceAdvisor</span><span class="hljs-params">(Advisor a, Advisor b)</span> <span class="hljs-keyword">throws</span> AopConfigException</span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isFrozen</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><code>getAdvisors()</code> 方法将返回已添加到工厂中的每个<code>Advisor</code>、拦截器或其他通知类型的通知者。如果添加了<code>Advisor</code>，那么这个索引中的返回的通知者将是添加的对象。 如果添加了拦截器或其他通知类型，那么Spring将在通知者中将一个总是返回<code>true</code>的切点封装。因此，如果添加了 <code>MethodInterceptor</code>，则返回的通知者将是 <code>DefaultPointcutAdvisor</code>返回来的<code>MethodInterceptor</code>和与所有类和方法匹配的切点。</p><p><code>addAdvisor()</code>方法可用于添加任意的<code>Advisor</code>。通常，持有切点和通知的通知者是通用的<code>DefaultPointcutAdvisor</code>类，它可以用于任意通知或切点（但不能用于引入）。</p><p>默认情况下， 即使已经创建了代理，也可以添加或删除通知者或拦截器。唯一的限制是无法添加或删除引入通知者，因为来自工厂的现有代理将不会展示接口的变化。 (开发者可以从工厂获取新的代理，以避免这种问题）。</p><p>将AOP代理转换为通知接口并检查和操作其通知的简单示例 :</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Advised advised = (Advised) myObject;Advisor[] advisors = advised.getAdvisors();<span class="hljs-type">int</span> oldAdvisorCount = advisors.length;<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(oldAdvisorCount + &quot; advisors&quot;);<br>// <span class="hljs-keyword">Add</span> an advice <span class="hljs-keyword">like</span> an interceptor <span class="hljs-keyword">without</span> a pointcut// Will match <span class="hljs-keyword">all</span> proxied methods// Can use <span class="hljs-keyword">for</span> interceptors, <span class="hljs-keyword">before</span>, <span class="hljs-keyword">after</span> <span class="hljs-keyword">returning</span> <span class="hljs-keyword">or</span> throws adviceadvised.addAdvice(<span class="hljs-built_in">new</span> DebugInterceptor());<br>// <span class="hljs-keyword">Add</span> selective advice <span class="hljs-keyword">using</span> a pointcutadvised.addAdvisor(<span class="hljs-built_in">new</span> DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));<br>assertEquals(&quot;Added two advisors&quot;, oldAdvisorCount + <span class="hljs-number">2</span>, advised.getAdvisors().length);<br></code></pre></td></tr></table></figure><p>在生产中修改业务对象的通知是否可取(没有双关语）是值得怀疑的，尽管它是合法的使用案例。但是，它可能在开发中非常有用（例如，在测试中）。有时发现能够以拦截器或其他通知的形式添加测试代码也非常有用， 可以在需要测试的方法调用中获取。（例如，通知可以进入为该方法创建的事务中；例如，在标记要回滚的事务之前运行sql以检查数据库是否已正确更新）。</p><p>根据您创建代理的方式，通常可以设置<code>frozen</code> 标志。在这种情况下，通知的 <code>isFrozen()</code> 方法将返回<code>true</code>，任何通过添加或删除修改通知的尝试都将导致<code>AopConfigException</code>异常。 在某些情况下冻结通知的对象状态的功能很有用（例如，防止调用代码删除安全拦截器）。如果已知的运行时通知不需要修改的话，它也可以在Spring 1.1中使用以获得最好的优化。</p><h3 id="3-8-使用自动代理功能"><a href="#3-8-使用自动代理功能" class="headerlink" title="3.8. 使用自动代理功能"></a>3.8. 使用自动代理功能</h3><p>到目前为止，上面的章节已经介绍了使用<code>ProxyFactoryBean</code>或类似的工厂bean显式地创建AOP代理。</p><p>Spring还支持使用 “auto-proxy”（自动代理） 的bean定义, 允许自动代理选择bean定义.这是建立在Spring的’s “bean post processor”基础上的，它允许修改任何bean定义作为容器加载。</p><p>在这个模式下，可以在XML bean定义文件中设置一些特殊的bean定义，用来配置基础的自动代理。这允许开发者只需声明符合自动代理的目标即可，开发者无需使用<code>ProxyFactoryBean</code>。</p><p>有两种方法可以做到这一点：:</p><ul><li>使用在当前上下文中引用特定bean的自动代理创建器</li><li>自动代理创建的一个特例值得单独考虑：由源代码级别的元数据属性驱动的自动代理创建。</li></ul><h4 id="3-8-1-自动代理bean的定义"><a href="#3-8-1-自动代理bean的定义" class="headerlink" title="3.8.1. 自动代理bean的定义"></a>3.8.1. 自动代理bean的定义</h4><p>本节介绍<code>org.springframework.aop.framework.autoproxy</code> 包提供的自动代理创建器。</p><h5 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a><code>BeanNameAutoProxyCreator</code></h5><p><code>BeanNameAutoProxyCreator</code>类是一个<code>BeanPostProcessor</code>的实现，它会自动为具有匹配文本值或通配符的名称的bean创建AOP代理。以下示例显示如何创建<code>BeanNameAutoProxyCreator</code> bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanNames&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdk*,onlyJdk&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interceptorNames&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>myInterceptor<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与<code>ProxyFactoryBean</code>一样，它拥有<code>interceptorNames</code>属性而不是持有拦截器列表，以便为原型通知者提供正确的行为。通知者和任意的通知类型都可命名为“interceptors”。</p><p>与普通的自动代理一样，使用<code>BeanNameAutoProxyCreator</code>的主要目的是能将相同的配置同时或共享地应用于多个对象，此时配置是最少的。 将声明性事务应用于多个对象是很普遍的例子。</p><p>在上例中，名称匹配的Bean定义（例如<code>jdkMyBean</code> 和 <code>onlyJdk</code>）是带有目标类的、普通的、老式的bean定义。 AOP代理由<code>BeanNameAutoProxyCreator</code>自动创建。相同的通知也适用于所有匹配到的bean。注意，如果使用通知着（而不是上述示例中的拦截器），那么切点可能随bean的不同用处而变化。</p><h5 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a><code>DefaultAdvisorAutoProxyCreator</code></h5><p><code>DefaultAdvisorAutoProxyCreator</code>是另一个更通用、功能更强大的自动代理创建器。它会在当前的上下文中自动用于符合条件的通知者，而无需在自动代理通知者的bean定义中包含特定的bean名称。 它具有<code>BeanNameAutoProxyCreator</code>相同的配置，以及避免重复定义的有点。.</p><p>使用此机制涉及:</p><ul><li>指定<code>DefaultAdvisorAutoProxyCreator</code> bean定义</li><li>在相同或相关上下文中指定任意数量的通知者。注意，这里必须是通知者，而不是拦截器或其他通知类型。这种约束是必需的，因为必须引入对切点的评估， 以检查每个通知是否符合候选bean定义的要求。</li></ul><p><code>DefaultAdvisorAutoProxyCreator</code>将自动评估包含在每个通知者中的切点，以查看它是否适用于每个业务对象（如示例中的<code>businessObject1</code> 和 <code>businessObject2</code> ）的通知（如果有的话）。</p><p>这意味着可以将任意数量的通知者自动用于每个业务对象。如果任意通知者都没有一个切点与业务对象中的任何方法匹配，那么对象将不会被代理。当为新的业务对象添加了bean定义时，如果需要这些对象都将被自动代理。</p><p>一般来说，自动代理具有使调用方或依赖项无法获取un-advised对象的优点。在这个<code>ApplicationContext</code>调用<code>getBean(&quot;businessObject1&quot;)</code>方法将返回AOP代理， 而不是目标业务对象。（前面显示的 “inner bean” 语义也提供了这种好处）。</p><p>以下示例创建一个<code>DefaultAdvisorAutoProxyCreator</code> bean以及本节中讨论的其他元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionInterceptor&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionInterceptor&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customAdvisor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.MyAdvisor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessObject1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.BusinessObject1&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Properties omitted --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessObject2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mycompany.BusinessObject2&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>如果希望对多个业务对象适用相同的通知，那么<code>DefaultAdvisorAutoProxyCreator</code>类会显得非常有用。一旦基础架构已定义，就可以简单地添加新的业务对象， 而不必再设置特定的代理配置。还可以很容易地删除其他切面，例如跟踪或性能监视切面 ， 这样对配置的更改最小。</p><p><code>DefaultAdvisorAutoProxyCreator</code>提供对过滤器（filtering）的支持（使用命名约定，以便只评估某些通知者，允许在同一工厂中使用多个不同配置的AdvisorAutoProxyCreators）和排序。 通知者可以实现<code>org.springframework.core.Ordered</code>接口，以确保正确的排序，如果需要排序的话。 上面的例子中使用的<code>TransactionAttributeSourceAdvisor</code>类具有具有可配置的排序值， 默认的设置是无序的。</p><h3 id="3-9-使用TargetSource实现"><a href="#3-9-使用TargetSource实现" class="headerlink" title="3.9. 使用TargetSource实现"></a>3.9. 使用<code>TargetSource</code>实现</h3><p>Spring提供了<code>TargetSource</code>概念，定义在 <code>org.springframework.aop.TargetSource</code> 接口中。 这个接口用于返回目标对象实现的连接点。 每次AOP代理处理方法调用时，都会要求目标实例进行 <code>TargetSource</code>实现。</p><p>使用Spring AOP的开发者通常无需直接使用<code>TargetSource</code>，一般都是提供了支持池，热部署和用于其他复杂目标的强大手段。 例如，池化的<code>TargetSource</code>可以为每个调用返回一个不同的目标实例，并使用一个池来管理实例。</p><p>如果未指定<code>TargetSource</code>，则使用默认实现来包装本地对象。 每次调用都会返回相同的目标（正如您所期望的那样）。</p><p>将下来介绍Spring提供的标准目标源（target sources），以及如何使用。</p><p>当使用自定义的target source,目标通常需要配置成原型而不是单例的bean定义。 这允许Spring按需时创建新的目标实例</p><h4 id="3-9-1-Hot-swappable-Target-Sources"><a href="#3-9-1-Hot-swappable-Target-Sources" class="headerlink" title="3.9.1. Hot-swappable Target Sources"></a>3.9.1. Hot-swappable Target Sources</h4><p><code>org.springframework.aop.target.HotSwappableTargetSource</code> 的存在是为了允许切换AOP代理的目标。</p><p>改变目标源的目标会立即有效，<code>HotSwappableTargetSource</code>是线程安全的。</p><p>可以通过HotSwappableTargetSource上的<code>swap()</code>方法更改目标，如下所示:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HotSwappableTargetSource swapper <span class="hljs-operator">=</span> (HotSwappableTargetSource) beanFactory.getBean(<span class="hljs-string">&quot;swapper&quot;</span>)<span class="hljs-comment">;</span><br><br>Object oldTarget <span class="hljs-operator">=</span> swapper.swap(newTarget)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了所需的XML定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;initialTarget&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;mycompany.OldTarget&quot;</span>/&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;swapper&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.springframework.aop.target.HotSwappableTargetSource&quot;</span>&gt;    &lt;constructor-arg <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;initialTarget&quot;</span>/&gt;&lt;/bean&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;swappable&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;targetSource&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;swapper&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>前面的<code>swap()</code>方法改变了swappable bean的目标。持有对该bean引用的客户端将不会察觉到目标的更改，但会马上开始处理新目标。</p><p>虽然这个例子没有添加任何通知 ， 也没有必要添加通知来使用<code>TargetSource</code>，当然任意的 <code>TargetSource</code>都可以和任意的通知一起使用。</p><h4 id="3-9-2-创建目标源池"><a href="#3-9-2-创建目标源池" class="headerlink" title="3.9.2. 创建目标源池"></a>3.9.2. 创建目标源池</h4><p>使用池化的目标源为无状态会话EJB提供了类似的编程模型，它维护了相同实例池，调用方法将会释放池中的对象。</p><p>Spring池和SLSB池有一个关键的区别是：Spring池可以应用于任意POJO。和Spring一样，这个服务可以以非侵入的方式应用。</p><p>Spring为Commons Pool 2.2，提供了开箱即用的支持，它提供了一个相当高效的池化实现。开发者需要在应用程序的类路径上添加 <code>commons-pool</code>的jar包来启用此功能。 也可以对<code>org.springframework.aop.target.AbstractPoolingTargetSource</code> to support any other进行子类化来支持任意其它池化的API。</p><p>Commons Pool 1.5+ 的版本也是支持的，但是在Spring Framework 4.2已经过时了。</p><p>以下清单显示了一个示例配置:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;businessObjectTarget&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.mycompany.MyBusinessObject&quot;</span>        scope<span class="hljs-operator">=</span><span class="hljs-string">&quot;prototype&quot;</span>&gt;    ... properties omitted&lt;/bean&gt;<br>&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;poolTargetSource&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.aop.target.CommonsPool2TargetSource&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetBeanName&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;maxSize&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span>/&gt;&lt;/bean&gt;<br>&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;businessObject&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetSource&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;poolTargetSource&quot;</span>/&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;interceptorNames&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;myInterceptor&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>请注意，目标对象 ( 例如示例中的<code>businessObjectTarget</code>)必须是原型的。 这允许<code>PoolingTargetSource</code>能够实现按需创建目标的新实例，用于扩展池。 请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">javadoc of<code>AbstractPoolingTargetSource</code></a>以及用于其属性信息的具体子类。 <code>maxSize</code> 是最基本的，并且始终保证存在。</p><p>在这种情况下, <code>myInterceptor</code> 是需要在相同的IoC上下文中定义的拦截器的名称。但是，无需指定拦截器来使用池。如果只希望使用池化功能而不需要通知，那么可以不设置<code>interceptorNames</code>属性。</p><p>可以对Spring进行配置，以便将任意池对象强制转换到<code>org.springframework.aop.target.PoolingConfig</code> 接口,从而引入公开的，有关池的配置和当前大小的信息。 此时需要像下面这样定义通知者:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;poolConfigAdvisor&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetObject&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;poolTargetSource&quot;</span>/&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetMethod&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;getPoolingConfigMixin&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>这个通知者是通过在<code>AbstractPoolingTargetSource</code>类上调用一个方便的方法获得的，因此可以调用<code>MethodInvokingFactoryBean</code>。通知者的名字（在这里是<code>poolConfigAdvisor</code>）必须包含在拦截器名字的列表中，<code>ProxyFactoryBean</code>公开了池化的对象。</p><p>The cast is defined as follows:</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">PoolingConfig conf = (PoolingConfig) beanFactory.getBea<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;businessObject&quot;</span>);<br><br>System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;Max pool size is &quot;</span> + conf.getMaxSize());<br></code></pre></td></tr></table></figure><p>池化的无状态服务对象一般是没有必要的。一般这种选择不是默认的，因为大多数无状态的对象本质上是线程安全的，并且如果资源是缓存的话，其实例池化是有问题的。</p><p>使用自动代理可以创建更简单的池，可以设置任何自动代理创建者使用的<code>TargetSource</code> 。</p><h4 id="3-9-3-原型目标源"><a href="#3-9-3-原型目标源" class="headerlink" title="3.9.3. 原型目标源"></a>3.9.3. 原型目标源</h4><p>设置“prototype” 目标源与合并<code>TargetSource</code>类似。在这种情况下，每个方法调用都会创建一个新的目标实例。 尽管在现代JVM中创建新对象的成本并不高， 但是连接新对象（满足其IoC依赖性）的成本可能会更高。因此，如果没有很好的理由，不应该使用这种方法。</p><p>为此, 可以修改上面显示的 <code>poolTargetSource</code> 定义，如下所示（为清晰起见，我们还更改了名称）：:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;prototypeTargetSource&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.aop.target.PrototypeTargetSource&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetBeanName&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>唯一的属性是目标bean的名称。在<code>TargetSource</code>实现中使用继承来确保一致的命名。与池化目标源一样，目标bean必须是原型bean定义。</p><h4 id="3-9-4-ThreadLocal-的目标源"><a href="#3-9-4-ThreadLocal-的目标源" class="headerlink" title="3.9.4. ThreadLocal 的目标源"></a>3.9.4. <code>ThreadLocal</code> 的目标源</h4><p>如果您需要为每个传入请求创建一个对象（每个线程），<code>ThreadLocal</code>目标源很有用。<code>ThreadLocal</code>的概念提供了一个JDK范围的工具，用于透明地将资源与线程存储在一起。 设置<code>ThreadLocalTargetSource</code>几乎与其他类型的目标源设置一样。如下例所示:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;threadlocalTargetSource&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;org.springframework.aop.target.ThreadLocalTargetSource&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetBeanName&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;businessObjectTarget&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>当在多线程和多类加载器环境中错误地使用它们时，<code>ThreadLocal</code>会带来严重的问题（可能导致内存泄漏）。您应该始终考虑将threadlocal包装在其他类中，并且永远不要直接使用 <code>ThreadLocal</code>本身（除了在包装类中）。 另外，应该始终记得正确设置和取消设置（后者只需调用<code>ThreadLocal.set(null)</code>方法）线程的本地资源。在任何情况下都应该写取消设置，如果不取消将会出问题。 Spring的<code>ThreadLocal</code>支持此设置并且应当被考虑支持使用<code>ThreadLocal</code>而不是手动操作代码。</p><h3 id="3-10-定义新的通知类型"><a href="#3-10-定义新的通知类型" class="headerlink" title="3.10. 定义新的通知类型"></a>3.10. 定义新的通知类型</h3><p>Spring AOP被设计为可扩展的。尽管拦截器实施机制目前只在内部使用，但除了围绕通知拥有开箱即用的拦截器之外，还可以支持任意的通知类型，例如前置、异常和后置返回的通知。</p><p>The <code>org.springframework.aop.framework.adapter</code>包是一个SPI包，允许在不改变核心框架的情况下添加新的自定义通知类型。自定义通知类型的唯一约束是它必须实现 <code>org.aopalliance.aop.Advice</code>标识接口。</p><p>See the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code></a> javadoc for further information.</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP编程(上)</title>
    <link href="/post/6afadaa8-943a-4804-bc56-bcb95040e76e/"/>
    <url>/post/6afadaa8-943a-4804-bc56-bcb95040e76e/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP-编程-上"><a href="#AOP-编程-上" class="headerlink" title="AOP 编程(上)"></a>AOP 编程(上)</h1><p>Spring 教程</p><hr><h2 id="2-使用Spring面向切面编程"><a href="#2-使用Spring面向切面编程" class="headerlink" title="2. 使用Spring面向切面编程"></a>2. 使用Spring面向切面编程</h2><p>面向切面编程(Aspect-oriented Programming 简称AOPAOP) ,是相对面向对象编程(Object-oriented Programming 简称OOP)的框架,作为OOP的一种功能补充. OOP主要的模块单元是类(class)。而AOP则是切面（aspect）。切面会将诸如事务管理这样跨越多个类型和对象的关注点模块化（在AOP的语义中，这类关注点被称为横切关注点（crosscutting））。</p><p>AOP是Spring框架重要的组件，虽然Spring IoC容器没有依赖AOP，因此Spring不会强迫开发者使用AOP。但AOP提供了非常棒的功能，用做对Spring IoC的补充。</p><p>Spring 2.0+ AOP</p><p>Spring 2.0 引入了一种更简单、更强大的方式用来自定义切面，开发者可以选择使用基于模式 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-schema">schema-based approach</a> 的方式或使用<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj">@AspectJ注解风格</a>方式来定义。这两种方式都完全支持通知（Advice）类型和AspectJ的切点语义，虽然实际上仍然是使用Spring AOP织入（weaving）的。</p><p>本章主要讨论Spring 2.0+ 框架对基于模式和基于@AspectJ的AOP支持。<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-api">下一章</a>，将讨论底层的AOP支持，如Spring 1.2应用程序中常见的那样。 The lower-level AOP support, as commonly exposed in Spring 1.2 applications, is discussed in .</p><p>AOP在Spring Framework中用于:</p><ul><li>提供声明式企业服务，特别是用于替代EJB的声明式服务。最重要的服务是<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#transaction-declarative">声明式事务管理</a>（declarative transaction management），这个服务建立在Spring的抽象事务管理（transaction abstraction）之上。</li><li>允许开发者实现自定义切面，使用AOP来完善OOP的功能。</li></ul><p>如果只打算使用通用的声明式服务或者已有的声明式中间件服务，例如缓冲池（pooling）那么可以不直接使用AOP，也可以忽略本章大部分内容。</p><h3 id="2-1-AOP-概念"><a href="#2-1-AOP-概念" class="headerlink" title="2.1. AOP 概念"></a>2.1. AOP 概念</h3><p>让我们从定义一些核心AOP概念和术语开始。 这些术语不是特定于Spring的。 不幸的是，AOP术语不是特别直观。 但是，如果Spring使用自己的术语，那将更加令人困惑。</p><ul><li>切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-schema">schema-based approach</a>）或者在普通类中以<code>@Aspect</code>注解（<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj">@AspectJ 注解方式</a>）来实现。</li><li>连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。</li><li>通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。</li><li>切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。</li><li>引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 <code>IsModified</code>接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。</li><li>目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。</li><li>AOP代理（AOP proxy）:AOP 框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。</li><li>织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。</li></ul><p>Spring AOP包含以下类型的通知:</p><ul><li>前置通知（Before advice）: 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。</li><li>后置返回通知（After returning advice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。</li><li>后置异常通知（After throwing advice）: 在方法抛出异常退出时执行的通知。</li><li>后置通知（总会执行）（After (finally) advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型，。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。</li></ul><p>环绕通知是最常用的一种通知类型。与AspectJ一样，在选择Spring提供的通知类型时，团队推荐开发者尽量使用简单的通知类型来实现需要的功能。例如， 如果只是需要使用方法的返回值来作缓存更新，虽然使用环绕通知也能完成同样的事情，但是仍然推荐使用后置返回通知来代替。使用最合适的通知类型可以让编程模型变得简单， 还能避免很多潜在的错误。例如，开发者无需调用于环绕通知（用<code>JoinPoint</code>）的 <code>proceed()</code>方法，也就不会产生调用的问题。</p><p>在Spring 2.0中，所有通知参数都是静态类型的，因此您可以使用相应类型的通知参数（例如，方法执行的返回值的类型）而不是<code>Object</code>数组。</p><p>切点和连接点匹配是AOP的关键概念，这个概念让AOP不同于其它仅仅提供拦截功能的旧技术。切入点使得通知可以独立于面向对象的层次结构进行定向。 例如，您可以将一个提供声明式事务管理的通知应用于跨多个对象（例如服务层中的所有业务操作）的一组方法。</p><h3 id="2-2-Spring-AOP的功能和目标"><a href="#2-2-Spring-AOP的功能和目标" class="headerlink" title="2.2. Spring AOP的功能和目标"></a>2.2. Spring AOP的功能和目标</h3><p>Spring AOP是用纯Java实现的。 不需要特殊的编译过程。 Spring AOP不需要控制类加载器层次结构，因此适合在servlet容器或应用程序服务器中使用。</p><p>Spring目前仅支持方法调用的方式作为连接点（在Spring bean上通知方法的执行）。虽然可以在不影响到Spring AOP核心API的情况下加入对成员变量拦截器支持， 但Spring并没有实现成员变量拦截器。如果需要通知对成员变量的访问和更新连接点，可以考虑其它语言，例如AspectJ。</p><p>Spring实现AOP的方法与其他的框架不同，Spring并不是要尝试提供最完整的AOP实现（尽管Spring AOP有这个能力），相反地，它其实侧重于提供一种AOP与Spring IoC容器的整合的实现，用于帮助解决在企业级开发中的常见问题。</p><p>因此，例如，Spring Framework的AOP功能通常与Spring IoC容器一起使用。通过使用普通bean定义语法来配置切面（尽管Spring提供了强大的“自动代理”功能）。 这是与其他AOP实现的重要区别。 使用Spring AOP无法轻松或高效地完成某些操作，例如建议非常细粒度的对象（通常是域对象）。 在这种情况下，AspectJ是最佳选择。 但是，我们的经验是，Spring AOP为适合AOP的企业Java应用程序中的大多数问题提供了出色的解决方案。</p><p>Spring AOP从来没有打算通过提供一种全面的AOP解决方案用于取代AspectJ，我们相信，基于代理的框架（如Spring AOP）和完整的框架（如AspectJ）都很有价值，而且它们是互补的，而不是竞争。 Spring将Spring AOP和IoC与AspectJ无缝集成，使得所有的AOP功能完全融入基于Spring的应用体系。这样的集成不会影响Spring AOP API或者AOP Alliance API。 Spring AOP仍然向后兼容。 有关Spring AOP API的讨论，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-api">以下章节</a>。</p><p>Spring框架的一个核心原则是非侵入性。这意味着开发者无需在自身的业务&#x2F;域模型上被迫引入框架特定的类和接口。然而，有些时候，Spring框架可以让开发者选择引入Spring框架特定的依赖关系到业务代码。 给予这种选择的理由是因为在某些情况下它可能是更易读或易于编写某些特定功能。Spring框架（几乎）总能给出这样的选择，开发者可以自由地做出明智的决定，选择最适合的特定用例或场景。</p><p>与本章相关的一个选择是选择哪种AOP框架（以及哪种AOP样式）。您可以选择AspectJ，Spring AOP或两者。也可以选择@AspectJ注解式的方法或Spring的XML配置方式。 事实上，本章以介绍@AspectJ方式为先不应该被视为Spring团队倾向于@AspectJ的方式胜过Spring的XML配置方式。</p><p>请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-choosing">选择要使用的AOP声明样式</a>，以更全面地讨论每种样式的“为什么和如何进行”。</p><h3 id="2-3-AOP-代理"><a href="#2-3-AOP-代理" class="headerlink" title="2.3. AOP 代理"></a>2.3. AOP 代理</h3><p>Spring默认使用标准的JDK动态代理来作为AOP的代理。这样任何接口（或者接口的set）都可以被代理。</p><p>Spring也支持使用CGLIB代理。对于需要代理类而不是代理接口的时候CGLIB代理是很有必要的。如果业务对象并没有实现接口，默认就会使用CGLIB代理 。此外，面向接口编程也是最佳实践，业务对象通常都会实现一个或多个接口。此外，还可以<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-proxying">强制的使用CGLIB代理</a>， 在那些（希望是罕见的）需要通知没有在接口中声明的方法时，或者当需要传递一个代理对象作为一种具体类型到方法的情况下。</p><p>掌握Spring AOP是基于代理的这一事实非常重要。 请参阅 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-understanding-aop-proxies">AOP代理</a>，以全面了解此实现细节的实际含义。.</p><h3 id="2-4-AspectJ注解支持"><a href="#2-4-AspectJ注解支持" class="headerlink" title="2.4.@AspectJ注解支持"></a>2.4.@AspectJ注解支持</h3><p>@AspectJ会将切面声明为常规Java类的注解类型。 <a href="https://www.eclipse.org/aspectj">AspectJ项目</a>引入了@AspectJ风格，并作为AspectJ 5发行版的一部分。Spring使用的注解类似于AspectJ 5， 使用AspectJ提供的库用来解析和匹配切点。AOP运行时仍然是纯粹的Spring AOP，并不依赖AspectJ编译器或编织器。</p><p>使用AspectJ编译器和织入并允许使用全部基于AspectJ语言，并在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-using-aspectj">Using AspectJ with Spring Applications</a>进行了讨论。</p><h4 id="2-4-1-允许-AspectJ的支持"><a href="#2-4-1-允许-AspectJ的支持" class="headerlink" title="2.4.1. 允许@AspectJ的支持"></a>2.4.1. 允许@AspectJ的支持</h4><p>要在Spring配置中使用@AspectJ切面，需要启用Spring支持，用于根据@AspectJ切面配置Spring AOP，并根据这些切面自动代理bean（事先判断是否在通知的范围内）。 通过自动代理的意思是：如果Spring确定一个bean是由一个或多个切面处理的，将据此为bean自动生成代理bean，并以拦截方法调用并确保需要执行的通知。</p><p>可以使用XML或Java配置的方式启用@AspectJ支持。不管哪一种方式，您还需要确保AspectJ的<code>aspectjweaver.jar</code>库位于应用程序的类路径中（版本1.8或更高版本）。此库可在AspectJ分发的<code>lib</code> 目录中或Maven Central存储库中找到。</p><h5 id="使用Java配置启用-AspectJ支持"><a href="#使用Java配置启用-AspectJ支持" class="headerlink" title="使用Java配置启用@AspectJ支持"></a>使用Java配置启用@AspectJ支持</h5><p>要使用Java <code>@Configuration</code>启用@AspectJ支持，请添加 <code>@EnableAspectJAutoProxy</code>注解，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableAspectJAutoProxypublic</span> class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用XML配置启用-AspectJ支持"><a href="#使用XML配置启用-AspectJ支持" class="headerlink" title="使用XML配置启用@AspectJ支持"></a>使用XML配置启用@AspectJ支持</h5><p>要使用基于XML的配置启用@AspectJ支持，请使用 <code>aop:aspectj-autoproxy</code>元素，如以下示例所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;aop:aspectj-<span class="hljs-built_in">auto</span>proxy/&gt;<br></code></pre></td></tr></table></figure><p>这假设您使用<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#xsd-schemas">XML Schema-based configuration</a>中描述的schema支持。 有关如何在aop命名空间中导入标记，请参阅 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#xsd-schemas-aop">在<code>aop</code>aop命名空间中导入标记</a>。</p><h4 id="2-4-2-声明切面"><a href="#2-4-2-声明切面" class="headerlink" title="2.4.2. 声明切面"></a>2.4.2. 声明切面</h4><p>启用了@AspectJ支持后，在应用程序上下文中定义的任意bean（有<code>@Aspect</code>注解）的类都将被Spring自动检测，并用于配置Spring AOP。 接下来的两个示例显示了非常有用的方面所需的最小定义。</p><p>这两个示例中的第一个示例在应用程序上下文中显示了一个常规bean定义，该定义指向具有<code>@Aspect</code>注解的bean类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- configure properties of the aspect here --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这两个示例中的第二个显示了<code>NotVeryUsefulAspect</code>类定义，该定义使用 <code>org.aspectj.lang.annotation.Aspect</code> 注解进行注解;</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> org.xyz;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotVeryUsefulAspect</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>切面（使用 <code>@Aspect</code>的类）可以拥有方法和属性，与其他类并无不同。也可以包括切点、通知和内置类型（即引入）声明。</p><p>通过组件扫描自动检测切面</p><p>您可以在Spring XML配置中将切面类注册为常规bean，或者通过类路径扫描自动检测它们 - 与任何其他Spring管理的bean相同。然而注意到<code>@Aspect</code>注解对于类的自动探测是不够的， 为此，需要单独添加<code>@Component</code> ，注解（或自定义注解声明，用作Spring组件扫描器的规则之一）。</p><p>是否可以作为其他切面的切面通知?</p><p>在Spring AOP中，不可能将切面本身被作为其他切面的目标。类上的<code>@Aspect</code>注解表明他是一个切面并且排除在自动代理的范围之外。</p><h4 id="2-4-3-声明切点"><a href="#2-4-3-声明切点" class="headerlink" title="2.4.3. 声明切点"></a>2.4.3. 声明切点</h4><p>切点决定了匹配的连接点，从而使我们能够控制通知何时执行。Spring AOP只支持使用Spring bean的方法执行连接点，所以可以将切点看出是匹配Spring bean上方法的执行。 切点的声明包含两个部分：包含名称和任意参数的签名，以及明确需要匹配的方式执行的切点表达式。在@AspectJ注解方式的AOP中，一个切点的签名由常规方法定义来提供， 并且切点表达式使用 <code>@Pointcut</code>注解指定（方法作为切点签名必须有类型为<code>void</code>的返回）。</p><p>使用例子有助于更好地区分切点签名和切点表达式之间的关系。以下示例定义名为named <code>anyOldTransfer</code>的切点，该切点与名为<code>transfer</code>的任何方法的执行相匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span><span class="hljs-comment">// the pointcut expression</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">anyOldTransfer</span><span class="hljs-params">()</span> &#123;&#125;<span class="hljs-comment">// the pointcut signature</span><br></code></pre></td></tr></table></figure><p>切点表达式由<code>@Pointcut</code> 注解的值是常规的AspectJ 5切点表达式。关于AspectJ切点语言的描述，见 <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ的编程指南</a> （作为扩展， 请参考<a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5 Developer’s Notebook</a>）或者Colyer著的关于AspectJ的书籍。 例如，<em>Eclipse AspectJ</em>，或者参看Ramnivas Laddad的_AspectJ in Action_。</p><h5 id="支持切点标识符"><a href="#支持切点标识符" class="headerlink" title="支持切点标识符"></a>支持切点标识符</h5><p>Spring AOP支持使用以下AspectJ切点标识符(PCD),用于切点表达式：</p><ul><li><code>execution</code>: 用于匹配方法执行连接点。 这是使用Spring AOP时使用的主要切点标识符。</li><li><code>within</code>: 限制匹配特定类型中的连接点（在使用Spring AOP时，只需执行在匹配类型中声明的方法）。</li><li><code>this</code>: 在bean引用（Spring AOP代理）是给定类型的实例的情况下，限制匹配连接点（使用Spring AOP时方法的执行）。</li><li><code>target</code>: 限制匹配到连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。</li><li><code>args</code>: 限制与连接点的匹配（使用Spring AOP时方法的执行），其中变量是给定类型的实例。 AOP) where the arguments are instances of the given types.</li><li><code>@target</code>: 限制与连接点的匹配（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注解。</li><li><code>@args</code>: 限制匹配连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注解。</li><li><code>@within</code>: 限制与具有给定注解的类型中的连接点匹配（使用Spring AOP时在具有给定注解的类型中声明的方法的执行）。</li><li><code>@annotation</code>:限制匹配连接点（在Spring AOP中执行的方法具有给定的注解）。</li></ul><p>其他切点类型</p><p>Spring并没有完全地支持AspectJ切点语言声明的切点标识符，包括 <code>call</code>, <code>get</code>, <code>set</code>, <code>preinitialization</code>, <code>staticinitialization</code>, <code>initialization</code>, <code>handler</code>, <code>adviceexecution</code>, <code>withincode</code>, <code>cflow</code>, <code>cflowbelow</code>, <code>if</code>, <code>@this</code>, 和 <code>@withincode</code>。在由Spring AOP解释的切点表达式中，使用这些切点标识符将导致<code>IllegalArgumentException</code>异常。</p><p>Spring AOP支持的切点标识符可以在将来的版本中扩展，以支持更多的AspectJ切点标识符。</p><p>因为Spring AOP限制了只匹配方法的连接点执行，所以上面的切点标识符的讨论比在AspectJ编程指南中找到的定义要窄。另外，AspectJ本身具有基于类型的语义， 并且在执行连接点上，<code>this</code>和<code>target</code>都指向同一个对象-即执行方法的对象。Spring AOP是一个基于代理的系统，区分代理对象本身（绑定到<code>this</code>）和代理（绑定到<code>target</code>）后的目标对象。</p><p>由于Spring AOP框架是基于代理的特性，定义的protected方法将不会被处理，不管是JDK的代理（做不到）还是CGLIB代理（有技术可以实现但是不建议）。 因此，任何给定的切点将只能与public方法匹配。</p><p>请注意，切点定义通常与任何截获的方法匹配。 如果切点严格意义上是公开的，即使在通过代理进行潜在非公共交互的CGLIB代理方案中，也需要相应地定义切点。</p><p>如果需要拦截包括protected和private方法甚至是构造函数，请考虑使用基于Spring驱动的<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw">本地AspectJ编织</a>而不是Spring的基于代理的AOP框架。 这构成了不同特性的AOP使用模式，所以在做出决定之前一定要先熟悉一下编织。</p><p>Spring AOP支持更多的PCD命名<code>bean</code>。PCD允许将连接点的匹配限制为特定的Spring bean或一系列Spring bean。 <code>bean</code> PCD具有以下形式：:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">bean</span><span class="hljs-params">(idOrNameOfBean)</span></span><br></code></pre></td></tr></table></figure><p><code>idOrNameOfBean</code>标识可以是任意符合Spring bean的名字， 提供了使用<code>*</code>字符的有限通配符支持，因此，如果为Spring bean建立了一些命名约定，则可以编写<code>bean</code> PCD表达式来选择它们。 与其他切点标识符的情况一样，PCD bean可以是<code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code>。</p><p><code>bean</code> PCD仅在Spring AOP中受支持，而在本机AspectJ编织中不受支持。 它是AspectJ定义的标准PCD的Spring特定扩展，因此不适用于 <code>@Aspect</code> 模型中声明的切面。</p><p>PCD <code>bean</code>运行在实例级别上（基于Spring bean名称概念构建），而不是仅在类型级别（这是基于编织的AOP所限制的）。 基于实例的切点标识符是Spring基于代理的AOP框架的特殊功能，它与Spring bean工厂紧密集成，通过名称识别特定的bean是自然而直接的。</p><h5 id="合并切点表达式"><a href="#合并切点表达式" class="headerlink" title="合并切点表达式"></a>合并切点表达式</h5><p>您可以使用 <code>&amp;&amp;,</code> <code>||</code> 和 <code>!</code>等符号进行合并操作。也可以通过名字来指向切点表达式。 以下示例显示了三个切入点表达式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(public * *(..))&quot;</span>)private void <span class="hljs-built_in">anyPublicOperation</span>() &#123;&#125; (<span class="hljs-number">1</span>)<br><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;within(com.xyz.someapp.trading..*)&quot;</span>)private void <span class="hljs-built_in">inTrading</span>() &#123;&#125; (<span class="hljs-number">2</span>)<br><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;</span>)private void <span class="hljs-built_in">tradingOperation</span>() &#123;&#125; (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><strong>(1)。</strong><code>anyPublicOperation</code>：如果方法执行连接点表示任何公共方法的执行，则匹配</p><p><strong>(2)。</strong><code>inTrading</code> ：如果方法执行在trading中，则匹配.</p><p><strong>(3)。</strong><code>tradingOperation</code> ：如果方法执行表示trading中的任何公共方法，则匹配。</p><p>如上所示，用更小的命名组件构建更复杂的切入点表达式是最佳实践。当按名称引用切点时，将应用普通的Java可见性规则（可以看到相同类型的私有切点，层次结构中受保护的切点，任何位置的公共切点等）。可见性并不影响切点匹配。</p><h5 id="共享通用的切点定义"><a href="#共享通用的切点定义" class="headerlink" title="共享通用的切点定义"></a>共享通用的切点定义</h5><p>在处理企业应用程序时，通常需要从几个切面来引用应用程序的模块和特定的操作集。建议定义一个“SystemArchitecture” 切面，以此为目的捕获通用的切点表达式。这样的切面通常类似于以下示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.xyz</span><span class="hljs-selector-class">.someapp</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.aspectj</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Aspect</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.aspectj</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Pointcut</span>;<br>@<span class="hljs-selector-tag">Aspectpublic</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">SystemArchitecture</span> &#123;<br>    <span class="hljs-comment">/**     * A join point is in the web layer if the method is defined     * in a type in the com.xyz.someapp.web package or any sub-package     * under that.     */</span>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;within(com.xyz.someapp.web..*)&quot;</span>)    public void <span class="hljs-built_in">inWebLayer</span>() &#123;&#125;<br>    <span class="hljs-comment">/**     * A join point is in the service layer if the method is defined     * in a type in the com.xyz.someapp.service package or any sub-package     * under that.     */</span>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;within(com.xyz.someapp.service..*)&quot;</span>)    public void <span class="hljs-built_in">inServiceLayer</span>() &#123;&#125;<br>    <span class="hljs-comment">/**     * A join point is in the data access layer if the method is defined     * in a type in the com.xyz.someapp.dao package or any sub-package     * under that.     */</span>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;within(com.xyz.someapp.dao..*)&quot;</span>)    public void <span class="hljs-built_in">inDataAccessLayer</span>() &#123;&#125;<br>    <span class="hljs-comment">/**     * A business service is the execution of any method defined on a service     * interface. This definition assumes that interfaces are placed in the     * &quot;service&quot; package, and that implementation types are in sub-packages.     *     * If you group service interfaces by functional area (for example,     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;     * could be used instead.     *     * Alternatively, you can write the expression using the &#x27;bean&#x27;     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have     * named your Spring service beans in a consistent fashion.)     */</span>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span>)    public void <span class="hljs-built_in">businessService</span>() &#123;&#125;<br>    <span class="hljs-comment">/**     * A data access operation is the execution of any method defined on a     * dao interface. This definition assumes that interfaces are placed in the     * &quot;dao&quot; package, and that implementation types are in sub-packages.     */</span>    <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;</span>)    public void <span class="hljs-built_in">dataAccessOperation</span>() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样定义的切点可以用在任何需要切点表达式的地方， 例如，要使服务层具有事务性，您可以编写以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span>        <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;com.xyz.someapp.SystemArchitecture.businessService()&quot;</span>        <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;aop:config&gt;</code> and <code>&lt;aop:advisor&gt;</code>元素在 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-schema">基于Schema的AOP 支持</a>中进行了讨论。 <a href="https://sca.aliyun.com/learn/spring/core/aop/data-access.html#transaction">事务管理</a>中讨论了事务元素。</p><h5 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h5><p>Spring AOP用户可能最常使用<code>execution</code>切点标识符 ，执行表达式的格式为：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">execution(modifiers-<span class="hljs-built_in">pattern</span>? ret-type-<span class="hljs-built_in">pattern</span> declaring-type-<span class="hljs-built_in">pattern</span>?name-<span class="hljs-built_in">pattern</span>(param-<span class="hljs-built_in">pattern</span>)<br><br>            throws-<span class="hljs-built_in">pattern</span>?)<br></code></pre></td></tr></table></figure><p>除返回类型模式（上面片段中的<code>ret-type-pattern</code> ）以外的所有部件、名称模式和参数模式都是可选的。返回类型模式确定要匹配的连接点的方法的返回类型必须是什么。 通常，可以使用<code>*</code>作为返回类型模式，它匹配任何返回类型。只有当方法返回给定类型时，完全限定的类型名称才会匹配。名称模式与方法名称匹配，可以将<code>*</code>通配符用作名称模式的全部或部分。 如果指定声明类型模式，则需要有后缀 <code>.</code>将其加入到名称模式组件中。参数模式稍微复杂一点。<code>()</code>匹配没有参数的方法。<code>(..)</code>匹配任意个数的参数（0个或多个）。 <code>(*)</code>匹配任何类型的单个参数。<code>(*,String)</code>匹配有两个参数而且第一个参数是任意类型，第二个必须是<code>String</code>的方法。有关更多信息，请参阅AspectJ编程指南的<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义</a>部分。</p><p>以下示例显示了一些常见的切点表达式：</p><ul><li><p>匹配任意公共方法的执行:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">public</span> * *(..))<br></code></pre></td></tr></table></figure></li><li><p>匹配任意以<code>set</code>开始的方法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* set*(..)</span></span>)<br></code></pre></td></tr></table></figure></li><li><p>匹配定义了<code>AccountService</code>接口的任意方法:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(* com.xyz.service.AccountService.*(..)</span></span>)<br></code></pre></td></tr></table></figure></li><li><p>匹配定义在<code>service</code> 包中的任意方法:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">*</span> com.xyz.service.*.*(..))<br></code></pre></td></tr></table></figure></li><li><p>匹配定义在service包和其子包中的任意方法:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">*</span> com.xyz.service..*.*(..))<br></code></pre></td></tr></table></figure></li><li><p>匹配在service包中的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">within</span><span class="hljs-params">(com.xyz.service.*)</span></span><br></code></pre></td></tr></table></figure></li><li><p>匹配在service包及其子包中的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">within</span><span class="hljs-params">(com.xyz.service..*)</span></span><br></code></pre></td></tr></table></figure></li><li><p>匹配代理实现了<code>AccountService</code> 接口的任意连接点（只在Spring AOP中的方法执行）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">this</span><span class="hljs-params">(com.xyz.service.AccountService)</span></span><br></code></pre></td></tr></table></figure><p>‘this’ 常常以捆绑的形式出现. 见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用代理对象。</p></li><li><p>匹配当目标对象实现了<code>AccountService</code>接口的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target</span><span class="hljs-params">(com.xyz.service.AccountService)</span></span><br></code></pre></td></tr></table></figure><p>‘target’ 常常以捆绑的形式出现. 见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用目标对象。</p></li><li><p>匹配使用了单一的参数，并且参数在运行时被传递时可以序列化的任意连接点（只在Spring的AOP中的方法执行）。:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">args</span><span class="hljs-params">(java.io.Serializable)</span></span><br></code></pre></td></tr></table></figure><p>‘args’ 常常以捆绑的形式出现.见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用方法参数。</p><p>注意在这个例子中给定的切点不同于<code>execution(* *(java.io.Serializable))</code>. 如果在运行时传递的参数是可序列化的，则与execution匹配，如果方法签名声明单个参数类型可序列化，则与args匹配。</p></li><li><p>匹配当目标对象有<code>@Transactional</code>注解时的任意连接点（只在Spring AOP中的方法执行）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@<span class="hljs-built_in">target</span>(org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.annotation</span>.Transactional)<br></code></pre></td></tr></table></figure><p>‘@target’ 也可以以捆绑的形式使用.见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用注解对象。</p></li><li><p>匹配当目标对象的定义类型有<code>@Transactional</code>注解时的任意连接点（只在Spring的AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@<span class="hljs-built_in">within</span>(org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.annotation</span>.Transactional)<br></code></pre></td></tr></table></figure><p>‘@within’ 也可以以捆绑的形式使用.见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用注解对象。</p></li><li><p>匹配当执行的方法有<code>@Transactional</code>注解的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@<span class="hljs-built_in">annotation</span>(org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.annotation</span>.Transactional)<br></code></pre></td></tr></table></figure><p>‘@annotation’ 也可以以捆绑的形式使用.见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用注解对象。</p></li><li><p>匹配有单一的参数并且在运行时传入的参数类型有<code>@Classified</code>注解的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@<span class="hljs-built_in">args</span>(com<span class="hljs-selector-class">.xyz</span><span class="hljs-selector-class">.security</span>.Classified)<br></code></pre></td></tr></table></figure><p>‘@args’ 也可以以捆绑的形式使用.见后续的章节讨论如何在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-advice">声明通知</a>中使用注解对象。</p></li><li><p>匹配在名为<code>tradeService</code>的Spring bean上的任意连接点（只在Spring AOP中的方法执行）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">bean</span><span class="hljs-params">(tradeService)</span></span><br></code></pre></td></tr></table></figure></li><li><p>匹配以<code>Service</code>结尾的Spring bean上的任意连接点（只在Spring AOP中方法执行） :</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">bean</span><span class="hljs-params">(*Service)</span></span><br></code></pre></td></tr></table></figure></li></ul><h5 id="编写好的切点"><a href="#编写好的切点" class="headerlink" title="编写好的切点"></a>编写好的切点</h5><p>在编译过程中，AspectJ会尝试和优化匹配性能来处理切点。检查代码并确定每个连接点是否匹配（静态或动态）给定切点是一个代价高昂的过程。（动态匹配意味着无法从静态分析中完全确定匹配， 并且将在代码中放置测试，以确定在运行代码时是否存在实际匹配）。在第一次遇到切点声明时，AspectJ会将它重写为匹配过程的最佳形式。这是什么意思？基本上，切点是在DNF（析取范式）中重写的 ，切点的组成部分会被排序，以便先检查那些比较明确的组件。这意味着开发者不必担心各种切点标识符的性能，并且可以在切点声明中以任何顺序编写。</p><p>但是，AspectJ只能与被它指定的内容协同工作，并且为了获得最佳的匹配性能，开发者应该考虑它们试图实现的目标，并在定义中尽可能缩小匹配的搜索空间。 现有的标识符会自动选择下面三个中的一个 kinded, scoping, 和 contextual:</p><ul><li>Kinded选择特定类型的连接点的标识符: <code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, 和 <code>handler</code>.</li><li>Scoping选择一组连接点的匹配 （可能是许多种类）: <code>within</code> and <code>withincode</code></li><li>Contextual基于上下文匹配 （或可选绑定）的标识符: <code>this</code>, <code>target</code>, and <code>@annotation</code></li></ul><p>一个写得很好的切入点应该至少包括前两种类型（kinded和scoping）。同时contextual标识符或许会被包括如果希望匹配基于连接点上下文或绑定在通知中使用的上下文。 只是提供kinded标识符或只提供contextual标识符器也能够工作，但是可能影响处理性能（时间和内存的使用），浪费了额外的处理和分析时间或空间。scoping标识符可以快速匹配并且使用AspectJ可以快速排除不会被处理的连接点组， 这也说明编写好的切点表达式是很重要的（因为没有明确指定时，它就会Loop Lookup循环匹配）。</p><h4 id="2-4-4-声明通知"><a href="#2-4-4-声明通知" class="headerlink" title="2.4.4. 声明通知"></a>2.4.4. 声明通知</h4><p>通知是与切点表达式相关联的概念，可以在切点匹配的方法之前、之后或之间执行。切点表达式可以是对命名切点的简单引用，也可以是即时声明的切点表达式。</p><h5 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h5><p>您可以使用<code>@Before</code>注解在切面中的通知之前声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Before;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeforeExample</span> &#123;<br>    <span class="hljs-meta">@Before(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doAccessCheck() &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用内置切点表达式，我们可以重写前面的示例，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeforeExample</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAccessCheck</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后置返回通知"><a href="#后置返回通知" class="headerlink" title="后置返回通知"></a>后置返回通知</h5><p>要想用后置返回通知可以在切面上添加<code>@AfterReturning</code>注解:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.AfterReturning;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningExample</span> &#123;<br>    <span class="hljs-meta">@AfterReturning(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doAccessCheck() &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在同一切面中当然可以声明多个通知。在此只是为了迎合讨论的主题而只涉及单个通知。</p><p>有些时候需要在通知中获取实际的返回值。可以使用<code>@AfterReturning</code>，并指定returning字段如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.AfterReturning;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterReturningExample</span> &#123;<br>    <span class="hljs-meta">@AfterReturning(        pointcut=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>,        returning=<span class="hljs-string">&quot;retVal&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doAccessCheck(Object retVal) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>returning</code>属性中使用的名字必须和通知方法中的参数名相关，方法执行返回时，返回值作为相应的参数值传递给advice方法。<code>returning</code>子句还限制只匹配那些返回指定类型的值的方法执行（在本例中为<code>Object</code>，它匹配任何返回值对象）。</p><p>请注意，当使用after-returning的通知时。不能返回不同的引用。</p><h5 id="后置异常通知"><a href="#后置异常通知" class="headerlink" title="后置异常通知"></a>后置异常通知</h5><p>当方法执行并抛出异常时后置异常通知会被执行，需要使用<code>@AfterThrowing</code>注解来定义。如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.AfterThrowing;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterThrowingExample</span> &#123;<br>    <span class="hljs-meta">@AfterThrowing(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doRecoveryActions() &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>开发者常常希望当给定类型的异常被抛出时执行通知，并且也需要在通知中访问抛出的异常。使用<code>throwing</code>属性来限制匹配（如果需要，使用 <code>Throwable</code>作为异常类型），并将引发的异常绑定到通知参数。以下示例显示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.AfterThrowing;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterThrowingExample</span> &#123;<br>    <span class="hljs-meta">@AfterThrowing(        pointcut=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>,        throwing=<span class="hljs-string">&quot;ex&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doRecoveryActions(DataAccessException ex) &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>throwing</code>属性中使用的名字必须和通知方法中的参数名相关。当方法执行并抛出异常时，异常将会传递给通知方法作为相关的参数值。 抛出子句还限制与只引发指定类型的异常（在本例中为<code>DataAccessException</code>）的方法执行的匹配。</p><h5 id="后置通知-总会执行"><a href="#后置通知-总会执行" class="headerlink" title="后置通知(总会执行)"></a>后置通知(总会执行)</h5><p>当匹配方法执行之后后置通知（总会执行）会被执行。这种情况使用<code>@After</code>注解来定义。后置通知必须被准备来处理正常或异常的返回条件。通常用于释放资源等等:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.After;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterFinallyExample</span> &#123;<br>    <span class="hljs-meta">@After(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;</span>)</span>    <span class="hljs-keyword">public</span> void doReleaseLock() &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h5><p>最后一种通知是环绕通知，环绕通知围绕方法执行。可以在方法执行之前和执行之后执行，并且定义何时做什么，甚至是否真正得到执行。如果需要在方法执行之前和之后以线程安全的方式 （例如启动和停止计时器） 共享状态， 则通常会使用环绕通知。总是建议使用最适合要求的通知（即可以用前置通知解决的就不要用环绕通知了）。</p><p>使用<code>@Around</code>注解来定义环绕通知，第一个参数必须是<code>ProceedingJoinPoint</code>类型的。在通知中调用 <code>ProceedingJoinPoint</code>中的 <code>proceed()</code>方法来引用执行的方法。<code>proceed</code>方法也可以被调用传递数组对象- 数组的值将会被当作参数在方法执行时被使用。proceed方法也可以传入 <code>Object[]</code>。 数组中的值在进行时用作方法执行的参数。</p><p>在使用 <code>Object[]</code> 调用时 <code>proceed</code> 的行为与在AspectJ编译器编译的环绕通知进行的行为略有不同。对于使用传统AspectJ语言编写的通知， 传递给<code>proceed</code>的参数数必须与传递给环绕通知的参数数量（不是被连接点处理的参数的数目）匹配，并且传递的值将<code>proceed</code> 在给定的参数位置取代该值绑定到的实体的连接点的原始值（如果现在无法理解 ，请不要担心）。Spring处理的方式是简单的并且基于代理的，会生成更好的匹配语义。现在只需意识到这两种是有这么一点的不同的即可。有一种方法可以编写出100%兼容Spring AOP和AspectJ的匹配， <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-advice-params">在后续的章节中</a>将会讨论通知的参数。</p><p>以下示例显示如何使用around通知：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.<span class="hljs-keyword">annotation</span>.Around;<span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AroundExample</span> &#123;<br>    <span class="hljs-meta">@Around(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>)</span>    <span class="hljs-keyword">public</span> Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;        <span class="hljs-comment">// start stopwatch        Object retVal = pjp.proceed();        // stop stopwatch        return retVal;    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>环绕通知返回的值将会被调用的方法看到，例如，一个简单的缓存切面可以从缓存中返回一个值（如果有的话），如果没有则调用<code>proceed()</code>。 请注意，可以在around通知的主体内调用一次，多次或根本不调用。 所有这些都是合法的。</p><h5 id="通知的参数"><a href="#通知的参数" class="headerlink" title="通知的参数"></a>通知的参数</h5><p>Spring提供了全部类型的通知，这意味着需在通知签名中声明所需的参数（正如上面返回和异常的示例），而不是一直使用 <code>Object[]</code>数组。接着将会看到怎么声明参数以及上下文的值是如何在通知实体中被使用的。 首先，来看看如何编写一般的通知，找出编写通知的法子。</p><h6 id="访问当前的连接点"><a href="#访问当前的连接点" class="headerlink" title="访问当前的连接点"></a>访问当前的<code>连接点</code></h6><p>任何通知方法都可以声明一个类型为 <code>org.aspectj.lang.JoinPoint</code>的参数作为其第一个参数（注意，需要使用around advice来声明一个类型为<code>ProceedingJoinPoint</code>的第一个参数， 它是<code>JoinPoint</code>的一个子类。<code>JoinPoint</code>接口提供很多有用的方法：:</p><ul><li><code>getArgs()</code>: 返回方法参数.</li><li><code>getThis()</code>: 返回代理对象.</li><li><code>getTarget()</code>: 返回目标对象.</li><li><code>getSignature()</code>:返回正在通知的方法的描述.</li><li><code>toString()</code>: 打印方法被通知的有用描述.</li></ul><p>See the <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">javadoc</a> for more detail.</p><h6 id="传递参数给通知"><a href="#传递参数给通知" class="headerlink" title="传递参数给通知"></a>传递参数给通知</h6><p>我们已经看到了如何绑定返回的值或异常值（在返回之后和抛出通知之后使用）。为了在通知代码段中使用参数值，可以使用绑定<code>args</code>的形式。如果在参数表达式中使用参数名代替类型名称， 则在调用通知时，要将相关的参数值当作参数传递。例如，假如在dao操作时将Account对象作为第一个参数传递给通知，并且需要在通知代码段内访问<code>Account</code>，可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateAccount</span><span class="hljs-params">(Account account)</span> &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>切点表达式的<code>args(account,..)</code> 部分有两个目的。p它严格匹配了至少带一个参数的执行方法，并且传递给传递的参数是<code>Account</code>实例。 第二，它使得实际的<code>Account</code>对象通过<code>account</code>参数提供给通知。 parameter, and the argument passed to that parameter is an instance of . Second, it makes the actual object available to the advice through the parameter.</p><p>另一个方法写法就是先定义切点，然后，“provides”<code>Account</code>对象给匹配的连接点，有了连接点，那么引用连接点作为切点的通知就能获得Account对象的值。这看起来如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;</span>)private void <span class="hljs-built_in">accountDataAccessOperation</span>(Account account) &#123;&#125;<br><span class="hljs-variable">@Before</span>(<span class="hljs-string">&quot;accountDataAccessOperation(account)&quot;</span>)public void <span class="hljs-built_in">validateAccount</span>(Account account) &#123;    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>有关更多详细信息，请参阅AspectJ编程指南。</p><p>代理对象( <code>this</code>)，目标对象 ( <code>target</code>)和注解 ( <code>@within</code>, <code>@target</code>, <code>@annotation</code>, and <code>@args</code>)都可以以类似的方式绑定。接下来的两个示例显示如何匹配带有<code>@Auditable</code>注解的注解方法的执行并获取audit代码代码:</p><p>首先是<code>@Auditable</code>注解的定义:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><br>public <span class="hljs-variable">@interface</span> Auditable &#123;<br><br>    <span class="hljs-selector-tag">AuditCode</span> <span class="hljs-selector-tag">value</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后是匹配<code>@Auditable</code>方法通知的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Auditable auditable)</span> &#123;<br><br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="通知参数和泛型"><a href="#通知参数和泛型" class="headerlink" title="通知参数和泛型"></a>通知参数和泛型</h6><p>Spring AOP可以处理类声明和方法参数中使用的泛型。假设如下泛型类型:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Sample</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleGenericMethod</span>(<span class="hljs-params">T param</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sampleGenericCollectionMethod</span>(<span class="hljs-params">Collection&lt;T&gt; param</span>)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>只需将通知参数键入要拦截方法的参数类型，就可以将方法类型的检测限制为某些参数类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(MyType param)</span> &#123;<br><br>    <span class="hljs-comment">// Advice implementation</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>此方法不适用于泛型集合。 因此，您无法按如下方式定义切点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSampleMethod</span><span class="hljs-params">(Collection&lt;MyType&gt; param)</span> &#123;<br><br>    <span class="hljs-comment">// Advice implementation</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理<code>null</code>值。 要实现与此类似的操作，您必须将参数键入<code>Collection&lt;?&gt;</code> 并手动检查元素的类型。</p><h6 id="声明参数的名字"><a href="#声明参数的名字" class="headerlink" title="声明参数的名字"></a>声明参数的名字</h6><p>参数在通知中的绑定依赖于名字匹配，重点在切点表达式中定义的参数名的方法签名上（通知和切点）。参数名称不能通过Java反射获得，因此Spring AOP使用以下策略来确定参数名称：</p><ul><li><p>如果用户已明确指定参数名称，则使用指定的参数名称。通知和切点注解都有一个可选的<code>argNames</code>属性，您可以使用该属性指定带注解的方法的参数名称。 这些参数名称在运行时可用。 以下示例显示如何使用<code>argNames</code>属性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">        argNames=&quot;bean,auditable&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(Object bean, Auditable auditable)</span> &#123;<br><br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br><br>    <span class="hljs-comment">// ... use code and bean</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果第一个参数是<code>JoinPoint</code>, <code>ProceedingJoinPoint</code>, 或 <code>JoinPoint.StaticPart</code> 类型，则可以从<code>argNames</code>属性的值中省略参数的名称。 例如，如果修改前面的通知以接收连接点对象，则<code>argNames</code>属性不需要包含它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">        argNames=&quot;bean,auditable&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(JoinPoint jp, Object bean, Auditable auditable)</span> &#123;<br><br>    <span class="hljs-type">AuditCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> auditable.value();<br><br>    <span class="hljs-comment">// ... use code, bean, and jp</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>对<code>JoinPoint</code>,<code>ProceedingJoinPoint</code>, and <code>JoinPoint.StaticPart</code>类型的第一个参数的特殊处理方便不收集任何其他连接点上下文的通知。 在这种情况下，可以简单地省略<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod()&quot;)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">audit</span><span class="hljs-params">(JoinPoint jp)</span> &#123;<br><br>    <span class="hljs-comment">// ... use jp</span><br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<code>&#39;argNames&#39;</code>属性有点笨拙，所以如果没有指定<code>&#39;argNames&#39;</code>属性，Spring AOP会查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要使用调试信息(<code>&#39;-g:vars&#39;</code>）编译类， 就会出现此信息。使用此标志进行编译的后果是：(1).您的代码将容易被理解(逆向工程。(2). 类文件的大小将会有些大(通常不是什么事)。(3). 对非使用本地变量的优化将不会应用于你的编译器。 换句话说，通过使用此标志构建，您应该不会遇到任何困难。</p><p>如果即使没有调试信息，AspectJ编译器（ajc）也编译了@AspectJ方面，则无需添加 <code>argNames</code>属性，因为编译器会保留所需的信息。</p></li><li><p>如果代码是在没有必要的调试信息的情况下编译的，那么Spring AOP将尝试推断绑定变量与参数的配对（例如，如果在切点表达式中只绑定了一个变量，并且该通知方法只需要一个参数，此时两者匹配是明显的）。 如果给定了可用信息，变量的绑定是不明确的话，则会引发<code>AmbiguousBindingException</code>异常。</p></li><li><p>如果上述所有策略都失败，则抛出<code>IllegalArgumentException</code> 异常。</p></li></ul><h6 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h6><p>前面说过。将描述如何用在Spring AOP和AspectJ中一致的参数中编写<code>proceed</code>处理函数。解决方案是确保建议签名按顺序绑定每个方法参数。 以下示例显示了如何执行此操作：:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Around</span>(<span class="hljs-string">&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot;</span> +<br><br>        <span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot;</span> +<br><br>        <span class="hljs-string">&quot;args(accountHolderNamePattern)&quot;</span>)<br><br><span class="hljs-keyword">public</span> Object preProcessQueryPattern(ProceedingJoinPoint pjp,<br><br>        <span class="hljs-keyword">String</span> accountHolderNamePattern) throws Throwable &#123;<br><br>    <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Pattern</span> = preProcess(accountHolderNamePattern);<br><br>    <span class="hljs-keyword">return</span> pjp.proceed(<span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[] &#123;<span class="hljs-keyword">new</span><span class="hljs-type">Pattern</span>&#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在许多情况下，无论如何都要执行此绑定（如前面的示例所示）。</p><h5 id="通知的顺序"><a href="#通知的顺序" class="headerlink" title="通知的顺序"></a>通知的顺序</h5><p>当多个通知都希望在同一连接点上运行时会发生什么情况？Spring AOP遵循与AspectJ相同的优先级规则来确定通知执行的顺序。拥有最高优先权的通知会途中先”进入”（因此，给定两条前置通知，优先级最高的通知首先运行）。 从连接点”退出”，拥有最高优先级的通知最后才运行（退出）（（因此，如果有两个后置通知，那么拥有最高优先级的将在最后运行（退出））。</p><p>如果在不同切面定义的两个通知都需要在同一个连接点运行，那么除非开发者指定运行的先后，否则执行的顺序是未定义的。 可以通过指定优先级来控制执行顺序。这也是Spring推荐的方式，通过在切面类实现<code>org.springframework.core.Ordered</code>接口或使用<code>Order</code>对其进行注解即可。 如果有两个切面，从<code>Ordered.getValue()</code>（或注解值）返回较低值的方面具有较高的优先级。</p><p>当在同一切面定义的两条通知都需要在同一个连接点上运行时，排序也是未定义的（因为没有办法通过反射检索Javac编译的类的声明顺序） 。考虑将通知方法与一个通知方法合并，根据每个连接点在每个切面类或将通知切分为切面类，可以在切面级别指定顺序。</p><h4 id="2-4-5-引入"><a href="#2-4-5-引入" class="headerlink" title="2.4.5. 引入"></a>2.4.5. 引入</h4><p>引入（作为AspectJ中内部类型的声明）允许切面定义通知的对象实现给定的接口,并代表这些对象提供该接口的实现.</p><p>引入使用<code>@DeclareParents</code>注解来定义,这个注解用于声明匹配拥有新的父类的类型（因此得名）。例如， 给定名为<code>UsageTracked</code> 的接口和名为<code>DefaultUsageTracked</code>的接口的实现，以下切面声明服务接口的所有实现者也实现<code>UsageTracked</code>接口（例如，通过JMX公开统计信息）:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Aspectpublic <span class="hljs-keyword">class</span> <span class="hljs-symbol">UsageTracking</span> &#123;<br>    @DeclareParents(value=<span class="hljs-string">&quot;com.xzy.myapp.service.*+&quot;</span>, defaultImpl=DefaultUsageTracked.class)    <span class="hljs-keyword">public</span> static UsageTracked <span class="hljs-keyword">mixin</span>;<br>    @Before(<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> recordUsage(UsageTracked usageTracked) &#123;        usageTracked.incrementUseCount();    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要实现的接口由注解属性的类型来确定。 <code>@DeclareParents</code>注解的<code>value</code>值是AspectJ类型模式引过来的。注意上面例子中的前置通知， 服务bean可以直接作为<code>UsageTracked</code>接口的实现，如果以编程方式访问bean，您将编写以下内容：:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UsageTracked usageTracked <span class="hljs-operator">=</span> (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-4-6-切面实例化模型"><a href="#2-4-6-切面实例化模型" class="headerlink" title="2.4.6. 切面实例化模型"></a>2.4.6. 切面实例化模型</h4><p>这是一个高级主题。 如果您刚刚开始使用AOP，您可以跳过它直到稍后再了解。</p><p>默认情况下，应用程序上下文中的每个切面都有一个实例。AspectJ将其称为单例实例化模型。 可以使用交替生命周期定义切面。 Spring支持AspectJ的<code>perthis</code>和 <code>pertarget</code>实例化模型（目前不支持<code>percflow, percflowbelow,</code> 和 <code>pertypewithin</code>）。</p><p>您可以通过在<code>@Aspect</code>注解中指定<code>perthis</code>子句来声明相关方面。 请考虑以下示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect(&quot;perthis(com.xyz.myapp.SystemArchitecture.businessService())&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> someState;<br>    <span class="hljs-meta">@Before(com.xyz.myapp.SystemArchitecture.businessService())</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordServiceUsage</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// ...    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中，<code>&#39;perthis&#39;</code>子句的作用是为执行业务服务的每个唯一服务对象创建一个切面实例（每个唯一对象在由切点表达式匹配的连接点处绑定到’this’）。 方法实例是在第一次在服务对象上调用方法时创建的。当服务对象超出范围时，该切面也将超出范围。在创建切面实例之前，它包含的任意通知都不会执行。在创建了切面实例后， 其中声明的通知将在匹配的连接点中执行，但仅当服务对象是此切面关联的通知时才会运行。有关<code>per</code> 子句的更多信息，请参阅AspectJ编程指南。</p><p><code>pertarget</code> 实例化模型的工作方式与<code>perthis</code>完全相同，但它为匹配的连接点处的每个唯一目标对象创建一个切面实例。</p><h4 id="2-4-7-AOP-例子"><a href="#2-4-7-AOP-例子" class="headerlink" title="2.4.7. AOP 例子"></a>2.4.7. AOP 例子</h4><p>现在您已经了解了所有组成部分的工作原理，我们可以将它们放在一起做一些有用的事情.</p><p>由于并发问题（例如，死锁失败者），业务服务的执行有时会失败。如果重试该操作，则可能在下次尝试时成功。对于适合在这种情况下重试的业务服务（不需要返回给用户来解决冲突的幂等操作）。 希望透明地重试该操作，以避免客户端看到<code>PessimisticLockingFailureException</code>异常。这个需求很明显，它跨越了服务层中的多个服务，因此非常适合通过切面来实现。</p><p>因为我们想要重试操作，所以我们需要使用环绕通知，以便我们可以多次调用<code>proceed</code>。 以下清单显示了基本方面的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentOperationExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxRetries</span> <span class="hljs-operator">=</span> DEFAULT_MAX_RETRIES;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxRetries</span><span class="hljs-params">(<span class="hljs-type">int</span> maxRetries)</span> &#123;        <span class="hljs-built_in">this</span>.maxRetries = maxRetries;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.order;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> order)</span> &#123;        <span class="hljs-built_in">this</span>.order = order;    &#125;<br>    <span class="hljs-meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doConcurrentOperation</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">numAttempts</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        PessimisticLockingFailureException lockFailureException;        <span class="hljs-keyword">do</span> &#123;            numAttempts++;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> pjp.proceed();            &#125;            <span class="hljs-keyword">catch</span>(PessimisticLockingFailureException ex) &#123;                lockFailureException = ex;            &#125;        &#125; <span class="hljs-keyword">while</span>(numAttempts &lt;= <span class="hljs-built_in">this</span>.maxRetries);        <span class="hljs-keyword">throw</span> lockFailureException;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，该方面实现了<code>Ordered</code>接口，以便我们可以将切面的优先级设置为高于事务通知（我们每次重试时都需要一个新的事务）。 <code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要的操作是在<code>doConcurrentOperation</code>的环绕通知中。请注意，请注意，目前，我们将重试逻辑应用于每个 <code>businessService()</code>。 尝试执行时，如果失败了，将产生<code>PessimisticLockingFailureException</code>异常，但是不用管它，只需再次尝试执行即可，除非已经用尽所有的重试次数。</p><p>相应的Spring配置如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;aop:aspectj-autoproxy/&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;concurrentOperationExecutor&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;maxRetries&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>为了优化切面以便它只重试幂等操作，我们可以定义以下<code>Idempotent</code>注解:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br>public <span class="hljs-variable">@interface</span> Idempotent &#123;<br><br>    <span class="hljs-comment">// marker annotation</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用它来注解服务操作的实现。对切面的更改只需要重试等幂运算，只需细化切点表达式，以便只匹配<code>@Idempotent</code>操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; &quot; +</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">        &quot;@annotation(com.xyz.myapp.service.Idempotent)&quot;)</span><br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doConcurrentOperation</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-基于Schema的AOP支持"><a href="#2-5-基于Schema的AOP支持" class="headerlink" title="2.5. 基于Schema的AOP支持"></a>2.5. 基于Schema的AOP支持</h3><p>如果您更喜欢基于XML的格式，Spring还支持使用新的<code>aop</code>命名空间标签定义切面。完全相同的切点表达式和通知类型在使用@AspectJ方式时同样得到支持。 因此，在本节中，我们将重点放在新语法上，并将读者引用到上一节（<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj">@AspectJ支持</a>）中的讨论，以了解编写切点表达式和通知参数的绑定。</p><p>要使用本节中描述的aop命名空间标签，您需要导入<code>spring-aop</code> schema，如<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#xsd-schemas">基于XML模式的配置中所述</a>。 有关如何在<code>aop</code>命名空间中导入标记，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#xsd-schemas-aop">the AOP schema</a>。</p><p>在Spring配置中，所有aspect和advisor元素必须放在 <code>&lt;aop:config&gt;</code>元素中（在应用程序上下文配置中可以有多个 <code>&lt;aop:config&gt;</code>元素）。 <code>&lt;aop:config&gt;</code>元素可以包含切点，通知者和切面元素（请注意，这些元素必须按此顺序声明）。</p><p><code>&lt;aop:config&gt;</code>配置样式大量使用了Spring的<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-autoproxy">自动代理</a>机制。如果已经通过使用<code>BeanNameAutoProxyCreator</code> 或类似的类使用了显式的自动代理， 则可能会出现问题（如通知还没被编织）。建议的使用模式是仅使用<code>&lt;aop:config&gt;</code>样式或仅使用<code>AutoProxyCreator</code>样式，并且永远不要混用它们。</p><h4 id="2-5-1-声明切面"><a href="#2-5-1-声明切面" class="headerlink" title="2.5.1.声明切面"></a>2.5.1.声明切面</h4><p>如果使用schema，那么切面只是在Spring应用程序上下文中定义为bean的常规Java对象。在对象的字段和方法中获取状态和行为，并且在XML中获取切点和通知信息。</p><p>您可以使用<a href="aop:aspect">aop:aspect</a>元素声明方面，并使用<code>ref</code>属性引用支持bean，如以下示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span>        ...    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>    ...<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>支持切面的bean（在这种情况下是<code>aBean</code>）当然可以像任何其他Spring bean一样配置和依赖注入。</p><h4 id="2-5-2-声明切点"><a href="#2-5-2-声明切点" class="headerlink" title="2.5.2. 声明切点"></a>2.5.2. 声明切点</h4><p>您可以在<code>&lt;aop:config&gt;</code>元素中声明一个命名切点，让切点定义在多个切面和通知者之间共享。</p><p>表示服务层中任何业务服务执行的切点可以定义如下：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>        <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>切点表达式本身使用的是相同的AspectJ切点表达式语言，如<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj">@AspectJ支持</a>所述。如果使用基于schema的声明样式，则可以引用在切点表达式内的类型(@Aspects)中定义的命名切点 。定义上述切入点的另一种方法如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>        <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设有一个<code>SystemArchitecture</code>的切面（如<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-common-pointcuts">共享通用的切点定义</a>一节所述）。</p><p>切面声明切点与声明top-level切点非常相似，如下例所示：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>            <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>与@AspectJ方面的方法相同，使用基于schema的定义样式声明的切点可能会收集连接点上下文。例如，以下切点将<code>this</code>对象收集为连接点上下文并将其传递给通知：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>            <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..)) <span class="hljs-symbol">&amp;amp;</span><span class="hljs-symbol">&amp;amp;</span> this(service)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;businessService&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;monitor&quot;</span>/&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>必须通过包含匹配名称的参数来声明接收所收集的连接点上下文的通知，如下所示：:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">monitor</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> service</span>) &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在组合切点表达式中， <code>&amp;&amp;</code> 在XML文档中很难处理，因此您可以分别使用 <code>and</code>, <code>or</code>和<code>not</code> 分别用来代替<code>&amp;&amp;</code>, <code>||</code>, 和 <code>!</code> 。例如，以前的切点可以更好地编写如下：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>            <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service..(..)) and this(service)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;businessService&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;monitor&quot;</span>/&gt;</span><br>        ...    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以这种方式定义的切点由其XML <code>id</code>引用，不能用作命名切点以形成复合切点。因此，基于schema定义样式中的命名切点比@AspectJ样式提供的受到更多的限制。</p><h4 id="2-5-3-声明通知"><a href="#2-5-3-声明通知" class="headerlink" title="2.5.3. 声明通知"></a>2.5.3. 声明通知</h4><p>同样的五种通知类型也支持@AspectJ样式，并且它们具有完全相同的语义。</p><h5 id="前置通知-1"><a href="#前置通知-1" class="headerlink" title="前置通知"></a>前置通知</h5><p>前置通知很明显是在匹配方法执行之前被调用， 它通过使用 <a href="aop:before">aop:before</a>元素在<code>&lt;aop:aspect&gt;</code>中声明，如下例所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;beforeExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">before</span>        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        method=<span class="hljs-string">&quot;doAccessCheck&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>这里<code>dataAccessOperation</code> 是在最外层的(<code>&lt;aop:config&gt;</code>)定义的切点id。若要以内联方式定义切点，请将<code>pointcut-ref</code>属性替换为切点属性。如下所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;beforeExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">before</span>        pointcut=<span class="hljs-string">&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;</span>        method=<span class="hljs-string">&quot;doAccessCheck&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>正如我们在讨论@AspectJ样式时所提到的，使用命名切点可以显着提高代码的可读性。</p><p><code>method</code>属性定义的 (<code>doAccessCheck</code>)方法用于通知的代码体内。这个方法包含切面元素所引用的bean。在数据访问操作之前通知会被执行(当然连接点匹配中的切点)， 即切面bean的<code>doAccessCheck</code>方法会被调用。</p><h5 id="后置返回通知-1"><a href="#后置返回通知-1" class="headerlink" title="后置返回通知"></a>后置返回通知</h5><p>在匹配的方法执行正常完成后返回通知运行。 它在 <code>&lt;aop:aspect&gt;</code>中以与前置通知相同的方式声明。 以下示例显示了如何声明它:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;afterReturningExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">after</span>-<span class="hljs-keyword">returning</span>        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        method=<span class="hljs-string">&quot;doAccessCheck&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>与@AspectJ样式一样，可以在通知代码体内获取返回值。为此，使用returning属性定义参数的名字来传递返回值，如以下示例所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;afterReturningExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">after</span>-<span class="hljs-keyword">returning</span>        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        <span class="hljs-keyword">returning</span>=<span class="hljs-string">&quot;retVal&quot;</span>        method=<span class="hljs-string">&quot;doAccessCheck&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p><code>doAccessCheck</code>方法必须声明一个名为<code>retVal</code>的参数，此参数的类型约束匹配的方式与<code>@AfterReturning</code>所描述的相同。例如，您可以按如下方式声明方法签名:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">doAccessCheck</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> retVal</span>) &#123;...<br></code></pre></td></tr></table></figure><h5 id="后置异常通知-1"><a href="#后置异常通知-1" class="headerlink" title="后置异常通知"></a>后置异常通知</h5><p>就是匹配的方法运行抛出异常后后置异常通知会运行，它在<code>&lt;aop:aspect&gt;</code>中使用 after-throwing元素声明。如下例所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;afterThrowingExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">after</span>-throwing        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        method=<span class="hljs-string">&quot;doRecoveryActions&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>与@AspectJ样式一样，可以在通知代码体内获取抛出的异常，使用throwing属性定义参数的名字来传递异常。如以下示例所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;afterThrowingExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">after</span>-throwing        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        throwing=<span class="hljs-string">&quot;dataAccessEx&quot;</span>        method=<span class="hljs-string">&quot;doRecoveryActions&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p><code>doRecoveryActions</code>方法必须声明名为 <code>dataAccessEx</code>的参数。此参数的类型约束匹配的方式与<code>@AfterThrowing</code>所描述的相同。 例如，方法签名可以声明如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">doRecoveryActions</span>(<span class="hljs-params">DataAccessException dataAccessEx</span>) &#123;...<br></code></pre></td></tr></table></figure><h5 id="后置通知-总会执行的"><a href="#后置通知-总会执行的" class="headerlink" title="后置通知(总会执行的)"></a>后置通知(总会执行的)</h5><p>当方法执行完成并退出后，后置通知会被执行(而且是总会被执行)。如以下示例所示:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;afterFinallyExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">after</span>        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;dataAccessOperation&quot;</span>        method=<span class="hljs-string">&quot;doReleaseLock&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><h5 id="环绕通知-1"><a href="#环绕通知-1" class="headerlink" title="环绕通知"></a>环绕通知</h5><p>最后一种通知是环绕通知. 环绕通知 “around” 匹配的方法执行运行。它有机会在方法执行之前和之后进行工作，并确定方法何时、 如何以及甚至是否真正执行。环绕通知经常用于需要在方法执行前或后在线程安全的情况下共享状态（例如开始和结束时间）。确认可使用的通知形式， 要符合最小匹配原则。</p><p>您可以使用<code>aop:around</code>元素声明环绕通知。通知方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型。在通知代码体中，调用<code>ProceedingJoinPoint</code>实现的<code>proceed()</code>会使匹配的方法继续执行。 <code>proceed</code>方法也可以通过传递 <code>Object[]</code>– 数组的值给原方法作为传入参数。有关调用继续使用 <code>Object[]</code>的说明，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-around-advice">环绕通知</a>。 以下示例显示如何在XML中声明通知：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;aop:aspect <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;aroundExample&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;<br>    &lt;aop:<span class="hljs-keyword">around</span>        pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;businessService&quot;</span>        method=<span class="hljs-string">&quot;doBasicProfiling&quot;</span>/&gt;<br>    ...<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p><code>doBasicProfiling</code>通知的运行与@AspectJ示例中的完全相同（当然省略了注解）。如以下示例所示:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">doBasicProfiling</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>    <span class="hljs-comment">// start stopwatch</span><br><br>    Object retVal = pjp.<span class="hljs-keyword">proceed</span>();<br><br>    <span class="hljs-comment">// stop stopwatch</span><br><br>    <span class="hljs-keyword">return</span> retVal;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通知参数"><a href="#通知参数" class="headerlink" title="通知参数"></a>通知参数</h5><p>基于schema的声明样式支持所有类型的通知，其方式与@AspectJ支持的描述相同 - 通过按名称匹配切点参数与通知方法参数相匹配。有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-advice-params">通知参数</a>。 如果希望显式指定通知方法的参数名称（不依赖于前面描述的检测策略）则使用通知元素的<code>arg-names</code>属性来完成这一操作。其处理方式和通知注解中的<code>argNames</code>属性是相同的， 在通知注解中（如<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-advice-params-names">确定参数名称</a>中所述）。 以下示例显示如何在XML中指定参数名称:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;aop:before<br><br>    <span class="hljs-attribute">pointcut</span>=<span class="hljs-string">&quot;com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)&quot;</span><br><br>    <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;audit&quot;</span><br><br>    <span class="hljs-attribute">arg-names</span>=<span class="hljs-string">&quot;auditable&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><code>arg-names</code> 属性接受以逗号分隔的参数名称列表。</p><p>下面是一个基于XSD方式的多调用示例，它说明环绕通知是如何与一些强类型参数共同使用的:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> x.y.service;<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<br>    Person getPerson(<span class="hljs-keyword">String</span> personName, int age);&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFooService</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">FooService</span></span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Person getPerson(<span class="hljs-keyword">String</span> name, int age) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>(name, age);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>接下来定义切面。请注意，<code>profile(..)</code>方法接受许多强类型参数，其中第一个是用于方法调用的连接点。这个参数用于声明<code>profile(..)</code>作为环绕通知来使用，如以下示例所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package x.y;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<span class="hljs-keyword">import</span> org.springframework.util.StopWatch;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SimpleProfiler &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> profile(ProceedingJoinPoint <span class="hljs-keyword">call</span>, String <span class="hljs-type">name</span>, <span class="hljs-type">int</span> age) throws Throwable &#123;        StopWatch clock = <span class="hljs-built_in">new</span> StopWatch(&quot;Profiling for &#x27;&quot; + <span class="hljs-type">name</span> + &quot;&#x27; and &#x27;&quot; + age + &quot;&#x27;&quot;);        try &#123;            clock.<span class="hljs-keyword">start</span>(<span class="hljs-keyword">call</span>.toShortString());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">call</span>.proceed();        &#125; finally &#123;            clock.stop();            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(clock.prettyPrint());        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>最后，下面是为特定连接点执行上述建议所需的XML配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- this is the object that will be proxied by Spring&#x27;s AOP infrastructure --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;personService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.service.DefaultPersonService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- this is the actual advice itself --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;profiler&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.SimpleProfiler&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;profiler&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;theExecutionOfSomePersonServiceMethod&quot;</span>                <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* x.y.service.PersonService.getPerson(String,int))                and args(name, age)&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;theExecutionOfSomePersonServiceMethod&quot;</span>                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;profile&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请考虑以下驱动程序脚本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">import</span> x.y.service.PersonService;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Boot</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;x/y/plain.xml&quot;</span>);        <span class="hljs-type">PersonService</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (PersonService) ctx.getBean(<span class="hljs-string">&quot;personService&quot;</span>);        person.getPerson(<span class="hljs-string">&quot;Pengo&quot;</span>, <span class="hljs-number">12</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>使用这样的Boot类，我们将在标准输出上获得类似于以下内容的输出：:</p><p>StopWatch ‘Profiling for ‘Pengo’ and ‘12”: running time (millis) &#x3D; 0 —————————————– ms % Task name —————————————– 00000 ? execution(getFoo)</p><h5 id="通知的顺序-1"><a href="#通知的顺序-1" class="headerlink" title="通知的顺序"></a>通知的顺序</h5><p>当多个通知需要在同一个连接点（执行方法）执行时，排序规则如<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-advice-ordering">通知排序</a>中所述。 方面之间的优先级是通过将<code>Order</code>注释添加到支持方面的bean或通过让bean实现 <code>Ordered</code>接口来确定的。</p><h4 id="2-5-4-引入"><a href="#2-5-4-引入" class="headerlink" title="2.5.4. 引入"></a>2.5.4. 引入</h4><p>引入（作为AspectJ中内部类型的声明）允许切面定义通知的对象实现给定的接口，并代表这些对象提供该接口的实现。</p><p>您可以在<code>aop:aspect</code>中使用<code>aop:declare-parents</code>元素进行引入。。 您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有父级（因此名称）。 例如，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>的接口的实现，以下方面声明服务接口的所有实现者也实现<code>UsageTracked</code> 接口。 （例如，为了通过JMX公开统计信息。）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;aop:aspect id=&quot;usageTrackerAspect&quot; <span class="hljs-keyword">ref</span>=&quot;usageTracking&quot;&gt;<br>    &lt;aop:<span class="hljs-keyword">declare</span>-parents        <span class="hljs-keyword">types</span>-matching=&quot;com.xzy.myapp.service.*+&quot;        implement-interface=&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;        <span class="hljs-keyword">default</span>-impl=&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;/&gt;<br>    &lt;aop:<span class="hljs-keyword">before</span>        pointcut=&quot;com.xyz.myapp.SystemArchitecture.businessService()            and this(usageTracked)&quot;            <span class="hljs-keyword">method</span>=&quot;recordUsage&quot;/&gt;<br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>然后，支持<code>usageTracking</code>bean的类将包含以下方法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">recordUsage</span>(<span class="hljs-params">UsageTracked usageTracked</span>) &#123;<br><br>    usageTracked.<span class="hljs-title function_">incrementUseCount</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要实现的接口由<code>implement-interface</code>属性确定。<code>types-matching</code>属性的值是AspectJ类型模式。任何匹配类型的bean都将实现<code>UsageTracked</code>接口。 请注意，在前面的示例的通知中，服务bean可以直接用作<code>UsageTracked</code>接口的实现。要以编程方式访问bean，您可以编写以下代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UsageTracked usageTracked <span class="hljs-operator">=</span> (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-5-切面实例化模型"><a href="#2-5-5-切面实例化模型" class="headerlink" title="2.5.5. 切面实例化模型"></a>2.5.5. 切面实例化模型</h4><p>唯一受支持的schema定义的实例化模型是单例模型，在将来的版本中可能支持其他实例化模型。</p><h4 id="2-5-6-通知者"><a href="#2-5-6-通知者" class="headerlink" title="2.5.6. 通知者"></a>2.5.6. 通知者</h4><p>通知者的概念是在Spring 1.2中提出的，能被AOP支持。而在AspectJ中没有等价的概念。通知者就像迷你的切面，包含单一的通知。通知本身可以通过bean来代表，并且必须实现Spring中的<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-api-advice-types">通知类型</a>中描述的通知接口之一， 通知者可以利用AspectJ的切点表达式</p><p>Spring使用<code>&lt;aop:advisor&gt;</code>元素支持通知者概念。通常会看到它与事务性通知一起使用，它在Spring中也有自己的命名空间支持。 以下示例显示了一个通知者:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span>        <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span>        <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;businessService&quot;</span>        <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tx-advice&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了前面示例中使用的<code>pointcut-ref</code>属性之外，您还可以使用切点属性来内联定义切点表达式。</p><p>如果想将通知排序，可以定义通知者的优先级。在通知者上可以使用<code>order</code>属性来定义<code>Ordered</code>值。</p><h4 id="2-5-7-AOP-Schema-例子"><a href="#2-5-7-AOP-Schema-例子" class="headerlink" title="2.5.7. AOP Schema 例子"></a>2.5.7. AOP Schema 例子</h4><p>本节说明如何使用Schema支持重写<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ataspectj-example">An AOP Example</a>示例中的并发锁定失败重试示例。</p><p>由于并发问题（例如，死锁失败者），业务服务的执行有时会失败。如果重试该操作，则可能在下次尝试时成功。对于适合在这种情况下重试的业务服务（不需要返回给用户来解决冲突的幂等操作）。 希望透明地重试该操作，以避免客户端看到<code>PessimisticLockingFailureException</code>异常。这个需求很明显，它跨越了服务层中的多个服务，因此非常适合通过切面来实现。</p><p>因为我们想要重试操作，所以我们需要使用环绕通知，以便我们可以多次调用<code>proceed</code>。 以下清单显示了基本方面的实现（使用Schema支持的常规Java类）:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentOperationExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Ordered</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_MAX_RETRIES = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> maxRetries = DEFAULT_MAX_RETRIES;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">order</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setMaxRetries(<span class="hljs-built_in">int</span> maxRetries) &#123;        <span class="hljs-keyword">this</span>.maxRetries = maxRetries;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> getOrder() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">order</span>;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setOrder(<span class="hljs-built_in">int</span> <span class="hljs-keyword">order</span>) &#123;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">order</span> = <span class="hljs-keyword">order</span>;    &#125;<br>    <span class="hljs-keyword">public</span> Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;        <span class="hljs-built_in">int</span> numAttempts = <span class="hljs-number">0</span>;        PessimisticLockingFailureException lockFailureException;        <span class="hljs-keyword">do</span> &#123;            numAttempts++;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> pjp.proceed();            &#125;            <span class="hljs-keyword">catch</span>(PessimisticLockingFailureException ex) &#123;                lockFailureException = ex;            &#125;        &#125; <span class="hljs-keyword">while</span>(numAttempts &lt;= <span class="hljs-keyword">this</span>.maxRetries);        <span class="hljs-keyword">throw</span> lockFailureException;    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，该方面实现了<code>Ordered</code>接口，以便我们可以将切面的优先级设置为高于事务通知（我们每次重试时都需要一个新的事务）。 <code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要的操作是在<code>doConcurrentOperation</code>的环绕通知中。请注意，请注意，目前，我们将重试逻辑应用于每个 <code>businessService()</code>。 尝试执行时，如果失败了，将产生<code>PessimisticLockingFailureException</code>异常，但是不用管它，只需再次尝试执行即可，除非已经用尽所有的重试次数。</p><p>此类与@AspectJ示例中使用的类相同，但删除了注释。</p><p>相应的Spring配置如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;concurrentOperationRetry&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;concurrentOperationExecutor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;idempotentOperation&quot;</span>            <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span>            <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;idempotentOperation&quot;</span>            <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;doConcurrentOperation&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;concurrentOperationExecutor&quot;</span>    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxRetries&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请注意，在当时，我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入<code>Idempotent</code>注解并使用注解来注解服务操作的实现来优化切面，使其重试时是幂等操作，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br>public <span class="hljs-variable">@interface</span> Idempotent &#123;<br><br>    <span class="hljs-comment">// marker annotation</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>对切面的更改只需要重试等幂运算，只需细化切点表达式，以便只匹配<code>@Idempotent</code>操作，如下所示:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;aop:pointcut <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;idempotentOperation&quot;</span><br><br>        <span class="hljs-attribute">expression</span>=<span class="hljs-string">&quot;execution(* com.xyz.myapp.service.*.*(..)) and</span><br><span class="hljs-string"></span><br><span class="hljs-string">        @annotation(com.xyz.myapp.service.Idempotent)&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="2-6-选择要使用的AOP声明样式"><a href="#2-6-选择要使用的AOP声明样式" class="headerlink" title="2.6. 选择要使用的AOP声明样式"></a>2.6. 选择要使用的AOP声明样式</h3><p>一旦确定某个切面是实现给定需求的最佳方法，您如何决定使用Spring AOP或AspectJ以及Aspect语言（代码）样式， @ AspectJ注解样式还是Spring XML样式？ 这些决策受到许多因素的影响，包括应用程序要求，开发工具和团队对AOP的熟悉程度。</p><h4 id="2-6-1-使用Spring-AOP还是全面使用AspectJ"><a href="#2-6-1-使用Spring-AOP还是全面使用AspectJ" class="headerlink" title="2.6.1. 使用Spring AOP还是全面使用AspectJ?"></a>2.6.1. 使用Spring AOP还是全面使用AspectJ?</h4><p>使用最简单的方法。 Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器&#x2F; 编织器。如果只是需要在Spring bean上执行通知操作，那么使用Spring AOP是正确的选择。 如果需要的通知不是由Spring容器管理的对象（通常是域对象），那么就需要使用AspectJ。如果想使用通知连接点而不是简单的方法执行，也需要使用AspectJ（例如，字段获取或设置连接点等），则还需要使用AspectJ。</p><p>使用AspectJ时，您可以选择AspectJ语言语法（也称为“代码样式”）或@AspectJ注释样式。显然，如果没有使用Java 5+版本那么选择已经确定了…使用代码方式。 如果切面在你的设计中扮演重要角色，并且想使用针对Eclipse的<a href="https://www.eclipse.org/ajdt/">AspectJ开发工具（AJDT）</a> 插件，那么AspectJ语言语法是首选项：它更清晰和更简单，因为语言是专门用于编写切面的。 如果没有使用Eclipse，或者只有一些切面在应用程序中不起主要作用，那么可能需要考虑使用@AspectJ方式，并在IDE中使用常规Java编译，并加入切面编织阶段构建的脚本。</p><h4 id="2-6-2-选择-AspectJ注解还是Spring-AOP的XML配置"><a href="#2-6-2-选择-AspectJ注解还是Spring-AOP的XML配置" class="headerlink" title="2.6.2. 选择@AspectJ注解还是Spring AOP的XML配置?"></a>2.6.2. 选择@AspectJ注解还是Spring AOP的XML配置?</h4><p>如果您选择使用Spring AOP，则可以选择@AspectJ或XML样式。 需要考虑各种权衡。</p><p>XML样式可能是现有Spring用户最熟悉的，并且由真正的POJO支持。当使用AOP作为一种工具来配置企业服务时， XML就是一个很好的选择（可以用以下方法测试：是否认为切入点表达式是想要独立改变的配置的一部分）。 使用XML配置的方式，可以从配置中更清楚地了解系统中存在哪些切面。</p><p>XML样式有两个缺点。首先，它并没有按实现的要求完全封装到单个地方。DRY原则是说：在任何知识系统中，应该有一个单一的、明确的、权威的职责。使用XML的样式时，如果要求的知识是实现拆分的bean类的声明，并且是配置在文件的XML中。 当使用@AspectJ的风格实现单一的模块时，切面的信息是封装的。其次，XML的样式在能表达的功能方面比@AspectJ风格的有更多的限制，只有“singleton”切面的实例化模式得到支持，这在XML声明的切点中是不可能的。 例如，在@AspectJ样式中，您可以编写如下内容:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(* get*())&quot;</span>)public void <span class="hljs-built_in">propertyAccess</span>() &#123;&#125;<br><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;execution(org.xyz.Account+ *(..))&quot;</span>)public void <span class="hljs-built_in">operationReturningAnAccount</span>() &#123;&#125;<br><span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;propertyAccess() &amp;&amp; operationReturningAnAccount()&quot;</span>)public void <span class="hljs-built_in">accountPropertyAccess</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>在XML样式中，您可以声明前两个切入点:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;aop:pointcut <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;propertyAccess&quot;</span>        <span class="hljs-attribute">expression</span>=<span class="hljs-string">&quot;execution(* get*())&quot;</span>/&gt;<br>&lt;aop:pointcut <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;operationReturningAnAccount&quot;</span>        <span class="hljs-attribute">expression</span>=<span class="hljs-string">&quot;execution(org.xyz.Account+ *(..))&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>XML的方法的缺点是，您无法通过组合这些定义来定义<code>accountPropertyAccess</code>切点。</p><p>@AspectJ的风格支持更多的实例化模式和丰富的切点组合。它的优点是将切面确保为单元模块化，@AspectJ的使用对理解切面也很有优势（也很容易接受）， 无论是通过Spring AOP还是AspectJ的使用 。 所以如果决定需要AspectJ的能力解决额外的要求，然后迁移到一个基于AspectJ的方法，是非常简单的。 Spring团队建议使用@AspectJ的方式。</p><h3 id="2-7-混合切面类型"><a href="#2-7-混合切面类型" class="headerlink" title="2.7. 混合切面类型"></a>2.7. 混合切面类型</h3><p>在实际应用中，完全有可能混合使用@AspectJ的切面方式，用于支持自动代理、schema定义<code>&lt;aop:aspect&gt;</code>，<code>&lt;aop:advisor&gt;</code>声明通知者甚至在同一配置中定义使用Spring 1.2 风格的代理和拦截器。所有这些都是使用相同的底层支持机制实现的，并且可以愉快地共存。</p><h3 id="2-8-代理策略"><a href="#2-8-代理策略" class="headerlink" title="2.8. 代理策略"></a>2.8. 代理策略</h3><p>Spring AOP使用JDK动态代理或CGLIB为给定目标对象创建代理。 （只要有选择，JDK动态代理就是首选）。</p><p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。 目标类型实现的所有接口都是代理的。 如果目标对象未实现任何接口，则会创建CGLIB代理。</p><p>如果要强制使用CGLIB代理（例如，代理为目标对象定义的每个方法，而不仅仅是那些由其接口实现的方法），您可以这样做。 但是，您应该考虑以下问题：</p><ul><li><code>final</code> 声明为final的方法不能使用，因为它们不能被覆盖。</li><li>从Spring 3.2开始，不再需要将CGLIB添加到项目类路径中，因为CGLIB类在<code>org.springframework</code>下重新打包并直接包含在spring-core JAR中。这意味着基于CGLIB的代理支持可以像JDK动态代理那样方便地工作。</li><li>从Spring 4.0开始，代理对象的构造函数不再被调用两次，因为CGLIB代理实例是通过Objenesis创建的。只有当JVM不允许构造器绕过时，可能会看到来自Spring AOP的代理支持双重调用以及看到相应的调试日志。</li></ul><p>要强制使用CGLIB代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的值设置为<code>true</code>，如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- other beans defined here... --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要在使用@AspectJ自动代理支持时强制CGLIB代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code> 元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;aop:aspectj-<span class="hljs-built_in">auto</span>proxy proxy-target-<span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">true</span>&quot;/&gt;<br></code></pre></td></tr></table></figure><p>多个<code>&lt;aop:config/&gt;</code>选择被集合到一个统一的自动代理创建器中运行，它使用了一个强代理设置，这些配置是任意 <code>&lt;aop:config/&gt;</code> 的子代码段（通常是来自不同的XML bean定义文件） 。这也适用于<code>&lt;tx:annotation-driven/&gt;</code>和<code>&lt;aop:aspectj-autoproxy/&gt;</code>。</p><p>要明确的是，在<code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素上使用<code>proxy-target-class=&quot;true&quot;</code> &#x3D;“true”会强制使用CGLIB代理 他们。</p><h4 id="2-8-1-理解AOP代理"><a href="#2-8-1-理解AOP代理" class="headerlink" title="2.8.1. 理解AOP代理"></a>2.8.1. 理解AOP代理</h4><p>Spring AOP是基于代理的，在编写自定义切面或使用Spring框架提供的任何基于Spring AOP的切面前，掌握上一个语句的实际语义是非常重要的。</p><p>首先需要考虑的情况如下，假设有一个普通的、非代理的、没有什么特殊的、直接的引用对象。如下面的代码片段所示:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePojo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pojo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// this next method invocation is a direct call on the &#x27;this&#x27; reference        this.bar();    &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// some logic...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图所示：:</p><p><img src="aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Pojo</span> pojo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimplePojo</span>();<br>        <span class="hljs-comment">// this is a direct method call on the &#x27;pojo&#x27; reference        pojo.foo();    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>当客户端代码是代理的引用时，事情发生了细微的变化。请考虑以下图表和代码段:</p><p><img src="aop-proxy-call.png" alt="aop proxy call"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ProxyFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> ProxyFactory(<span class="hljs-keyword">new</span> SimplePojo());        <span class="hljs-keyword">factory</span>.addInterface(Pojo.<span class="hljs-keyword">class</span>);        <span class="hljs-keyword">factory</span>.addAdvice(<span class="hljs-keyword">new</span> RetryAdvice());<br>        Pojo pojo = (Pojo) <span class="hljs-keyword">factory</span>.getProxy();<br>        <span class="hljs-comment">// this is a method call on the proxy!        pojo.foo();    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这里要理解的关键是 <code>Main</code>类的 <code>main(..)</code>方法中的客户端代码具有对代理的引用。这意味着对该对象引用的方法将在代理上调用，因此代理将能够委托与该特定方法调用相关的所有拦截器（通知）。 然而，一旦调用终于达到了目标对象（在这个例子中是<code>SimplePojo</code>引用），任何方法调用都会传递给他，例如<code>this.bar()</code>或<code>this.foo()</code>， 都会调用这个引用，而不是代理。这具有重要的意义，这意味着自我调用不会导致与方法调用相关联的通知，从而也不会获得执行的机会。</p><p>好的，那要做些什么呢？ 最好的方法（这个“最好”的，也是迫不得已的）是重构代码，以便不会发生自我调用。这确实需要您做一些工作，但这是最好的，最少侵入性的方法。 下一个办法绝对是可怕的，我几乎不愿意指出，正是因为它是如此可怕。您可以（对我们来说很痛苦）将类中的逻辑完全绑定到Spring AOP，如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePojo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pojo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// this works, but... gah!        ((Pojo) AopContext.currentProxy()).bar();    &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// some logic...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这完全将代码与AOP相耦合，这使类本身意识到它正在AOP上下文中使用，犹如在AOP面前耍大刀一般。当创建代理时，它还需要一些额外的配置。如以下示例所示:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        ProxyFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> ProxyFactory(<span class="hljs-keyword">new</span> SimplePojo());        <span class="hljs-keyword">factory</span>.adddInterface(Pojo.<span class="hljs-keyword">class</span>);        <span class="hljs-keyword">factory</span>.addAdvice(<span class="hljs-keyword">new</span> RetryAdvice());        <span class="hljs-keyword">factory</span>.setExposeProxy(<span class="hljs-keyword">true</span>);<br>        Pojo pojo = (Pojo) <span class="hljs-keyword">factory</span>.getProxy();<br>        <span class="hljs-comment">// this is a method call on the proxy!        pojo.foo();    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>最后，必须注意的是AspectJ没有这种自我调用问题，因为它不是基于代理的AOP框架。</p><h3 id="2-9-编程创建-AspectJ代理"><a href="#2-9-编程创建-AspectJ代理" class="headerlink" title="2.9. 编程创建@AspectJ代理"></a>2.9. 编程创建@AspectJ代理</h3><p>除了在配置中使用<code>&lt;aop:config&gt;</code>或 <code>&lt;aop:aspectj-autoproxy&gt;</code>来声明切面外，还可以使用编程的方式创建代理的通知目标对象。 有关Spring的AOP API的完整详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-api">下一章</a>。在这里，我们的关注点是希望使用@AspectJ方面自动创建代理的能力。</p><p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> 类为一个或多个@AspectJ切面通知的目标对象创建代理。 此类的基本用法非常简单，如下例所示:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);</span><br><span class="hljs-comment">// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);</span><br><span class="hljs-comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);</span><br><span class="hljs-comment">// now get the proxy object...MyInterfaceType proxy = factory.getProxy();</span><br></code></pre></td></tr></table></figure><p>See the <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">javadoc</a> for more information.</p><h3 id="2-10-在Spring应用中使用AspectJ"><a href="#2-10-在Spring应用中使用AspectJ" class="headerlink" title="2.10. 在Spring应用中使用AspectJ"></a>2.10. 在Spring应用中使用AspectJ</h3><p>到目前为止，我们在本章中介绍的所有内容都是纯粹的Spring AOP。将介绍如何使用AspectJ编译器&#x2F;编织器代替AOP，还介绍了超越Spring AOP而单独提供的功能。</p><p>Spring有一个小的AspectJ切面库，是一个单独管理的<code>spring-aspects.jar</code>包。如果使用到切面那么需要将它添加到类路径中。在<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-atconfigurable">使用Spring中的AspectJ独立注入域对象</a> 和 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-ajlib-other">在Spring中使用的AspectJ另外的切面</a> 会讨论这个库的内容以及如何使用。<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-configure">使用Spring的IoC配置AspectJ切面</a>讨论如何依赖于使用AspectJ编译器编织的AspectJ切面。最后， 在 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw">在Spring框架中使用AspectJ的加载时织入</a> 将讨论在Spring的应用中使用AspectJ涉及的编织时机的讨论。</p><h4 id="2-10-1-使用Spring中的AspectJ独立注入域对象"><a href="#2-10-1-使用Spring中的AspectJ独立注入域对象" class="headerlink" title="2.10.1. 使用Spring中的AspectJ独立注入域对象"></a>2.10.1. 使用Spring中的AspectJ独立注入域对象</h4><p>Spring容器实例化和配置会在应用程序上下文中定义bean。也可以让bean工厂配置预先存在的对象，给定一个包含要应用的配置的bean定义名称。<code>spring-aspects.jar</code> 包含了注解驱动的切面， 利用这个功能来允许依赖注入到任意对象。该支持旨在用于在创建任何容器控制之外的对象。域对象通常属于这一类，因为它们通常是使用<code>new</code>的操作符以编程方式创建的，或由ORM工具为数据库查询的结果创建的。</p><p><code>@Configurable</code>注解标记一个类符合Spring驱动配置的条件，在最简单的情况下，您可以纯粹使用它作为标记注解，如下例所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.xyz.myapp.domain;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Configurable;<br><span class="hljs-meta">@Configurablepublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>作为这样一个标识接口, Spring将会为这个注解类型（在例子中是<code>Account</code>）利用定义bean的方式（典型的原型作用域）配置一个新实例， 这个实例拥有与完全限定类型相同的名字(<code>com.xyz.myapp.domain.Account</code>)。因为一个bean的默认名称是它的类型的完全限定名，这个简便的方式只是省略了它的 <code>id</code>属性。如以下示例所示:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.xyz.myapp.domain.Account&quot;</span> scope<span class="hljs-operator">=</span><span class="hljs-string">&quot;prototype&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;fundsTransferService&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;fundsTransferService&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>如果想要显式指定为原型bean使用的名称，可以直接在注解执行此操作，如以下示例所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.xyz.myapp.domain;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Configurable;<br><span class="hljs-meta">@Configurable(<span class="hljs-string">&quot;account&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>Spring现在查找名为<code>account</code> 的bean定义，并将其用作配置新<code>Account</code>实例的定义。</p><p>也可以使用自动装配以避免指定一个特定的专用bean定义。Spring将利用<code>@Configurable</code>注解的自动装配属性来自动装配bean，可以使用<code>@Configurable(autowire=Autowire.BY_NAME</code>或者 <code>@Configurable(autowire=Autowire.BY_TYPE)</code>分别自动装配基于名称和基于类型的bean。另外，Spring 2.5之后明确地指定了更好的策略， 在类中有<code>@Configurable</code>注解的bean上，其域或方法级别上使用<code>@Autowired</code>或<code>@Inject</code>能够使用注解驱动的依赖注入。 有关更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#beans-annotation-config">基于注解的容器配置</a>。</p><p>最后，可以使用Spring依赖的名为<code>dependencyCheck</code>的特性去检查新建的对象引用以及配置对象（例如， <code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>） 。如果将此特性设置为 <code>true</code>，那么Spring将在配置之后确认所有属性（非原始或集合）已被设置。</p><p>当然，使用注解本身没有任何作用。这是 <code>spring-aspects.jar</code>包中的<code>AnnotationBeanConfigurerAspect</code>注解的存在行为。实质上， 该切面表达的是，一个带有<code>@Configurable</code>注解类型的新对象在初始化返回之后，按照注解的属性使用Spring配置创建新的对象。在这种情况下，初始化是指新实例化的对象（例如， 用<code>new</code> 运算符实例化的对象）以及正在经历反序列化（例如，通过<a href="https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve()</a>）的可序列化对象。</p><p>上一段的一个关键短语是 “实质”.。在大多数情况下，精确的语义从一个新对象初始化后返回是适合的。“初始化后”意味着依赖将会在对象被构建完毕后注入 ， 这意味着依赖在类构造器当中是不能使用的。如果想依赖的注入发生在构造器执行之前，而且能够用在构造器之中，那么需要像下面这样声明 <code>@Configurable</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@Configurable(<span class="hljs-attribute">preConstruction</span>=<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>您可以在 <a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">本附录</a> 中 <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ编程指南</a>一书中找到更多有关AspectJ的信息</p><p>这个注解类型必须使用AspectJ编织织入才可以工作 ， 开发者可以使用构建组件Ant或Maven来完成这个任务（<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ Development Environment Guide</a>有参考例子），或者在装配时织入（请参考 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw">在Spring框架中使用AspectJ的加载时织入</a>）。<code>AnnotationBeanConfigurerAspect</code>注解本身需要Spring来配置（为了获取一个bean工厂引用，被用于配置新的对象）。如果使用基于Java的配置， 那么只需将<code>@EnableSpringConfigured</code> 注解加入到任意的<code>@Configuration</code>类中即可，如下所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableSpringConfiguredpublic</span> class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果基于XML配置，那么只要在Spring <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#xsd-schemas-context"><code>context</code></a>的命名空间声明中添加<code>context:spring-configured</code>。您可以按如下方式使用它：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;context:spring-configured/&gt;</span><br></code></pre></td></tr></table></figure><p>在配置切面之前创建<code>@Configurable</code>对象的实例将会向调试日志发消息，并且不会对该对象进行配置。一个例子是在Spring配置中的一个bean，它在Spring初始化时创建域对象。 在这种情况下，可以使用<code>depends-on</code>bean属性来手动指定bean依赖的切面配置。以下示例显示了如何使用<code>depends-on</code>属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xzy.myapp.service.MyService&quot;</span>        <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不用通过bean的切面配置来激活<code>@Configurable</code>处理过程，除非真的想在运行中依赖其语义。特别地，不要在一个已经在容器上注册过的Spring bean上去再去使用<code>@Configurable</code>注解。 否则，这个bean将会被初始化两次，容器一次，切面一次。</p><h5 id="单元测试-Configurable的对象"><a href="#单元测试-Configurable的对象" class="headerlink" title="单元测试@Configurable的对象"></a>单元测试<code>@Configurable</code>的对象</h5><p>开启<code>@Configurable</code>支持的一个目标就是使单元测试独立于域对象，从而没有碰到诸如硬编码查找一样的困难。如果<code>@Configurable</code>注解没有使用AspectJ织入那么它就不会对单元测试造成影响， 这样就可以正常地进行mock或stub测试。如果<code>@Configurable</code>是使用AspectJ织入的，那么依然可以在容器之外正常地进行单元测试，但是如果每次都构建一个<code>@Configurable</code>对象都会看到警告消息， 它表示此配置并非Spring的配置。</p><h5 id="多个应用上下文一起工作"><a href="#多个应用上下文一起工作" class="headerlink" title="多个应用上下文一起工作"></a>多个应用上下文一起工作</h5><p><code>AnnotationBeanConfigurerAspect</code>类在AspectJ中用来实现<code>@Configurable</code>支持的单个切面。单个切面的作用域与静态成员的作用域是相同的， 也就是说每一个类加载器都会定义这个切面的实例类型。这意味着，如果使用相同的类加载器层来定义多个应用上下文。那么必须考虑在哪儿定义<code>@EnableSpringConfigured</code> bean以及在哪个路径存放 <code>spring-aspects.jar</code>包。</p><p>考虑一个典型的Spring Web应用程序配置，其中有一个共享的父应用上下文，定义公共业务服务和支持它们所需的所有内容，每个Servlet包含一个子应用上下文， 其中包含特定于Servlet的定义。所有这些上下文共存于相同的类加载器层次，所以<code>AnnotationBeanConfigurerAspect</code>能够持有他们之中的一个的引用。在这种情况下， 建议在共享的（父）应用上下文上使用<code>@EnableSpringConfigured</code> bean定义，这个定义的服务， 可能想注入到域对象中。结果是，开发者不能在子上下文（特定的Servlet） 中使用@Configurable去定义域对象的引用bean（也许并不想做些什么）。</p><p>在同一个容器部署多个Web应用程序时，确保每个Web应用程序加载<code>spring-aspects.jar</code>类型是在使用自己的加载器引用（例如，通过 <code>&#39;WEB-INF/lib&#39;</code>）。如果<code>spring-aspects.jar</code>仅在容器的类路径下（也就是装在父母共享的加载器的引用），所有的Web应用程序将共享相同的切面实例，而这可能不是你想要的。</p><h4 id="2-10-2-在Spring中使用的AspectJ额外的切面"><a href="#2-10-2-在Spring中使用的AspectJ额外的切面" class="headerlink" title="2.10.2. 在Spring中使用的AspectJ额外的切面"></a>2.10.2. 在Spring中使用的AspectJ额外的切面</h4><p>除了<code>@Configurable</code>切面，<code>spring-aspects.jar</code>还包含AspectJ切面，可以用来驱动Spring的事务管理，用于注解带<code>@Transactional</code>注解的类型和方法 。这主要是为那些希望在Spring容器之外使用Spring框架的事务支持的用户而设计的。</p><p>解析 <code>@Transactional</code> 注解的切面是 <code>AnnotationTransactionAspect</code>。当使用这个切面时，必须注解这个实现类（和&#x2F;或在类的方法上），不是接口（如果有的话） 的实现类。AspectJ遵循Java的规则，注解的接口不能被继承。</p><p><code>@Transactional</code>注解的类指定默认的事务语义的各种公共操作的类.</p><p>在类的方法上注解<code>@Transactional</code>将会覆盖由给定默认事务语义的注解（如果存在），任意可见性的方法都可以被注解，包括私有方法。直接注解非公共方法是获得执行此类方法的事务划分的唯一方法。</p><p>从Spring Framework 4.2开始，<code>spring-aspects</code>提供了类似的切面，为标准的<code>javax.transaction.Transactional</code>注解提供了完全相同的功能。 查看<code>JtaAnnotationTransactionAspect</code> 获取更多细节</p><p>对于希望使用Spring配置和事务管理支持但不希望（或不能）使用注解的AspectJ程序员， <code>spring-aspects.jar</code>还包含可以扩展以提供自定义切点定义的抽象切面。 有关更多信息，请参阅<code>AbstractBeanConfigurerAspect</code>和<code>AbstractTransactionAspect</code>切面的源码。 作为示例，以下摘录显示了如何使用与完全限定的类名匹配的原型bean定义来编写一个切面 ，用于配置域模型中定义的所有对象实例:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">aspect</span> <span class="hljs-title">DomainObjectConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanConfigurerAspect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DomainObjectConfiguration</span><span class="hljs-params">()</span> </span>&#123;        setBeanWiringInfoResolver(<span class="hljs-keyword">new</span> ClassNameBeanWiringInfoResolver());    &#125;<br>    <span class="hljs-comment">// the creation of a new bean (any object in the domain model)    protected pointcut beanCreation(Object beanInstance) :        initialization(new(..)) &amp;&amp;        SystemArchitecture.inDomainModel() &amp;&amp;        this(beanInstance);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-10-3-使用Spring-IoC配置AspectJ切面"><a href="#2-10-3-使用Spring-IoC配置AspectJ切面" class="headerlink" title="2.10.3. 使用Spring IoC配置AspectJ切面"></a>2.10.3. 使用Spring IoC配置AspectJ切面</h4><p>当在Spring应用中使用AspectJ的切面时，很自然的希望能够使用Spring来配置切面。AspectJ运行时本身是负责创建和配置切面的， AspectJ通过Spring创建切面取决于AspectJ实例化模型的方法（<code>per-xxx</code>引起的）的切面使用。</p><p>多数的AspectJ切面是单例切面。这些切面的配置非常容易，只需正常地创建一个bean定义引用切面的类型，包含bean属性<code>factory-method=&quot;aspectOf&quot;</code> 。这保证了Spring获得的是AspectJ的实例而不是试图创建实例本身的切面。下示例显示如何使用 <code>factory-method=&quot;aspectOf&quot;</code>属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;profiler&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.xyz.profiler.Profiler&quot;</span>        <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;aspectOf&quot;</span>&gt; (1)<br>    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;profilingStrategy&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;jamonProfilingStrategy&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><strong>(1)。</strong>请注意<code>factory-method=&quot;aspectOf&quot;</code> 属性</p><p>非单例切面很难配置，但是这样做也是有可能的，通过创建原型bean的定义和从<code>spring-aspects.jar</code>中使用<code>@Configurable</code>的支持。这些工作需要在AspectJ运行之后在创建之中去配置切面实例才能成功。</p><p>如果想要使用AspectJ编写一些@AspectJ切面（例如，针对领域模型类型使用加载时编织）以及希望与Spring AOP一起使用的其他@AspectJ切面，并且这些切面都使用Spring进行配置 。 那么需要告诉Spring AOP @AspectJ自动代理支持在配置中定义的@AspectJ方面的确切子集应该用于自动代理。可以通过在<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素中声明使用一个或多个 <code>&lt;include/&gt;</code>元素来完成此操作。 每个 <code>&lt;include/&gt;</code>元素指定一个名称模式，并且只有名称与至少一个模式相匹配的bean才会用于Spring AOP自动代理配置。以下示例显示了如何使用<code>&lt;include/&gt;</code>元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:include</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;thisBean&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:include</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;thatBean&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不要被 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素的名称误导。 使用它会导致创建Spring AOP代理。 切面声明的@AspectJ方式只是在这里使用，AspectJ运行时是没有用到的。</p><h4 id="2-10-4-在Spring框架中使用AspectJ的加载时织入"><a href="#2-10-4-在Spring框架中使用AspectJ的加载时织入" class="headerlink" title="2.10.4. 在Spring框架中使用AspectJ的加载时织入"></a>2.10.4. 在Spring框架中使用AspectJ的加载时织入</h4><p>是指AspectJ切面在JVM加载类文件时被织入到程序的类文件的过程。本部分的重点是配置和使用LTW在Spring框架上的具体内容，本节不是LTW的简介。 只有AspectJ能够详细地讲述LTW的特性和配置（与Spring完全没有关系），可以参看<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW section of the AspectJ Development Environment Guide</a>。</p><p>Spring框架在AspectJ的LTW织入的过程中提供了更细粒度的控制，‘Vanilla’ AspectJ LTW是一个高效的使用Java（1.5+)的代理，它会在JVM启动的时候改变一个VM参数。 这是一种JVM范围的设置，在某些情况下可能会很适合，但是太粗粒度了。Spring的LTW能够为LTW提供类加载前的织入，显然这是一个更细粒度的控制，而且它在’single-JVM-multiple-application’ 的环境下更具意义（在典型的应用程序服务器环境中就是这样做的）。</p><p>此外，在特定的环境中（查看<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw-environments">in certain environments</a>），这种方式可以在对应用程序服务器运行脚本不做任何修改的情形下支持LTW， 但需要添加<code>-javaagent:path/to/aspectjweaver.jar</code>（本节稍后将会描述）或<code>-javaagent:path/to/org.springframework.instrument-&#123;version&#125;.jar</code>（原名为 <code>spring-agent.jar</code>）。 开发人员只需修改构成应用程序上下文的一个或多个文件，以启用加载时编入，而不是依赖通常负责部署配置的管理文件。例如启动脚本。</p><p>到此为止，推销宣传部分已经结束了，那么让我们首先介绍使用Spring的AspectJ LTW的快速示例，然后详细介绍示例中介绍的元素。 有关完整示例，请参阅<a href="https://github.com/spring-projects/spring-petclinic">Petclinic示例应用程序</a>。</p><h5 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h5><p>假设您是一名应用程序开发人员，负责诊断系统中某些性能问题的原因。我们无需打开一个分析工具，而是要打开一个简单的剖析切面，让我们能够很快获得了一些性能指标， 这样我们就可以在随后立即使用更细粒度的分析工具。</p><p>这里介绍的例子使用XML格式的配置，也可以使用 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#beans-java">Java配置</a>和和@AspectJ的方式。特别是<code>@EnableLoadTimeWeaving</code>注解可以起 到替代<code>&lt;context:load-time-weaver/&gt;</code> （详情<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw-spring">见下文</a>）。</p><p>下面是一个用于性能分析的切面，它不需要太花哨，它是一个基于时间的分析器，它使用@ AspectJ样式的方面声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> foo;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<span class="hljs-keyword">import</span> org.springframework.util.StopWatch;<span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-meta">@Aspectpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfilingAspect</span> &#123;<br>    <span class="hljs-meta">@Around(&quot;methodsToBeProfiled()&quot;)</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">profile</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>(getClass().getSimpleName());        <span class="hljs-keyword">try</span> &#123;            sw.start(pjp.getSignature().getName());            <span class="hljs-keyword">return</span> pjp.proceed();        &#125; <span class="hljs-keyword">finally</span> &#123;            sw.stop();            System.out.println(sw.prettyPrint());        &#125;    &#125;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * foo..*.*(..))&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodsToBeProfiled</span><span class="hljs-params">()</span>&#123;&#125;&#125;<br></code></pre></td></tr></table></figure><p>此外还需要创建一个<code>META-INF/aop.xml</code> 文件，它将通知AspectJ将<code>ProfilingAspect</code>织入到类中。这是文件的惯例， 即在Java类路径中存在名为<code>META-INF/aop.xml</code>的文件（或多个文件）是标准AspectJ。 以下示例显示了<code>aop.xml</code> 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">aspectj</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//AspectJ//DTD//EN&quot;</span> <span class="hljs-string">&quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aspectj</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">weaver</span>&gt;</span>        <span class="hljs-comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">within</span>=<span class="hljs-string">&quot;foo.*&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">weaver</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aspects</span>&gt;</span>        <span class="hljs-comment">&lt;!-- weave in just this aspect --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aspect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;foo.ProfilingAspect&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">aspects</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aspectj</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在来配置的Spring特定部分。 我们需要配置<code>LoadTimeWeaver</code>（稍后解释）。LTW是从一个或多个<code>META-INF/aop.xml</code> 文件中织入到应用类的切面配置的主要部分。幸运的是它不需要大量的配置，如下所示（还有一些选项可以指定，但是后面会详细介绍）。如以下示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entitlementCalculationService&quot;</span>            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo.StubEntitlementCalculationService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- this switches on the load-time weaving --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:load-time-weaver</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在所有必需的材料( aspect, <code>META-INF/aop.xml</code>文件, Spring 的配置) 都已到位，我们可以使用<code>main(..)</code>方法创建以下驱动程序类，以演示LTW的运行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> foo;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>, Main.class);<br>        <span class="hljs-type">EntitlementCalculationService</span> <span class="hljs-variable">entitlementCalculationService</span>            <span class="hljs-operator">=</span> (EntitlementCalculationService) ctx.getBean(<span class="hljs-string">&quot;entitlementCalculationService&quot;</span>);<br>        <span class="hljs-comment">// the profiling aspect is &#x27;woven&#x27; around this method execution        entitlementCalculationService.calculateEntitlement();    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>我们还有最后一件事要做。 本节的介绍确实说可以使用Spring在每个ClassLoader的基础上有选择地打开LTW，这是事实。 但是，对于此示例，我们使用Java代理（随Spring提供）来打开LTW。 我们使用以下命令来运行前面显示的 <code>Main</code>类：</p><p>java -javaagent:C:&#x2F;projects&#x2F;foo&#x2F;lib&#x2F;global&#x2F;spring-instrument.jar foo.Main</p><p><code>-javaagent</code>是一个标志，用于指定和启用 <a href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理程序来检测在JVM上运行的程序</a>。Spring Framework附带了一个代理程序<code>InstrumentationSavingAgent</code>， 它包装在<code>spring-instrument.jar</code>中，它作为前面示例中-javaagent参数的值提供。</p><p>主程序的输出将如下所示。（前面已经介绍了<code>Thread.sleep(..)</code>声明为 <code>calculateEntitlement()</code>实现使分析器实际上捕获了比0毫秒更多的东西（<code>01234</code>毫秒不是AOP引入的开销） ）下面的清单显示了输出 我们运行我们的探查器时得到了:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Calculating entitlement<br>StopWatch <span class="hljs-string">&#x27;ProfilingAspect&#x27;</span>: running time (millis) = <span class="hljs-number">1234</span><span class="hljs-string">\-\-\-\-\-\-</span> <span class="hljs-string">\-\-\-\-\-</span> <span class="hljs-string">\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-ms</span>     %     Task name<span class="hljs-string">\-\-\-\-\-\-</span> <span class="hljs-string">\-\-\-\-\-</span> <span class="hljs-string">\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-01234</span>  <span class="hljs-number">100</span>%  calculateEntitlement<br></code></pre></td></tr></table></figure><p>由于LTW是会对AspectJ产生影响的，而不是仅仅局限在Spring的beans。在 <code>Main</code>程序的轻微变化会产生相同的结果:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> foo;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>, Main.class);<br>        EntitlementCalculationService entitlementCalculationService =            <span class="hljs-keyword">new</span> <span class="hljs-type">StubEntitlementCalculationService</span>();<br>        <span class="hljs-comment">// the profiling aspect will be &#x27;woven&#x27; around this method execution        entitlementCalculationService.calculateEntitlement();    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>请注意，在前面的程序中，我们如何引导Spring容器，然后在Spring的上下文之外创建一个新的<code>StubEntitlementCalculationService</code>实例。 分析通知依然会被编织。</p><p>不可否认，这个例子很简单。但是在Spring中支持LTW的基础都介绍到了，而且为什么使用以及怎样使用配置在后面的章节也将解释。</p><p>在这个例子中使用的<code>ProfilingAspect</code>可能很基础的，但它非常有用。是一个开发者可以使用在开发过程中使用开发时间切面的例子， 然后很容易地排除来自应用程序被部署到测试或生产中的因素。</p><h5 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h5><p>在LTW使用的aspects必须是AspectJ的切面。它们可以写在AspectJ语言本身也可以在@AspectJ方式声明。这意味着aspects在AspectJ和Spring AOP的切面都有效。 此外，编译切面的类需要包含在类路径中。</p><h5 id="‘META-INF-aop-xml’"><a href="#‘META-INF-aop-xml’" class="headerlink" title="‘META-INF&#x2F;aop.xml’"></a>‘META-INF&#x2F;aop.xml’</h5><p>使用AspectJ LTW的基础设施是一个或多个<code>META-INF/aop.xml</code>配置文件，这是在Java类路径中的（直接的或者更通常是一个JAR文件）。</p><p>LTW部分 <a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ参考文档</a>中详细介绍了此文件的结构和内容。 由于aop.xml文件是100％AspectJ，因此我们不在此进一步描述。</p><h5 id="需要的类库-JARS"><a href="#需要的类库-JARS" class="headerlink" title="需要的类库(JARS)"></a>需要的类库(JARS)</h5><p>至少，您需要以下库来使用Spring Framework对AspectJ LTW的支持:</p><ul><li><code>spring-aop.jar</code> (version 2.5 or later, plus all mandatory dependencies)</li><li><code>aspectjweaver.jar</code> (version 1.6.8 or later)</li></ul><p>如果使用<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw-environment-generic">Spring提供的代理程序启用检测</a>，则还需要：</p><ul><li><code>spring-instrument.jar</code></li></ul><h5 id="Spring的配置"><a href="#Spring的配置" class="headerlink" title="Spring的配置"></a>Spring的配置</h5><p>Spring支持LTW的关键部件是 <code>LoadTimeWeaver</code>接口（位于<code>org.springframework.instrument.classloading</code>包），而这接口有大部分的实现分布在Spring中。 <code>LoadTimeWeaver</code>负责添加一个或多个<code>java.lang.instrument.ClassFileTransformers</code> 到运行时的类装载器中。 这为各种有趣的应用程序打开了大门，其中一个恰好是方面的LTW。</p><p>如果您不熟悉运行时类文件转换的概念，请在继续之前查看<code>java.lang.instrument</code> 包的javadoc API文档。虽然该文档并不全面，但至少可以看到关键接口和类（供您阅读本节时参考）。</p><p>配置一个特定的<code>ApplicationContext</code> <code>LoadTimeWeaver</code>就像加入一行代码一样容易。（请注意，几乎可以肯定会将<code>ApplicationContext</code>作为的Spring容器- 通常一个<code>BeanFactory</code>是不够的，因为LTW的支持利用到<code>BeanFactoryPostProcessors</code>）。</p><p>要启用Spring Framework的LTW支持，您需要配置<code>LoadTimeWeaver</code>，通常使用<code>@EnableLoadTimeWeaving</code>注解来完成，如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableLoadTimeWeavingpublic</span> class AppConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者，如果您更喜欢基于XML的配置，请使用<code>&lt;context:load-time-weaver/&gt;</code>元素。请注意，元素是在 <code>context</code>命名空间中定义的。 以下示例显示如何使用<code>&lt;context:load-time-weaver/&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:load-time-weaver</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的配置自动为你登记了一些特定的基础beans，例如<code>LoadTimeWeaver</code>和<code>AspectJWeavingEnabler</code>。 默认的<code>LoadTimeWeaver</code>是<code>DefaultContextLoadTimeWeaver</code> 类，它试图装饰并自动检测<code>LoadTimeWeaver</code>。 “自动检测”的<code>LoadTimeWeaver</code>的确切类型取决于您的运行时环境。 下表总结了各种<code>LoadTimeWeaver</code>实现:</p><p>Table 13. DefaultContextLoadTimeWeaver LoadTimeWeavers</p><table><thead><tr><th>运行时环境</th><th><code>LoadTimeWeaver</code> 实现</th></tr></thead><tbody><tr><td>Running in Oracle’s <a href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a></td><td><code>WebLogicLoadTimeWeaver</code></td></tr><tr><td>Running in Oracle’s <a href="http://glassfish.dev.java.net/">GlassFish</a></td><td><code>GlassFishLoadTimeWeaver</code></td></tr><tr><td>Running in <a href="https://tomcat.apache.org/">Apache Tomcat</a></td><td><code>TomcatLoadTimeWeaver</code></td></tr><tr><td>Running in Red Hat’s <a href="http://www.jboss.org/jbossas/">JBoss AS</a> or <a href="http://www.wildfly.org/">WildFly</a></td><td><code>JBossLoadTimeWeaver</code></td></tr><tr><td>Running in IBM’s <a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a></td><td><code>WebSphereLoadTimeWeaver</code></td></tr><tr><td>JVM started with Spring <code>InstrumentationSavingAgent</code> (<code>java -javaagent:path/to/spring-instrument.jar</code>)</td><td><code>InstrumentationLoadTimeWeaver</code></td></tr><tr><td>Fallback, expecting the underlying ClassLoader to follow common conventions (for example applicable to <code>TomcatInstrumentableClassLoader</code> and <a href="http://www.caucho.com/">Resin</a>)</td><td><code>ReflectiveLoadTimeWeaver</code></td></tr></tbody></table><p>请注意，该表仅列出使用<code>DefaultContextLoadTimeWeaver</code>时自动检测的 <code>LoadTimeWeavers</code>。 您可以准确指定要使用的<code>LoadTimeWeaver</code>实现。</p><p>使用Java配置指定特定的 <code>LoadTimeWeaver</code>实现<code>LoadTimeWeavingConfigurer</code> 接口并覆盖 <code>getLoadTimeWeaver()</code> 方法。以下示例指定<code>ReflectiveLoadTimeWeaver</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@EnableLoadTimeWeavingpublic</span> class AppConfig implements LoadTimeWeavingConfigurer &#123;<br>    <span class="hljs-variable">@Override</span>    public LoadTimeWeaver <span class="hljs-built_in">getLoadTimeWeaver</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ReflectiveLoadTimeWeaver</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果使用基于XML的配置，则可以将完全限定的类名指定为<code>&lt;context:load-time-weaver/&gt;</code>元素上的 <code>weaver-class</code>属性的值。 同样，以下示例指定了 <code>ReflectiveLoadTimeWeaver</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:load-time-weaver</span>            <span class="hljs-attr">weaver-class</span>=<span class="hljs-string">&quot;org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>稍后可以使用众所周知的名称 <code>loadTimeWeaver</code>从Spring容器中检索由配置定义和注册的<code>LoadTimeWeaver</code> 。请记住， <code>LoadTimeWeaver</code>只是作为Spring的LTW基础结构的机制来添加一个或多个<code>ClassFileTransformer</code>，执行LTW的实际<code>ClassFileTransformers</code>是 <code>ClassPreProcessorAgentAdapter</code>（来自<code>org.aspectj.weaver.loadtime</code>包）。有关详细信息，请参阅<code>ClassPreProcessorAgentAdapter</code>类的类级javadoc， 因为编织实际如何实现的细节超出了本文档的范围。</p><p>剩下要讨论的配置有一个最终属性：<code>aspectjWeaving</code>属性（如果使用XML，则为<code>aspectj-weaving</code>）。 此属性控制是否启用LTW。 它接受三个可能值中的一个，如果该属性不存在，则默认值为<code>autodetect</code>。 下表总结了三个可能的值:</p><p>Table 14. AspectJ织入的属性值</p><table><thead><tr><th>Annotation Value</th><th>XML Value</th><th>Explanation</th></tr></thead><tbody><tr><td><code>ENABLED</code></td><td><code>on</code></td><td>AspectJ编织开启，切面在加载时织入。</td></tr><tr><td><code>DISABLED</code></td><td><code>off</code></td><td>LTW已关闭。 没有切面加载时织入。</td></tr><tr><td><code>AUTODETECT</code></td><td><code>autodetect</code></td><td>如果Spring LTW基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，那么AspectJ编织就会打开。 否则，它关闭。 这是默认值。</td></tr></tbody></table><h5 id="特定环境的配置"><a href="#特定环境的配置" class="headerlink" title="特定环境的配置"></a>特定环境的配置</h5><p>最后一部分包含在应用程序服务器和Web容器等环境中使用Spring LTW支持时所需的任何其他设置和配置。</p><h6 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h6><p>从历史上看, <a href="https://tomcat.apache.org/">Apache Tomcat</a>的默认类加载器不支持类转换，这就是为什么Spring提供了一个增强的实现来满足这一需求。 名字叫<code>TomcatInstrumentableClassLoader</code>，加载程序适用于Tomcat 6.0及更高版本。</p><p>不要在Tomcat 8.0及更高版本上定义<code>TomcatInstrumentableClassLoader</code> 。 相反，让Spring通过<code>TomcatLoadTimeWeaver</code> 策略自动使用Tomcat的新的，原生的<code>InstrumentableClassLoader</code>工具。</p><p>如果仍需要使用<code>TomcatInstrumentableClassLoader</code>，则可以为每个Web应用程序单独注册，如下所示:</p><ol><li><p>将<code>org.springframework.instrument.tomcat.jar</code>复制到<code>$CATALINA_HOME/lib</code>中，其中<code>$CATALINA_HOME</code>表示Tomcat安装的根目录</p></li><li><p>通过编辑Web应用程序上下文文件，指示Tomcat使用自定义类加载器（而不是默认值），如以下示例所示:</p></li></ol><p>Apache Tomcat 6.0+支持多个上下文位置:</p><ul><li>服务配置文件 : <code>$CATALINA_HOME/conf/server.xml</code></li><li>默认上下文配置 : <code>$CATALINA_HOME/conf/context.xml</code>, which affects all deployed web applications</li><li>每个应用程序的配置, 可以在服务器端的<code>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</code>上部署也可以嵌入在web应用程序<code>META-INF/context.xml</code>中</li></ul><p>为了提高效率，建议使用嵌入式Web应用程序配置风格，因为它只影响使用自定义类装入器的应用程序，不需要对服务器配置进行任何更改。 有关可用上下文位置的更多详细信息，请参阅Tomcat 6.0.x<a href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html">文档</a>。</p><p>或者，考虑使用Spring提供的通用VM代理，在Tomcat的启动脚本中指定（在本节前面介绍过）。 这将使功能适用于所有部署的Web应用程序，无论它们恰好运行在哪个<code>ClassLoader</code>上。</p><h6 id="WebLogic-WebSphere-Resin-GlassFish-and-JBoss"><a href="#WebLogic-WebSphere-Resin-GlassFish-and-JBoss" class="headerlink" title="WebLogic, WebSphere, Resin, GlassFish, and JBoss"></a>WebLogic, WebSphere, Resin, GlassFish, and JBoss</h6><p>最新版本的WebLogic Server（版本10及更高版本），IBM WebSphere Application Server（版本7及更高版本），Resin（版本3.1及更高版本）和JBoss（版本6.x或更高版本） 提供了一个能够进行本地检测的ClassLoader。Spring的原生LTW利用这种ClassLoader实现来实现AspectJ织入。 <a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-using-aspectj">如前所述</a>，您可以通过激活加载时织入来启用LTW。 具体来说，您无需修改启动脚本即可添加<code>-javaagent:path/to/spring-instrument.jar</code>。</p><p>请注意，具有GlassFish功能的<code>ClassLoader</code> 仅在其EAR环境中可用。对于GlassFish Web应用程序，请按照<a href="https://sca.aliyun.com/learn/spring/core/aop/?spm=0.29160081.0.0.51f92e5dCHrGI4#aop-aj-ltw-environment-tomcat">上面概述</a>的Tomcat设置说明进行操作。 .</p><p>注意在JBoss 6.x中， 应用程序服务器的扫描需要禁用，防止它加载的类的应用之前实际上已经开始。快速的解决方案是增加一个叫<code>WEB-INF/jboss-scanning.xml</code>的文档并加入以下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;scanning <span class="hljs-attribute">xmlns</span>=<span class="hljs-string">&quot;urn:jboss:scanning:1.0&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h6 id="通用的Java应用"><a href="#通用的Java应用" class="headerlink" title="通用的Java应用"></a>通用的Java应用</h6><p>在不支持现有<code>LoadTimeWeaver</code>实现或不受现有<code>LoadTimeWeaver</code>实现支持的环境中需要类检测时，使用JDK代理可能是唯一的解决方案。对于这种情况， Spring提供了<code>InstrumentationLoadTimeWeaver</code>，它需要Spring特有的（但也是非常普通的）VM代理包<code>org.springframework.instrument-&#123;version&#125;.jar</code>(以前称为 <code>spring-agent.jar</code>).</p><p>要使用它，必须通过提供以下JVM选项来启动带有Spring代理的虚拟机。:</p><p>-javaagent:&#x2F;path&#x2F;to&#x2F;org.springframework.instrument-{version}.jar</p><p>这需要修改VM启动脚本，这可能会阻止在应用服务器环境中使用它（具体取决于操作策略）。此外，JDK代理可以检测整个VM，这可能很昂贵。。</p><p>出于性能原因，我们建议您仅在目标环境（例如<a href="https://www.eclipse.org/jetty/">Jetty</a>）没有（或不支持）专用LTW时才使用此配置。</p><h3 id="2-11-更多资源"><a href="#2-11-更多资源" class="headerlink" title="2.11. 更多资源"></a>2.11. 更多资源</h3><p>有关AspectJ的更多信息可以在<a href="https://www.eclipse.org/aspectj">AspectJ website</a>上找到。</p><p>_Eclipse AspectJ_的书Eclipse AspectJ (Addison-Wesley, 2005) 提供了详尽的有关AspectJ语言的介绍</p><p><em>AspectJ in Action</em>, 一书的第二版由Ramnivas Laddad（Manning，2009)出版，也是强烈推荐的。这本书的重点是AspectJ，但也在一定的深度上探讨了普通的AOP主题。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC容器</title>
    <link href="/post/ee218146-1936-4260-8d7e-ac7205d4d805/"/>
    <url>/post/ee218146-1936-4260-8d7e-ac7205d4d805/</url>
    
    <content type="html"><![CDATA[<h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><p><code>hexo template generate by typora plugin templater</code></p><h1 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h1><p>Spring 教程</p><hr><h2 id="1-IOC容器"><a href="#1-IOC容器" class="headerlink" title="1. IOC容器"></a>1. IOC容器</h2><p>这章重点说明IOC容器.</p><h3 id="1-1-Spring-IoC容器和bean的介绍"><a href="#1-1-Spring-IoC容器和bean的介绍" class="headerlink" title="1.1. Spring IoC容器和bean的介绍"></a>1.1. Spring IoC容器和bean的介绍</h3><p>本章介绍Spring框架中控制反转 <a href="https://github.com/DocsHome/spring-docs/blob/master/pages/overview/overview.md#background-ioc">Inversion of Control</a> 的实现. IOC与大家熟知的依赖注入同理，指的是对象仅通过构造函数参数、工厂方法的参数或在对象实例构造以后或从工厂方法返回以后，在对象实例上设置的属性来定义它们的依赖关系（即它们使用的其他对象). 然后容器在创建bean时注入这些需要的依赖。 这个过程基本上是bean本身的逆过程（因此称为IOC），通过使用类的直接构造或服务定位器模式等机制来控制其依赖项的实例化或位置。</p><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 是实现Spring IOC容器框架的基础. <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a> 接口提供了一种更先进的配置机制来管理任意类型的对象. <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> 是<code>BeanFactory</code>的子接口. 他提供了:</p><ul><li>更容易与Spring的AOP特性集成</li><li>消息资源处理(用于国际化)</li><li>事件发布</li><li>应用层特定的上下文，如用于web应用程序的<code>WebApplicationContext</code>.</li></ul><p>简而言之，<code>BeanFactory</code>提供了配置框架的基本功能，<code>ApplicationContext</code>添加了更多特定于企业的功能。 <code>ApplicationContext</code>完全扩展了<code>BeanFactory</code>的功能，这些内容将在介绍Spring IoC容器的章节专门讲解。有关使用<code>BeanFactory</code>更多信息，请参见<code>BeanFactory</code>。</p><p>在Spring中，由Spring IOC容器管理的，构成程序的骨架的对象成为Bean。bean对象是指经过IoC容器实例化，组装和管理的对象。此外，bean就是应用程序中众多对象之一 。bean和bean的依赖由容器所使用的配置元数据反射而来。</p><h3 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2. 容器概述"></a>1.2. 容器概述</h3><p><code>org.springframework.context.ApplicationContext</code>是Spring IoC容器实现的代表，它负责实例化，配置和组装Bean。容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明 。配置元数据可以使用XML、Java注解或Java代码来呈现。它允许你处理应用程序的对象与其他对象之间的互相依赖关系。</p><p>Spring提供了<code>ApplicationContext</code>接口的几个实现。 在独立应用程序中，通常创建<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>或<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a>的实例。虽然XML一直是定义配置元数据的传统格式， 但是您可以指定容器使用Java注解或编程的方式编写元数据格式，并通过提供少量的XML配置以声明对某些额外元数据的支持。</p><p>在大多数应用场景中，不需要用户显式的编写代码来实例化IOC容器的一个或者多个实例。例如，在Web应用场景中，只需要在web.xml中添加大概8行简单的web描述样板就行了。（ <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-create">便捷的ApplicationContext实例化Web应用程序</a>） 如果你使用的是基于Eclipse的<a href="https://spring.io/tools/sts">Spring Tool Suite</a>开发环境，该样板配置只需点击几下鼠标或按几下键盘就能创建了。</p><p>下图展示了Spring工作方式的高级视图，应用程序的类与元数据配置相互配合，这样，在<code>ApplicationContext</code>创建和初始化后，你立即拥有一个可配置的，可执行的系统或应用程序。</p><p><img src="container-magic.png" alt="container magic"></p><p>图 1. IOC容器</p><h4 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1. 配置元数据"></a>1.2.1. 配置元数据</h4><p>如上图所示，Spring IOC容器使用元数据配置这种形式，这个配置元数据表示了应用开发人员告诉Spring容器以何种方式实例化、配置和组装应用程序中的对象。</p><p>配置元数据通常以简单、直观的XML格式提供，本章的大部分内容都使用这种格式来说明Spring IoC容器的关键概念和特性。</p><p>XML并不是配置元数据的唯一方式，Spring IoC容器本身是完全与元数据配置的实际格式分离的。现在，许多开发人员选择<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java">基于Java的配置</a>来开发应用程序。</p><p>更多其他格式的元数据见:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-annotation-config">基于注解的配置</a>: Spring 2.5 支持基于注解的元数据配置.</li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java">基于Java的配置</a>: 从 Spring 3.0开始, 由Spring JavaConfig项目提供的功能已经成为Spring核心框架的一部分。因此，你可以使用Java配置来代替XML配置定义外部bean 。要使用这些新功能，请参阅 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>, 和 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</li></ul><p>Spring配置至少一个（通常不止一个）由容器来管理。基于XML的元数据配置将这些bean配置为<code>&lt;bean/&gt;</code>元素，并放置于<code>&lt;bean/&gt;</code>元素内部。 典型的Java配置是在使用<code>@Configuration</code>注解过的类中，在它的方法上使用<code>@Bean</code>注解。</p><p>这些bean定义会对应到构成应用程序的实际对象。通常你会定义服务层对象，数据访问对象（DAOs），表示对象(如Struts <code>Action</code>的实例)，基础对象（如Hibernate 的<code>SessionFactories</code>, JMS <code>Queues</code>）。通常不会在容器中配置细粒度的域对象，但是，因为它的创建和加载通常是DAO和业务逻辑的任务。 但是，你可以使用Spring与AspectJ 集成独立于 IoC 容器来创建的对象，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aop-atconfigurable">AspectJ在Spring中进行依赖关系注入域对象</a></p><p>下面的示例显示了基于XML元数据配置的基本结构:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>  (1) (2)        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong></p><p><code>id</code> 属性是字符串 ，用来识别唯一的bean定义.</p><p><strong>2</strong></p><p><code>class</code> 属性定义了bean的类型，使用全类名.</p><p><code>id</code>属性的值是指引用协作对象（在这个例子没有显示用于引用协作对象的XML）。请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-dependencies">依赖</a>获取更多信息</p><h4 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2. 实例化容器"></a>1.2.2. 实例化容器</h4><p>提供给ApplicationContext构造函数的路径就是实际的资源字符串，使容器能从各种外部资源(如本地文件系统、Java类路径等)装载元数据配置。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ApplicationContext context</span> = new ClassPathXmlApplicationContext(<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>);<br></code></pre></td></tr></table></figure><p>当你了解Spring IoC容器，你可能想知道更多关于Spring的抽象资源（详细描述<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#resources">资源</a>）它提供了一种方便的，由URI语法定义的位置读取InputStream描述的方式 ，资源路径被用于构建应用程序上下文<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#resources-app-ctx">应用环境和资源路径</a></p><p>下面的例子显示了服务层对象(<code>services.xml</code>)配置文件::</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;petStore&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accountDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;accountDao&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;itemDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;itemDao&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的示例显示了数据访问对象（<code>daos.xml</code>）配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountDao&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;itemDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，服务层由PetStoreServiceImpl类，两个数据访问对象JpaAccountDao类和JpaItemDao类（基于JPA对象&#x2F;关系映射标准）组成 property name元素是指JavaBean属性的名称，而ref元素引用另一个bean定义的名称。id和ref元素之间的这种联系表达了组合对象之间的相互依赖关系。有关对象间的依赖关系，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-dependencies">依赖</a> .</p><h5 id="组合基于XML的元数据配置"><a href="#组合基于XML的元数据配置" class="headerlink" title="组合基于XML的元数据配置"></a>组合基于XML的元数据配置</h5><p>使用XML配置，可以让bean定义分布在多个XML文件上，这种方法直观优雅清晰明显。通常，每个单独的XML配置文件代表架构中的一个逻辑层或模块。</p><p>你可以使用应用程序上下文构造函数从所有这些XML片段加载bean定义，这个构造函数可以输入多个资源位置，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-instantiation">如上一节所示</a>。 或者，使用<code>&lt;import/&gt;</code>元素也可以从另一个（或多个）文件加载bean定义。例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;beans&gt;    &lt;import <span class="hljs-attribute">resource</span>=<span class="hljs-string">&quot;services.xml&quot;</span>/&gt;    &lt;import <span class="hljs-attribute">resource</span>=<span class="hljs-string">&quot;resources/messageSource.xml&quot;</span>/&gt;    &lt;import <span class="hljs-attribute">resource</span>=<span class="hljs-string">&quot;/resources/themeSource.xml&quot;</span>/&gt;<br>    &lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bean1&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;    &lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bean2&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>上面的例子中，使用了3个文件：<code>services.xml</code>, <code>messageSource.xml</code>, 和 <code>themeSource.xml</code>来加载外部Bean的定义。 导入文件采用的都是相对路径，因此<code>services.xml</code>必须和导入文件位于同一目录或类路径中，而<code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须在导入文件的资源位置中。正如你所看到的，前面的斜线将会被忽略，但考虑到这些路径是相对的，最佳的使用是不用斜线的。 这个XML文件的内容都会被导入，包括顶级的 <code>&lt;beans/&gt;</code>元素，但必须遵循Spring Schema定义XML bean定义的规则 。</p><p>这种相对路径的配置是可行的，但不推荐这样做，引用在使用相对于”..&#x2F;“路径的父目录文件中，这样做会对当前应用程序之外的文件产生依赖关系。 特别是对于<code>classpath:</code>: URLs(例如<code>classpath:../services.xml</code>)，不建议使用此引用，因为在该引用中，运行时解析过程选择“最近的”classpath根目录，然后查看其父目录。 类路径的变化或者选择了不正确的目录都会导致此配置不可用。</p><p>您可以使用完全限定的资源位置而不是相对路径:例如，<code>file:C:/config/services.xml</code>或者<code>classpath:/config/services.xml</code>.。 但是，请注意，您正在将应用程序的配置与特定的绝对位置耦合。通常会选取间接的方式应对这种绝对路径，例如使用占位符“${…}”来解决对JVM系统属性的引用。</p><p>import 是由bean命名空间本身提供的功能。在Spring提供的XML命名空间中，如“<code>context</code>”和“<code>util</code>”命名空间，可以用于对普通bean定义进行更高级的功能配置。</p><h5 id="DSL定义Groovy-Bean"><a href="#DSL定义Groovy-Bean" class="headerlink" title="DSL定义Groovy Bean"></a>DSL定义Groovy Bean</h5><p>作为从外部配置元数据的另一个示例，bean定义也可以使用Spring的Groovy DSL来定义。Grails框架有此配置实例，通常， 可以在具有以下结构的”.groovy”文件中配置bean定义。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs markdown">beans &#123;<br><br><span class="hljs-code">    dataSource(BasicDataSource) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        driverClassName = &quot;org.hsqldb.jdbcDriver&quot;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        url = &quot;jdbc:hsqldb:mem:grailsDB&quot;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        username = &quot;sa&quot;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        password = &quot;&quot;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        settings = [mynew:&quot;setting&quot;]</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    sessionFactory(SessionFactory) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        dataSource = dataSource</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    myService(MyService) &#123;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">            dataSource = dataSource</span><br><span class="hljs-code"></span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code"></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种配置风格在很大程度上等价于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过<code>importBeans</code>指令导入XML bean定义文件。</p><h4 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3. 使用容器"></a>1.2.3. 使用容器</h4><p><code>ApplicationContext</code>是能够创建bean定义以及处理相互依赖关系的高级工厂接口，使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>获取容器实例。</p><p><code>ApplicationContext</code>可以读取bean定义并访问它们 如下 :</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">// create <span class="hljs-keyword">and</span> configure beansApplicationContext <span class="hljs-keyword">context</span> = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>);<br>// retrieve configured instancePetStoreService service = <span class="hljs-keyword">context</span>.getBean(<span class="hljs-string">&quot;petStore&quot;</span>, PetStoreService.class);<br>// <span class="hljs-keyword">use</span> configured instanceList&lt;<span class="hljs-built_in">String</span>&gt; userList = service.getUsernameList();<br></code></pre></td></tr></table></figure><p>使用Groovy配置引导看起来非常相似，只是用到不同的上下文实现类：它是Groovy感知的（但也需理解XML bean定义） 如下:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ApplicationContext context</span> = new GenericGroovyApplicationContext(<span class="hljs-string">&quot;services.groovy&quot;</span>, <span class="hljs-string">&quot;daos.groovy&quot;</span>);<br></code></pre></td></tr></table></figure><p>最灵活的变体是<code>GenericApplicationContext</code>，例如读取XML文件的<code>XmlBeanDefinitionReader</code>。如下面的示例所示:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">GenericApplicationContext <span class="hljs-built_in">context</span> = <span class="hljs-built_in">new</span> GenericApplicationContext();<br><br><span class="hljs-built_in">new</span> XmlBeanDefinitionReader(<span class="hljs-built_in">context</span>).loadBeanDefinitions(<span class="hljs-string">&quot;services.xml&quot;</span>, <span class="hljs-string">&quot;daos.xml&quot;</span>);<br><br><span class="hljs-built_in">context</span>.refresh();<br></code></pre></td></tr></table></figure><p>您还可以为Groovy文件使用<code>GroovyBeanDefinitionReader</code>，如下面的示例所示:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">GenericApplicationContext <span class="hljs-built_in">context</span> = <span class="hljs-built_in">new</span> GenericApplicationContext();<br><br><span class="hljs-built_in">new</span> GroovyBeanDefinitionReader(<span class="hljs-built_in">context</span>).loadBeanDefinitions(<span class="hljs-string">&quot;services.groovy&quot;</span>, <span class="hljs-string">&quot;daos.groovy&quot;</span>);<br><br><span class="hljs-built_in">context</span>.refresh();<br></code></pre></td></tr></table></figure><p>这一类的读取可以在同一个 <code>ApplicationContext</code>上混合使用，也可以自动匹配，如果需要可以从不同的配置源读取bean定义。</p><p>您可以使用 <code>getBean</code>来获取bean实例， <code>ApplicationContext</code>接口也可以使用其他的方法来获取bean。但是在理想情况下，应用程序代码永远不应该使用它们。 事实上，你的应用程序代码也不应该调用的<code>getBean()</code>方法，因此对Spring API没有依赖。例如，Spring与Web框架的集成为各种Web框架组件(如控制器和JSF管理bean） 提供了依赖项注入功能，从而允许开发者通过元数据声明对特定bean的依赖(例如，自动注解）。</p><h3 id="1-3-Bean-的概述"><a href="#1-3-Bean-的概述" class="headerlink" title="1.3. Bean 的概述"></a>1.3. Bean 的概述</h3><p>Spring IoC容器管理一个或多个bean。这些bean是由您提供给容器的元数据配置创建的(例如，XML <code>&lt;bean/&gt;</code>定义的形式)。</p><p>在容器内部，这些bean定义表示为<code>BeanDefinition</code>对象，其中包含（其他信息）以下元数据</p><ul><li>限定包类名称: 通常，定义的bean的实际实现类。</li><li>bean行为配置元素, 定义Bean的行为约束(例如作用域，生命周期回调等等）</li><li>bean需要引用其他bean来完成工作. 这些引用也称为协作或依赖关系.</li><li>其他配置用于新对象的创建，例如使用bean的数量来管理连接池，或者限制池的大小。</li></ul><p>以下是每个bean定义的属性:</p><p>Table 1. Bean的定义</p><table><thead><tr><th>Property</th><th>对应的章节名</th></tr></thead><tbody><tr><td>Class</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class">实例化Bean</a></td></tr><tr><td>Name</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-beanname">命名Bean</a></td></tr><tr><td>Scope</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes">Bean 的作用域</a></td></tr><tr><td>Constructor arguments</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-collaborators">依赖注入</a></td></tr><tr><td>Properties</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-collaborators">依赖注入</a></td></tr><tr><td>Autowiring mode</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire">自动装配</a></td></tr><tr><td>Lazy initialization mode</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lazy-init">懒加载Bean</a></td></tr><tr><td>Initialization method</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean">初始化方法回调</a></td></tr><tr><td>Destruction method</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-disposablebean">销毁方法回调</a></td></tr></tbody></table><p>除了bean定义包含如何创建特定的bean的信息外，<code>ApplicationContext</code>实现还允许用户在容器中注册现有的、已创建的对象。 通过<code>getBeanFactory()</code>访问到返回值为<code>DefaultListableBeanFactory</code>的实现的ApplicationContext的BeanFactory <code>DefaultListableBeanFactory</code>支持通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法来注册对象。 然而，典型的应用程序只能通过元数据配置来定义bean。</p><p>为了让容器正确推断它们在自动装配和其它内置步骤，需要尽早注册Bean的元数据和手动使用单例的实例。虽然覆盖现有的元数据和现有的单例实例在某种程度上是支持的， 但是新bean在运行时(同时访问动态工厂）注册官方并不支持，可能会导致并发访问异常、bean容器中的不一致状态，或者两者兼有。</p><h4 id="1-3-1-命名bean"><a href="#1-3-1-命名bean" class="headerlink" title="1.3.1. 命名bean"></a>1.3.1. 命名bean</h4><p>每个bean都有一个或多个标识符，这些标识符在容器托管时必须是唯一的。bean通常只有一个标识符，但如果需要到的标识不止一个时，可以考虑使用别名。</p><p>在基于XML的配置中，开发者可以使用<code>id</code>属性，name属性或两者都指定bean的标识符。 <code>id</code>属性允许您指定一个<code>id</code>，通常这些名字使用字母和数字的组合(例如’myBean’, ‘someService’，等等），但也可以包含特殊字符。 如果你想使用bean别名，您可以在name属性上定义，使用逗号(<code>,</code>），分号(<code>;</code>)，或白色空格进行分隔。由于历史因素， 请注意，在Spring 3.1之前的版本中，id属性被定义为<code>xsd:ID</code>类型，它会限制某些字符。从3.1开始，它被定义为<code>xsd:string</code>类型。请注意，由于bean <code>id</code>的唯一性，他仍然由容器执行，不再由XML解析器执行。</p><p>您也无需提供bean的<code>name</code>或 <code>id</code>，如果没有显式地提供<code>name</code>或 <code>id</code>，容器会给bean生成唯一的名称。 然而，如果你想引用bean的名字，可以使用ref元素或使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-servicelocator">Service Locator</a>（服务定位器）来进行查找（此时必须提供名称）。 不使用名称的情况有： <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-inner-beans">内部bean</a>和<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire">自动装配的协作者</a></p><p>Bean 的命名约定</p><p>bean的命名是按照标准的Java字段名称命名来进行的。也就是说，bean名称开始需要以小写字母开头，后面采用“驼峰式”的方法。 例如<code>accountManager</code>,<code>accountService</code>, <code>userDao</code>, <code>loginController</code>等。</p><p>一致的beans命名能够让配置更方便阅读和理解，如果你正在使用Spring AOP，当你通过bean名称应用到通知时，这种命名方式会有很大的帮助。</p><p>在类路径中进行组件扫描时， Spring 会根据上面的规则为未命名的组件生成 bean 名称，规则是：采用简单的类名，并将其初始字符转化为小写字母。 然而，在特殊情况下，当有一个以上的字符，同时第一个和第二个字符都是大写时，原来的规则仍然应该保留。这些规则与Java中定义实例的相同。 例如Spring使用的<code>java.beans.Introspector.decapitalize</code> 类。</p><h5 id="为外部定义的bean起别名"><a href="#为外部定义的bean起别名" class="headerlink" title="为外部定义的bean起别名"></a>为外部定义的bean起别名</h5><p>在对bean定义时，除了使用<code>id</code>属性指定唯一的名称外，还可以提供多个别名，这需要通过<code>name</code>属性指定。 所有这个名称都会指向同一个bean，在某些情况下提供别名非常有用，例如为了让应用每一个组件都能更容易的对公共组件进行引用。</p><p>然而，在定义bean时就指定所有的别名并不是很恰当的。有时期望能够在当前位置为那些在别处定义的bean引入别名。在XML配置文件中， 可以通过<code>&lt;alias/&gt;</code>元素来定义bean别名，例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">alias</span> <span class="hljs-type">name</span>=&quot;fromName&quot; <span class="hljs-keyword">alias</span>=&quot;toName&quot;/&gt;<br></code></pre></td></tr></table></figure><p>上面示例中，在同一个容器中名为<code>fromName</code> 的bean定义，在增加别名定义后，也可以使用<code>toName</code>来引用。</p><p>例如，在子系统A中通过名字<code>subsystemA-dataSource</code>配置的数据源。在子系统B中可能通过名字 <code>subsystemB-dataSource</code>来引用。 当两个子系统构成主应用的时候，主应用可能通过名字<code>myApp-dataSource</code>引用数据源，将全部三个名字引用同一个对象，你可以将下面的别名定义添加到应用配置中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">alias</span> <span class="hljs-type">name</span>=&quot;subsystemA-dataSource&quot; <span class="hljs-keyword">alias</span>=&quot;subsystemB-dataSource&quot;/&gt;<br><br>&lt;<span class="hljs-keyword">alias</span> <span class="hljs-type">name</span>=&quot;subsystemA-dataSource&quot; <span class="hljs-keyword">alias</span>=&quot;myApp-dataSource&quot; /&gt;<br></code></pre></td></tr></table></figure><p>现在，每个组件和主应用程序都可以通过一个唯一的名称引用dataSource，并保证不与任何其他定义冲突（有效地创建命名空间），但它们引用相同的bean。 .</p><p>Java配置</p><p>如果你是用java配置， <code>@Bean</code>可以用来提供别名，详情见<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-bean-annotation">使用<code>@Bean</code> 注解。</a></p><h4 id="1-3-2-实例化Bean"><a href="#1-3-2-实例化Bean" class="headerlink" title="1.3.2. 实例化Bean"></a>1.3.2. 实例化Bean</h4><p>bean定义基本上就是用来创建一个或多个对象的配置，当需要bean的时候，容器会查找配置并且根据bean定义封装的元数据来创建（或获取）实际对象。</p><p>如果你使用基于XML的配置，那么可以在<code>&lt;bean/&gt;</code> 元素中通过 <code>class</code>属性来指定对象类型。 class属性实际上就是<code>BeanDefinition</code>实例中的<code>class</code>属性。他通常是必需的（一些例外情况，查看 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a> 和 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-child-bean-definitions">Bean 定义的继承</a>)。有两种方式使用Class属性</p><ul><li>通常情况下，会直接通过反射调用构造方法来创建bean，这种方式与Java代码的<code>new</code>创建相似。</li><li>通过静态工厂方法创建，类中包含静态方法。通过调用静态方法返回对象的类型可能和Class一样，也可能完全不一样。</li></ul><p>内部类名</p><p>如果你想配置静态内部类，那么必须使用内部类的二进制名称。</p><p>例如，在<code>com.example</code>有个<code>SomeThing</code>类，这个类里面有个静态内部类<code>OtherThing</code>，这种情况下bean定义的class属性应该写作 <code>com.example.SomeThing$OtherThing</code>.</p><p>使用$字符来分隔外部类和内部类的名称</p><h5 id="使用构造器实例化"><a href="#使用构造器实例化" class="headerlink" title="使用构造器实例化"></a>使用构造器实例化</h5><p>当您通过构造方法创建bean时，所有普通类都可以使用并与Spring兼容。也就是说，正在开发的类不需要实现任何特定接口或以特定方式编码。 只要指定bean类就足够了。但是，根据您为该特定bean使用的IoC类型，您可能需要一个默认（空）构造函数。</p><p>Spring IoC容器几乎可以管理您希望它管理的任何类。它不仅限于管理真正的JavaBeans。大多数Spring用户更喜欢管理那些只有一个默认构造函数（无参数） 和有合适的setter和getter方法的真实的JavaBeans，还可以在容器中放置更多的外部非bean形式（non-bean-style)类，例如：如果需要使用一个绝对违反JavaBean规范的遗留连接池时 Spring也是可以管理它的。</p><p>使用基于XML的配置元数据，您可以按如下方式指定bean类：:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span>/&gt;<br>&lt;bean <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;anotherExample&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>给构造方法指定参数以及为bean实例化设置属性将在后面的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-collaborators">依赖注入</a>中说明。</p><h5 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h5><p>当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过<code>factory-method</code> 属性来指定创建bean实例的工厂方法。 Spring将会调用此方法（其可选参数接下来会介绍）返回实例对象。从这样看来，它与通过普通构造器创建类实例没什么两样。</p><p>下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定对象的返回类型，只是指定了该类包含的工厂方法，在这个例中， <code>createInstance()</code>必须是一个静态（static）的方法。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;clientService&quot;</span><br><br>    <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.ClientService&quot;</span><br><br>    <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>以下示例显示了一个可以使用前面的bean定义的类:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClientService</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientService();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ClientService</span>()</span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientService <span class="hljs-title">createInstance</span>()</span> &#123;        <span class="hljs-keyword">return</span> clientService;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>给工厂方法指定参数以及为bean实例设置属性的详细内容请查阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-properties-detailed">依赖和配置详解</a> 。</p><h5 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h5><p>通过调用工厂实例的非静态方法进行实例化与通过<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class-static-factory-method">静态工厂方法</a>实例化类似， 要使用此机制，请将class属性保留为空，并在<code>factory-bean</code>属性中指定当前（或父级或祖先）容器中bean的名称，该容器包含要调用以创建对象的实例方法。 使用<code>factory-method</code>属性设置工厂方法本身的名称。以下示例显示如何配置此类bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- the bean to be created via the factory bean --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span>    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span>    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了相应的Java类:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span>()</span> &#123;        <span class="hljs-keyword">return</span> clientService;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>一个工厂类也可以包含多个工厂方法，如以下示例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span>    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span>    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span>    <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;serviceLocator&quot;</span>    <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了相应的Java类:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultServiceLocator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClientService clientService = <span class="hljs-keyword">new</span> ClientServiceImpl();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AccountService accountService = <span class="hljs-keyword">new</span> AccountServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientService <span class="hljs-title">createClientServiceInstance</span>()</span> &#123;        <span class="hljs-keyword">return</span> clientService;    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AccountService <span class="hljs-title">createAccountServiceInstance</span>()</span> &#123;        <span class="hljs-keyword">return</span> accountService;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>这种方法表明可以通过依赖注入（DI）来管理和配置工厂bean本身。请参阅详细信息中的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-properties-detailed">依赖和配置详解</a>。</p><p>在Spring文档中，“factory bean”是指在Spring容器中配置并通过<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class-instance-factory-method">实例</a> 或 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class-static-factory-method">静态工厂方法</a> 创建对象的bean。相比之下，FactoryBean（注意大小写）是指Spring特定的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-factorybean"><code>FactoryBean</code></a>。</p><h3 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4. 依赖"></a>1.4. 依赖</h3><p>一般情况下企业应用不会只有一个对象（Spring Bean），甚至最简单的应用都需要多个对象协同工作。下一节将解释如何从定义单个Bean到让多个Bean协同工作。</p><h4 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1. 依赖注入"></a>1.4.1. 依赖注入</h4><p>依赖注入是让对象只通过构造参数、工厂方法的参数或者配置的属性来定义他们的依赖的过程。这些依赖也是其他对象所需要协同工作的对象， 容器会在创建Bean的时候注入这些依赖。整个过程完全反转了由Bean自己控制实例化或者依赖引用，所以这个过程也称之为“控制反转”</p><p>当使用了依赖注入的特性以后，会让开发者更容易管理和解耦对象之间的依赖，使代码变得更加简单。对象之间不再关注依赖，也不需要知道依赖类的位置。如此一来，开发的类更易于测试 尤其是当开发者的依赖是接口或者抽象类的情况时，开发者可以轻易地在单元测试中mock对象。</p><p>依赖注入主要使用两种方式，一种是<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-constructor-injection">基于构造函数的注入</a>，另一种的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-setter-injection">基于Setter方法的依赖注入</a>。</p><h5 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h5><p>基于构造函数的依赖注入是由IoC容器来调用类的构造函数，构造函数的参数代表这个Bean所依赖的对象。构造函数的依赖注入与调用带参数的静态工厂方法基本一样。 调用具有特定参数的静态工厂方法来构造bean几乎是等效的，本讨论同样处理构造函数和静态工厂方法的参数。下面的例子展示了一个通过构造函数来实现依赖注入的类。:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SimpleMovieLister &#123;<br>    <span class="hljs-comment">// the SimpleMovieLister has a dependency on a MovieFinder    private MovieFinder movieFinder;</span><br>    <span class="hljs-comment">// a constructor so that the Spring container can inject a MovieFinder    public SimpleMovieLister(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;</span><br>    <span class="hljs-comment">// business logic that actually uses the injected MovieFinder is omitted...&#125;</span><br></code></pre></td></tr></table></figure><p>请注意，这个类没有什么特别之处。 它是一个POJO，它不依赖于容器特定的接口，基类或注解。</p><h6 id="解析构造器参数"><a href="#解析构造器参数" class="headerlink" title="解析构造器参数"></a>解析构造器参数</h6><p>构造函数的参数解析是通过参数的类型来匹配的。如果在Bean的构造函数参数不存在歧义，那么构造器参数的顺序也就是就是这些参数实例化以及装载的顺序。参考如下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> x.y;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThingOne</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThingOne</span><span class="hljs-params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>假设<code>ThingTwo</code>和<code>ThingThree</code>类与继承无关，也没有什么歧义。下面的配置完全可以工作正常。开发者无需再到<code>&lt;constructor-arg/&gt;</code>元素中指定构造函数参数的index或type</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;beans&gt;    &lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;thingOne&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;x.y.ThingOne&quot;</span>&gt;        &lt;constructor-arg ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;thingTwo&quot;</span>/&gt;        &lt;constructor-arg ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;thingThree&quot;</span>/&gt;    &lt;/bean&gt;<br>    &lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;thingTwo&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;x.y.ThingTwo&quot;</span>/&gt;<br>    &lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;thingThree&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;x.y.ThingThree&quot;</span>/&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>当引用另一个bean时，如果类型是已知的，匹配就会工作正常（与前面的示例一样）。当使用简单类型的时候（例如<code>&lt;value&gt;true&lt;/value&gt;</code>）， Spring IoC容器无法判断值的类型，所以也是无法匹配的，考虑代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> examples;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleBean</span> &#123;<br>    <span class="hljs-comment">// Number of years to calculate the Ultimate Answer    private int years;</span><br>    <span class="hljs-comment">// The Answer to Life, the Universe, and Everything    private String ultimateAnswer;</span><br>    <span class="hljs-keyword">public</span> ExampleBean(int years, String ultimateAnswer) &#123;        <span class="hljs-keyword">this</span>.years = years;        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>构造函数参数类型匹配</p><p>在前面的场景中，如果使用 type 属性显式指定构造函数参数的类型，则容器可以使用与简单类型的类型匹配。如下例所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;exampleBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;<br><br>    &lt;constructor-arg type<span class="hljs-operator">=</span><span class="hljs-string">&quot;int&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;7500000&quot;</span>/&gt;<br><br>    &lt;constructor-arg type<span class="hljs-operator">=</span><span class="hljs-string">&quot;java.lang.String&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;42&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>构造函数参数索引</p><p>您可以使用<code>index</code>属性显式指定构造函数参数的索引，如以下示例所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;exampleBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;<br><br>    &lt;constructor-arg index<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;7500000&quot;</span>/&gt;<br><br>    &lt;constructor-arg index<span class="hljs-operator">=</span><span class="hljs-string">&quot;1&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;42&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有相同类型的两个参数的歧义。</p><p>index 从0开始。</p><p>构造函数参数名称</p><p>您还可以使用构造函数参数名称消除歧义，如以下示例所示：:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;exampleBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;<br><br>    &lt;constructor-arg name<span class="hljs-operator">=</span><span class="hljs-string">&quot;years&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;7500000&quot;</span>/&gt;<br><br>    &lt;constructor-arg name<span class="hljs-operator">=</span><span class="hljs-string">&quot;ultimateAnswer&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;42&quot;</span>/&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>需要注意的是，解析这个配置的代码必须启用了调试标记来编译，这样Spring才可以从构造函数查找参数名称。开发者也可以使用<a href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a>注解来显式声明构造函数的名称。 例如下面代码:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> examples;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleBean</span> &#123;<br>    <span class="hljs-comment">// Fields omitted</span><br>    <span class="hljs-meta">@ConstructorProperties(&#123;<span class="hljs-string">&quot;years&quot;</span>, <span class="hljs-string">&quot;ultimateAnswer&quot;</span>&#125;)</span>    <span class="hljs-keyword">public</span> ExampleBean(int years, String ultimateAnswer) &#123;        <span class="hljs-keyword">this</span>.years = years;        <span class="hljs-keyword">this</span>.ultimateAnswer = ultimateAnswer;    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="基于setter方法的依赖注入"><a href="#基于setter方法的依赖注入" class="headerlink" title="基于setter方法的依赖注入"></a>基于setter方法的依赖注入</h5><p>基于setter函数的依赖注入是让容器调用拥有Bean的无参构造函数，或者<code>无参静态工厂方法</code>，然后再来调用setter方法来实现依赖注入。</p><p>下面的例子展示了使用setter方法进行的依赖注入的过程。其中类对象只是简单的POJO，它不依赖于容器特定的接口，基类或注解。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">SimpleMovieLister</span> &#123;<br>    <span class="hljs-comment">// the SimpleMovieLister has a dependency on the MovieFinder    private MovieFinder movieFinder;</span><br>    <span class="hljs-comment">// a setter method so that the Spring container can inject a MovieFinder    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;</span><br>    <span class="hljs-comment">// business logic that actually uses the injected MovieFinder is omitted...&#125;</span><br></code></pre></td></tr></table></figure><p><code>ApplicationContext</code>所管理Bean同时支持基于构造函数和基于setter方法的依赖注入，同时也支持使用setter方法在通过构造函数注入依赖之后再次注入依赖。 开发者在<code>BeanDefinition</code>中可以使用<code>PropertyEditor</code>实例来自由选择注入方式。然而，大多数的开发者并不直接使用这些类，而是更喜欢使用XML配置来进行bean定义， 或者基于注解的组件（例如使用 <code>@Component</code>,<code>@Controller</code>等），或者在配置了<code>@Configuration</code>的类上面使用<code>@Bean</code>的方法。 然后，这些源在内部转换为 <code>BeanDefinition</code>的实例，并用于加载整个Spring IoC容器实例。</p><p>如何选择基于构造器和基于setter方法?</p><p>因为开发者可以混用两种依赖注入方式，两种方式用于处理不同的情况：必要的依赖通常通过构造函数注入，而可选的依赖则通过setter方法注入。其中，在setter方法上添加<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-required-annotation">@Required</a> 注解可用于构造必要的依赖。</p><p>Spring团队推荐使用基于构造函数的注入，因为这种方式会促使开发者将组件开发成不可变对象并且确保注入的依赖不为<code>null</code>。另外，基于构造函数的注入的组件被客户端调用的时候也已经是完全构造好的 。当然，从另一方面来说，过多的构造函数参数也是非常糟糕的代码方式，这种方式说明类附带了太多的功能，最好重构将不同职能分离。</p><p>基于setter的注入只用于可选的依赖，但是也最好配置一些合理的默认值。否则，只能对代码的依赖进行非null值检查了。基于setter方法的注入有一个便利之处是：对象可以重新配置和重新注入。 因此，使用setter注入管理 <a href="https://github.com/DocsHome/spring-docs/blob/master/pages/integration/integration.md#jmx">JMX MBeans</a> 是很方便的</p><p>依赖注入的两种风格适合大多数的情况，但是在使用第三方库的时候，开发者可能并没有源码，那么就只能使用基于构造函数的依赖注入了。</p><h5 id="决定依赖的过程"><a href="#决定依赖的过程" class="headerlink" title="决定依赖的过程"></a>决定依赖的过程</h5><p>容器解析Bean的过程如下:</p><ul><li>创建并根据描述的元数据来实例化<code>ApplicationContext</code>，元数据配置可以是XML文件、Java代码或者注解。</li><li>每一个Bean的依赖都通过构造函数参数或属性，或者静态工厂方法的参数等等来表示。这些依赖会在Bean创建的时候装载和注入</li><li>每一个属性或者构造函数的参数都是真实定义的值或者引用容器其他的Bean.</li><li>每一个属性或者构造参数可以根据指定的类型转换为所需的类型。Spring也可以将String转成默认的Java内置类型。例如<code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>等 。</li></ul><p>Spring容器会在容器创建的时候针对每一个Bean进行校验。但是Bean的属性在Bean没有真正创建之前是不会进行配置的，单例类型的Bean是容器创建的时候配置成预实例状态的。 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes">Bean的作用域</a>后面再说，其他的Bean都只有在请求的时候，才会创建，显然创建Bean对象会有一个依赖顺序图，这个图表示Bean之间的依赖关系。 容器根据此来决定创建和配置Bean的顺序。</p><p>循环依赖</p><p>如果开发者主要使用基于构造函数的依赖注入，那么很有可能出现循环依赖的情况。</p><p>例如：类A在构造函数中依赖于类B的实例，而类B的构造函数又依赖类A的实例。如果这样配置类A和类B相互注入的话，Spring IoC容器会发现这个运行时的循环依赖， 并且抛出<code>BeanCurrentlyInCreationException</code>。</p><p>开发者可以选择setter方法来配置依赖注入，这样就不会出现循环依赖的情况。或者根本就不使用基于构造函数的依赖注入，而仅仅使用基于setter方法的依赖注入。 换言之，但是开发者可以将循环依赖配置为基于Setter方法的依赖注入（尽管不推荐这样做）</p><p>不像典型的例子（没有循环依赖的情况），bean A和bean B之间的循环依赖关系在完全初始化之前就已经将其中一个bean注入到另一个中了（典型的鸡和鸡蛋的故事）</p><p>你可以信任Spring做正确的事。它在容器加载时检测配置问题，例如对不存在的bean和循环依赖的引用。 当实际创建bean时，Spring会尽可能晚地设置属性并解析依赖项。这也意味着Spring容器加载正确后会在bean注入依赖出错的时候抛出异常。例如，bean抛出缺少属性或者属性不合法的异常 ，这种延迟的解析也是<code>ApplicationContext</code> 的实现会令单例Bean处于预实例化状态的原因。这样，通过<code>ApplicationContext</code>创建bean，可以在真正使用bean之前消耗一些内存代价而发现配置的问题 。开发者也可以覆盖默认的行为让单例bean延迟加载，而不总是处于预实例化状态。</p><p>如果不存在循环依赖的话，bean所引用的依赖会预先全部构造。举例来说，如果bean A依赖于bean B，那么Spring IoC容器会先配置bean B，然后调用bean A的setter方法来构造bean A。 换言之，bean先会实例化，然后再注入依赖，最后才是相关生命周期方法的调用（就像配置文件的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean">初始化方法</a> 或者<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean">InitializingBean的回调函数</a>那样）。</p><h5 id="依赖注入的例子"><a href="#依赖注入的例子" class="headerlink" title="依赖注入的例子"></a>依赖注入的例子</h5><p>下面的例子使用基于XML的元数据配置，然后使用setter方式进行依赖注入。下面是Spring中使用XML文件声明bean定义的片段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- setter injection using the nested ref element --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanOne&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;beanTwo&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;integerProperty&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.AnotherBean&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了相应的 <code>ExampleBean</code>类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleBean</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">AnotherBean</span> beanOne;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">YetAnotherBean</span> beanTwo;<br>    <span class="hljs-keyword">private</span> int i;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setBeanOne</span>(<span class="hljs-params">AnotherBean beanOne</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">beanOne</span> = beanOne;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setBeanTwo</span>(<span class="hljs-params">YetAnotherBean beanTwo</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">beanTwo</span> = beanTwo;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setIntegerProperty</span>(<span class="hljs-params">int i</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> = i;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中，setter被声明为与XML文件中指定的属性匹配。以下示例使用基于构造函数的DI：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- constructor injection using the nested ref element --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.AnotherBean&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;examples.YetAnotherBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了相应的<code>ExampleBean</code>类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleBean</span> &#123;<br>    <span class="hljs-keyword">private</span> AnotherBean beanOne;<br>    <span class="hljs-keyword">private</span> YetAnotherBean beanTwo;<br>    <span class="hljs-keyword">private</span> int i;<br>    <span class="hljs-keyword">public</span> ExampleBean(        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;        <span class="hljs-keyword">this</span>.beanOne = anotherBean;        <span class="hljs-keyword">this</span>.beanTwo = yetAnotherBean;        <span class="hljs-keyword">this</span>.i = i;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>bean定义中指定的构造函数参数用作 <code>ExampleBean</code>的构造函数的参数。</p><p>现在考虑这个示例的变体，其中，不使用构造函数，而是告诉Spring调用静态工厂方法来返回对象的实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;exampleBean&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span> <span class="hljs-attribute">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>&gt;    &lt;constructor-arg <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span>/&gt;    &lt;constructor-arg <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span>/&gt;    &lt;constructor-arg <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;&lt;/bean&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;anotherExampleBean&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.AnotherBean&quot;</span>/&gt;&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;yetAnotherBean&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;examples.YetAnotherBean&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>以下示例显示了相应的<code>ExampleBean</code>类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> </span>&#123;<br>    <span class="hljs-comment">// a private constructor    private ExampleBean(...) &#123;        ...    &#125;</span><br>    <span class="hljs-comment">// a static factory method; the arguments to this method can be    // considered the dependencies of the bean that is returned,    // regardless of how those arguments are actually used.    public static ExampleBean createInstance (        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;</span><br>        ExampleBean eb = <span class="hljs-keyword">new</span> <span class="hljs-type">ExampleBean</span> (...);        <span class="hljs-comment">// some other operations...        return eb;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p><code>静态工厂方法</code>的参数由<code>&lt;constructor-arg/&gt;</code>元素提供，与实际使用的构造函数完全相同。工厂方法返回类的类型不必与包含<code>静态工厂方法</code> 的类完全相同， 尽管在本例中是这样。实例（非静态）工厂方法的使用方式也是相似的（除了使用<code>factory-bean</code>属性而不是<code>class</code>属性。因此此处不在展开讨论。</p><h4 id="1-4-2-依赖和配置的细节"><a href="#1-4-2-依赖和配置的细节" class="headerlink" title="1.4.2. 依赖和配置的细节"></a>1.4.2. 依赖和配置的细节</h4><p><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-collaborators">如上一节所述</a>，您可以将bean的属性和构造函数参数定义为对其他bean的引用，或者作为其内联定义的值。Spring可以允许您在基于XML的配置元数据（定义Bean）中使用子元素<code>&lt;property/&gt;</code> and <code>&lt;constructor-arg/&gt;</code> 来达到这种目的。</p><h5 id="直接值（基本类型，String等等）"><a href="#直接值（基本类型，String等等）" class="headerlink" title="直接值（基本类型，String等等）"></a>直接值（基本类型，String等等）</h5><p><code>&lt;property/&gt;</code> 元素的<code>value</code> 属性将属性或构造函数参数指定为人类可读的字符串表示形式， Spring的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#core-convert-ConversionService-API">conversion service</a>用于将这些值从<code>String</code> 转换为属性或参数的实际类型。 以下示例显示了要设置的各种值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;masterkaoli&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-p-namespace">p命名空间</a>进行更简洁的XML配置：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    xmlns:p=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span>    xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;myDataSource&quot;</span> class=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>        destroy-method=<span class="hljs-string">&quot;close&quot;</span>        <span class="hljs-selector-tag">p</span>:driverClassName=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>        <span class="hljs-selector-tag">p</span>:url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>        <span class="hljs-selector-tag">p</span>:username=<span class="hljs-string">&quot;root&quot;</span>        <span class="hljs-selector-tag">p</span>:password=<span class="hljs-string">&quot;masterkaoli&quot;</span>/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>前面的XML更简洁。 但是因为属性的类型是在运行时确定的，而非设计时确定的。所有有可能在运行时发现拼写错误。，除非您在创建bean定义时使用支持自动属性完成的IDE（例如<a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> or the <a href="https://spring.io/tools/sts">Spring Tool Suite</a>）。 所以，强烈建议使用此类IDE帮助。</p><p>你也可以配置一个<code>java.util.Properties</code> 的实例，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mappings&quot;</span>    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- typed as a java.util.Properties --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>            jdbc.driver.className=com.mysql.jdbc.Driver            jdbc.url=jdbc:mysql://localhost:3306/mydb        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring的容器会将<code>&lt;value/&gt;</code>里面的文本通过JavaBean的<code>PropertyEditor</code> 机制转换成<code>java.util.Properties</code> 实例， 这种嵌套<code>&lt;value/&gt;</code>元素的快捷方式也是Spring团队推荐使用的。</p><h6 id="idref-元素"><a href="#idref-元素" class="headerlink" title="idref 元素"></a><code>idref</code> 元素</h6><p><code>idref</code> 元素只是一种防错方法，可以将容器中另一个bean的<code>id</code>（字符串值 - 而不是引用）传递给<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;theTargetBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;...&quot;</span>/&gt;<br>&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;theClientBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;...&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;targetName&quot;</span>&gt;        &lt;idref bean<span class="hljs-operator">=</span><span class="hljs-string">&quot;theTargetBean&quot;</span>/&gt;    &lt;/property&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>前面的bean定义代码段运行时与以下代码段完全等效：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;theTargetBean&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span> /&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;client&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;targetName&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;theTargetBean&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>Spring团队更推荐第一种方式，因为使用了<code>idref</code> 标签，它会让容器在部署阶段就对bean进行校验，以确保bean一定存在。而使用第二种方式的话，是没有任何校验的。 只有实际上引用了<code>client</code> bean的<code>targetName</code>属性，不对其值进行校验。在实例化client的时候才会被发现。如果client是<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes">prototype</a>类型的Bean的话，那么类似拼写之类的错误会在容器部署以后很久才能发现。</p><p><code>idref</code>元素的<code>local</code>属性在Spring 4.0以后的xsd中已经不再支持了，而是使用了bean引用。如果更新了版本的话，只要将<code>idref local</code>引用都转换成<code>idref bean</code> 即可。</p><p>在<code>ProxyFactoryBean</code>定义中，元素所携带的值在<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aop-pfb-1">AOP拦截器a&gt;的配置中很常见（至少在Spring 2.0之前的版本是这样）。在指定拦截器名称时使用&#96;&#96; 元素可防止拦截器漏掉id或拼写错误。</a></p><h5 id="引用其他的Bean（装配）"><a href="#引用其他的Bean（装配）" class="headerlink" title="引用其他的Bean（装配）"></a>引用其他的Bean（装配）</h5><p><code>ref</code> 元素是<code>&lt;constructor-arg/&gt;</code> 或 or <code>&lt;property/&gt;</code>定义元素中的最后一个元素。 你可以通过这个标签配置一个bean来引用另一个bean。当需要引用一个bean的时候，被引用的bean会先实例化，然后配置属性，也就是引用的依赖。如果该bean是单例bean的话 ，那么该bean会早由容器初始化。最终会引用另一个对象的所有引用，bean的范围以及校验取决于你是否有通过<code>bean</code>, <code>local,</code> or <code>parent</code> 这些属性来指定对象的id或者name属性。</p><p>通过指定 <code>bean</code>属性中的<code>&lt;ref/&gt;</code>元素来指定依赖是最常见的一种方式，可以引用容器或者父容器中的bean，不在同一个XML文件定义也可以引用。 其中<code>bean</code> 属性中的值可以和其他引用<code>bean</code> 中的<code>id</code>属性一致，或者和其中的某个<code>name</code> 属性一致，以下示例显示如何使用ref元素：：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;ref <span class="hljs-attribute">bean</span>=<span class="hljs-string">&quot;someBean&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>通过指定bean的<code>parent</code>属性可以创建一个引用到当前容器的父容器之中。<code>parent</code>属性的值可以与目标bean的<code>id</code>属性一致，或者和目标bean的<code>name</code>属性中的某个一致，目标bean必须是当前引用目标bean容器的父容器 。开发者一般只有在存在层次化容器，并且希望通过代理来包裹父容器中一个存在的bean的时候才会用到这个属性。 以下一对列表显示了如何使用父属性:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml"><span class="hljs-comment">&lt;!-- in the parent context --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.SimpleAccountService&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- insert dependencies as required as here --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- in the child (descendant) context --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">bean</span> <span class="hljs-attr">name</span> <span class="hljs-attr">is</span> <span class="hljs-attr">the</span> <span class="hljs-attr">same</span> <span class="hljs-attr">as</span> <span class="hljs-attr">the</span> <span class="hljs-attr">parent</span> <span class="hljs-attr">bean</span> <span class="hljs-attr">--</span>&gt;</span>    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;accountService&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- notice how we refer to the parent bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>与idref标签一样，<code>ref</code>元素中的<code>local</code> 标签在xsd 4.0，以后已经不再支持了，开发者可以通过将已存在的<code>ref local</code>改为<code>ref bean</code> 来完成Spring版本升级。</p><h5 id="内部bean"><a href="#内部bean" class="headerlink" title="内部bean"></a>内部bean</h5><p>定义在<code>&lt;bean/&gt;</code>元素的<code>&lt;property/&gt;</code>或者<code>&lt;constructor-arg/&gt;</code> 元素之内的bean叫做内部bean，如下例所示：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.Person&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- this is the inner bean --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Fiona Apple&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>内部bean定义不需要定义的ID或名称。如果指定，则容器不使用此类值作为标识符。容器还会在创建时忽略<code>scope</code> 标签，因为内部bean始终是匿名的，并且始终使用外部bean创建。 开发者是无法将内部bean注入到外部bean以外的其他bean中的。</p><p>作为一个极端情况，可以从自定义范围接收销毁回调 ， 例如：请求范围的内部bean包含了单例bean，那么内部bean实例会绑定到包含的bean，而包含的bean允许访问request的scope生命周期。 这种场景并不常见，内部bean通常只是供给它的外部bean使用。</p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>在<code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;props/&gt;</code>元素中，您可以分别配置Java集合类型 <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>的属性和参数。 以下示例显示了如何使用它们:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;moreComplexObject&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.ComplexObject&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adminEmails&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;administrator&quot;</span>&gt;</span>administrator@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;support&quot;</span>&gt;</span>support@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>development@example.org<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someList&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>a list element followed by a reference<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myDataSource&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someMap&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;an entry&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;just some string&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span> =<span class="hljs-string">&quot;a ref&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;myDataSource&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;someSet&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>just some string<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myDataSource&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，map的key或者value，或者集合的value都可以配置为下列元素之一:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">bean | <span class="hljs-type">ref</span> | <span class="hljs-type">idref</span> | <span class="hljs-type">list</span> | <span class="hljs-type">set</span> | <span class="hljs-type">map</span> | <span class="hljs-type">props</span> | <span class="hljs-type">value</span> | <span class="hljs-type">null</span><br></code></pre></td></tr></table></figure><h6 id="集合的合并"><a href="#集合的合并" class="headerlink" title="集合的合并"></a>集合的合并</h6><p>Spring的容器也支持集合合并，开发者可以定义父样式的<list/>, <map/>, <set/> 或 <props/>元素， 同时有子样式的<list/>, <map/>, <set/> 或 <props/>元素。也就是说，子集合的值是父元素和子元素集合的合并值。</p><p>有关合并的这一节讨论父子bean机制，不熟悉父和子bean定义的读者可能希望在继续之前阅读<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-child-bean-definitions">相关部分</a>。</p><p>以下示例演示了集合合并：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.ComplexObject&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adminEmails&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;administrator&quot;</span>&gt;</span>administrator@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;support&quot;</span>&gt;</span>support@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;adminEmails&quot;</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span> <span class="hljs-attr">merge</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;sales&quot;</span>&gt;</span>sales@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;support&quot;</span>&gt;</span>support@example.co.uk<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请注意，在<code>child</code> bean 定义的<code>adminEmails</code>中的<code>&lt;props/&gt;</code>使用<code>merge=true</code> 属性。 当容器解析并实例化<code>child</code> bean时，生成的实例有一个<code>adminEmails</code>属性集合， 其实例中包含的<code>adminEmails</code>集合就是child的<code>adminEmails</code>以及parent的<code>adminEmails</code>集合。以下清单显示了结果： :</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">administrator</span>=administrator@example.com<br><br><span class="hljs-attr">sales</span>=sales@example.com<br><br><span class="hljs-attr">support</span>=support@example.co.uk<br></code></pre></td></tr></table></figure><p>子<code>属性</code>集合的值集继承父<code>&lt;props/&gt;</code>的所有属性元素，子值的<code>支持</code>值覆盖父集合中的值。</p><p>这个合并的行为和<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;set/&gt;</code>之类的集合类型的行为是类似的。<code>List</code> 在特定例子中，与List集合类型类似， 有着隐含的 <code>ordered</code>概念。所有的父元素里面的值，是在所有子元素的值之前配置的。但是像<code>Map</code>, <code>Set</code>, 和 <code>Properties</code>的集合类型，是不存在顺序的。</p><h6 id="集合合并的限制"><a href="#集合合并的限制" class="headerlink" title="集合合并的限制"></a>集合合并的限制</h6><p>您不能合并不同类型的集合（例如要将<code>Map</code> 和<code>List</code>合并是不可能的）。如果开发者硬要这样做就会抛出异常， <code>merge</code>的属性是必须特指到更低级或者继承的子节点定义上， 特指merge属性到父集合的定义上是冗余的，而且在合并上也没有任何效果。</p><h6 id="强类型的集合"><a href="#强类型的集合" class="headerlink" title="强类型的集合"></a>强类型的集合</h6><p>在Java 5以后，开发者可以使用强类型的集合了。也就是，开发者可以声明<code>Collection</code>类型，然后这个集合只包含<code>String</code>元素（举例来说）。 如果开发者通过Spring来注入强类型的Collection到bean中，开发者就可以利用Spring的类型转换支持来做到 以下Java类和bean定义显示了如何执行此操作:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Float</span>&gt; accounts;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAccounts</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Float&gt; accounts</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">accounts</span> = accounts;    &#125;&#125;<br>&lt;beans&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;something&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.SomeClass&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;accounts&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;9.99&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2.75&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;six&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3.99&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>当<code>something</code>的属性<code>accounts</code>准备注入的时候，accounts的泛型信息Map<code>Map&lt;String, Float&gt;</code> 就会通过反射拿到。 这样，Spring的类型转换系统能够识别不同的类型，如上面的例子<code>Float</code>然后会将字符串的值<code>9.99, 2.75</code>, 和<code>3.99</code>转换成对应的<code>Float</code>类型。</p><h5 id="Null-and-空字符串"><a href="#Null-and-空字符串" class="headerlink" title="Null and 空字符串"></a>Null and 空字符串</h5><p><code>Strings</code>将属性的空参数视为空字符串。下面基于XML的元数据配置就会将<code>email</code> 属性配置为String的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;bean <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">ExampleBean</span>&quot;&gt;<br><br>    &lt;<span class="hljs-symbol">property</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">email</span>&quot; <span class="hljs-symbol">value</span>=&quot;&quot;/&gt;<br><br>&lt;/<span class="hljs-symbol">bean</span>&gt;<br></code></pre></td></tr></table></figure><p>上面的示例等效于以下Java代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">exampleBean.setEmail(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>&lt;null/&gt;</code>将被处理为null值。以下清单显示了一个示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;bean <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">ExampleBean</span>&quot;&gt;<br><br>    &lt;<span class="hljs-symbol">property</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">email</span>&quot;&gt;<br><br>        &lt;<span class="hljs-symbol">null</span>/&gt;<br><br>    &lt;/<span class="hljs-symbol">property</span>&gt;<br><br>&lt;/<span class="hljs-symbol">bean</span>&gt;<br></code></pre></td></tr></table></figure><p>上述配置等同于以下Java代码：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">exampleBean.setEmail(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h5 id="使用p命名空间简化XML配置"><a href="#使用p命名空间简化XML配置" class="headerlink" title="使用p命名空间简化XML配置"></a>使用p命名空间简化XML配置</h5><p>p命名空间让开发者可以使用<code>bean</code>的属性，而不必使用嵌套的<code>&lt;property/&gt;</code>元素。</p><p>Spring是支持基于XML的格式化<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#xsd-schemas">命名空间</a>扩展的。本节讨论的<code>beans</code> 配置都是基于XML的，p命名空间是定义在Spring Core中的（不是在XSD文件）。</p><p>以下示例显示了两个XML片段（第一个使用标准XML格式，第二个使用p命名空间），它们解析为相同的结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;classic&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.ExampleBean&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;someone@somewhere.com&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;p-namespace&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.ExampleBean&quot;</span>        <span class="hljs-attr">p:email</span>=<span class="hljs-string">&quot;someone@somewhere.com&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的例子在bean中定义了<code>email</code>的属性。这种定义告知Spring这是一个属性声明。如前面所描述的，p命名空间并没有标准的定义模式，所以开发者可以将属性的名称配置为依赖名称。</p><p>下一个示例包括另外两个bean定义，它们都引用了另一个bean:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;<br>    &lt;bean <span class="hljs-type">name</span>=&quot;john-classic&quot; <span class="hljs-keyword">class</span>=&quot;com.example.Person&quot;&gt;        &lt;property <span class="hljs-type">name</span>=&quot;name&quot; <span class="hljs-keyword">value</span>=&quot;John Doe&quot;/&gt;        &lt;property <span class="hljs-type">name</span>=&quot;spouse&quot; <span class="hljs-keyword">ref</span>=&quot;jane&quot;/&gt;    &lt;/bean&gt;<br>    &lt;bean <span class="hljs-type">name</span>=&quot;john-modern&quot;        <span class="hljs-keyword">class</span>=&quot;com.example.Person&quot;        p:<span class="hljs-type">name</span>=&quot;John Doe&quot;        p:spouse-<span class="hljs-keyword">ref</span>=&quot;jane&quot;/&gt;<br>    &lt;bean <span class="hljs-type">name</span>=&quot;jane&quot; <span class="hljs-keyword">class</span>=&quot;com.example.Person&quot;&gt;        &lt;property <span class="hljs-type">name</span>=&quot;name&quot; <span class="hljs-keyword">value</span>=&quot;Jane Doe&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>此示例不仅包含使用p命名空间的属性值，还使用特殊格式来声明属性引用。第一个bean定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>来创建从bean <code>john</code>到bean <code>jane</code>的引用， 而第二个bean定义使用<code>p:spouse-ref=&quot;jane&quot;</code>来作为指向bean的引用。在这个例子中 <code>spouse</code>是属性的名字，而<code>-ref</code>部分表名这个依赖不是直接的类型，而是引用另一个bean。</p><p>p命名空间并不如标准XML格式灵活。例如，声明属性的引用可能和一些以<code>Ref</code>结尾的属性相冲突，而标准的XML格式就不会。Spring团队推荐开发者能够和团队商量一下，协商使用哪一种方式，而不要同时使用三种方法。</p><h5 id="使用c命名空间简化XML"><a href="#使用c命名空间简化XML" class="headerlink" title="使用c命名空间简化XML"></a>使用c命名空间简化XML</h5><p>与 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-p-namespace">p命名空间</a>类似，c命名空间是在Spring 3.1首次引入的，c命名空间允许使用内联的属性来配置构造参数而不必使用<code>constructor-arg</code> 。</p><p>以下示例使用<code>c:</code>命名空间的例子来执行与<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-constructor-injection">基于Constructor的依赖注入</a>相同的操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thingOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thingTwo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingThree&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- traditional declaration --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thingOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingOne&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;thingTwo&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;thingThree&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;something@somewhere.com&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- c-namespace declaration --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thingOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingOne&quot;</span> <span class="hljs-attr">c:thingTwo-ref</span>=<span class="hljs-string">&quot;thingTwo&quot;</span> <span class="hljs-attr">c:thingThree-ref</span>=<span class="hljs-string">&quot;thingThree&quot;</span> <span class="hljs-attr">c:email</span>=<span class="hljs-string">&quot;something@somewhere.com&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>c:</code>:命名空间使用了和<code>p:</code> :命名空间相类似的方式（使用了<code>-ref</code> 来配置引用).而且,同样的,c命名空间也是定义在Spring Core中的（不是XSD模式).</p><p>在少数的例子之中,构造函数的参数名字并不可用（通常,如果字节码没有debug信息的编译),你可以使用回调参数的索引，如下面的例子:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- c-namespace index declaration --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thingOne&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.ThingOne&quot;</span> <span class="hljs-attr">c:_0-ref</span>=<span class="hljs-string">&quot;thingTwo&quot;</span> <span class="hljs-attr">c:_1-ref</span>=<span class="hljs-string">&quot;thingThree&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>由于XML语法，索引表示法需要使用<code>_</code>作为属性名字的前缀，因为XML属性名称不能以数字开头（即使某些IDE允许它）。</p><p>实际上，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-ctor-arguments-resolution">构造函数解析机制</a>在匹配参数方面非常有效，因此除非您确实需要，否则我们建议在整个配置中使用名称表示法。</p><h5 id="组合属性名"><a href="#组合属性名" class="headerlink" title="组合属性名"></a>组合属性名</h5><p>开发者可以配置混合的属性，只需所有的组件路径（除了最后一个属性名字）不能为<code>null</code>即可。参考如下定义：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;something&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;things.ThingOne&quot;</span>&gt;<br><br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;fred.bob.sammy&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;123&quot;</span> /&gt;<br><br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><code>something</code>有 <code>fred</code>的属性，而其中<code>fred</code>属性有<code>bob</code>属性，而<code>bob</code>属性之中有<code>sammy</code>属性，那么最后这个<code>sammy</code>属性会配置为123。 想要上述的配置能够生效，<code>fred</code>属性需要有<code>bob</code>属性而且在<code>fred</code>构造之后不为null即可。</p><h4 id="1-4-3-使用-depends-on属性"><a href="#1-4-3-使用-depends-on属性" class="headerlink" title="1.4.3. 使用 depends-on属性"></a>1.4.3. 使用 <code>depends-on</code>属性</h4><p>如果一个bean是另一个bean的依赖，通常这个bean也就是另一个bean的属性之一。多数情况下，开发者可以在配置XML元数据的时候使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-ref-element">&#96;&#96;</a>标签。 然而，有时bean之间的依赖不是直接关联的。例如：需要调用类的静态实例化器来触发依赖，类似数据库驱动注册。<code>depends-on</code>属性可以显式强制初始化一个或多个bean。 以下示例使用depends-on属性表示对单个bean的依赖关系:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;beanOne&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;ExampleBean&quot;</span> <span class="hljs-attribute">depends-on</span>=<span class="hljs-string">&quot;manager&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;manager&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;ManagerBean&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>如果想要依赖多个bean，可以提供多个名字作为<code>depends-on</code>的值。以逗号、空格或者分号分割:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;beanOne&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;ExampleBean&quot;</span> depends-on<span class="hljs-operator">=</span><span class="hljs-string">&quot;manager,accountDao&quot;</span>&gt;    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;manager&quot;</span> ref<span class="hljs-operator">=</span><span class="hljs-string">&quot;manager&quot;</span> /&gt;&lt;/bean&gt;<br>&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;manager&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;ManagerBean&quot;</span> /&gt;&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;accountDao&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><code>depends-on</code>属性既可以指定初始化时间依赖性，也可以指定单独的bean，相应的销毁时间的依赖。独立定义了<code>depends-on</code>属性的bean会优先销毁 （相对于<code>depends-on</code>的bean销毁，这样<code>depends-on</code>可以控制销毁的顺序。</p><h4 id="1-4-4-懒加载Bean"><a href="#1-4-4-懒加载Bean" class="headerlink" title="1.4.4. 懒加载Bean"></a>1.4.4. 懒加载Bean</h4><p>默认情况下， <code>ApplicationContext</code> 会在实例化的过程中创建和配置所有的单例<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-singleton">singleton</a> bean。总的来说， 这个预初始化是很不错的。因为这样能及时发现环境上的一些配置错误，而不是系统运行了很久之后才发现。如果这个行为不是迫切需要的，开发者可以通过将Bean标记为延迟加载就能阻止这个预初始化 懒加载bean会通知IoC不要让bean预初始化而是在被引用的时候才会实例化。</p><p>在XML中，此行为由<code>&lt;bean/&gt;</code>元素上的<code>lazy-init</code> 属性控制，如以下示例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="hljs-attribute">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;not.lazy&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.AnotherBean&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>当将bean配置为上述XML的时候， <code>ApplicationContext</code>之中的<code>lazy</code> bean是不会随着 <code>ApplicationContext</code>的启动而进入到预初始化状态的。 只有那些非延迟加载的bean是处于预初始化的状态的。</p><p>然而，如果延迟加载的类是作为单例非延迟加载的bean的依赖而存在的话，<code>ApplicationContext</code>仍然会在<code>ApplicationContext</code>启动的时候加载。 因为作为单例bean的依赖，会随着单例bean的实例化而实例化。</p><p>您还可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性在容器级别控制延迟初始化，以下示例显示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">default-lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-5-自动装配"><a href="#1-4-5-自动装配" class="headerlink" title="1.4.5. 自动装配"></a>1.4.5. 自动装配</h4><p>Spring容器可以根据bean之间的依赖关系自动装配，开发者可以让Spring通过<code>ApplicationContext</code>来自动解析这些关联，自动装载有很多优点:</p><ul><li>自动装载能够明显的减少指定的属性或者是构造参数。（在本章<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-child-bean-definitions">其他地方讨论</a>的其他机制，如bean模板，在这方面也很有价值。）</li><li>自动装载可以扩展开发者的对象，比如说，如果开发者需要加一个依赖，只需关心如何更改配置即可自动满足依赖关联。这样，自动装载在开发过程中是极其高效的，无需明确选择装载的依赖会使系统更加稳定</li></ul><p>使用基于XML的配置元数据（请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-collaborators">依赖注入</a>）时，可以使用<code>&lt;bean/&gt;</code> 元素的<code>autowire</code>属性为bean定义指定autowire模式。 自动装配功能有四种方式。开发者可以指定每个bean的装配方式，这样bean就知道如何加载自己的依赖。下表描述了四种自动装配模式：</p><p>Table 2. 装配模式</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><code>no</code></td><td>(默认) 不自动装配。Bean引用必须由 <code>ref</code> 元素定义，对于比较大的项目的部署，不建议修改默认的配置 ，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td></tr><tr><td><code>byName</code></td><td>按属性名称自动装配。 Spring查找与需要自动装配的属性同名的bean。 例如，如果bean配置为根据名字装配，他包含 的属性名字为<code>master</code>（即，它具有<code>setMaster(..)</code>方法），则Spring会查找名为 <code>master</code> 的bean定义并使用它来设置属性。</td></tr><tr><td><code>byType</code></td><td>如果需要自动装配的属性的类型在容器中只存在一个的话，他允许自动装配。如果存在多个，则抛出致命异常，这表示您不能对该bean使用<code>byType</code>自动装配。 如果没有匹配的bean，则不会发生任何事情（未设置该属性）。</td></tr><tr><td><code>constructor</code></td><td>类似于<code>byType</code>，但应用于构造函数参数。 如果容器中没有一个Bean的类型和构造函数参数类型一致的话，则会引发致命错误。</td></tr></tbody></table><p>通过<code>byType</code>或者<code>constructor</code>的自动装配方式，开发者可以装载数组和强类型集合。在这样的例子中，所有容器中的匹配了指定类型的bean都会自动装配到bean上来完成依赖注入。 开发者可以自动装配key为<code>String</code>.的强类型的 <code>Map</code> 。自动装配的Map值会包含所有的bean实例值来匹配指定的类型，<code>Map</code>的key会包含关联的bean的名字。</p><h5 id="自动装配的局限和缺点"><a href="#自动装配的局限和缺点" class="headerlink" title="自动装配的局限和缺点"></a>自动装配的局限和缺点</h5><p>自动装配在项目中一致使用时效果最佳。如果一般不使用自动装配，那么开发人员使用它来装配一个或两个bean定义可能会让人感到困惑。</p><p>考虑自动装配的局限和缺点:</p><ul><li><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终覆盖自动装配。开发者不能自动装配一些简单属性，您不能自动装配简单属性，例如基本类型 ，字符串和类（以及此类简单属性的数组）。这种限制是按设计的。</li><li>自动装配比显式的配置更容易歧义，尽管上表表明了不同自动配置的特点，Spring也会尽可能避免不必要的装配错误。但是Spring管理的对象关系仍然不如显式配置那样明确。</li><li>从Spring容器生成文档的工具可能无法有效的提供装配信息。</li><li>容器中的多个bean定义可能与setter方法或构造函数参数所指定的类型相匹配， 这有利于自动装配。对于arrays, collections, or <code>Map</code>实例来说这不是问题。但是如果是对只有一个依赖项的值是有歧义的话，那么这个项是无法解析的。如果没有唯一的bean，则会抛出异常。</li></ul><p>在后面的场景，你可有如下的选择：</p><ul><li>放弃自动装配，改用显式的配置。</li><li>通过将<code>autowire-candidate</code> 属性设置为<code>false</code>，避免对bean定义进行自动装配，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire-candidate">如下一节所述</a>。</li><li>通过将其<code>&lt;bean/&gt;</code> 元素的<code>primary</code>属性设置为 <code>true</code>，将单个bean定义指定为主要候选项。</li><li>使用基于注解的配置实现更细粒度的控制，如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-annotation-config">基于注解的容器配置</a>中所述。</li></ul><h5 id="将bean从自动装配中排除"><a href="#将bean从自动装配中排除" class="headerlink" title="将bean从自动装配中排除"></a>将bean从自动装配中排除</h5><p>在每个bean的基础上，您可以从自动装配中排除bean。 在Spring的XML格式中，将<code>&lt;bean/&gt;</code> 元素的<code>autowire-candidate</code> 属性设置为<code>false</code>。 容器使特定的bean定义对自动装配基础结构不可用（包括注解样式配置，如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-autowired-annotation"><code>@Autowired</code></a>）。</p><p><code>autowire-candidate</code> 属性旨在仅影响基于类型的自动装配。 它不会影响名称的显式引用，即使指定的bean未标记为autowire候选，也会解析它。 因此，如果名称匹配，则按名称自动装配会注入bean。</p><p>开发者可以通过模式匹配而不是Bean的名字来限制自动装配的候选者。最上层的<code>&lt;beans/&gt;</code> 元素会在<code>default-autowire-candidates</code> 属性中来配置多种模式。 例如，限制自动装配候选者的名字以<code>Repository</code>结尾，可以配置成<code>*Repository</code>。如果需要配置多种模式，只需要用逗号分隔开即可。 bean定义的<code>autowire-candidate</code>属性的显式值<code>true</code> 或<code>false</code>始终优先。 对于此类bean，模式匹配规则不适用。</p><p>上面的这些技术在配置那些无需自动装配的bean是相当有效的，当然这并不是说这类bean本身无法自动装配其他的bean。而是说这些bean不再作为自动装配的依赖候选者。</p><h4 id="1-4-6-方法注入"><a href="#1-4-6-方法注入" class="headerlink" title="1.4.6.方法注入"></a>1.4.6.方法注入</h4><p>在大多数的应用场景下，多数的bean都是<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-singleton">单例</a>的。当这个单例的bean需要和另一个单例的或者非单例的bean协作使用的时候，开发者只需要配置依赖bean为这个bean的属性即可。 但是有时会因为bean具有不同的生命周期而产生问题。假设单例的bean A在每个方法调用中使用了非单例的bean B。容器只会创建bean A一次，而只有一个机会来配置属性。 那么容器就无法为每一次创建bean A时都提供新的bean B实例。</p><p>一种解决方案就是放弃IoC，开发者可以通过实现<code>ApplicationContextAware</code>接口让<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware">bean A对ApplicationContext</a>可见。 从而通过调用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-client"><code>getBean(&quot;B&quot;)</code></a>来在bean A 需要新的实例的时候来获取到新的B实例。参考下面例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// a <span class="hljs-keyword">class</span> that uses a stateful Command-style <span class="hljs-keyword">class</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">perform</span> <span class="hljs-keyword">some</span> processingpackage fiona.apple;<br>// Spring-API importsimport org.springframework.beans.BeansException;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CommandManager implements ApplicationContextAware &#123;<br>    private ApplicationContext applicationContext;<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> process(Map commandState) &#123;        // grab a <span class="hljs-built_in">new</span> instance <span class="hljs-keyword">of</span> the appropriate Command        Command command = createCommand();        // <span class="hljs-keyword">set</span> the state <span class="hljs-keyword">on</span> the (hopefully brand <span class="hljs-built_in">new</span>) Command instance        command.setState(commandState);        <span class="hljs-keyword">return</span> command.<span class="hljs-keyword">execute</span>();    &#125;<br>    protected Command createCommand() &#123;        // <span class="hljs-keyword">notice</span> the Spring API dependency!        <span class="hljs-keyword">return</span> this.applicationContext.getBean(&quot;command&quot;, Command.<span class="hljs-keyword">class</span>);    &#125;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setApplicationContext(            ApplicationContext applicationContext) throws BeansException &#123;        this.applicationContext = applicationContext;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>上面的代码并不让人十分满意，因为业务的代码已经与Spring框架耦合在一起。方法注入是Spring IoC容器的一个高级功能，可以让您处理这种问题。 Spring提供了一个稍微高级的注入方式来处理这种问题</p><p>您可以在此<a href="https://spring.io/blog/2004/08/06/method-injection/">博客条目</a>中阅读有关方法注入的更多信息。</p><h5 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h5><p>查找方法注入是容器覆盖管理bean上的方法的能力，以便返回容器中另一个命名bean的查找结果。查找方法通常涉及原型bean，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-method-injection">如前面描述的场景</a>。 Spring框架通过使用CGLIB库生成的字节码来生成动态子类重写的方法实现此注入。</p><ul><li>如果想让这个动态子类正常工作，那么Spring容器所继承的Bean不能是<code>final</code>的，而覆盖的方法也不能是<code>final</code>的。</li><li>对具有<code>抽象</code>方法的类进行单元测试时，需要开发者对类进行子类化，并提供<code>抽象</code>方法的具体实现。</li><li>组件扫描也需要具体的方法，因为它需要获取具体的类。</li><li>另一个关键限制是查找方法不适用于工厂方法，特别是在配置类中不使用<code>@Bean</code>的方法。因为在这种情况下，容器不负责创建实例，因此不能在运行时创建运行时生成的子类。</li></ul><p>对于前面代码片段中的<code>CommandManager</code>类，Spring容器动态地覆盖<code>createCommand()</code>方法的实现。 <code>CommandManager</code>类不再拥有任何的Spring依赖，如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">package fiona.apple;<br>// no more Spring imports!<span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> abstract</span> class CommandManager &#123;<br>   <span class="hljs-keyword"> public</span> Object process(Object commandState) &#123;        // grab a<span class="hljs-built_in"> new </span>instance of the appropriate Command interface        Command command = createCommand();        // set the state on the (hopefully brand new) Command<span class="hljs-built_in"> instance </span>       command.setState(commandState);       <span class="hljs-built_in"> return </span>command.execute();    &#125;<br>    // okay... but where is the implementation of this method?   <span class="hljs-keyword"> protected</span><span class="hljs-keyword"> abstract</span> Command createCommand();&#125;<br></code></pre></td></tr></table></figure><p>在包含需要注入方法的客户端类中 (在本例中为<code>CommandManager</code>）注入方法的签名需要如下形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;<span class="hljs-keyword">public</span>|<span class="hljs-keyword">protected</span>&gt; [<span class="hljs-keyword">abstract</span>] &lt;<span class="hljs-keyword">return</span>-<span class="hljs-keyword">type</span>&gt; <span class="hljs-title function_">theMethodName</span>(no-<span class="hljs-variable language_">arguments</span>);<br></code></pre></td></tr></table></figure><p>如果方法是<code>abstract</code>的， 那么动态生成的子类会实现该方法。否则，动态生成的子类将覆盖原始类定义的具体方法。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCommand&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- inject dependencies here as required --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commandManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">lookup-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;createCommand&quot;</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;myCommand&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当需要新的myCommand bean实例时，标识为<code>commandManager</code>的bean会调用自身的<code>createCommand()</code>方法.开发者必须小心部署<code>myCommand</code> bean为原型bean. 如果所需的bean是<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-singleton">单例</a>的,那么每次都会返回相同的<code>myCommand</code> bean实例.</p><p>另外,如果是基于注解的配置模式,你可以在查找方法上定义<code>@Lookup</code>注解,如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandManager</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> commandState</span>) &#123;        <span class="hljs-title class_">Command</span> command = <span class="hljs-title function_">createCommand</span>();        command.<span class="hljs-title function_">setState</span>(commandState);        <span class="hljs-keyword">return</span> command.<span class="hljs-title function_">execute</span>();    &#125;<br>    <span class="hljs-meta">@Lookup</span>(<span class="hljs-string">&quot;myCommand&quot;</span>)    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title class_">Command</span> <span class="hljs-title function_">createCommand</span>();&#125;<br></code></pre></td></tr></table></figure><p>或者，更常见的是，开发者也可以根据查找方法的返回类型来查找匹配的bean，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandManager</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> commandState</span>) &#123;        <span class="hljs-title class_">MyCommand</span> command = <span class="hljs-title function_">createCommand</span>();        command.<span class="hljs-title function_">setState</span>(commandState);        <span class="hljs-keyword">return</span> command.<span class="hljs-title function_">execute</span>();    &#125;<br>    <span class="hljs-meta">@Lookup</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title class_">MyCommand</span> <span class="hljs-title function_">createCommand</span>();&#125;<br></code></pre></td></tr></table></figure><p>注意开发者可以通过创建子类实现lookup方法，以便使它们与Spring的组件扫描规则兼容，同时抽象类会在默认情况下被忽略。这种限制不适用于显式注册bean或明确导入bean的情况。</p><p>另一种可以访问不同生命周期的方法是<code>ObjectFactory</code>&#x2F;<code>Provider</code>注入，具体参看 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other-injection">作用域的bean依赖</a></p><p>您可能还会发现<code>ServiceLocatorFactoryBean</code>（在<code>org.springframework.beans.factory.config</code>包中）很有用。</p><h5 id="替换任意方法"><a href="#替换任意方法" class="headerlink" title="替换任意方法"></a>替换任意方法</h5><p>从前面的描述中，我们知道查找方法是有能力来覆盖任何由容器管理的bean方法的。开发者最好跳过这一部分，除非一定需要用到这个功能。</p><p>通过基于XML的元数据配置，开发者可以使用<code>replaced-method</code>元素来替换已存在方法的实现。考虑以下类，它有一个我们想要覆盖的名为<code>computeValue</code> 的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyValueCalculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">computeValue</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> input</span>) &#123;        <span class="hljs-comment">// some real code...    &#125;</span><br>    <span class="hljs-comment">// some other methods...&#125;</span><br></code></pre></td></tr></table></figure><p>实现<code>org.springframework.beans.factory.support.MethodReplacer</code>接口的类提供了新的方法定义，如以下示例所示：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/** * meant to be used to override the existing computeValue(String) * implementation in MyValueCalculator */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplacementComputeValue</span> implements MethodReplacer &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">reimplement</span>(<span class="hljs-built_in">Object</span> o, Method m, <span class="hljs-built_in">Object</span>[] args) <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-comment">// get the input value, work with it, and return a computed result        String input = (String) args[0];        ...        return ...;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>如果需要覆盖bean方法的XML配置如下类似于以下示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myValueCalculator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- arbitrary method replacement --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">replaced-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;computeValue&quot;</span> <span class="hljs-attr">replacer</span>=<span class="hljs-string">&quot;replacementComputeValue&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">arg-type</span>&gt;</span>String<span class="hljs-tag">&lt;/<span class="hljs-name">arg-type</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">replaced-method</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;replacementComputeValue&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>您可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个 <code>&lt;arg-type/&gt;</code>元素来指示被覆盖的方法的方法。当需要覆盖的方法存在重载方法时，必须指定所需参数。 为了方便起见，字符串的类型会匹配以下类型，它完全等同于<code>java.lang.String</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">java.lang.<span class="hljs-type">String</span><br><br><span class="hljs-type">String</span><br><br>Str<br></code></pre></td></tr></table></figure><p>因为，通常来说参数的个数已经足够区别不同的方法，这种快捷的写法可以省去很多的代码。</p><h3 id="1-5-bean的作用域"><a href="#1-5-bean的作用域" class="headerlink" title="1.5. bean的作用域"></a>1.5. bean的作用域</h3><p>创建bean定义时，同时也会定义该如何创建Bean实例。 这些具体创建的过程是很重要的，因为只有通过对这些配置过程，您才能创建实例对象。</p><p>您不仅可以将不同的依赖注入到bean中，还可以配置bean的作用域。这种方法是非常强大而且也非常灵活，开发者可以通过配置来指定对象的作用域，无需在Java类的层次上配置。 bean可以配置多种作用域，Spring框架支持五种作用域，有三种作用域是当开发者使用基于Web的<code>ApplicationContext</code>的时候才有效的。您还可以创建<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-custom">自定义范围.</a>。</p><p>下表描述了支持的范围:</p><p>Table 3. Bean 的作用域</p><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-singleton">singleton</a></td><td>(默认) 每一Spring IOC容器都拥有唯一的实例对象。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-prototype">prototype</a></td><td>一个Bean定义可以创建任意多个实例对象.</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-request">request</a></td><td>将单个bean定义范围限定为单个HTTP请求的生命周期。 也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。 只有基于Web的Spring <code>ApplicationContext</code>的才可用。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-session">session</a></td><td>将单个bean定义范围限定为HTTP <code>Session</code>的生命周期。 只有基于Web的Spring <code>ApplicationContext</code>的才可用。</td></tr><tr><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-application">application</a></td><td>将单个bean定义范围限定为<code>ServletContext</code>的生命周期。 只有基于Web的Spring <code>ApplicationContext</code>的才可用。</td></tr><tr><td><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/web/web.md#websocket-stomp-websocket-scope">websocket</a></td><td>将单个bean定义范围限定为 <code>WebSocket</code>的生命周期。 只有基于Web的Spring <code>ApplicationContext</code>的才可用。</td></tr></tbody></table><p>从Spring 3.0开始，线程作用域默认是可用的，但默认情况下未注册。 有关更多信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>的文档。 有关如何注册此范围或任何其他自定义范围的说明，请参阅使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-custom-using">自定义范围</a>。</p><h4 id="1-5-1-单例作用域"><a href="#1-5-1-单例作用域" class="headerlink" title="1.5.1. 单例作用域"></a>1.5.1. 单例作用域</h4><p>单例bean在全局只有一个共享的实例，所有依赖单例bean的场景中，容器返回的都是同一个实例。</p><p>换句话说，当您定义一个bean并且它的范围是一个单例时，Spring IoC容器只会根据bean的定义来创建该bean的唯一实例。 这些唯一的实例会缓存到容器中，后续针对单例bean的请求和引用，都会从这个缓存中拿到这个唯一实例。 下图显示了单例范围的工作原理：</p><p><img src="singleton.png" alt="singleton"></p><p>Spring的单例bean概念不同于设计模式（GoF）之中所定义的单例模式。设计模式中的单例模式是将一个对象的作用域硬编码的，一个ClassLoader只能有唯一的一个实例。 而Spring的单例作用域是以容器为前提的，每个容器每个bean只能有一个实例。 这意味着，如果在单个Spring容器中为特定类定义一个bean，则Spring容器会根据bean定义创建唯一的bean实例。 单例作用域是Spring的默认作用域。 下面的例子是在XML中配置单例模式Bean的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-5-2-原型作用域"><a href="#1-5-2-原型作用域" class="headerlink" title="1.5.2. 原型作用域"></a>1.5.2. 原型作用域</h4><p>非单例的、原型bean指的是每次请求bean实例时,返回的都是新的对象实例。也就是说，每次注入到另外的bean或者通过调用 <code>getBean()</code>方法来获得的bean都是全新的实例。 基于线程安全性的考虑，当bean对象有状态时使用原型作用域，而无状态时则使用单例作用域。</p><p>下图说明了Spring原型作用域：:</p><p><img src="prototype.png" alt="prototype"></p><p>（数据访问对象（DAO）通常不配置为原型，因为典型的DAO不具有任何会话状态。我们可以更容易重用单例图的核心。）</p><p>用下面的例子来说明Spring的原型作用域:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>与其他作用域相比，Spring不会完整地管理原型bean的生命周期。 Spring容器只会初始化、配置和装载这些bean，然后传递给Client。但是之后就不会再有该原型实例的进一步记录。 也就是说，初始化生命周期回调方法在所有作用域的bean是都会调用的，但是销毁生命周期回调方法在原型bean是不会调用的。所以，客户端代码必须注意清理原型bean以及释放原型bean所持有的资源。 可以通过使用自定义的<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-bpp">bean post-processor</a>（Bean的后置处理器）来让Spring释放掉原型bean所持有的资源。</p><p>在某些方面，Spring容器关于原型作用域的bean就是取代了Java的<code>new</code> 操作符。 所有的生命周期的控制都由客户端来处理（有关Spring容器中bean的生命周期的详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle">Bean的生命周期</a>）。</p><h4 id="1-5-3-依赖原型bean的单例bean"><a href="#1-5-3-依赖原型bean的单例bean" class="headerlink" title="1.5.3. 依赖原型bean的单例bean"></a>1.5.3. 依赖原型bean的单例bean</h4><p>当您使用具有依赖于原型bean的单例作用域bean时，请注意在实例化时解析依赖项。 因此，如果将原型bean注入到单例的bean中，则会实例化一个新的原型bean，然后将依赖注入到单例bean中。 这个依赖的原型bean仍然是同一个实例。</p><p>但是，假设您希望单例作用域的bean在运行时重复获取原型作用域的bean的新实例。 您不能将原型作用域的bean依赖注入到您的单例bean中， 因为当Spring容器实例化单例bean并解析注入其依赖项时，该注入只发生一次。 如果您需要在运行时多次使用原型bean的新实例，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-method-injection">方法注入</a>。</p><h4 id="1-5-4-请求，会话，应用程序和WebSocket作用域"><a href="#1-5-4-请求，会话，应用程序和WebSocket作用域" class="headerlink" title="1.5.4. 请求，会话，应用程序和WebSocket作用域"></a>1.5.4. 请求，会话，应用程序和WebSocket作用域</h4><p><code>request</code>, <code>session</code>, <code>application</code>, 和 <code>websocket</code>作用域只有在Web中使用Spring的<code>ApplicationContext</code>（例如<code>ClassPathXmlApplicationContext</code>）的情况下才用得上。 如果在普通的Spring IoC容器，例如ClassPathXmlApplicationContext中使用这些作用域，将会抛出IllegalStateException异常来说明使用了未知的作用域。</p><h5 id="初始化Web的配置"><a href="#初始化Web的配置" class="headerlink" title="初始化Web的配置"></a>初始化Web的配置</h5><p>为了能够使用请求 <code>request</code>, <code>session</code>, <code>application</code>, 和<code>websocket</code>（Web范围的bean），需要在配置bean之前作一些基础配置。 而对于标准的作用域，例如单例和原型作用域，这种基础配置是不需要的。</p><p>如何完成此初始设置取决于您的特定Servlet环境.</p><p>例如，如果开发者使用了Spring Web MVC框架，那么每一个请求都会通过Spring的<code>DispatcherServlet</code>来处理，那么也无需特殊的设置了。DispatcherServlet和DispatcherPortlet已经包含了相应状态。</p><p>如果您使用Servlet 2.5 Web容器，并且在Spring的<code>DispatcherServlet</code>之外处理请求（例如，使用JSF或Struts时），则需要注册<code>org.springframework.web.context.request.RequestContextListener</code>或者<code>ServletRequestListener</code>。 对于Servlet 3.0+，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。 如果需要兼容旧版本容器的话，将以下声明添加到Web应用程序的<code>web.xml</code> 文件中:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span></span><br><br><span class="hljs-code">    ...</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &lt;listener&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">        &lt;listener-class&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">            org.springframework.web.context.request.RequestContextListener</span><br><span class="hljs-code"></span><br><span class="hljs-code">        &lt;/listener-class&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    &lt;/listener&gt;</span><br><span class="hljs-code"></span><br><span class="hljs-code">    ...</span><br><span class="hljs-code"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>或者，如果对Listener不是很熟悉，请考虑使用Spring的<code>RequestContextFilter</code>。 Filter映射取决于Web应用的配置，因此您必须根据需要进行更改。 以下清单显示了Web应用程序的过滤器部分:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br><br>    ...<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>requestContextFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>requestContextFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    ...<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code>所做的工作实际上是一样的，都是将request对象请求绑定到服务的 <code>Thread</code>上。 这才使bean在之后的调用链上对请求和会话作用域可见。</p><h5 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h5><p>参考下面这个XML配置的bean定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;loginAction&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.LoginAction&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;request&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>Spring容器会在每次使用<code>LoginAction</code>来处理每个HTTP请求时都会创建新的<code>LoginAction</code>实例。也就是说，<code>LoginAction</code> bean的作用域是HTTP Request级别的。 开发者可以随意改变实例的状态，因为其他通过<code>loginAction</code>请求来创建的实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求创建的。当请求处理完毕，这个bean也将会销毁。</p><p>当使用注解配置或Java配置时，使用<code>@RequestScope</code>注解修饰的bean会被设置成request作用域。 以下示例显示了如何执行此操作：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RequestScope</span><br><br><span class="hljs-variable">@Component</span><br><br>public class LoginAction &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Session作用域"><a href="#Session作用域" class="headerlink" title="Session作用域"></a>Session作用域</h5><p>参考下面XML配置的bean的定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.UserPreferences&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;session&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>Spring容器通过在单个HTTP会话的生命周期中使用<code>UserPreferences</code> bean定义来创建<code>UserPreferences</code> bean的新实例。换言之，<code>UserPreferences</code> Bean的作用域是HTTP S<code>Session</code>级别的，在request-scoped作用域的bean上， 开发者可以随意的更改实例的状态，同样，其他HTTP <code>Session</code>的基本实例在每个<code>Session</code>中都会请求userPreferences来创建新的实例，所以，开发者更改bean的状态， 对于其他的Bean仍然是不可见的。当HTTP <code>Session</code>被销毁时，根据这个<code>Session</code>来创建的bean也将会被销毁。</p><p>使用注解配置和Java配置时，使用<code>@SessionScope</code> 注解修饰的 bean 会被设置成<code>session</code>作用域。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SessionScope</span><br><br><span class="hljs-variable">@Component</span><br><br>public class UserPreferences &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Application作用域"><a href="#Application作用域" class="headerlink" title="Application作用域"></a>Application作用域</h5><p>参考下面用XML配置的bean的定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;appPreferences&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.AppPreferences&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;application&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>Spring容器会在整个Web应用内使用到<code>appPreferences</code>的时候创建一个新的<code>AppPreferences</code>的实例。也就是说，<code>appPreferences</code> bean是在<code>ServletContext</code> 级别的， 就像普通的<code>ServletContext</code> 属性一样。这种作用域在一些程度上来说和Spring的单例作用域是极为相似，但是也有如下不同之处，应用作用域是每个<code>ServletContext</code> 中包含一个 而不是每个Spring ApplicationContext中只有一个（某些应用可能包含多个ApplicationContext）。应用作用域仅仅对<code>ServletContext</code> 可见，单例bean是对ApplicationContext可见。</p><p>当使用注解配置或Java配置时，使用<code>@ApplicationScope</code> 注解修饰的bean会被设置成<code>application</code>作用域 。以下示例显示了如何执行此操作:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ApplicationScope</span><br><br><span class="hljs-variable">@Component</span><br><br>public class AppPreferences &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="有作用域bean的依赖"><a href="#有作用域bean的依赖" class="headerlink" title="有作用域bean的依赖"></a>有作用域bean的依赖</h5><p>Spring IoC容器不仅仅管理对象（bean）的实例化，同时也负责装配依赖。如果开发者要将一个bean装配到比它作用域更广的bean时（例如HTTP请求返回的bean），那么开发者应当选择注入AOP代理而不是使用带作用域的bean。 也就是说，开发者需要注入代理对象，而这个代理对象既可以找到实际的bean，还能够创建全新的bean。</p><p>您还可以在作为单例的作用域的bean之间使用<code>&lt;aop:scoped-proxy/&gt;</code>，然后引用通过可序列化的中间代理，从而能够在反序列化时重新获取目标<code>单例</code>bean。</p><p>当针对原型作用域的bean声明<code>&lt;aop:scoped-proxy/&gt;</code>时，每个通过代理的调用都会产生新的目标实例。</p><p>此外，作用域代理并不是取得作用域bean的唯一安全方式。 开发者也可以通过简单的声明注入（即构造函数或setter参数或自动装配字段）<code>ObjectFactory&lt;MyTargetBean&gt;</code>， 然后允许通过类似<code>getObject()</code>的方法调用来获取一些指定的依赖，而不是直接储存依赖的实例。</p><p>作为扩展变体，您可以声明<code>ObjectProvider&lt;MyTargetBean&gt;</code>，它提供了几个额外的访问变体，包括<code>getIfAvailable</code> 和 <code>getIfUnique</code>。</p><p>JSR-330将这样的变种称为Provider，它使用<code>Provider&lt;MyTargetBean&gt;</code> 声明以及相关的 <code>get()</code> 方法来尝试获取每一个配置。 有关JSR-330整体的更多详细信息，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-standard-annotations">请参看此处</a>。</p><p>以下示例中的配置只有一行，但了解“为什么”以及它背后的“如何”非常重要：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.UserPreferences&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;session&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:scoped-proxy</span>/&gt;</span> (1)    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.SimpleUserService&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userPreferences&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、定义代理的行。</p><p>要创建这样的一个代理，只需要在带作用域的bean定义中添加子节点<code>&lt;aop:scoped-proxy/&gt;</code>即可（具体查看<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other-injection-proxies">选择创建代理的类型</a>和 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#xsd-schemas">基于XML Schema的配置</a>）。为什么在<code>request</code>, <code>session</code>和自定义作用域级别范围内的bean定义需要<code>&lt;aop:scoped-proxy/&gt;</code>， 考虑以下单例bean定义，并将其与您需要为上述范围定义的内容进行对比（请注意，以下<code>userPreferences</code>bean定义不完整）:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.UserPreferences&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;session&quot;</span>/&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;userManager&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.something.UserManager&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;userPreferences&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>在上面的例子中，单例bean（<code>userManager</code>）注入了注入了HTTP <code>Session</code>级别的<code>userPreferences</code>依赖。 显然， 问题就是<code>userPreferences</code>在Spring容器中只会实例化一次。它的依赖项（在这种情况下只有一个，<code>userPreferences</code>）也只注入一次。 这意味着<code>userManager</code> 每次使用的是完全相同的<code>userPreferences</code>对象（即最初注入它的对象）进行操作。</p><p>这不是将短周期作用域bean注入到长周期作用域bean时所需的行为，例如将HTTP <code>Session</code>级别的作用域bean作为依赖注入到单例bean中。相反，开发者需要一个 <code>userManager</code>对象， 而在HTTP <code>Session</code>的生命周期中，开发者需要一个特定于HTTP Session的 userPreferences 对象。因此，容器创建一个对象，该对象公开与UserPreferences类（理想情况下为<code>UserPreferences</code>实例的对象） 完全相同的公共接口，该对象可以从作用域机制（HTTP Request、<code>Session</code>等）中获取真实的<code>UserPreferences</code>对象。容器将这个代理对象注入到<code>userManager</code>中， 而不知道这个<code>UserPreferences</code>引用是一个代理。在这个例子中，当一个UserManager实例在依赖注入的UserPreferences对象上调用一个方法时， 它实际上是在调用代理的方法，再由代理从HTTP <code>Session</code>（本例）获取真实的<code>UserPreferences</code>对象，并将方法调用委托给检索到的实际<code>UserPreferences</code>对象。</p><p>因此，在将<code>request-</code> and <code>session-scoped</code>的bean来作为依赖时，您需要以下（正确和完整）配置，如以下示例所示： 所以当开发者希望能够正确的使用配置请求、会话或者全局会话级别的bean来作为依赖时，需要进行如下类似的配置。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.something.UserPreferences&quot;</span> scope=<span class="hljs-string">&quot;session&quot;</span>&gt;    &lt;aop:scoped-proxy/&gt;&lt;/bean&gt;<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userManager&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.something.UserManager&quot;</span>&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userPreferences&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h6 id="选择要创建的代理类型"><a href="#选择要创建的代理类型" class="headerlink" title="选择要创建的代理类型"></a>选择要创建的代理类型</h6><p>默认情况下，当Spring容器为使用<code>&lt;aop:scoped-proxy/&gt;</code> 元素标记的bean创建代理时，将创建基于CGLIB的类代理。</p><p>CGLIB代理只拦截公共方法调用！ 不要在这样的代理上调用非公共方法。 它们不会委托给实际的作用域目标对象。</p><p>或者，您可以通过为<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code> 属性的值指定<code>false</code>来配置Spring容器， 以便为此类作用域bean创建基于JDK接口的标准代理。 使用基于接口的JDK代理意味着开发者无需引入第三方库即可完成代理。 但是，这也意味着带作用域的bean需要额外实现一个接口，而依赖是从这些接口来获取的。 以下示例显示基于接口的代理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.stuff.DefaultUserPreferences&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;session&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:scoped-proxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.stuff.UserManager&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userPreferences&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有关选择基于类或基于接口的代理的更多详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aop-proxying">代理机制</a>。</p><h4 id="1-5-5-自定义作用域"><a href="#1-5-5-自定义作用域" class="headerlink" title="1.5.5. 自定义作用域"></a>1.5.5. 自定义作用域</h4><p>bean的作用域机制是可扩展的，开发者可以自定义作用域，甚至重新定义已经存在的作用域，但是Spring团队不推荐这样做，而且开发者也不能重写<code>singleton</code> 和 <code>prototype</code>作用域。</p><h5 id="创建自定义作用域"><a href="#创建自定义作用域" class="headerlink" title="创建自定义作用域"></a>创建自定义作用域</h5><p>为了能够使Spring可以管理开发者定义的作用域，开发者需要实现<code>org.springframework.beans.factory.config.Scope</code>。如何实现自定义的作用域， 可以参考Spring框架的一些实现或者有关<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code></a> 的javadoc</p><p><code>Scope</code>接口有四个方法用于操作对象,例如获取、移除或销毁等操作。</p><p>例如，传入Session作用域该方法将会返回一个 session-scoped的bean（如果它不存在，那么将会返回绑定session作用域的新实例）。下面的方法返回相应作用域的对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-built_in">String</span> name, ObjectFactory objectFactory)<br></code></pre></td></tr></table></figure><p>下面的方法将从相应的作用域中移除对象。同样，以会话为例，该函数会删除会话作用域的Bean。删除的对象会作为返回值返回，当无法找到对象时将返回null。 以下方法从相应作用域中删除对象：:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Object</span> remove(<span class="hljs-keyword">String</span> <span class="hljs-keyword">name</span>)<br></code></pre></td></tr></table></figure><p>以下方法注册范围在销毁时或在Scope中的指定对象被销毁时应该执行的回调:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerDestructionCallback</span><span class="hljs-params">(<span class="hljs-type">String</span> name, Runnable destructionCallback)</span></span><br></code></pre></td></tr></table></figure><p>有关销毁回调的更多信息，请参看<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback">javadoc</a>或Spring的Scope实现部分。</p><p>下面的方法获取相应作用域的区分标识符:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">String</span> <span class="hljs-function"><span class="hljs-title">getConversationId</span>()</span><br></code></pre></td></tr></table></figure><p>这个标识符在不同的作用域中是不同的。例如对于会话作用域，这个标识符就是会话的标识符。.</p><h5 id="使用自定义作用域"><a href="#使用自定义作用域" class="headerlink" title="使用自定义作用域"></a>使用自定义作用域</h5><p>在实现了自定义<code>作用域</code>后，开发者还需要让Spring容器能够识别发现所创建的新<code>作用域</code>。下面的方法就是在Spring容器中用来注册新<code>Scope</code>的:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">registerScope</span><span class="hljs-params">(<span class="hljs-type">String</span> scopeName, Scope scope)</span></span>;<br></code></pre></td></tr></table></figure><p>这个方法是在<code>ConfigurableBeanFactory</code>的接口中声明的，可以用在多数的<code>ApplicationContext</code>实现，也可以通过 <code>BeanFactory</code>属性来调用。</p><p><code>registerScope(..)</code>方法的第一个参数是相关<code>作用域</code>的唯一名称。举例来说，Spring容器中的单例和原型就以它本身来命名。 第二个参数就是开发者希望注册和使用的自定义<code>Scope</code>实现的具有对象 T</p><p>假定开发者实现了自定义<code>Scope</code>，然后可以按如下步骤来注册。</p><p>下一个示例使用SimpleThreadScope，这个例子在Spring中是有实现的，但没有默认注册。 您自定义的作用域也可以通过如下的方式来注册。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Scope threadScope = <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleThreadScope</span>();<br><br>beanFactory.registerScope(<span class="hljs-string">&quot;thread&quot;</span>, threadScope);<br></code></pre></td></tr></table></figure><p>然后，您可以创建符合自定义Scope的作用域规则的bean定义，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;thread&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>在自定义作用域中，开发者也不限于仅仅通过编程的方式来注册作用域，还可以通过配置<code>CustomScopeConfigurer</code> 类来实现。如以下示例所示：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;scopes&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;thread&quot;</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.SimpleThreadScope&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thing2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.Thing2&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;thread&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Rick&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:scoped-proxy</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;thing1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x.y.Thing1&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;thing2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;thing2&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>FactoryBean</code>实现中添加了<code>&lt;aop:scoped-proxy/&gt;</code>元素时，它是工厂bean本身的作用域，而不是从<code>getObject()</code>方法返回的对象。</p><h3 id="1-6-自定义Bean的特性"><a href="#1-6-自定义Bean的特性" class="headerlink" title="1.6. 自定义Bean的特性"></a>1.6. 自定义Bean的特性</h3><p>Spring Framework提供了许多可用于自定义bean特性的接口。 本节将它们分组如下：</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle">Lifecycle Callbacks(生命周期回调)</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aware-list">其他 <code>Aware</code> 接口</a></li></ul><h4 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1. 生命周期回调"></a>1.6.1. 生命周期回调</h4><p>你可以实现<code>InitializingBean</code> 和 <code>DisposableBean</code>接口，让容器里管理Bean的生命周期。容器会在调用<code>afterPropertiesSet()</code> 之后和<code>destroy()</code>之前会允许bean在初始化和销毁bean时执行某些操作。</p><p>JSR-250 <code>@PostConstruct</code> 和 <code>@PreDestroy</code>注解通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。 使用这些注解意味着您的bean不会耦合到特定于Spring的接口。 有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-postconstruct-and-predestroy-annotations">使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code></a>.</p><p>如果您不想使用JSR-250注解但仍想删除耦合，请考虑使用<code>init-method</code> 和 <code>destroy-method</code>定义对象元数据。</p><p>在内部，Spring 框架使用<code>BeanPostProcessor</code> 实现来处理任何回调接口并调用适当的方法。 如果您需要Spring默认提供的自定义功能或其他生命周期行为，您可以自己实现<code>BeanPostProcessor</code>。 有关更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension">容器扩展点</a>。</p><p>除了初始化和销毁方法的回调，Spring管理的对象也实现了Lifecycle接口来让管理的对象在容器的<code>生命周期</code>内启动和关闭。</p><p>本节描述了生命周期回调接口。.</p><h5 id="初始化方法回调"><a href="#初始化方法回调" class="headerlink" title="初始化方法回调"></a>初始化方法回调</h5><p><code>org.springframework.beans.factory.InitializingBean</code>接口允许bean在所有的必要的依赖配置完成后执行bean的初始化， <code>InitializingBean</code> 接口中指定使用如下方法:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br></code></pre></td></tr></table></figure><p>Spring团队是不建议开发者使用<code>InitializingBean</code>接口，因为这样会将代码耦合到Spring的特殊接口上。他们建议使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> 注解或者指定一个POJO的实现方法， 这会比实现接口更好。在基于XML的元数据配置上，开发者可以使用<code>init-method</code> 属性来指定一个没有参数的方法，使用Java配置的开发者可以在<code>@Bean</code>上添加 <code>initMethod</code> 属性。 请参阅 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-lifecycle-callbacks">接收生命周期回调</a>接收生命周期回调：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;bean id=<span class="hljs-string">&quot;exampleInitBean&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;examples.ExampleBean&quot;</span> <span class="hljs-keyword">init</span>-method=<span class="hljs-string">&quot;init&quot;</span>/&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleBean</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;        <span class="hljs-comment">// do some initialization work    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>前面的示例与以下示例（由两个列表组成）具有几乎完全相同的效果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;bean id=<span class="hljs-string">&quot;exampleInitBean&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherExampleBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">afterPropertiesSet</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// do some initialization work    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>但是，前面两个示例中的第一个没有将代码耦合到Spring。</p><h5 id="销毁方法的回调"><a href="#销毁方法的回调" class="headerlink" title="销毁方法的回调"></a>销毁方法的回调</h5><p>实现<code>org.springframework.beans.factory.DisposableBean</code> 接口的Bean就能让容器通过回调来销毁bean所引用的资源。 <code>DisposableBean</code> 接口指定一个方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br></code></pre></td></tr></table></figure><p>我们建议您不要使用 <code>DisposableBean</code> 回调接口，因为它会不必要地将代码耦合到Spring。或者，我们建议使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a>注解 或指定bean定义支持的泛型方法。 在基于XML的元数据配置中，您可以在<code>&lt;bean/&gt;</code>上使用<code>destroy-method</code>属性。 使用Java配置，您可以使用<code>@Bean</code>的 <code>destroyMethod</code> 属性。 请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-lifecycle-callbacks">接收生命周期回调</a>。 考虑以下定义：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;bean id=&quot;exampleInitBean&quot; <span class="hljs-keyword">class</span>=&quot;examples.ExampleBean&quot; destroy-<span class="hljs-keyword">method</span>=&quot;cleanup&quot;/&gt;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ExampleBean &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> cleanup() &#123;        // <span class="hljs-keyword">do</span> <span class="hljs-keyword">some</span> destruction <span class="hljs-keyword">work</span> (<span class="hljs-keyword">like</span> releasing pooled connections)    &#125;&#125;<br></code></pre></td></tr></table></figure><p>前面的定义与以下定义几乎完全相同：:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;bean id=<span class="hljs-string">&quot;exampleInitBean&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherExampleBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisposableBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// do some destruction work (like releasing pooled connections)    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>但是，前面两个定义中的第一个没有将代码耦合到Spring。.</p><p>您可以为<code>&lt;bean&gt;</code> 元素的<code>destroy-method</code>属性分配一个特殊的（推断的）值，该值指示Spring自动检测特定bean类的<code>close</code>或者<code>shutdown</code>方法。 （因此，任何实现<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>的类都将匹配。） 您还可以在<code>&lt;bean&gt;</code> 元素的<code>default-destroy-method</code>属性上设置此特殊（推断）值，用于让所有的bean都实现这个行为（<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-default-init-destroy-methods">参见默认初始化和销毁方法</a>）。 请注意，这是Java配置的默认行为。</p><h5 id="默认初始化和销毁方法"><a href="#默认初始化和销毁方法" class="headerlink" title="默认初始化和销毁方法"></a>默认初始化和销毁方法</h5><p>当您不使用Spring特有的<code>InitializingBean</code>和 <code>DisposableBean</code>回调接口来实现初始化和销毁方法时，您定义方法的名称最好类似于<code>init()</code>, <code>initialize()</code>, <code>dispose()</code>。 这样可以在项目中标准化类方法，并让所有开发者都使用一样的名字来确保一致性。</p><p>您可以配置Spring容器来针对每一个Bean都查找这种名字的初始化和销毁回调方法。也就是说， 任意的开发者都会在应用的类中使用一个叫 <code>init()</code>的初始化回调。而不需要在每个bean中都定义<code>init-method=&quot;init&quot;</code> 这种属性， Spring IoC容器会在bean创建的时候调用那个回调方法（<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle">如前面描述</a>的标准生命周期一样）。这个特性也将强制开发者为其他的初始化以及销毁回调方法使用同样的名字。</p><p>假设您的初始化回调方法名为<code>init()</code>，而您的destroy回调方法名为<code>destroy()</code>。 然后，您的类类似于以下示例中的类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">DefaultBlogService</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">BlogService</span> &#123;<br>    <span class="hljs-keyword">private</span> BlogDao blogDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> setBlogDao(BlogDao blogDao) &#123;        <span class="hljs-keyword">this</span>.blogDao = blogDao;    &#125;<br>    <span class="hljs-comment">// this is (unsurprisingly) the initialization callback method    public void init() &#123;        if (this.blogDao == null) &#123;            throw new IllegalStateException(&quot;The [blogDao] property must be set.&quot;);        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>然后，您可以在类似于以下内容的bean中使用该类:</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;beans <span class="hljs-keyword">default</span>-init-<span class="hljs-keyword">method</span>=&quot;<span class="hljs-title function_">init</span>&quot;&gt;<br>    &lt;<span class="hljs-title function_">bean</span> <span class="hljs-title function_">id</span>=&quot;<span class="hljs-title function_">blogService</span>&quot; <span class="hljs-title function_">class</span>=&quot;<span class="hljs-title function_">com</span>.<span class="hljs-title function_">something</span>.<span class="hljs-title function_">DefaultBlogService</span>&quot;&gt;        &lt;<span class="hljs-title function_">property</span> <span class="hljs-title function_">name</span>=&quot;<span class="hljs-title function_">blogDao</span>&quot; <span class="hljs-title function_">ref</span>=&quot;<span class="hljs-title function_">blogDao</span>&quot; /&gt;    &lt;/<span class="hljs-title function_">bean</span>&gt;<br>&lt;/<span class="hljs-title function_">beans</span>&gt;<br></code></pre></td></tr></table></figure><p>顶级<code>&lt;beans/&gt;</code>元素属性上存在<code>default-init-method</code>属性会导致Spring IoC容器将bean类上的<code>init</code>方法识别为初始化方法回调。 当bean被创建和组装时，如果bean拥有同名方法的话，则在适当的时候调用它。</p><p>您可以使用 <code>&lt;beans/&gt;</code>元素上的<code>default-destroy-method</code>属性，以类似方式（在XML中）配置destroy方法回调。</p><p>当某些bean已有的回调方法与配置的默认回调方法不相同时，开发者可以通过特指的方式来覆盖掉默认的回调方法。以XML为例，可以通过使用元素的<code>init-method</code> 和<code>destroy-method</code>属性来覆盖掉<code>&lt;bean/&gt;</code>中的配置。</p><p>Spring容器会做出如下保证，bean会在装载了所有的依赖以后，立刻就开始执行初始化回调。这样的话，初始化回调只会在直接的bean引用装载好后调用， 而此时AOP拦截器还没有应用到bean上。首先目标的bean会先完全初始化，然后AOP代理和拦截链才能应用。如果目标bean和代理是分开定义的，那么开发者的代码甚至可以跳过AOP而直接和引用的bean交互。 因此，在初始化方法中应用拦截器会前后矛盾，因为这样做耦合了目标bean的生命周期和代理&#x2F;拦截器，还会因为与bean产生了直接交互进而引发不可思议的现象。</p><h5 id="组合生命周期策略"><a href="#组合生命周期策略" class="headerlink" title="组合生命周期策略"></a>组合生命周期策略</h5><p>从Spring 2.5开始，您有三种选择用于控制bean生命周期行为:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a> 和 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a> 回调接口</li><li>自定义 <code>init()</code> 和 <code>destroy()</code> 方法</li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解</a>. 你也可以在bean上同时使用这些机制.</li></ul><p>如果bean配置了多个生命周期机制，而且每个机制都配置了不同的方法名字时，每个配置的方法会按照以下描述的顺序来执行。但是，如果配置了相同的名字， 例如初始化回调为<code>init()</code>，在不止一个生命周期机制配置为这个方法的情况下，这个方法只会执行一次。如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-default-init-destroy-methods">上一节中所述</a>。</p><p>为同一个bean配置的多个生命周期机制具有不同的初始化方法，如下所示:</p><ol><li>包含<code>@PostConstruct</code>注解的方法</li><li>在<code>InitializingBean</code> 接口中的<code>afterPropertiesSet()</code> 方法</li><li>自定义的<code>init()</code> 方法</li></ol><p>Destroy方法以相同的顺序调用:</p><ol><li>包含<code>@PreDestroy</code>注解的方法</li><li>在<code>DisposableBean</code>接口中的<code>destroy()</code> 方法</li><li>自定义的<code>destroy()</code> 方法</li></ol><h5 id="开始和关闭回调"><a href="#开始和关闭回调" class="headerlink" title="开始和关闭回调"></a>开始和关闭回调</h5><p><code>Lifecycle</code>接口中为所有具有自定义生命周期需求的对象定义了一些基本方法（例如启动或停止一些后台进程）:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Lifecycle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">isRunning</span>()</span>;&#125;<br></code></pre></td></tr></table></figure><p>任何Spring管理的对象都可以实现<code>Lifecycle</code> 接口。然后，当<code>ApplicationContext</code>接收到启动和停止信号时（例如，对于运行时的停止&#x2F;重启场景），ApplicationContext会通知到所有上下文中包含的生命周期对象。 它通过委托 <code>LifecycleProcessor</code>完成此操作，如下面的清单所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LifecycleProcessor</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lifecycle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span>()</span>;&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>LifecycleProcessor</code>是 <code>Lifecycle</code>接口的扩展。 它还添加了另外两种方法来响应刷新和关闭的上下文。</p><p>注意，常规的<code>org.springframework.context.Lifecycle</code>接口只是为明确的开始&#x2F;停止通知提供一个约束，而并不表示在上下文刷新就会自动开始。 要对特定bean的自动启动（包括启动阶段）进行细粒度控制，请考虑实现<code>org.springframework.context.SmartLifecycle</code>接口。</p><p>同时，停止通知并不能保证在销毁之前出现。在正常的关闭情况下，所有的<code>Lifecycle</code>都会在销毁回调准备好之前收到停止通知，然而， 在上下文生命周期中的热刷新或者停止尝试刷新时，则只会调用销毁方法。</p><p>启动和关闭调用的顺序非常重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，并且在其依赖之前停止。但是，有时，直接依赖性是未知的。 您可能只知道某种类型的对象应该在另一种类型的对象之前开始。 在这些情况下， <code>SmartLifecycle</code>接口定义了另一个选项，即在其超级接口<code>Phased</code> 上定义的 <code>getPhase()</code> 方法。 以下清单显示了<code>Phased</code>接口的定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Phased</span> &#123;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getPhase</span>()</span>;&#125;<br></code></pre></td></tr></table></figure><p>以下清单显示了<code>SmartLifecycle</code>接口的定义:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">SmartLifecycle</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Lifecycle</span>, <span class="hljs-symbol">Phased</span> &#123;<br>    <span class="hljs-built_in">bool</span>ean isAutoStartup();<br>    <span class="hljs-built_in">void</span> stop(Runnable callback);&#125;<br></code></pre></td></tr></table></figure><p>当启动时，拥有最低phased的对象会优先启动，而当关闭时，会相反的顺序执行。因此，如果一个对象实现了<code>SmartLifecycle</code>，然后令其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>值的话， 就会让该对象最早启动，而最晚销毁。显然，如果<code>getPhase()</code>方法返回了<code>Integer.MAX_VALUE</code>值则表明该对象会最晚启动，而最早销毁。 当考虑到使用phased值时，也同时需要了解正常没有实现<code>SmartLifecycle</code>的<code>Lifecycle</code>对象的默认值，这个值是0。因此，配置任意的负值都将表明将对象会在标准组件启动之前启动 ，而在标准组件销毁以后再进行销毁。</p><p><code>SmartLifecycle</code>接口也定义了一个名为stop的回调方法，任何实现了<code>SmartLifecycle</code>接口的方法都必须在关闭流程完成之后调用回调中的<code>run()</code>方法。 这样做可以进行异步关闭，而<code>lifecycleProcessor</code>的默认实现<code>DefaultLifecycleProcessor</code>会等到配置的超时时间之后再调用回调。默认的每一阶段的超时时间为30秒。 您可以通过在上下文中定义名为 <code>lifecycleProcessor</code> 的bean来覆盖默认生命周期处理器实例。 如果您只想修改超时，则定义以下内容就足够了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lifecycleProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- timeout value in milliseconds --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timeoutPerShutdownPhase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如前所述，<code>LifecycleProcessor</code> 接口还定义了用于刷新和关闭上下文的回调方法。在关闭过程中，如果<code>stop()</code>方法已经被调用，则就会执行关闭流程。 但是如果上下文正在关闭中则不会在进行此流程，而刷新的回调会使用到<code>SmartLifecycle</code>的另一个特性。当上下文刷新完毕（所有的对象已经实例化并初始化）后， 就会调用刷新回调，默认的生命周期处理器会检查每一个<code>SmartLifecycle</code> 对象的<code>isAutoStartup()</code>方法返回的Boolean值.如果为真，对象将会自动启动而不是等待明确的上下文调用， 或者调用自己的<code>start()</code>方法(不同于上下文刷新，标准的上下文实现是不会自动启动的）。<code>phase</code>的值以及“depends-on”关系会决定对象启动和销毁的顺序。</p><h5 id="在非Web应用中优雅地关闭Spring-IoC容器"><a href="#在非Web应用中优雅地关闭Spring-IoC容器" class="headerlink" title="在非Web应用中优雅地关闭Spring IoC容器"></a>在非Web应用中优雅地关闭Spring IoC容器</h5><p>本节仅适用于非Web应用程序。 Spring的基于Web的<code>ApplicationContext</code> 实现已经具有代码，可以在关闭相关Web应用程序时正常关闭Spring IoC容器。</p><p>如果开发者在非Web应用环境使用Spring IoC容器的话（例如，在桌面客户端的环境下）开发者需要在JVM上注册一个关闭的钩子，来确保在关闭Spring IoC容器的时候能够调用相关的销毁方法来释放掉引用的资源。 当然，开发者也必须正确配置和实现那些销毁回调。</p><p>要注册关闭钩子，请调用<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook()</code> 方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Boot</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>        <span class="hljs-comment">// add a shutdown hook for the above context...        ctx.registerShutdownHook();</span><br>        <span class="hljs-comment">// app runs here...</span><br>        <span class="hljs-comment">// main method exits, hook is called prior to the app shutting down...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-2-ApplicationContextAware-和-BeanNameAware"><a href="#1-6-2-ApplicationContextAware-和-BeanNameAware" class="headerlink" title="1.6.2. ApplicationContextAware 和 BeanNameAware"></a>1.6.2. <code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></h4><p>当<code>ApplicationContext</code> 创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的对象实例时，将为该实例提供对该 <code>ApplicationContext</code>.的引用。 以下清单显示了<code>ApplicationContextAware</code>接口的定义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;<br></code></pre></td></tr></table></figure><p>这样bean就能够通过编程的方式创建和操作<code>ApplicationContext</code> 了。通过<code>ApplicationContext</code> 接口，或者通过将引用转换成已知的接口的子类， 例如<code>ConfigurableApplicationContext</code>就能够提供一些额外的功能。其中的一个用法就是可以通过编程的方式来获取其他的bean。 有时候这个能力非常有用。当然，Spring团队并不推荐这样做，因为这样会使代码与Spring框架耦合，同时也没有遵循IoC的风格。 <code>ApplicationContext</code> 中其它的方法可以提供一些诸如资源的访问、发布应用事件或者添加<code>MessageSource</code>之类的功能。<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-introduction"><code>ApplicationContext</code>的附加功能</a>中描述了这些附加功能。</p><p>从Spring 2.5开始， 自动装配是另一种获取<code>ApplicationContext</code>引用的替代方法。传统的的<code>构造函数</code> 和 <code>byType</code>的装载方式自动装配模式（如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire">自动装配</a>中所述） 可以通过构造函数或setter方法的方式注入，开发者也可以通过注解注入的方式。为了更为方便，包括可以注入的字段和多个参数方法，请使用新的基于注解的自动装配功能。 这样，<code>ApplicationContext</code>将自动装配字段、构造函数参数或方法参数，如果相关的字段，构造函数或方法带有 <code>@Autowired</code>注解，则该参数需要<code>ApplicationContext</code>类型。 有关更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-autowired-annotation">使用 <code>@Autowired</code></a>@Autowired。</p><p>当<code>ApplicationContext</code>创建实现了<code>org.springframework.beans.factory.BeanNameAware</code>接口的类，那么这个类就可以针对其名字进行配置。以下清单显示了BeanNameAware接口的定义：:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;<br></code></pre></td></tr></table></figure><p>这个回调的调用在属性配置完成之后，但是在初始化回调之前。例如<code>InitializingBean</code>, <code>afterPropertiesSet</code>方法以及自定义的初始化方法等。</p><h4 id="1-6-3-其他的-Aware接口"><a href="#1-6-3-其他的-Aware接口" class="headerlink" title="1.6.3. 其他的 Aware接口"></a>1.6.3. 其他的 <code>Aware</code>接口</h4><p>除了 <code>ApplicationContextAware</code>和<code>BeanNameAware</code>（前面已讨论过）之外，Spring还提供了一系列<code>Aware</code>接口，让bean告诉容器，它们需要一些具体的基础配置信息。。 一些重要的<code>Aware</code>接口参看下表：</p><p>Table 4. Aware 接口</p><table><thead><tr><th>名称</th><th>注入的依赖</th><th>所对应的章节</th></tr></thead><tbody><tr><td><code>ApplicationContextAware</code></td><td>声明 <code>ApplicationContext</code></td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware"><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a></td></tr><tr><td><code>ApplicationEventPublisherAware</code></td><td><code>ApplicationContext</code>的事件发布者</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-introduction"><code>ApplicationContext</code>的其他功能</a></td></tr><tr><td><code>BeanClassLoaderAware</code></td><td>用于加载bean类的类加载器</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-class">实例化Bean</a></td></tr><tr><td><code>BeanFactoryAware</code></td><td>声明 <code>BeanFactory</code>.</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware"><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a></td></tr><tr><td><code>BeanNameAware</code></td><td>声明bean的名称.</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware"><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a></td></tr><tr><td><code>BootstrapContextAware</code></td><td>容器运行的资源适配器<code>BootstrapContext</code>。通常仅在JCA感知的 <code>ApplicationContext</code> 实例中可用</td><td><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/integration/integration.md#cci">JCA CCI</a></td></tr><tr><td><code>LoadTimeWeaverAware</code></td><td>定义的weaver用于在加载时处理类定义.</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aop-aj-ltw">在Spring框架中使用AspectJ进行加载时织入</a></td></tr><tr><td><code>MessageSourceAware</code></td><td>用于解析消息的已配置策略（支持参数化和国际化）</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-introduction"><code>ApplicationContext</code>的其他作用</a></td></tr><tr><td><code>NotificationPublisherAware</code></td><td>Spring JMX通知发布者</td><td><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/integration/integration.md#jmx-notifications">通知</a></td></tr><tr><td><code>ResourceLoaderAware</code></td><td>配置的资源加载器</td><td><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#resources">资源</a></td></tr><tr><td><code>ServletConfigAware</code></td><td>当前<code>ServletConfig</code>容器运行。仅在Web下的Spring <code>ApplicationContext</code>中有效</td><td><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/web/web.md#mvc">Spring MVC</a></td></tr><tr><td><code>ServletContextAware</code></td><td>容器运行的当前ServletContext。仅在Web下的Spring <code>ApplicationContext</code>中有效。</td><td><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/web/web.md#mvc">Spring MVC</a></td></tr></tbody></table><p>请再次注意，使用这些接口会将您的代码绑定到Spring API，而不会遵循IoC原则。 因此，我们建议将它们用于需要以编程方式访问容器的基础架构bean。</p><h3 id="1-7-bean定义的继承"><a href="#1-7-bean定义的继承" class="headerlink" title="1.7. bean定义的继承"></a>1.7. bean定义的继承</h3><p>bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。 子bean定义从父定义继承配置数据。 子定义可以覆盖某些值或根据需要添加其他值。 使用父子bean定义可以节省很多配置输入。 实际上，这是一种模板形式。</p><p>如果开发者编程式地使用<code>ApplicationContext</code>接口，子bean定义可以通过<code>ChildBeanDefinition</code>类来表示。很多开发者不会使用这个级别的方法， 而是会在类似于<code>ClassPathXmlApplicationContext</code>中声明式地配置bean定义。当你使用基于XML的配置时，你可以在子bean中使用parent属性，该属性的值用来识别父bean。 以下示例显示了如何执行此操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inheritedTestBean&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inheritsWithDifferentClass&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.DerivedTestBean&quot;</span>        <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;inheritedTestBean&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initialize&quot;</span>&gt;</span>  (1)    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;override&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>。请注意<code>parent</code>属性。</p><p>子bean如果没有指定class，它将使用父bean定义的class。但也可以进行重写。在后一种情况中，子bean必须与父bean兼容，也就是说，它必须接受父bean的属性值。</p><p>子bean定义从父类继承作用域、构造器参数、属性值和可重写的方法，除此之外，还可以增加新值。开发者指定任何作用域、初始化方法、销毁方法和&#x2F;或者静态工厂方法设置都会覆盖相应的父bean设置。</p><p>剩下的设置会取子bean定义：依赖、自动注入模式、依赖检查、单例、延迟加载。</p><p>前面的示例通过使用<code>abstract</code>属性将父bean定义显式标记为<code>abstract</code>。 如果父定义未指定类，则需要将父bean定义显式标记为<code>abstract</code>，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inheritsWithClass&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.DerivedTestBean&quot;</span>        <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initialize&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;override&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父bean不能单独实例化，因为它不完整，并且也明确标记为<code>abstract</code>。当定义是<code>abstract</code>的时，它只能用作纯模板bean定义，用作子定义的父定义。如果试图单独地使用声明了<code>abstract</code>的父bean， 通过引用它作为另一个bean的ref属性，或者使用父bean id进行显式的<code>getBean()</code>调用，都将返回一个错误。同样，容器内部的 <code>preInstantiateSingletons()</code>方法也会忽略定义为<code>abstract</code>的bean。</p><p><code>ApplicationContext</code> 默认会预先实例化所有的单例bean。因此，如果开发者打算把(父）bean定义仅仅作为模板来使用，同时为它指定了class属性， 那么必须确保设置_abstract_的属性值为true。否则，应用程序上下文会(尝试）预实例化这个<code>abstract</code> bean。</p><h3 id="1-8-容器的扩展点"><a href="#1-8-容器的扩展点" class="headerlink" title="1.8. 容器的扩展点"></a>1.8. 容器的扩展点</h3><p>通常，应用程序开发者无需继承<code>ApplicationContext</code>的实现类。相反，Spring IoC容器可以通过插入特殊的集成接口实现进行扩展。接下来的几节将介绍这些集成接口。</p><h4 id="1-8-1-使用BeanPostProcessor自定义Bean"><a href="#1-8-1-使用BeanPostProcessor自定义Bean" class="headerlink" title="1.8.1. 使用BeanPostProcessor自定义Bean"></a>1.8.1. 使用<code>BeanPostProcessor</code>自定义Bean</h4><p><code>BeanPostProcessor</code>接口定义了可以实现的回调方法，以提供您自己的（或覆盖容器的默认）实例化逻辑，依赖关系解析逻辑等。 如果要在Spring容器完成实例化，配置和初始化bean之后实现某些自定义逻辑，则可以插入一个或多个<code>BeanPostProcessor</code>实现。</p><p>您可以配置多个<code>BeanPostProcessor</code> 实例，并且可以通过设置<code>order</code>属性来控制这些 <code>BeanPostProcessor</code> 实例的执行顺序。 仅当<code>BeanPostProcessor</code>实现 <code>Ordered</code>接口时，才能设置此属性。如果编写自己的<code>BeanPostProcessor</code>，则应考虑实现Ordered接口。 有关更多详细信息， 请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>的javadoc。 另请参阅有关<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-programmatically-registering-beanpostprocessors"><code>BeanPostProcessor</code> 实例</a>的编程注册的说明。</p><p><code>BeanPostProcessor</code>实例在bean（或对象）实例上运行。 也就是说，Spring IoC容器实例化一个bean实例，然后才能用<code>BeanPostProcessor</code> 对这个实例进行处理。</p><p><code>BeanPostProcessor</code>会在整个容器内起作用，所有它仅仅与正在使用的容器相关。如果在一个容器中定义了<code>BeanPostProcessor</code>，那么它只会处理那个容器中的bean。 换句话说，在一个容器中定义的bean不会被另一个容器定义的<code>BeanPostProcessor</code>处理，即使这两个容器都是同一层次结构的一部分。</p><p>要更改实际的bean定义（即定义bean的蓝图），您需要使用<code>BeanFactoryPostProcessor</code>，使用BeanFactoryPostProcessor自定义配置元数据。 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-factory-postprocessors">使用 <code>BeanFactoryPostProcessor</code>自定义配置元数据</a>.</p><p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口由两个回调方法组成，当一个类被注册为容器的后置处理器时，对于容器创建的每个bean实例， 后置处理器都会在容器初始化方法（如<code>InitializingBean.afterPropertiesSet()</code>之前和容器声明的<code>init</code>方法）以及任何bean初始化回调之后被调用。后置处理器可以对bean实例执行任何操作， 包括完全忽略回调。bean后置处理器，通常会检查回调接口或者使用代理包装bean。一些Spring AOP基础架构类为了提供包装好的代理逻辑，会被实现为bean后置处理器。</p><p><code>ApplicationContext</code>会自动地检测所有定义在配置元文件中，并实现了<code>BeanPostProcessor</code> 接口的bean。<code>ApplicationContext</code>会注册这些beans为后置处理器， 使他们可以在bean创建完成之后被调用。bean后置处理器可以像其他bean一样部署到容器中。</p><p>当在配置类上使用 <code>@Bean</code> 工厂方法声明<code>BeanPostProcessor</code>时，工厂方法返回的类型应该是实现类自身。，或至少也是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口， 要清楚地表明这个bean的后置处理器的本质特点。否则，在它完全创建之前，<code>ApplicationContext</code>将不能通过类型自动探测它。由于<code>BeanPostProcessor</code>在早期就需要被实例化， 以适应上下文中其他bean的实例化，因此这个早期的类型检查是至关重要的。</p><p>以编程方式注册<code>BeanPostProcessor</code>实例，虽然<code>BeanPostProcessor</code>注册的推荐方法是通过<code>ApplicationContext</code>自动检测（如前所述），但您可以以编程的方式使用<code>ConfigurableBeanFactory</code>的<code>addBeanPostProcessor</code>方法进行注册。 这对于在注册之前需要对条件逻辑进行评估，或者是在继承层次的上下文之间复制bean的后置处理器中是有很有用的。 但请注意，以编程方式添加的<code>BeanPostProcessor</code>实例不遵循<code>Ordered</code>接口。这里，注册顺序决定了执行的顺序。 另请注意，以编程方式注册的<code>BeanPostProcessor</code>实例始终在通过自动检测注册的实例之前处理，而不管任何显式排序。</p><p><code>BeanPostProcessor</code> 实例 and AOP 自动代理</p><p>实现<code>BeanPostProcessor</code> 接口的类是特殊的，容器会对它们进行不同的处理。所有<code>BeanPostProcessor</code> 和他们直接引用的beans都会在容器启动的时候被实例化， 并作为<code>ApplicationContext</code>特殊启动阶段的一部分。接着，所有的<code>BeanPostProcessor</code> 都会以一个有序的方式进行注册，并应用于容器中的所有bean。 因为AOP自动代理本身被实现为<code>BeanPostProcessor</code>，这个<code>BeanPostProcessor</code>和它直接应用的beans都不适合进行自动代理，因此也就无法在它们中织入切面。</p><p>对于所有这样的bean，您应该看到一条信息性日志消息: <code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>.</p><p>如果你使用自动装配或 <code>@Resource</code>（可能会回退到自动装配）将Bean连接到<code>BeanPostProcessor</code>中，Spring可能会在搜索类型匹配的依赖关系候选时访问到意外类型的bean； 因此，对它们不适合进行自动代理，或者对其他类型的bean进行后置处理。例如，如果有一个使用 <code>@Resource</code> 注解的依赖项，其中字段或setter名称不直接对应于bean的声明名称而且没有使用name属性， 则Spring会访问其他bean以按类型匹配它们。</p><p>以下示例显示如何在<code>ApplicationContext</code>中编写，注册和使用<code>BeanPostProcessor</code>实例。</p><h5 id="示例-Hello-World-BeanPostProcessor-style"><a href="#示例-Hello-World-BeanPostProcessor-style" class="headerlink" title="示例: Hello World, BeanPostProcessor-style"></a>示例: Hello World, <code>BeanPostProcessor</code>-style</h5><p>第一个例子说明了基本用法。 该示例显示了一个自定义<code>BeanPostProcessor</code>实现，该实现在容器创建时调用每个bean的 <code>toString()</code> 方法，并将生成的字符串输出到系统控制台。</p><p>以下清单显示了自定义<code>BeanPostProcessor</code> 实现类定义:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">package scripting;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstantiationTracingBeanPostProcessor</span> implements BeanPostProcessor &#123;<br>    <span class="hljs-regexp">//</span> simply <span class="hljs-keyword">return</span> the instantiated bean <span class="hljs-keyword">as</span>-<span class="hljs-keyword">is</span>    public <span class="hljs-built_in">Object</span> postProcessBeforeInitialization(<span class="hljs-built_in">Object</span> bean, <span class="hljs-built_in">String</span> beanName) &#123;        <span class="hljs-keyword">return</span> bean; <span class="hljs-regexp">//</span> we could potentially <span class="hljs-keyword">return</span> any object reference here...    &#125;<br>    public <span class="hljs-built_in">Object</span> postProcessAfterInitialization(<span class="hljs-built_in">Object</span> bean, <span class="hljs-built_in">String</span> beanName) &#123;        System.out.println(<span class="hljs-string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; created : &quot;</span> + bean.toString());        <span class="hljs-keyword">return</span> bean;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下beans元素使用<code>InstantiationTracingBeanPostProcessor</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:lang</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/lang&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/lang        http://www.springframework.org/schema/lang/spring-lang.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">lang:groovy</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messenger&quot;</span>            <span class="hljs-attr">script-source</span>=<span class="hljs-string">&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">lang:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Fiona Apple Is Just So Dreamy.&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">lang:groovy</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--    when the above bean (messenger) is instantiated, this custom    BeanPostProcessor implementation will output the fact to the system console    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scripting.InstantiationTracingBeanPostProcessor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意<code>InstantiationTracingBeanPostProcessor</code>是如何定义的，它甚至没有名字，因为它是一个bean，所以它可以像任何其他bean一样进行依赖注入 （前面的配置还定义了一个由Groovy脚本支持的bean。在<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/languages/languages.md#dynamic-language">动态语言支持</a>一章中详细介绍了Spring动态语言支持）。</p><p>下面简单的Java应用执行了前面代码和配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<span class="hljs-keyword">import</span> org.springframework.scripting.Messenger;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Boot</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;scripting/beans.xml&quot;</span>);        <span class="hljs-type">Messenger</span> <span class="hljs-variable">messenger</span> <span class="hljs-operator">=</span> (Messenger) ctx.getBean(<span class="hljs-string">&quot;messenger&quot;</span>);        System.out.println(messenger);    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述应用程序的输出类似于以下内容:</p><p>Bean ‘messenger’ created : org.springframework.scripting.groovy.GroovyMessenger@272961 org.springframework.scripting.groovy.GroovyMessenger@272961</p><h5 id="示例-The-RequiredAnnotationBeanPostProcessor"><a href="#示例-The-RequiredAnnotationBeanPostProcessor" class="headerlink" title="示例: The RequiredAnnotationBeanPostProcessor"></a>示例: The <code>RequiredAnnotationBeanPostProcessor</code></h5><p>自定义<code>BeanPostProcessor</code>实现与回调接口或注解配合使用，是一种常见的扩展Spring IoC容器手段，一个例子就是<code>RequiredAnnotationBeanPostProcessor</code>，这是<code>BeanPostProcessor</code>实现。 它确保用（任意）注解标记的bean上的JavaBean属性实际上（配置为）依赖注入值。</p><h4 id="1-8-2-使用BeanFactoryPostProcessor自定义元数据配置"><a href="#1-8-2-使用BeanFactoryPostProcessor自定义元数据配置" class="headerlink" title="1.8.2. 使用BeanFactoryPostProcessor自定义元数据配置"></a>1.8.2. 使用<code>BeanFactoryPostProcessor</code>自定义元数据配置</h4><p>下一个我们要关注的扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与<code>BeanPostProcessor</code>类似， 但有一处不同，<code>BeanFactoryPostProcessor</code>操作bean的元数据配置。也就是说，也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据， 并可能在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何bean之前更改它。</p><p>您可以配置多个<code>BeanFactoryPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanFactoryPostProcessor</code>实例的运行顺序（<code>BeanFactoryPostProcessor</code>必须实现了<code>Ordered</code>接口才能设置这个属性）。 如果编写自己的BeanFactoryPostProcessor，则应考虑实现Ordered接口。 有关更多详细信息， 请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a> 接口的javadoc.</p><p>如果想修改实际的bean实例（也就是说，从元数据配置中创建的对象）那么需要使用<code>BeanPostProcessor</code>（前面在使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-bpp"><code>BeanPostProcessor</code>自定义Bean</a>中进行了描述）来替代。 在<code>BeanFactoryPostProcessor</code>（例如使用<code>BeanFactory.getBean()</code>）中使用这些bean的实例虽然在技术上是可行的，但这么来做会将bean过早实例化， 这违反了标准的容器生命周期。同时也会引发一些副作用，例如绕过bean的后置处理。</p><p><code>BeanFactoryPostProcessor</code>会在整个容器内起作用，所有它仅仅与正在使用的容器相关。如果在一个容器中定义了<code>BeanFactoryPostProcessor</code>， 那么它只会处理那个容器中的bean。 换句话说，在一个容器中定义的bean不会被另一个容器定义的<code>BeanFactoryPostProcessor</code>处理，即使这两个容器都是同一层次结构的一部分。</p><p>bean工厂后置处理器在<code>ApplicationContext</code>中声明时自动执行，这样就可以对定义在容器中的元数据配置进行修改。 Spring包含许多预定义的bean工厂后处理器， 例如<code>PropertyOverrideConfigurer</code> 和<code>PropertyPlaceholderConfigurer</code>。 您还可以使用自定义<code>BeanFactoryPostProcessor</code>。 例如，注册自定义属性编辑器。 .</p><p><code>ApplicationContext</code> 自动检测部署到其中的任何实现<code>BeanFactoryPostProcessor</code>接口的bean。 它在适当的时候使用这些bean作为bean工厂后置处理器。 你可以部署这些后置处理器为你想用的任意其它bean。</p><p>注意，和<code>BeanPostProcessor</code>一样，通常不应该配置<code>BeanFactoryPostProcessor</code>来进行延迟初始化。如果没有其它bean引用<code>Bean(Factory)PostProcessor</code>， 那么后置处理器就不会被初始化。因此，标记它为延迟初始化就会被忽略，，即便你在<code>&lt;beans /&gt;</code>元素声明中设置<code>default-lazy-init</code>&#x3D;true属性，<code>Bean(Factory)PostProcessor</code>也会提前初始化bean。</p><h5 id="示例-类名替换PropertyPlaceholderConfigurer"><a href="#示例-类名替换PropertyPlaceholderConfigurer" class="headerlink" title="示例: 类名替换PropertyPlaceholderConfigurer"></a>示例: 类名替换<code>PropertyPlaceholderConfigurer</code></h5><p>您可以使用<code>PropertyPlaceholderConfigurer</code>通过使用标准Java <code>Properties</code>格式从单独文件中的bean定义外部化属性值。 这样做可以使部署应用程序的人能够定制特定于环境的属性，如数据库URL和密码，而无需修改容器的主XML定义文件或文件的复杂性或风险。</p><p>考虑以下这个基于XML的元数据配置代码片段，这里的DataSource使用了占位符来定义:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;locations&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;&lt;/bean&gt;<br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attribute">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>        <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;jdbc.driverClassName&#125;</span>&quot;</span>/&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;jdbc.url&#125;</span>&quot;</span>/&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;jdbc.username&#125;</span>&quot;</span>/&gt;    &lt;property <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;jdbc.password&#125;</span>&quot;</span>/&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>该示例显示了从外部属性文件配置的属性。在运行时，<code>PropertyPlaceholderConfigurer</code>应用于替换DataSource的某些属性的元数据。 要替换的值被指定为$ {property-name}形式的占位符，它遵循Ant和log4j以及JSP EL样式。</p><p>而真正的值是来自于标准的Java <code>Properties</code>格式的文件:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.driverClassName</span>=org.hsqldb.jdbcDriver<br><br><span class="hljs-attr">jdbc.url</span>=jdbc:hsqldb:hsql://production:<span class="hljs-number">9002</span><br><br><span class="hljs-attr">jdbc.username</span>=sa<br><br><span class="hljs-attr">jdbc.password</span>=root<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>$&#123;jdbc.username&#125;</code> 字符串在运行时将替换为值’sa’，并且同样适用于与属性文件中的键匹配的其他占位符值。 <code>PropertyPlaceholderConfigurer</code>检查bean定义的大多数属性和属性中的占位符。 此外，您可以自定义占位符前缀和后缀。</p><p>使用Spring 2.5中引入的<code>context</code> 命名空间，您可以使用专用配置元素配置属性占位符。 您可以在<code>location</code>属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;context:property-placeholder <span class="hljs-attribute">location</span>=<span class="hljs-string">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><code>PropertyPlaceholderConfigurer</code>不仅在您指定的属性文件中查找属性。 默认情况下，如果它在指定的属性文件中找不到属性，它还会检查Java <code>System</code>属性。 开发者可以通过设置<code>systemPropertiesMode</code>属性，使用下面三个整数的某一个来自定义这种行为：</p><ul><li><code>never</code> (0): 从不检查系统属性。</li><li><code>fallback</code> (1): 如果没有在指定的属性文件中解析到属性，那么就检查系统属性（默认）。</li><li><code>override</code> (2): 在检查指定的属性文件之前，首先去检查系统属性，允许系统属性覆盖其它任意的属性资源。</li></ul><p>有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"><code>PropertyPlaceholderConfigurer</code></a> javadoc</p><p>你可以使用<code>PropertyPlaceholderConfigurer</code>来替换类名，当开发者在运行时需要选择某个特定的实现类时，这是很有用的。例如</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;locations&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:com/something/strategy.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>custom.strategy.class=com.something.DefaultStrategy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;serviceStrategy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;custom.strategy.class&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果在运行时无法将类解析为有效类，则在即将创建bean时，bean的解析将失败，这是 <code>ApplicationContext</code>在对非延迟初始化bean的<code>preInstantiateSingletons()</code>阶段发生的事。</p><h5 id="示例-PropertyOverrideConfigurer"><a href="#示例-PropertyOverrideConfigurer" class="headerlink" title="示例: PropertyOverrideConfigurer"></a>示例: <code>PropertyOverrideConfigurer</code></h5><p><code>PropertyOverrideConfigurer</code>, 另外一种bean工厂后置处理器，类似于<code>PropertyPlaceholderConfigurer</code>，但与后者不同的是：对于所有的bean属性，原始定义可以有默认值或也可能没有值。 如果一个<code>Properties</code>覆盖文件没有配置特定的bean属性，则就会使用默认的上下文定义</p><p>注意，bean定义是不知道是否被覆盖的，所以从XML定义文件中不能马上看到那个配置正在被使用。在拥有多个<code>PropertyOverrideConfigurer</code> 实例的情况下，为相同bean的属性定义不同的值时，基于覆盖机制只会有最后一个生效。</p><p>属性文件配置行采用以下格式:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">beanName.property</span>=value<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dataSource.driverClassName</span>=com.mysql.jdbc.Driver<br><br><span class="hljs-attr">dataSource.url</span>=jdbc:mysql:mydb<br></code></pre></td></tr></table></figure><p>这个示例文件可以和容器定义一起使用，该容器定义包含一个名为<code>dataSource</code>的bean，该bean具有 <code>driver</code>和<code>url</code>属性</p><p>复合属性名称也是被支持的，只要被重写的最后一个属性以外的路径中每个组件都已经是非空时（假设由构造方法初始化）。 在下面的示例中，<code>tom</code> bean的<code>fred</code>属性的 <code>bob</code>属性的<code>sammy</code>属性设置值为<code>123</code>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tom.fred.bob.sammy</span>=<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>指定的覆盖值通常是文字值，它们不会被转换成bean的引用。这个约定也适用于当XML中的bean定义的原始值指定了bean引用时。</p><p>使用Spring 2.5中引入的<code>context</code>命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;context:property-override <span class="hljs-attribute">location</span>=<span class="hljs-string">&quot;classpath:override.properties&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h4 id="1-8-3-使用FactoryBean自定义初始化逻辑"><a href="#1-8-3-使用FactoryBean自定义初始化逻辑" class="headerlink" title="1.8.3. 使用FactoryBean自定义初始化逻辑"></a>1.8.3. 使用<code>FactoryBean</code>自定义初始化逻辑</h4><p>为自己工厂的对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口。</p><p><code>FactoryBean</code>接口就是Spring IoC容器实例化逻辑的可插拔点，如果你的初始化代码非常复杂，那么相对于（潜在地）大量详细的XML而言，最好是使用Java语言来表达。 你可以创建自定义的<code>FactoryBean</code>，在该类中编写复杂的初始化代码。然后将自定义的<code>FactoryBean</code>插入到容器中。</p><p><code>FactoryBean</code>接口提供下面三个方法</p><ul><li><code>Object getObject()</code>: 返回这个工厂创建的对象实例。这个实例可能是共享的，这取决于这个工厂返回的是单例还是原型实例。</li><li><code>boolean isSingleton()</code>: 如果<code>FactoryBean</code>返回单例，那么这个方法就返回<code>true</code>，否则返回<code>false</code>。</li><li><code>Class getObjectType()</code>: 返回由<code>getObject()</code>方法返回的对象类型，如果事先不知道的类型则会返回null。</li></ul><p>Spring框架大量地使用了<code>FactoryBean</code> 的概念和接口，<code>FactoryBean</code> 接口的50多个实现都随着Spring一同提供。</p><p>当开发者需要向容器请求一个真实的<code>FactoryBean</code>实例（而不是它生产的bean）时，调用 <code>ApplicationContext</code>的<code>getBean()</code>方法时在bean的id之前需要添加连字符（&amp;） 所以对于一个给定id为myBean的<code>FactoryBean</code>，调用容器的<code>getBean(&quot;myBean&quot;)</code>方法返回的是FactoryBean的代理，而调用<code>getBean(&quot;&amp;myBean&quot;)</code>方法则返回FactoryBean实例本身</p><h3 id="1-9-基于注解的容器配置"><a href="#1-9-基于注解的容器配置" class="headerlink" title="1.9. 基于注解的容器配置"></a>1.9. 基于注解的容器配置</h3><p>注解是否比配置Spring的XML更好?</p><p>在引入基于注解的配置之后,引发了这种方法是否比XML更优秀的问题.简短的答案是得看情况,每种方法都有其优缺点。通常由开发人员决定使用更适合他们的策略。 首先看看两种定义方式,注解在它们的声明中提供了很多上下文信息，使得配置变得更短、更简洁；但是，XML擅长于在不接触源码或者无需反编译的情况下装配组件，一些开发人员更喜欢在源码上使用注解配置。 而另一些人认为注解类不再是POJO，同时认为注解配置会很分散，最终难以控制。</p><p>无论选择如何，Spring都可以兼顾两种风格，甚至可以将它们混合在一起。Spring通过其<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java">JavaConfig</a> 选项，允许注解以无侵入的方式使用，即无需接触目标组件源代码。 而且在工具应用方面， <a href="https://spring.io/tools/sts">Spring Tool Suite</a>支持所有配置形式。</p><p>XML设置的替代方法是基于注解的配置，它依赖于字节码元数据来连接组件进而替代XML声明。开发人员通过使用相关类、方法或字段声明上的注解来将配置移动到组件类本身。而不是使用XML bean来配置。 如示例中所述，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-bpp-examples-rabpp"><code>RequiredAnnotationBeanPostProcessor</code></a>,将<code>BeanPostProcessor</code> 与注解混合使用是扩展Spring IoC容器的常用方法。 例如，Spring 2.0引入了使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-required-annotation"><code>@Required</code></a>注解强制属性必须在配置的时候被填充， Spring 2.5使用同样的方式来驱动Spring的依赖注入。本质上，<code>@Autowired</code>注解提供的功能与<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire">自动装配协作</a>中描述的相同，但具有更细粒度的控制和更广泛的适用性。 Spring 2.5还增加了对JSR-250注解的支持，例如<code>@PostConstruct</code>和<code>@PreDestroy</code>。 Spring 3.0增加了对<code>javax.inject</code>包中包含的JSR-330（Java的依赖注入）注解的支持， 例如<code>@Inject</code>和<code>@Named</code>。有关这些注解的详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-standard-annotations">相关章节</a>。</p><p>注解注入在XML注入之前执行，因此同时使用这两种方式进行注入时，XML配置会覆盖注解配置。</p><p>与之前一样，你可以将它们注册为单独的bean定义，但也可以通过在基于XML的Spring配置中包含以下标记来隐式注册它们（请注意包含<code>context</code>命名空间）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（隐式注册的后处理器包括 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a>, <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a>, <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a>, 和前面提到的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>.)</p><p><code>&lt;context:annotation-config/&gt;</code>只有在定义bean的相同应用程序上下文中查找bean上的注解。 这意味着，如果将 <code>&lt;context:annotation-config/&gt;</code> 放在<code>DispatcherServlet</code>的<code>WebApplicationContext</code>中， 它只检查控制器中的<code>@Autowired</code> bean，而不检查您的服务。 有关更多信息，请参阅 <a href="https://github.com/DocsHome/spring-docs/blob/master/pages/web/web.md#mvc-servlet">DispatcherServlet</a>。</p><h4 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1. @Required"></a>1.9.1. @Required</h4><p><code>@Required</code>注解适用于bean属性setter方法，如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Required</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>此注解仅表示受影响的bean属性必须在配置时通过bean定义中的显式赋值或自动注入值。如果受影响的bean属性尚未指定值，容器将抛出异常；这导致及时的、明确的失败，避免在运行后再抛出<code>NullPointerException</code>或类似的异常。 在这里，建议开发者将断言放入bean类本身，例如放入init方法。这样做强制执行那些必需的引用和值，即使是在容器外使用这个类。</p><h4 id="1-9-2-Autowired"><a href="#1-9-2-Autowired" class="headerlink" title="1.9.2. @Autowired"></a>1.9.2. <code>@Autowired</code></h4><p>可以使用JSR 330的 <code>@Inject</code>注解代替本节中包含的示例中的Spring的<code>@Autowired</code>注解。 有关详细信息，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-standard-annotations">请参见此处</a></p><p>开发者可以在构造器上使用<code>@Autowired</code>注解:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CustomerPreferenceDao customerPreferenceDao;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        <span class="hljs-keyword">this</span>.customerPreferenceDao = customerPreferenceDao;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>从Spring Framework 4.3开始，如果目标bean仅定义一个构造函数，则不再需要<code>@Autowired</code>构造函数。如果有多个构造函数可用，则至少有一个必须注解<code>@Autowired</code>以让容器知道它使用的是哪个</p><p>您还可以将<code>@Autowired</code>注解应用于“传统”setter方法，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>您还可以将注解应用于具有任意名称和多个参数的方法，如以下示例所示：:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> MovieCatalog movieCatalog;<br>    <span class="hljs-keyword">private</span> CustomerPreferenceDao customerPreferenceDao;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> void prepare(MovieCatalog movieCatalog,            CustomerPreferenceDao customerPreferenceDao) &#123;        <span class="hljs-keyword">this</span>.movieCatalog = movieCatalog;        <span class="hljs-keyword">this</span>.customerPreferenceDao = customerPreferenceDao;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>还可以将<code>@Autowired</code>应用于字段，甚至可以和构造函数混合使用:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CustomerPreferenceDao customerPreferenceDao;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> MovieCatalog movieCatalog;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        <span class="hljs-keyword">this</span>.customerPreferenceDao = customerPreferenceDao;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>确保您的组件（例如，<code>MovieCatalog</code>或<code>CustomerPreferenceDao</code>）始终按照用于@Autowired注入点的类型声明。 否则，由于在运行时未找到类型匹配，注入可能会失败。</p><p>对于通过类路径扫描找到的XML定义的bean或组件类，容器通常预先知道具体类型。 但是，对于<code>@Bean</code>工厂方法，您需要确保其声明的具体返回类型。 对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法上声明最具体的返回类型（至少与引用bean的注入点所需的特定类型一致）。 .</p><p>也可以用在数组上，注解用于标注属性或方法，数组的类型是<code>ApplicationContext</code>中定义的bean类型。如以下示例所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieCatalog</span>[] movieCatalogs;<br>    <span class="hljs-regexp">//</span> ...&#125;<br></code></pre></td></tr></table></figure><p>也可以应用于集合类型，如以下示例所示:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">MovieCatalog</span>&gt; movieCatalogs;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieCatalogs</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;MovieCatalog&gt; movieCatalogs</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieCatalogs</span> = movieCatalogs;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>如果想让数组元素或集合元素按特定顺序排列，应用的bean可以实现<code>org.springframework.core.Ordered</code>， 或者使用<code>@Order</code>或标准的@<code>@Priority</code> 注解，否则，它们的顺序遵循容器中相应目标bean定义的注册顺序。</p><p>您可以在类级别和<code>@Bean</code>方法上声明 <code>@Order</code>注解，可能是通过单个bean定义（在多个定义使用相同bean类的情况下）。 <code>@Order</code>值可能会影响注入点的优先级，但要注意它们不会影响单例启动顺序，这是由依赖关系和<code>@DependsOn</code>声明确定的。</p><p>请注意，标准的<code>javax.annotation.Priority</code>注解在<code>@Bean</code>级别不可用，因为它无法在方法上声明。 它的语义可以通过<code>@Order</code>值与<code>@Primary</code>定义每个类型的单个bean上。</p><p>只要键类型是<code>String</code>，<code>Map</code>类型就可以自动注入。 Map值将包含所有类型的bean，并且键将包含相应的bean名称。如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">MovieCatalog</span>&gt; movieCatalogs;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieCatalogs</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, MovieCatalog&gt; movieCatalogs</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieCatalogs</span> = movieCatalogs;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>默认情况下，当没有候选的bean可用时，自动注入将会失败；默认的处理方式是将带有注解的方法，、构造函数和字段标明为required&#x3D;false属性。这种设置不是必须的，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-literal">false</span>)    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>只有一个带注解的构造函数per-class 可以标记为required，但是可以注解多个非必需的构造函数。在这种情况下，每个项都会是候选者，而Spring使用的是最贪婪的构造函数。 这个构造函数的依赖关系可以得到满足，那就是具有最多参数的构造函数。</p><p>推荐使用<code>@Required</code>注解来代替<code>@Autowired</code>的required属性，required属性表示该属性不是自动装配必需的，如果该属性不能被自动装配。 则该属性会被忽略。 另一方面， <code>@Required</code>会强调通过容器支持的任何方式来设置属性。 如果没有值被注入的话，会引发相应的异常。</p><p>或者，您可以通过Java 8的<code>java.util.Optional</code>表达特定依赖项的非必需特性，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">Optional&lt;MovieFinder&gt; movieFinder</span>) &#123;        ...    &#125;&#125;<br></code></pre></td></tr></table></figure><p>从Spring Framework 5.0开始，您还可以使用<code>@Nullable</code> 注解（任何包中的任何类型，例如，来自JSR-305的 <code>javax.annotation.Nullable</code>）：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">SimpleMovieLister</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    public void <span class="hljs-built_in">setMovieFinder</span>(<span class="hljs-variable">@Nullable</span> MovieFinder movieFinder) &#123;        ...    &#125;&#125;<br></code></pre></td></tr></table></figure><p>您也可以使用<code>@Autowired</code>作为常见的可解析依赖关系的接口，<code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, 和 <code>MessageSource</code> 这些接口及其扩展接口（例如<code>ConfigurableApplicationContext</code> 或 <code>ResourcePatternResolver</code>） 会自动解析，无需特殊设置。 以下示例自动装配<code>ApplicationContext</code>对象：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieRecommender</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ApplicationContext context;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieRecommender</span><span class="hljs-params">()</span> </span>&#123;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><code>@Autowired</code>, <code>@Inject</code>, <code>@Resource</code>, 和 <code>@Value</code> 注解 由 Spring <code>BeanPostProcessor</code> 实现.也就是说开发者不能使用自定义的<code>BeanPostProcessor</code>或者自定义<code>BeanFactoryPostProcessor</code>r来使用这些注解 必须使用XML或Spring @Bean方法显式地“连接”这些类型。</p><h4 id="1-9-3-Primary"><a href="#1-9-3-Primary" class="headerlink" title="1.9.3. @Primary"></a>1.9.3. <code>@Primary</code></h4><p>由于按类型的自动注入可能匹配到多个候选者，所以通常需要对选择过程添加更多的约束。使用Spring的<code>@Primary</code>注解是实现这个约束的一种方法。 它表示如果存在多个候选者且另一个bean只需要一个特定类型的bean依赖时，就明确使用标记有<code>@Primary</code>注解的那个依赖。如果候选中只有一个”Primary” bean，那么它就是自动注入的值</p><p>请考虑以下配置，将<code>firstMovieCatalog</code>定义为主要<code>MovieCatalog</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configurationpublic</span> class MovieConfiguration &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@Primary</span>    public MovieCatalog <span class="hljs-built_in">firstMovieCatalog</span>() &#123; ... &#125;<br>    <span class="hljs-variable">@Bean</span>    public MovieCatalog <span class="hljs-built_in">secondMovieCatalog</span>() &#123; ... &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>使用上述配置，以下 <code>MovieRecommender</code>将与<code>firstMovieCatalog</code>一起自动装配：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieCatalog</span> movieCatalog;<br>    <span class="hljs-regexp">//</span> ...&#125;<br></code></pre></td></tr></table></figure><p>相应的bean定义如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieRecommender&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.MovieRecommender&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-9-4-使用qualifiers微调基于注解的自动装配"><a href="#1-9-4-使用qualifiers微调基于注解的自动装配" class="headerlink" title="1.9.4. 使用qualifiers微调基于注解的自动装配"></a>1.9.4. 使用qualifiers微调基于注解的自动装配</h4><p><code>@Primary</code> 是一种用于解决自动装配多个值的注入的有效的方法，当需要对选择过程做更多的约束时，可以使用Spring的<code>@Qualifier</code>注解，可以为指定的参数绑定限定的值。 缩小类型匹配集，以便为每个参数选择特定的bean。 在最简单的情况下，这可以是一个简单的描述性值，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MovieRecommender</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@Qualifier</span>(<span class="hljs-string">&quot;main&quot;</span>)    private MovieCatalog movieCatalog;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>您还可以在各个构造函数参数或方法参数上指定<code>@Qualifier</code>注解，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-keyword">private</span> MovieCatalog movieCatalog;<br>    <span class="hljs-keyword">private</span> CustomerPreferenceDao customerPreferenceDao;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> void prepare(<span class="hljs-meta">@Qualifier(<span class="hljs-string">&quot;main&quot;</span>)</span>MovieCatalog movieCatalog,            CustomerPreferenceDao customerPreferenceDao) &#123;        <span class="hljs-keyword">this</span>.movieCatalog = movieCatalog;        <span class="hljs-keyword">this</span>.customerPreferenceDao = customerPreferenceDao;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了相应的bean定义。.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;main&quot;</span>/&gt;</span> (1)<br>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;action&quot;</span>/&gt;</span> (2)<br>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieRecommender&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.MovieRecommender&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、带有限定符”<code>main</code>”的bean会被装配到拥有相同值的构造方法参数上.</p><p><strong>2</strong>、带有限定符”<code>action</code>”的bean会被装配到拥有相同值的构造方法参数上.</p><p>bean的name会作为备用的qualifier值,因此可以定义bean的<code>id</code>为 main 替代内嵌的qualifier元素.这种匹配方式同样有效。但是，虽然可以使用这个约定来按名称引用特定的bean， 但是<code>@Autowired</code>默认是由带限定符的类型驱动注入的。这就意味着qualifier值，甚至是bean的name作为备选项，只是为了缩小类型匹配的范围。它们在语义上不表示对唯一bean id的引用。 良好的限定符值是像<code>main</code> 或 <code>EMEA</code> 或 <code>persistent</code>这样的，能表示与bean id无关的特定组件的特征，在匿名bean定义的情况下可以自动生成。</p><p>Qualifiers也可以用于集合类型，如上所述，例如 <code>Set&lt;MovieCatalog&gt;</code>。在这种情况下，根据声明的限定符，所有匹配的bean都作为集合注入。 这意味着限定符不必是唯一的。 相反，它们构成过滤标准。 例如，您可以使用相同的限定符值“action”定义多个<code>MovieCatalog</code> bean，所有这些bean都注入到使用<code>@Qualifier(&quot;action&quot;)</code>注解的<code>Set&lt;MovieCatalog&gt;</code>中。</p><p>在类型匹配候选项中，根据目标bean名称选择限定符值，在注入点不需要<code>@Qualifier</code>注解。 如果没有其他解析指示符（例如限定符或主标记）， 则对于非唯一依赖性情况，Spring会将注入点名称（即字段名称或参数名称）与目标bean名称进行匹配，然后选择同名的候选者，如果有的话。</p><p>如果打算by name来驱动注解注入，那么就不要使用<code>@Autowired</code>（多数情况），即使在技术上能够通过@Qualifier值引用bean名字。相反，应该使用JSR-250 <code>@Resource</code> 注解，该注解在语义上定义为通过其唯一名称标识特定目标组件，其中声明的类型与匹配进程无关。<code>@Autowired</code>具有多种不同的语义，在by type选择候选bean之后，指定的<code>String</code>限定的值只会考虑这些被选择的候选者。 例如将<code>account</code> 限定符与标有相同限定符标签的bean相匹配。</p><p>对于自身定义为 collection, <code>Map</code>, 或者 array type的bean， <code>@Resource</code>是一个很好的解决方案，通过唯一名称引用特定的集合或数组bean。 也就是说，从Spring4.3开始，只要元素类型信息保存在 <code>@Bean</code> 返回类型签名或集合（或其子类）中，您就可以通过Spring的 <code>@Autowired</code>类型匹配算法匹配Map和数组类型。 在这种情况下，可以使用限定的值来选择相同类型的集合，如上一段所述。</p><p>从Spring4.3开始，<code>@Autowired</code>也考虑了注入的自引用，即引用当前注入的bean。自引用只是一种后备选项，还是优先使用正常的依赖注入操作其它bean。 在这个意义上，自引用不参与到正常的候选者选择中，并且总是次要的，，相反，它们总是拥有最低的优先级。在实践中，自引用通常被用作最后的手段。例如，通过bean的事务代理在同一实例上调用其他方法 在这种情况下，考虑将受影响的方法分解为单独委托的bean，或者使用 <code>@Resource</code>,，它可以通过其唯一名称获取代理返回到当前的bean上。</p><p><code>@Autowired</code>可以应用在字段、构造函数和多参数方法上，允许在参数上使用qualifier限定符注解缩小取值范围。相比之下，<code>@Resource</code>仅支持具有单个参数的字段和bean属性setter方法。 因此，如果注入目标是构造函数或多参数方法，请使用qualifiers限定符。</p><p>开发者也可以创建自定义的限定符注解，只需定义一个注解，在其上提供了@Qualifier注解即可。如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Qualifierpublic</span> <span class="hljs-variable">@interface</span> Genre &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">value</span>();&#125;<br></code></pre></td></tr></table></figure><p>然后，您可以在自动装配的字段和参数上提供自定义限定符，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieRecommender</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Genre(<span class="hljs-string">&quot;Action&quot;</span>)</span>    <span class="hljs-keyword">private</span> MovieCatalog actionCatalog;<br>    <span class="hljs-keyword">private</span> MovieCatalog comedyCatalog;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> void setComedyCatalog(<span class="hljs-meta">@Genre(<span class="hljs-string">&quot;Comedy&quot;</span>)</span> MovieCatalog comedyCatalog) &#123;        <span class="hljs-keyword">this</span>.comedyCatalog = comedyCatalog;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>接下来，提供候选bean定义的信息。开发者可以添加<code>&lt;qualifier/&gt;</code>标签作为<code>&lt;bean/&gt;</code>标签的子元素，然后指定 <code>type</code>类型和<code>value</code>值来匹配自定义的qualifier注解。 type是自定义注解的权限定类名(包路径+类名）。如果没有重名的注解，那么可以使用类名(不含包路径）。 以下示例演示了两种方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Action&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;example.Genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Comedy&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieRecommender&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.MovieRecommender&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-classpath-scanning">类路径扫描和组件管理</a>,将展示一个基于注解的替代方法，可以在XML中提供qualifier元数据, 请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-scanning-qualifiers">使用注解提供限定符元数据。</a></p><p>在某些情况下，使用没有值的注解可能就足够了。当注解用于更通用的目的并且可以应用在多种不同类型的依赖上时，这是很有用的。 例如，您可以提供可在没有Internet连接时搜索的Offline目录。 首先，定义简单注解，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Qualifierpublic</span> <span class="hljs-variable">@interface</span> Offline &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将注解添加到需要自动注入的字段或属性中:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MovieRecommender</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@Offline</span> (<span class="hljs-number">1</span>)    private MovieCatalog offlineCatalog;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、此行添加<code>@Offline</code>注解</p><p>现在bean定义只需要一个限定符类型，如下例所示：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Offline&quot;</span>/&gt;</span> (1)<br><br>    <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、此元素指定限定符。</p><p>开发者还可以为自定义限定名qualifier注解增加属性，用于替代简单的<code>value</code>属性。如果在要自动注入的字段或参数上指定了多个属性值，则bean的定义必须全部匹配这些属性值才能被视为自动注入候选者。 例如，请考虑以下注解定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Qualifierpublic</span> <span class="hljs-variable">@interface</span> MovieQualifier &#123;<br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">genre</span>();<br>    <span class="hljs-selector-tag">Format</span> <span class="hljs-selector-tag">format</span>();&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下， <code>Format</code>是一个枚举类型，定义如下:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">Format</span> &#123;<br><br>    VHS, DVD, BLURAY<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要自动装配的字段使用自定义限定符进行注解，并包含两个属性的值：<code>genre</code> 和 <code>format</code>，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MovieRecommender</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@MovieQualifier</span>(format=Format.VHS, genre=<span class="hljs-string">&quot;Action&quot;</span>)    private MovieCatalog actionVhsCatalog;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@MovieQualifier</span>(format=Format.VHS, genre=<span class="hljs-string">&quot;Comedy&quot;</span>)    private MovieCatalog comedyVhsCatalog;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@MovieQualifier</span>(format=Format.DVD, genre=<span class="hljs-string">&quot;Action&quot;</span>)    private MovieCatalog actionDvdCatalog;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-variable">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="hljs-string">&quot;Comedy&quot;</span>)    private MovieCatalog comedyBluRayCatalog;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>最后，bean定义应包含匹配的限定符值。此示例还演示了可以使用bean meta属性而不是使用<code>&lt;qualifier/&gt;</code>子元素。如果可行，<code>&lt;qualifier/&gt;</code>元素及其属性优先， 但如果不存在此类限定符，那么自动注入机制会使用 <code>&lt;meta/&gt;</code> 标签中提供的值，如以下示例中的最后两个bean定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;MovieQualifier&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attribute</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;format&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;VHS&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attribute</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Action&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">qualifier</span>&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;MovieQualifier&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attribute</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;format&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;VHS&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attribute</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Comedy&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">qualifier</span>&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;format&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DVD&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Action&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.SimpleMovieCatalog&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;format&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BLURAY&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;genre&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Comedy&quot;</span>/&gt;</span>        <span class="hljs-comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-9-5-使用泛型作为自动装配限定符"><a href="#1-9-5-使用泛型作为自动装配限定符" class="headerlink" title="1.9.5. 使用泛型作为自动装配限定符"></a>1.9.5. 使用泛型作为自动装配限定符</h4><p>除了<code>@Qualifier</code> 注解之外，您还可以使用Java泛型类型作为隐式的限定形式。 例如，假设您具有以下配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">StringStore</span> <span class="hljs-title function_">stringStore</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringStore</span>();    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IntegerStore</span> <span class="hljs-title function_">integerStore</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntegerStore</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>假设上面的bean都实现了泛型接口,即 <code>Store&lt;String&gt;</code>和<code>Store&lt;Integer&gt;</code>,那么可以用<code>@Autowire</code>来注解<code>Store</code> 接口, 并将泛型用作限定符，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Autowiredprivate</span> Store&lt;String&gt; s1; <span class="hljs-comment">// &lt;String&gt; qualifier, injects the stringStore bean</span><br><span class="hljs-variable">@Autowiredprivate</span> Store&lt;Integer&gt; s2; <span class="hljs-comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span><br></code></pre></td></tr></table></figure><p>通用限定符也适用于自动装配列表，<code>Map</code>实例和数组。 以下示例自动装配通用<code>List</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span><br><br><span class="hljs-comment">// Store&lt;String&gt; beans will not appear in this list</span><br><br><span class="hljs-meta">@Autowired</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">Store</span>&lt;<span class="hljs-type">Integer</span>&gt;&gt; s;<br></code></pre></td></tr></table></figure><h4 id="1-9-6-CustomAutowireConfigurer"><a href="#1-9-6-CustomAutowireConfigurer" class="headerlink" title="1.9.6. CustomAutowireConfigurer"></a>1.9.6. <code>CustomAutowireConfigurer</code></h4><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a> 是一个<code>BeanFactoryPostProcessor</code>，它允许开发者注册自定义的qualifier注解类型，而无需指定<code>@Qualifier</code>注解，以下示例显示如何使用<code>CustomAutowireConfigurer</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;customAutowireConfigurer&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customQualifierTypes&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>example.CustomQualifier<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>AutowireCandidateResolver</code> 通过以下方式确定自动注入的候选者:</p><ul><li>每个bean定义的<code>autowire-candidate</code>值</li><li>在<code>&lt;beans/&gt;</code>元素上使用任何可用的 <code>default-autowire-candidates</code> 模式</li><li>存在 <code>@Qualifier</code> 注解以及使用<code>CustomAutowireConfigurer</code>注册的任何自定义注解</li></ul><p>当多个bean有资格作为自动注入的候选项时，“primary”的确定如下：如果候选者中只有一个bean定义的 <code>primary</code>属性设置为<code>true</code>，则选择它。</p><h4 id="1-9-7-Resource"><a href="#1-9-7-Resource" class="headerlink" title="1.9.7. @Resource"></a>1.9.7. <code>@Resource</code></h4><p>Spring还通过在字段或bean属性setter方法上使用JSR-250 <code>@Resource</code>注解来支持注入。 这是Java EE 5和6中的常见模式（例如，在JSF 1.2托管bean或JAX-WS 2.0端点中）。 Spring也为Spring管理对象提供这种模式。</p><p><code>@Resource</code> 接受一个name属性.。默认情况下，Spring将该值解释为要注入的bean名称。 换句话说，它遵循按名称语义，如以下示例所示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> MovieFinder movieFinder;<br>    <span class="hljs-meta">@Resource(name=<span class="hljs-string">&quot;myMovieFinder&quot;</span>)</span> (<span class="hljs-number">1</span>)    <span class="hljs-keyword">public</span> void setMovieFinder(MovieFinder movieFinder) &#123;        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、这行注入一个<code>@Resource</code>.</p><p>如果未明确指定名称，则默认名称是从字段名称或setter方法派生的。 如果是字段，则采用字段名称。 在setter方法的情况下，它采用bean属性名称。 下面的例子将把名为<code>movieFinder</code>的bean注入其setter方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><code>ApplicationContext</code>若使用了<code>CommonAnnotationBeanPostProcessor</code>，注解提供的name名字将被解析为bean的name名字。 如果配置了Spring的 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>，这些name名称就可以通过JNDI解析。但是，推荐使用默认的配置，简单地使用Spring的JNDI，这样可以保持逻辑引用。而不是直接引用。</p><p>@Resource在没有明确指定name时，其行为类似于<code>@Autowired</code>，对于特定bean(Spring API内的bean）， <code>@Resource</code> 找到主要类型匹配而不是特定的命名bean， 并解析众所周知的可解析依赖项：<code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, 和 <code>MessageSource</code>接口。</p><p>因此，在以下示例中，<code>customerPreferenceDao</code>字段首先查找名为customerPreferenceDao的bean，如果未找到，则会使用类型匹配<code>CustomerPreferenceDao</code>类的实例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieRecommender</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> CustomerPreferenceDao customerPreferenceDao;<br>    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ApplicationContext context; (<span class="hljs-number">1</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieRecommender</span><span class="hljs-params">()</span> </span>&#123;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、<code>context</code>域将会注入<code>ApplicationContext</code></p><h4 id="1-9-8-PostConstruct-和-PreDestroy"><a href="#1-9-8-PostConstruct-和-PreDestroy" class="headerlink" title="1.9.8. @PostConstruct 和 @PreDestroy"></a>1.9.8. <code>@PostConstruct</code> 和 <code>@PreDestroy</code></h4><p><code>CommonAnnotationBeanPostProcessor</code> 不仅仅识别<code>@Resource</code> 注解，还识别JSR-250生命周期注解。，在Spring 2.5中引入了这些注解， 它们提供了另一个替代<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean">初始化回调</a>和<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-disposablebean">销毁回调</a>。 如果<code>CommonAnnotationBeanPostProcessor</code>在Spring <code>ApplicationContext</code>中注册，它会在相应的Spring bean生命周期中调用相应的方法，就像是Spring生命周期接口方法，或者是明确声明的回调函数那样。 在以下示例中，缓存在初始化时预先填充并在销毁时清除：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingMovieLister</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">populateMovieCache</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// populates the movie cache upon initialization...    &#125;</span><br>    <span class="hljs-meta">@PreDestroy</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">clearMovieCache</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// clears the movie cache upon destruction...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>有关组合各种生命周期机制的影响的详细信息，请参阅组合<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-combined-effects">生命周期机制</a>。</p><h3 id="1-10-类路径扫描和管理组件"><a href="#1-10-类路径扫描和管理组件" class="headerlink" title="1.10. 类路径扫描和管理组件"></a>1.10. 类路径扫描和管理组件</h3><p>本章中的大多数示例会使用XML配置指定在Spring容器中生成每个<code>BeanDefinition</code>的元数据，上一节（<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-annotation-config">基于注解的容器配置</a>）演示了如何通过源代码注解提供大量的元数据配置。 然而，即使在这些示例中，注解也仅仅用于驱动依赖注入。 “base” bean依然会显式地在XML文件中定义。本节介绍通过扫描类路径隐式检测候选组件的选项。候选者组件是class类， 这些类经过过滤匹配，由Spring容器注册的bean定义会成为Spring bean。这消除了使用XML执行bean注册的需要(也就是没有XML什么事儿了),可以使用注解(例如<code>@Component</code>)， AspectJ类型表达式或开发者自定义过滤条件来选择哪些类将在容器中注册bean定义。</p><p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring 框架的一部分。这允许开发者使用Java而不是使用传统的XML文件来定义bean。 有关如何使用这些新功能的示例，请查看<code>@Configuration</code>, <code>@Bean</code>,<code>@Import</code>, 和 <code>@DependsOn</code>注解。</p><h4 id="1-10-1-Component注解和更多模板注解"><a href="#1-10-1-Component注解和更多模板注解" class="headerlink" title="1.10.1. @Component注解和更多模板注解"></a>1.10.1. <code>@Component</code>注解和更多模板注解</h4><p><code>@Repository</code>注解用于满足存储库(也称为数据访问对象或DAO)的情况,这个注解的用途是自动转换异常。如<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/dataaccess/data-access.md#orm-exception-translation">异常转换</a>中所述。</p><p>Spring提供了更多的构造型注解：<code>@Component</code>, <code>@Service</code>, 和<code>@Controller</code>. <code>@Component</code> 可用于管理任何Spring的组件。 <code>@Repository</code>, <code>@Service</code>, 或 <code>@Controller</code>是<code>@Component</code>的特殊化。用于更具体的用例（分别在持久性，服务和表示层中）。 因此，您可以使用<code>@Component</code>注解组件类，但是，通过使用<code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>注解它们，能够让你的类更易于被合适的工具处理或与相应的切面关联。 例如，这些注解可以使目标组件变成切入点。在Spring框架的未来版本中，<code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>也可能带有附加的语义。 因此，如果在使用<code>@Component</code> 或 <code>@Service</code> 来选择服务层时，@Service显然是更好的选择。同理，在持久化层要选择<code>@Repository</code>，它能自动转换异常。</p><h4 id="1-10-2-使用元注解和组合注解"><a href="#1-10-2-使用元注解和组合注解" class="headerlink" title="1.10.2. 使用元注解和组合注解"></a>1.10.2. 使用元注解和组合注解</h4><p>Spring提供的许多注解都可以在您自己的代码中用作元注解。 元注解是可以应用于另一个注解的注解。 例如，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-stereotype-annotations">前面提到的</a> <code>@Service</code>注解是使用<code>@Component</code>进行元注解的，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Documented</span><span class="hljs-variable">@Component</span> (<span class="hljs-number">1</span>)public <span class="hljs-variable">@interface</span> Service &#123;<br>    <span class="hljs-comment">// ....&#125;</span><br></code></pre></td></tr></table></figure><p><strong>1</strong>、<code>Component</code>使<code>@Service</code>以与@<code>@Component</code>相同的方式处理。</p><p>元注解也可以进行组合，进而创建组合注解。例如，来自Spring MVC的<code>@RestController</code>注解是由<code>@Controller</code>和<code>@ResponseBody</code>组成的</p><p>此外，组合注解也可以重新定义来自元注解的属性。这在只想公开元注解的部分属性时非常有用。例如，Spring的<code>@SessionScope</code>注解将它的作用域硬编码为<code>session</code>，但仍允许自定义<code>proxyMode</code>。 以下清单显示了<code>SessionScope</code>注解的定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Documented</span><span class="hljs-variable">@Scope</span>(WebApplicationContext.SCOPE_SESSION)public <span class="hljs-variable">@interface</span> SessionScope &#123;<br>    <span class="hljs-comment">/**     * Alias for &#123;@link Scope#proxyMode&#125;.     * &lt;p&gt;Defaults to &#123;@link ScopedProxyMode#TARGET_CLASS&#125;.     */</span>    <span class="hljs-variable">@AliasFor</span>(annotation = Scope.class)    ScopedProxyMode <span class="hljs-built_in">proxyMode</span>() default ScopedProxyMode.TARGET_CLASS;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，您可以使用<code>@SessionScope</code>而不声明<code>proxyMode</code>，如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br><br><span class="hljs-variable">@SessionScope</span><br><br>public class SessionScopedService &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>您还可以覆盖<code>proxyMode</code>的值，如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br><br><span class="hljs-variable">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)<br><br>public class SessionScopedUserService implements UserService &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring注解编程模型</a>wiki页面.</p><h4 id="1-10-3-自动探测类并注册bean定义"><a href="#1-10-3-自动探测类并注册bean定义" class="headerlink" title="1.10.3. 自动探测类并注册bean定义"></a>1.10.3. 自动探测类并注册bean定义</h4><p>Spring可以自动检测各代码层中被注解的类，并使用<code>ApplicationContext</code>内注册相应的<code>BeanDefinition</code>。例如，以下两个类就可以被自动探测：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Servicepublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> MovieFinder movieFinder;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> SimpleMovieLister(MovieFinder movieFinder) &#123;        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;    &#125;&#125;<br><span class="hljs-meta">@Repositorypublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaMovieFinder</span> <span class="hljs-title">implements</span> <span class="hljs-title">MovieFinder</span> &#123;    <span class="hljs-comment">// implementation elided for clarity&#125;</span><br></code></pre></td></tr></table></figure><p>想要自动检测这些类并注册相应的bean，需要在<code>@Configuration</code>配置中添加<code>@ComponentScan</code>注解，其中<code>basePackages</code>属性是两个类的父包路径。 （或者，您可以指定以逗号或分号或空格分隔的列表，其中包含每个类的父包）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>)<br><br>public class AppConfig  &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>为简洁起见，前面的示例可能使用了注解的<code>value</code>属性（即<code>@ComponentScan(&quot;org.example&quot;)</code>）。</p><p>或者使用XML配置代替扫描:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用<code>&lt;context:component-scan&gt;</code>隐式启用<code>&lt;context:annotation-config&gt;</code>的功能。 使用<code>&lt;context:component-scan&gt;</code>时，通常不需要包含<code>&lt;context:annotation-config&gt;</code>元素。</p><p>类路径扫描的包必须保证这些包出现在类路径中。当使用Ant构建JAR时，请确保你没有激活JAR任务的纯文件开关。此外在某些环境装由于安全策略，类路径目录可能不能访问。 JDK 1.7.0_45及更高版本上的独立应用程序（需要在清单中设置“Trusted-Library”） - 请参阅 <a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>）。</p><p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常按预期工作。，但是，请确保在模块信息描述符中导出组件类。 如果您希望Spring调用类的非公共成员，请确保它们已“打开”（即，它们在<code>module-info</code>描述符中使用<code>opens</code> 声明而不是<code>exports</code>声明）。</p><p>在使用component-scan元素时， <code>AutowiredAnnotationBeanPostProcessor</code> 和 <code>CommonAnnotationBeanPostProcessor</code>都会隐式包含。意味着这两个组件也是自动探测和注入的。 所有这些都无需XML配置。</p><p>您可以通过annotation-config&#x3D;false属性来禁用<code>AutowiredAnnotationBeanPostProcessor</code> 和<code>CommonAnnotationBeanPostProcessor</code>的注册。</p><h4 id="1-10-4-在自定义扫描中使用过滤器"><a href="#1-10-4-在自定义扫描中使用过滤器" class="headerlink" title="1.10.4. 在自定义扫描中使用过滤器"></a>1.10.4. 在自定义扫描中使用过滤器</h4><p>默认情况下，使用<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>,<code>@Controller</code>注解的类或者注解为<code>@Component</code>的自定义注解类才能被检测为候选组件。 但是，开发者可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code>注解的<code>includeFilters</code>或<code>excludeFilters</code>参数(或作为<code>component-scan</code> 元素。元素的<code>include-filter</code>或<code>exclude-filter</code>子元素。每个filter元素都需要包含<code>type</code>和<code>expression</code>属性。下表介绍了筛选选项：</p><p>Table 5.过滤类型</p><table><thead><tr><th>过滤类型</th><th>表达式例子</th><th>描述</th></tr></thead><tbody><tr><td>annotation (default)</td><td><code>org.example.SomeAnnotation</code></td><td>要在目标组件中的类级别出现的注解。</td></tr><tr><td>assignable</td><td><code>org.example.SomeClass</code></td><td>目标组件可分配给（继承或实现）的类（或接口）。</td></tr><tr><td>aspectj</td><td><code>org.example..*Service+</code></td><td>要由目标组件匹配的AspectJ类型表达式。</td></tr><tr><td>regex</td><td><code>org\.example\.Default.*</code></td><td>要由目标组件类名匹配的正则表达式。</td></tr><tr><td>custom</td><td><code>org.example.MyTypeFilter</code></td><td><code>org.springframework.core.type .TypeFilter</code>接口的自定义实现。</td></tr></tbody></table><p>以下示例显示忽略所有<code>@Repository</code> 注解并使用“stub”存储库的配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>,<br><br>        includeFilters = <span class="hljs-variable">@Filter</span>(type = FilterType.REGEX, pattern = <span class="hljs-string">&quot;.*Stub.*Repository&quot;</span>),<br><br>        excludeFilters = <span class="hljs-variable">@Filter</span>(Repository.class))<br><br>public class AppConfig &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以下清单显示了等效的XML：:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">&lt;beans&gt;<br><br>    &lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">&quot;org.example&quot;</span>&gt;<br><br>        &lt;<span class="hljs-keyword">context</span>:include-filter <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;regex&quot;</span><br><br>                expression=<span class="hljs-string">&quot;.*Stub.*Repository&quot;</span>/&gt;<br><br>        &lt;<span class="hljs-keyword">context</span>:exclude-filter <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;annotation&quot;</span><br><br>                expression=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;<br><br>    &lt;/<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>你还可以通过在注解上设置<code>useDefaultFilters=false</code>或通过<code>use-default-filters=&quot;false&quot;</code>作为&lt;<code>&lt;component-scan/&gt;</code> 元素的属性来禁用默认过滤器。这样将不会自动检测带有<code>@Component</code>, <code>@Repository</code>,<code>@Service</code>, <code>@Controller</code>, 或 <code>@Configuration</code>.</p><h4 id="1-10-5-在组件中定义bean的元数据"><a href="#1-10-5-在组件中定义bean的元数据" class="headerlink" title="1.10.5.在组件中定义bean的元数据"></a>1.10.5.在组件中定义bean的元数据</h4><p>Spring组件也可以向容器提供bean定义元数据，。在<code>@Configuration</code>注解的类中使用<code>@Bean</code>注解定义bean元数据(也就是Spring bean),以下示例显示了如何执行此操作：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Componentpublic</span> class FactoryMethodComponent &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@Qualifier</span>(<span class="hljs-string">&quot;public&quot;</span>)    public TestBean <span class="hljs-built_in">publicInstance</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">TestBean</span>(<span class="hljs-string">&quot;publicInstance&quot;</span>);    &#125;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">doWork</span>() &#123;        <span class="hljs-comment">// Component method implementation omitted    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这个类是一个Spring组件，它有个 <code>doWork()</code>方法。然而，它还有一个工厂方法 <code>publicInstance()</code>用于产生bean定义。<code>@Bean</code>注解了工厂方法， 还设置了其他bean定义的属性，例如通过<code>@Qualifier</code>注解的qualifier值。可以指定的其他方法级别的注解是 <code>@Scope</code>, <code>@Lazy</code>以及自定义的qualifier注解。</p><p>除了用于组件初始化的角色之外，<code>@Lazy</code>注解也可以在<code>@Autowired</code>或者code&gt;@Inject注解上，在这种情况下，该注入将会变成延迟注入代理lazy-resolution proxy（也就是懒加载）。</p><p>自动注入的字段和方法也可以像前面讨论的一样被支持，也支持<code>@Bean</code>方法的自动注入。以下示例显示了如何执行此操作：:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodComponent</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> int i;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">&quot;public&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TestBean</span> <span class="hljs-title function_">publicInstance</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBean</span>(<span class="hljs-string">&quot;publicInstance&quot;</span>);    &#125;<br>    <span class="hljs-comment">// use of a custom qualifier and autowiring of method parameters    @Bean    protected TestBean protectedInstance(            @Qualifier(&quot;public&quot;) TestBean spouse,            @Value(&quot;#&#123;privateInstance.age&#125;&quot;) String country) &#123;        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);        tb.setSpouse(spouse);        tb.setCountry(country);        return tb;    &#125;</span><br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">TestBean</span> <span class="hljs-title function_">privateInstance</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBean</span>(<span class="hljs-string">&quot;privateInstance&quot;</span>, i++);    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@RequestScope</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TestBean</span> <span class="hljs-title function_">requestScopedInstance</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBean</span>(<span class="hljs-string">&quot;requestScopedInstance&quot;</span>, <span class="hljs-number">3</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>该示例将方法参数为<code>String</code>，名称为<code>country</code>的bean自动装配为另一个名为<code>privateInstance</code>的bean的<code>age</code>属性值。 Spring表达式语言元素通过记号<code>#&#123; &lt;expression&gt; &#125;</code>来定义属性的值。对于 <code>@Value</code>注解，表达式解析器在解析表达式后，会查找bean的名字并设置value值。</p><p>从Spring4.3开始，您还可以声明一个类型为<code>InjectionPoint</code>的工厂方法参数（或其更具体的子类：<code>DependencyDescriptor</code>）以访问触发创建当前bean的请求注入点。 请注意，这仅适用于真实创建的bean实例，而不适用于注入现有实例。因此，这个特性对prototype scope的bean最有意义。对于其他作用域，工厂方法将只能看到触发在给定scope中创建新bean实例的注入点。 例如，触发创建一个延迟单例bean的依赖。在这种情况下，使用提供的注入点元数据拥有优雅的语义。 以下示例显示了如何使用<code>InjectionPoint</code>:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Componentpublic</span> class FactoryMethodComponent &#123;<br>    <span class="hljs-variable">@Bean</span> <span class="hljs-variable">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)    public TestBean <span class="hljs-built_in">prototypeInstance</span>(InjectionPoint injectionPoint) &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">TestBean</span>(<span class="hljs-string">&quot;prototypeInstance for &quot;</span> + injectionPoint.<span class="hljs-built_in">getMember</span>());    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在Spring组件中处理<code>@Bean</code>和在code&gt;@Configuration中处理是不一样的，区别在于，在<code>@Component</code>中，不会使用CGLIB增强去拦截方法和属性的调用。在<code>@Configuration</code>注解的类中， <code>@Bean</code>注解创建的bean对象会使用CGLIB代理对方法和属性进行调用。方法的调用不是常规的Java语法，而是通过容器来提供通用的生命周期管理和代理Spring bean， 甚至在通过编程的方式调用<code>@Bean</code>方法时也会产生对其它bean的引用。相比之下，在一个简单的<code>@Component</code>类中调用<code>@Bean</code>方法中的方法或字段具有标准Java语义，这里没有用到特殊的CGLIB处理或其他约束。</p><p>开发者可以将<code>@Bean</code>方法声明为<code>static</code>的，并允许在不将其包含的配置类作为实例的情况下调用它们。这在定义后置处理器bean时是特别有意义的。 例如<code>BeanFactoryPostProcessor</code> 或<code>BeanPostProcessor</code>),，因为这类bean会在容器的生命周期前期被初始化，而不会触发其它部分的配置。</p><p>对静态<code>@Bean</code>方法的调用永远不会被容器拦截，即使在<code>@Configuration</code>类内部。这是用为CGLIB的子类代理限制了只会重写非静态方法。因此， 对另一个<code>@Bean</code>方法的直接调用只能使用标准的Java语法。也只能从工厂方法本身直接返回一个独立的实例。</p><p>由于Java语言的可见性，<code>@Bean</code>方法并不一定会对容器中的bean有效。开发者可能很随意的在非<code>@Configuration</code>类中定义或定义为静态方法。然而， 在<code>@Configuration</code>类中的正常<code>@Bean</code>方法都会被重写，因此，它们不应该定义为<code>private</code>或<code>final</code>。</p><p><code>@Bean</code>方法也可以用在父类中，同样适用于Java 8接口中的默认方法。这使得组建复杂的配置时能具有更好的灵活性，甚至可能通过Java 8的默认方法实现多重继承。 这种特性在Spring 4.2开始支持。</p><p>最后，请注意，单个类可以为同一个bean保存多个<code>@Bean</code>方法，例如根据运行时可用的依赖关系选择合适的工厂方法。使用算法会选择 “最贪婪“的构造方法， 一些场景可能会按如下方法选择相应的工厂方法：满足最多依赖的会被选择，这与使用<code>@Autowired</code> 时选择多个构造方法时类似。</p><h4 id="1-10-6-命名自动注册组件"><a href="#1-10-6-命名自动注册组件" class="headerlink" title="1.10.6. 命名自动注册组件"></a>1.10.6. 命名自动注册组件</h4><p>扫描处理过程，其中一步就是自动探测组件，扫描器使用<code>BeanNameGenerator</code>对探测到的组件命名。默认情况下，各代码层注解(<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, 和 <code>@Controller</code>)所包含的name值，将会作为相应的bean定义的名字。</p><p>如果这些注解没有name值，或者是其他一些被探测到的组件（比如使用自定义过滤器探测到的)，默认会又bean name生成器生成，使用小写类名作为bean名字。 例如，如果检测到以下组件类，则名称为<code>myMovieLister</code>和<code>movieFinderImpl</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Service(<span class="hljs-string">&quot;myMovieLister&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;    <span class="hljs-comment">// ...&#125;</span><br><span class="hljs-meta">@Repositorypublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieFinderImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">MovieFinder</span> &#123;    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>如果您不想依赖默认的bean命名策略，则可以提供自定义bean命名策略。首先，实现 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>接口，并确保包括一个默认的无参构造函数。 然后，在配置扫描程序时提供完全限定的类名，如以下示例注解和bean定义所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>, nameGenerator = MyNameGenerator.class)public class AppConfig &#123;    ...&#125;<br>&lt;beans&gt;    &lt;<span class="hljs-attribute">context</span>:component-scan base-package=<span class="hljs-string">&quot;org.example&quot;</span>        name-generator=<span class="hljs-string">&quot;org.example.MyNameGenerator&quot;</span> /&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>作为一般规则，考虑在其他组件可能对其进行显式引用时使用注解指定名称。 另一方面，只要容器负责装配时，自动生成的名称就足够了。</p><h4 id="1-10-7-为自动检测组件提供范围"><a href="#1-10-7-为自动检测组件提供范围" class="headerlink" title="1.10.7.为自动检测组件提供范围"></a>1.10.7.为自动检测组件提供范围</h4><p>与一般的Spring管理组件一样，自动检测组件的默认和最常见的作用域是<code>singleton</code>。但是，有时您需要一个可由<code>@Scope</code>注解指定的不同作用域。 您可以在注解中提供作用域的名称，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)<br><br><span class="hljs-variable">@Repository</span><br><br>public class MovieFinderImpl implements MovieFinder &#123;<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Scope</code>注解仅在具体bean类（用于带注解的组件）或工厂方法（用于<code>@Bean</code>方法）上进行关联。 与XML bean定义相比，没有bean继承的概念，并且 类级别的继承结构与元数据无关。</p><p>有关特定于Web的范围（如Spring上下文中的“request” or “session”）的详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other">请求，会话，应用程序和WebSocket作用域</a>。 这些作用域与构建注解一样，您也可以使用Spring的元注解方法编写自己的作用域注解：例如，使用<code>@Scope(&quot;prototype&quot;)</code>进行元注解的自定义注解，可能还会声明自定义作用域代理模式。</p><p>想要提供自定义作用域的解析策略，而不是依赖于基于注解的方法，那么需要实现<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>接口，并确保包含一个默认的无参数构造函数。 然后，在配置扫描程序时提供完全限定类名。以下注解和bean定义示例显示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>, scopeResolver = MyScopeResolver.class)public class AppConfig &#123;    ...&#125;<br>&lt;beans&gt;    &lt;<span class="hljs-attribute">context</span>:component-scan base-package=<span class="hljs-string">&quot;org.example&quot;</span> scope-resolver=<span class="hljs-string">&quot;org.example.MyScopeResolver&quot;</span>/&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>当使用某个非单例作用域时，为作用域对象生成代理可能非常必要，原因参看 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other-injection">作为依赖关系的作用域bean</a>。 为此，组件扫描元素上提供了scoped-proxy属性。 三个可能的值是：<code>no</code>, <code>interfaces</code>, 和 <code>targetClass</code>。 例如，以下配置导致标准JDK动态代理：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>, scopedProxy = ScopedProxyMode.INTERFACES)public class AppConfig &#123;    ...&#125;<br>&lt;beans&gt;    &lt;<span class="hljs-attribute">context</span>:component-scan base-package=<span class="hljs-string">&quot;org.example&quot;</span> scoped-proxy=<span class="hljs-string">&quot;interfaces&quot;</span>/&gt;&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="1-10-8-为注解提供Qualifier元数据"><a href="#1-10-8-为注解提供Qualifier元数据" class="headerlink" title="1.10.8. 为注解提供Qualifier元数据"></a>1.10.8. 为注解提供Qualifier元数据</h4><p>在前面<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-autowired-annotation-qualifiers">使用qualifiers微调基于注解自动装配</a>讨论过<code>@Qualifier</code> 注解。该部分中的示例演示了在解析自动注入候选者时使用 <code>@Qualifier</code>注解和自定义限定符注解以提供细粒度控制。 因为这些示例基于XML bean定义，所以使用XML中的<code>bean</code>元素的 <code>qualifier</code> 或 <code>meta</code>子元素在候选bean定义上提供了限定符元数据。当依靠类路径扫描并自动检测组件时， 可以在候选类上提供具有类型级别注解的限定符元数据。以下三个示例演示了此技术：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><span class="hljs-variable">@Qualifier</span>(<span class="hljs-string">&quot;Action&quot;</span>)public class ActionMovieCatalog implements MovieCatalog &#123;    <span class="hljs-comment">// ...&#125;</span><br><span class="hljs-variable">@Component</span><span class="hljs-variable">@Genre</span>(<span class="hljs-string">&quot;Action&quot;</span>)public class ActionMovieCatalog implements MovieCatalog &#123;    <span class="hljs-comment">// ...&#125;</span><br><span class="hljs-variable">@Component</span><span class="hljs-variable">@Offlinepublic</span> class CachingMovieCatalog implements MovieCatalog &#123;    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>与大多数基于注解的替代方法一样，注解元数据绑定到类定义本身，而使用在XML配置时，允许同一类型的beans在qualifier元数据中提供变量， 因为元数据是依据实例而不是类来提供的。</p><h4 id="1-10-9-生成候选组件的索引"><a href="#1-10-9-生成候选组件的索引" class="headerlink" title="1.10.9. 生成候选组件的索引"></a>1.10.9. 生成候选组件的索引</h4><p>虽然类路径扫描非常快，但通过在编译时创建候选的静态列表。可以提高大型应用程序的启动性能。在此模式下，应用程序的所有模块都必须使用此机制， 当 <code>ApplicationContext</code>检测到此类索引时，它将自动使用它，而不是扫描类路径。</p><p>若要生成索引， 只需向包含组件扫描指令目标组件的每个模块添加一个附加依赖项。以下示例显示了如何使用Maven执行此操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-indexer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.3.BUILD-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下示例显示了如何使用Gradle执行此操作:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">dependencies</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-title">compileOnly</span>(<span class="hljs-string">&quot;org.springframework:spring-context-indexer:5.1.3.BUILD-SNAPSHOT&quot;</span>)</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程将产生一个名为<code>META-INF/spring.components</code>的文件，并将包含在jar包中。</p><p>在IDE中使用此模式时，必须将<code>spring-context-indexer</code>注册为注解处理器， 以确保更新候选组件时索引是最新的。</p><p>如果在类路径中找到 <code>META-INF/spring.components</code> 时，将自动启用索引。如果某个索引对于某些库(或用例)是不可用的， 但不能为整个应用程序构建，则可以将<code>spring.index.ignore</code>设置为<code>true</code>，从而将其回退到常规类路径的排列(即根本不存在索引)， 或者作为系统属性或在<code>spring.properties</code>文件位于类路径的根目录中。</p><h3 id="1-11-使用JSR-330标准注解"><a href="#1-11-使用JSR-330标准注解" class="headerlink" title="1.11. 使用JSR 330标准注解"></a>1.11. 使用JSR 330标准注解</h3><p>从Spring 3.0开始，Spring提供对JSR-330标准注解（依赖注入）的支持。 这些注解的扫描方式与Spring注解相同。 要使用它们，您需要在类路径中包含相关的jar。</p><p>如果使用Maven工具，那么<code>@javax.inject.Inject</code>可以在Maven中央仓库中找到( <a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/">http://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a>). 您可以将以下依赖项添加到文件pom.xml：:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-11-1-使用-Inject-和-Named注解实现依赖注入"><a href="#1-11-1-使用-Inject-和-Named注解实现依赖注入" class="headerlink" title="1.11.1. 使用@Inject 和 @Named注解实现依赖注入"></a>1.11.1. 使用<code>@Inject</code> 和 <code>@Named</code>注解实现依赖注入</h4><p><code>@javax.inject.Inject</code>可以使用以下的方式来替代<code>@Autowired</code>注解:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">inject</span>.<span class="hljs-property">Inject</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Inject</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listMovies</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span>.<span class="hljs-title function_">findMovies</span>(...);        ...    &#125;&#125;<br></code></pre></td></tr></table></figure><p>与 <code>@Autowired</code>一样，您可以在字段，方法和构造函数参数级别使用<code>@Inject</code>注解。此外，还可以将注入点声明为<code>Provider</code>。 它允许按需访问作用域较小的bean或通过<code>Provider.get()</code>调用对其他bean进行延迟访问。以下示例提供了前面示例的变体：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">inject</span>.<span class="hljs-property">Inject</span>;<span class="hljs-keyword">import</span> javax.<span class="hljs-property">inject</span>.<span class="hljs-property">Provider</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Provider</span>&lt;<span class="hljs-title class_">MovieFinder</span>&gt; movieFinder;<br>    <span class="hljs-meta">@Inject</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params">Provider&lt;MovieFinder&gt; movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listMovies</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span>.<span class="hljs-title function_">get</span>().<span class="hljs-title function_">findMovies</span>(...);        ...    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果想要为注入的依赖项使用限定名称，则应该使用<code>@Named</code>注解。如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">inject</span>.<span class="hljs-property">Inject</span>;<span class="hljs-keyword">import</span> javax.<span class="hljs-property">inject</span>.<span class="hljs-property">Named</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMovieLister</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MovieFinder</span> movieFinder;<br>    <span class="hljs-meta">@Inject</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setMovieFinder</span>(<span class="hljs-params"><span class="hljs-meta">@Named</span>(<span class="hljs-string">&quot;main&quot;</span>) MovieFinder movieFinder</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">movieFinder</span> = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>与<code>@Autowired</code>一样，<code>@Inject</code> 也可以与<code>java.util.Optional</code>或<code>@Nullable</code>一起使用。 这在这里用更适用，因为<code>@Inject</code>没有<code>required</code>的属性。 以下一对示例显示了如何使用<code>@Inject</code>和<code>@Nullable</code>:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">SimpleMovieLister</span> &#123;<br>    <span class="hljs-variable">@Inject</span>    public void <span class="hljs-built_in">setMovieFinder</span>(Optional&lt;MovieFinder&gt; movieFinder) &#123;        ...    &#125;&#125;<br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">SimpleMovieLister</span> &#123;<br>    <span class="hljs-variable">@Inject</span>    public void <span class="hljs-built_in">setMovieFinder</span>(<span class="hljs-variable">@Nullable</span> MovieFinder movieFinder) &#123;        ...    &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-11-2-Named-和-ManagedBean注解-标准与-Component-注解相同"><a href="#1-11-2-Named-和-ManagedBean注解-标准与-Component-注解相同" class="headerlink" title="1.11.2. @Named 和 @ManagedBean注解: 标准与 @Component 注解相同"></a>1.11.2. <code>@Named</code> 和 <code>@ManagedBean</code>注解: 标准与 <code>@Component</code> 注解相同</h4><p><code>@javax.inject.Named</code> 或 <code>javax.annotation.ManagedBean</code>可以使用下面的方式来替代<code>@Component</code>注解：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">inject</span>.<span class="hljs-keyword">Inject</span>;<span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">inject</span>.Named;<br>@Named(<span class="hljs-string">&quot;movieListener&quot;</span>)  <span class="hljs-comment">// @ManagedBean(&quot;movieListener&quot;) could be used as wellpublic class SimpleMovieLister &#123;</span><br>    <span class="hljs-keyword">private</span> MovieFinder movieFinder;<br>    @<span class="hljs-keyword">Inject</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setMovieFinder(MovieFinder movieFinder) &#123;        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>在不指定组件名称的情况下使用<code>@Component</code>是很常见的。 <code>@Named</code>可以以类似的方式使用，如下例所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">inject</span>.<span class="hljs-keyword">Inject</span>;<span class="hljs-keyword">import</span> javax.<span class="hljs-keyword">inject</span>.Named;<br>@Namedpublic <span class="hljs-keyword">class</span> SimpleMovieLister &#123;<br>    <span class="hljs-keyword">private</span> MovieFinder movieFinder;<br>    @<span class="hljs-keyword">Inject</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setMovieFinder(MovieFinder movieFinder) &#123;        <span class="hljs-keyword">this</span>.movieFinder = movieFinder;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>当使用<code>@Named</code> 或 <code>@ManagedBean</code>时，可以与Spring注解完全相同的方式使用component-scanning组件扫描。 如以下示例所示:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;org.example&quot;</span>)<br><br>public class AppConfig  &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>与<code>@Component</code>相反，JSR-330 <code>@Named</code> 和 JSR-250 <code>ManagedBean</code>注解不可组合。 请使用Spring的原型模型（stereotype mode)来构建自定义组件注解。</p><h4 id="1-11-3-使用-JSR-330标准注解的限制"><a href="#1-11-3-使用-JSR-330标准注解的限制" class="headerlink" title="1.11.3. 使用 JSR-330标准注解的限制"></a>1.11.3. 使用 JSR-330标准注解的限制</h4><p>使用标准注解时，需要知道哪些重要功能是不可用的。如下表所示：</p><p>Table 6. Spring的组件模型元素 vs JSR-330 变量</p><table><thead><tr><th>Spring</th><th>javax.inject.*</th><th>javax.inject restrictions &#x2F; comments</th></tr></thead><tbody><tr><td>@Autowired</td><td>@Inject</td><td><code>@Inject</code> 没有’required’属性。 可以与Java 8的 <code>Optional</code>一起使用。</td></tr><tr><td>@Component</td><td>@Named &#x2F; @ManagedBean</td><td>JSR-330不提供可组合模型，只是一种识别命名组件的方法。</td></tr><tr><td>@Scope(“singleton”)</td><td>@Singleton</td><td>JSR-330的默认作用域就像Spring的<code>prototype</code>。 但是，为了使其与Spring的一般默认值保持一致，默认情况下，Spring容器中声明的JSR-330 bean是一个 <code>singleton</code>。 为了使用除 <code>singleton</code>之外的范围，您应该使用Spring的<code>@Scope</code>注解。 <code>javax.inject</code>还提供了<a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a>注解。 然而，这个仅用于创建自己的注解。</td></tr><tr><td>@Qualifier</td><td>@Qualifier &#x2F; @Named</td><td><code>javax.inject.Qualifier</code> 只是用于构建自定义限定符的元注解。 可以通过<code>javax.inject.Named</code>创建与Spring中<code>@Qualifier</code>一样的限定符。</td></tr><tr><td>@Value</td><td>-</td><td>无</td></tr><tr><td>@Required</td><td>-</td><td>无</td></tr><tr><td>@Lazy</td><td>-</td><td>无</td></tr><tr><td>ObjectFactory</td><td>Provider</td><td><code>javax.inject.Provider</code> avax.inject.Provider是Spring的<code>ObjectFactory</code>的直接替代品， 仅仅使用简短的<code>get()</code>方法即可。 它也可以与Spring的<code>@Autowired</code>结合使用，也可以与非注解的构造函数和setter方法结合使用。</td></tr></tbody></table><h3 id="1-12-基于Java的容器配置"><a href="#1-12-基于Java的容器配置" class="headerlink" title="1.12. 基于Java的容器配置"></a>1.12. 基于Java的容器配置</h3><p>本节介绍如何在Java代码中使用注解来配置Spring容器。 它包括以下主题：:</p><ul><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-basic-concepts">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-instantiating-container">使用<code>AnnotationConfigApplicationContext</code>实例化Spring容器</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-bean-annotation">使用<code>@Bean</code>注解</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-configuration-annotation">使用<code>@Configuration</code>注解</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-composing-configuration-classes">编写基于Java的配置</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-definition-profiles">定义Bean配置文件</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-property-source-abstraction"><code>PropertySource</code> 抽象</a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-using-propertysource">使用 <code>@PropertySource</code></a></li><li><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-placeholder-resolution-in-statements">声明中的占位符</a></li></ul><h4 id="1-12-1-基本概念-Bean-和-Configuration"><a href="#1-12-1-基本概念-Bean-和-Configuration" class="headerlink" title="1.12.1. 基本概念: @Bean 和 @Configuration"></a>1.12.1. 基本概念: <code>@Bean</code> 和 <code>@Configuration</code></h4><p>Spring新的基于Java配置的核心内容是<code>@Configuration</code>注解的类和<code>@Bean</code>注解的方法。</p><p><code>@Bean</code>注解用于表明方法的实例化，、配置和初始化都是由Spring IoC容器管理的新对象，对于那些熟悉Spring的<code>&lt;beans/&gt;</code>XML配置的人来说， <code>@Bean</code>注解扮演的角色与<code>&lt;bean /&gt;</code>元素相同。开发者可以在任意的Spring <code>@Component</code>中使用<code>@Bean</code>注解方法 ，但大多数情况下，<code>@Bean</code>是配合<code>@Configuration</code>使用的。</p><p>使用<code>@Configuration</code>注解类时，这个类的目的就是作为bean定义的地方。此外，<code>@Configuration</code>类允许通过调用同一个类中的其他<code>@Bean</code>方法来定义bean间依赖关系。 最简单的<code>@Configuration</code>类如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">MyService</span> <span class="hljs-title function_">myService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceImpl</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>前面的<code>AppConfig</code>类等效于以下Spring <code>&lt;beans/&gt;</code>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整的@Configuration模式对比“lite”模式的@Bean?</p><p>当<code>@Bean</code>方法在没有用 <code>@Configuration</code>注解的类中声明时，它们将会被称为“lite”的模式处理。例如，<code>@Component</code>中声明的bean方法或者一个普通的旧类中的bean方法将被视为 “lite”的。包含类的主要目的不同，而<code>@Bean</code>方法在这里是一种额外的好处。。例如，服务组件可以通过在每个适用的组件类上使用额外的 <code>@Bean</code>方法将管理视图公开给容器。 在这种情况下，<code>@Bean</code>方法是一种通用的工厂方法机制。</p><p>与完整的 <code>@Configuration</code>不同，lite的<code>@Bean</code>方法不能声明bean之间的依赖关系。 相反，它们对其包含组件的内部状态进行操作，并且可以有选择的对它们可能声明的参数进行操作。因此，这样的<code>@Bean</code>注解的方法不应该调用其他<code>@Bean</code>注解的方法。 每个这样的方法实际上只是特定bean引用的工厂方法，没有任何特殊的运行时语义。不经过CGLIB处理，所以在类设计方面没有限制（即，包含类可能是最终的）。</p><p>在常见的场景中，<code>@Bean</code>方法将在<code>@Configuration</code>类中声明，确保始终使用“full”模式，这将防止相同的<code>@Bean</code>方法被意外地多次调用，这有助于减少在 “lite”模式下操作时难以跟踪的细微错误。</p><p><code>@Bean</code>和<code>@Configuration</code>注解将在下面的章节深入讨论，首先，我们将介绍使用基于Java代码的配置来创建Spring容器的各种方法。</p><h4 id="1-12-2-使用AnnotationConfigApplicationContext初始化Spring容器"><a href="#1-12-2-使用AnnotationConfigApplicationContext初始化Spring容器" class="headerlink" title="1.12.2. 使用AnnotationConfigApplicationContext初始化Spring容器"></a>1.12.2. 使用<code>AnnotationConfigApplicationContext</code>初始化Spring容器</h4><p>以下部分介绍了Spring的<code>AnnotationConfigApplicationContext</code>，它是在Spring 3.0中引入的。这是一个强大的(versatile)<code>ApplicationContext</code> 实现,它不仅能解析<code>@Configuration</code>注解类 ,也能解析 <code>@Component</code>注解的类和使用JSR-330注解的类.</p><p>当使用<code>@Configuration</code>类作为输入时,<code>@Configuration</code>类本身被注册为一个bean定义,类中所有声明的<code>@Bean</code>方法也被注册为bean定义.</p><p>当提供 <code>@Component</code>和JSR-330类时，它们被注册为bean定义，并且假定在必要时在这些类中使用DI元数据，例如<code>@Autowired</code> 或 <code>@Inject</code>。</p><h5 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h5><p>与实例化<code>ClassPathXmlApplicationContext</code>时Spring XML文件用作输入的方式大致相同， 在实例化<code>AnnotationConfigApplicationContext</code>时可以使用<code>@Configuration</code> 类作为输入。 这允许完全无XML使用Spring容器，如以下示例所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(AppConfig.<span class="hljs-keyword">class</span>);<br><br>    MyService myService = ctx.<span class="hljs-built_in">getBean</span>(MyService.<span class="hljs-keyword">class</span>);<br><br>    myService.<span class="hljs-built_in">doStuff</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于使用<code>@Configuration</code>类。 任何<code>@Component</code>或JSR-330带注解的类都可以作为输入提供给构造函数，如以下示例所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(MyServiceImpl.<span class="hljs-keyword">class</span>, Dependency1.<span class="hljs-keyword">class</span>, Dependency2.<span class="hljs-keyword">class</span>);<br><br>    MyService myService = ctx.<span class="hljs-built_in">getBean</span>(MyService.<span class="hljs-keyword">class</span>);<br><br>    myService.<span class="hljs-built_in">doStuff</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面假设<code>MyServiceImpl</code>, <code>Dependency1</code>, 和 <code>Dependency2</code>使用Spring依赖注入注解，例如<code>@Autowired</code>。</p><h5 id="使用register-Class…-编程构建容器"><a href="#使用register-Class…-编程构建容器" class="headerlink" title="使用register(Class&lt;?&gt;…)编程构建容器"></a>使用<code>register(Class&lt;?&gt;…)</code>编程构建容器</h5><p><code>AnnotationConfigApplicationContext</code>可以通过无参构造函数实例化，然后调用<code>register()</code> 方法进行配置。 这种方法在以编程的方式构建 <code>AnnotationConfigApplicationContext</code>时特别有用。下列示例显示了如何执行此操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>();<br><br>    ctx.<span class="hljs-built_in">register</span>(AppConfig.<span class="hljs-keyword">class</span>, OtherConfig.<span class="hljs-keyword">class</span>);<br><br>    ctx.<span class="hljs-built_in">register</span>(AdditionalConfig.<span class="hljs-keyword">class</span>);<br><br>    ctx.<span class="hljs-built_in">refresh</span>();<br><br>    MyService myService = ctx.<span class="hljs-built_in">getBean</span>(MyService.<span class="hljs-keyword">class</span>);<br><br>    myService.<span class="hljs-built_in">doStuff</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-使用scan-String…-扫描组件"><a href="#3-使用scan-String…-扫描组件" class="headerlink" title="3 使用scan(String…)扫描组件"></a>3 使用<code>scan(String…)</code>扫描组件</h5><p>要启用组件扫描，可以按如下方式注解<code>@Configuration</code>类:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;com.acme&quot;</span>) (<span class="hljs-number">1</span>)<br><br>public class AppConfig  &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、此注解可启用组件扫描。</p><p>有经验的用户可能更熟悉使用XML的等价配置形式，如下例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.acme&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，<code>com.acme</code>包会被扫描，只要是使用了<code>@Component</code>注解的类，都会被注册进容器中。同样地，<code>AnnotationConfigApplicationContext</code>公开的<code>scan(String…)</code> 方法也允许扫描类完成同样的功能 如以下示例所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>();<br><br>    ctx.<span class="hljs-built_in">scan</span>(<span class="hljs-string">&quot;com.acme&quot;</span>);<br><br>    ctx.<span class="hljs-built_in">refresh</span>();<br><br>    MyService myService = ctx.<span class="hljs-built_in">getBean</span>(MyService.<span class="hljs-keyword">class</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>请记住<code>@Configuration</code>类是使用<code>@Component</code>进行<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-meta-annotations">元注解</a>的，因此它们是组件扫描的候选者。 在前面的示例中， 假设AppConfig在com.acme包（或下面的任何包）中声明，它在<code>scan()</code>调用期间被拾取。 在<code>refresh()</code>之后，它的所有<code>@Bean</code>方法都被处理并在容器中注册为bean定义。</p><h5 id="使用AnnotationConfigWebApplicationContext支持Web应用程序"><a href="#使用AnnotationConfigWebApplicationContext支持Web应用程序" class="headerlink" title="使用AnnotationConfigWebApplicationContext支持Web应用程序"></a>使用<code>AnnotationConfigWebApplicationContext</code>支持Web应用程序</h5><p><code>WebApplicationContext</code>与<code>AnnotationConfigApplicationContext</code>的变种是 <code>AnnotationConfigWebApplicationContext</code>配置。这个实现可以用于配置Spring <code>ContextLoaderListener</code> servlet监听器 ，Spring MVC的 <code>DispatcherServlet</code>等等。以下web.xml代码段配置典型的Spring MVC Web应用程序（请注意<code>contextClass</code> context-param和init-param的使用）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext        instead of the default XmlWebApplicationContext --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>            org.springframework.web.context.support.AnnotationConfigWebApplicationContext        <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited        fully-qualified @Configuration classes. Fully-qualified packages may also be        specified for component-scanning --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.acme.AppConfig<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext            instead of the default XmlWebApplicationContext --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>                org.springframework.web.context.support.AnnotationConfigWebApplicationContext            <span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited            and fully-qualified @Configuration classes --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-12-3-使用-Bean-注解"><a href="#1-12-3-使用-Bean-注解" class="headerlink" title="1.12.3. 使用@Bean 注解"></a>1.12.3. 使用<code>@Bean</code> 注解</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Bean` @Bean是一个方法级别的注解，它与XML中的 `&lt;bean/&gt;`元素类似。注解支持 `&lt;bean/&gt;`提供的一些属性，例如 * [init-<span class="hljs-keyword">method</span>]<span class="hljs-params">(https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-initializingbean)</span> * [<span class="hljs-title function_">destroy</span>-<span class="hljs-title function_">method</span>]<span class="hljs-params">(https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-lifecycle-disposablebean)</span> * [<span class="hljs-title function_">autowiring</span>]<span class="hljs-params">(https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-autowire)</span> * `<span class="hljs-title function_">name</span><br></code></pre></td></tr></table></figure><p>开发者可以在<code>@Configuration</code>类或<code>@Component</code>类中使用<code>@Bean</code>注解。</p><h5 id="声明一个Bean"><a href="#声明一个Bean" class="headerlink" title="声明一个Bean"></a>声明一个Bean</h5><p>要声明一个bean，只需使用<code>@Bean</code>注解方法即可。使用此方法，将会在<code>ApplicationContext</code>内注册一个bean，bean的类型是方法的返回值类型。默认情况下， bean名称将与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferServiceImpl</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>前面的配置完全等同于以下Spring XML:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这两个声明都在<code>ApplicationContext</code>中创建一个名为<code>transferService</code>的bean，并且绑定了<code>TransferServiceImpl</code>的实例。如下图所示：</p><p>transferService -&gt; com.acme.TransferServiceImpl</p><p>您还可以使用接口（或基类）返回类型声明<code>@Bean</code>方法，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>但是，这会将预先类型预测的可见性限制为指定的接口类型(<code>TransferService</code>),然后在实例化受影响的单一bean时,只知道容器的完整类型(<code>TransferServiceImpl</code>）。 。非延迟的单例bean根据它们的声明顺序进行实例化，因此开发者可能会看到不同类型的匹配结果，这具体取决于另一个组件尝试按未类型匹配的时间(如<code>@Autowired TransferServiceImpl</code>， 一旦<code>transferService</code> bean已被实例化,这个问题就被解决了).</p><p>如果通过声明的服务接口都是引用类型,那么<code>@Bean</code> 返回类型可以安全地加入该设计决策.但是,对于实现多个接口的组件或可能由其实现类型引用的组件, 更安全的方法是声明可能的最具体的返回类型(至少按照注入点所要求的特定你的bean）。</p><h5 id="Bean之间的依赖"><a href="#Bean之间的依赖" class="headerlink" title="Bean之间的依赖"></a>Bean之间的依赖</h5><p>一个使用<code>@Bean</code>注解的方法可以具有任意数量的参数描述构建该bean所需的依赖，例如，如果我们的<code>TransferService</code>需要<code>AccountRepository</code>， 我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params">AccountRepository accountRepository</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>(accountRepository);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>这个解析机制与基于构造函数的依赖注入非常相似。有关详细信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-constructor-injection">相关部分</a>。</p><h5 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h5><p>使用<code>@Bean</code>注解定义的任何类都支持常规的生命周期回调，并且可以使用JSR-的<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。 有关更多详细信息，请参阅 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-postconstruct-and-predestroy-annotations">JSR-250</a> 注解。</p><p>完全支持常规的Spring<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-nature">生命周期</a>回调。 如果bean实现<code>InitializingBean</code>, <code>DisposableBean</code>, 或 <code>Lifecycle</code>，则它们各自的方法由容器调用。</p><p>同样地，还完全支持标准的<code>*Aware</code>，如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-beanfactory">BeanFactoryAware</a>, <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware">BeanNameAware</a>, <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-functionality-messagesource">MessageSourceAware</a>, <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-aware">ApplicationContextAware</a>。</p><p><code>@Bean</code>注解支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上的Spring XML的 <code>init-method</code>和<code>destroy-method</code> 属性一样，如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// initialization logic    &#125;&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTwo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// destruction logic    &#125;&#125;</span><br><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;init&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-title class_">BeanOne</span> <span class="hljs-title function_">beanOne</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();    &#125;<br>    <span class="hljs-meta">@Bean</span>(destroyMethod = <span class="hljs-string">&quot;cleanup&quot;</span>)    <span class="hljs-keyword">public</span> <span class="hljs-title class_">BeanTwo</span> <span class="hljs-title function_">beanTwo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanTwo</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，使用Java Config定义的bean中<code>close</code>方法或者<code>shutdown</code>方法，会作为销毁回调而自动调用。若bean中有<code>close</code> 或 <code>shutdown</code> 方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code> 添加到bean定义中以禁用默认<code>(inferred)</code> 模式。</p><p>开发者可能希望对通过JNDI获取的资源执行此操作，因为它的生命周期是在应用程序外部管理的。更进一步，使用 <code>DataSource</code>时一定要关闭它，不关闭将会出问题。</p><p>以下示例说明如何防止<code>DataSource</code>的自动销毁回调：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Bean</span>(destroyMethod=<span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NamingException </span>&#123;<br><br>    <span class="hljs-keyword">return</span> (DataSource) jndiTemplate.lookup(<span class="hljs-string">&quot;MyDS&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，使用<code>@Bean</code>方法，通常会选择使用程序化的JNDI查找：使用Spring的<code>JndiTemplate</code> &#x2F; <code>JndiLocatorDelegate</code>帮助类或直接使用JNDI的<code>InitialContext</code> ，但是不要使用<code>JndiObjectFactoryBean</code>的变体，因为它会强制开发者声明一个返回类型作为<code>FactoryBean</code>的类型用于代替实际的目标类型，这会使得交叉引用变得很困难。</p><p>对于前面注解中上面示例中的<code>BeanOne</code>，在构造期间直接调用<code>init()</code>方法同样有效，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">BeanOne</span> <span class="hljs-variable">beanOne</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();        beanOne.init();        <span class="hljs-keyword">return</span> beanOne;    &#125;<br>    <span class="hljs-comment">// ...&#125;</span><br></code></pre></td></tr></table></figure><p>当您直接使用Java（new对象那种）工作时，您可以使用对象执行任何您喜欢的操作，并且不必总是依赖于容器生命周期。</p><h5 id="指定Bean范围"><a href="#指定Bean范围" class="headerlink" title="指定Bean范围"></a>指定Bean范围</h5><p>Spring包含<code>@Scope</code>注解，以便您可以指定bean的范围。</p><h6 id="使用-Scope-注解"><a href="#使用-Scope-注解" class="headerlink" title="使用 @Scope 注解"></a>使用 <code>@Scope</code> 注解</h6><p>可以使用任意标准的方式为 <code>@Bean</code>注解的bean指定一个作用域，你可以使用<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes">Bean Scopes</a>中的任意标准作用域</p><p>默认范围是<code>singleton</code>的，但是可以使用 <code>@Scope</code>注解来覆盖。如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configurationpublic</span> class MyConfiguration &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)    public Encryptor <span class="hljs-built_in">encryptor</span>() &#123;        <span class="hljs-comment">// ...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h6 id="Scope-and-scoped-proxy"><a href="#Scope-and-scoped-proxy" class="headerlink" title="@Scope and scoped-proxy"></a><code>@Scope</code> and <code>scoped-proxy</code></h6><p>Spring提供了一种通过<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other-injection">scoped proxies</a>处理作用域依赖项的便捷方法。使用XML配置时创建此类代理的最简单方法是<code>&lt;aop:scoped-proxy/&gt;</code>元素。 使用<code>@Scope</code>注解在Java中配置bean提供了与<code>proxyMode</code>属性的等效支持。 默认值为无代理（<code>ScopedProxyMode.NO</code>），但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code> 或 <code>ScopedProxyMode.INTERFACES</code>。</p><p>如果使用Java将XML参考文档（请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-scopes-other-injection">scoped proxies</a>）的作用域代理示例移植到我们的 <code>@Bean</code>，它类似于以下内容：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> an HTTP Session-scoped bean exposed <span class="hljs-keyword">as</span> a proxy@Bean@SessionScopepublic UserPreferences userPreferences() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserPreferences();&#125;<br>@Beanpublic Service userService() &#123;    UserService service = <span class="hljs-keyword">new</span> SimpleUserService();    <span class="hljs-regexp">//</span> a reference to the proxied userPreferences bean    service.setUserPreferences(userPreferences());    <span class="hljs-keyword">return</span> service;&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义Bean命名"><a href="#自定义Bean命名" class="headerlink" title="自定义Bean命名"></a>自定义Bean命名</h5><p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。 但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(name = <span class="hljs-string">&quot;myThing&quot;</span>)</span>    <span class="hljs-keyword">public</span> Thing thing() &#123;        <span class="hljs-keyword">return</span> new Thing();    &#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="bean别名"><a href="#bean别名" class="headerlink" title="bean别名"></a>bean别名</h5><p>正如<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-beanname">Bean的 命名</a>中所讨论的，有时需要为单个bean提供多个名称，也称为bean别名。 <code>@Bean</code>注解的 <code>name</code>属性为此接受String数组。 以下示例显示如何为bean设置多个别名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(name = &#123; <span class="hljs-string">&quot;dataSource&quot;</span>, <span class="hljs-string">&quot;subsystemA-dataSource&quot;</span>, <span class="hljs-string">&quot;subsystemB-dataSource&quot;</span> &#125;)</span>    <span class="hljs-keyword">public</span> DataSource dataSource() &#123;        <span class="hljs-comment">// instantiate, configure and return DataSource bean...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="Bean-的描述"><a href="#Bean-的描述" class="headerlink" title="Bean 的描述"></a>Bean 的描述</h5><p>有时，提供更详细的bean文本描述会很有帮助。 当bean被暴露（可能通过JMX）用于监视目的时，这可能特别有用。</p><p>要向@Bean添加描述，可以使用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>注解，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configurationpublic</span> class AppConfig &#123;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-variable">@Description</span>(<span class="hljs-string">&quot;Provides a basic example of a bean&quot;</span>)    public Thing <span class="hljs-built_in">thing</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Thing</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-12-4-使用-Configuration-注解"><a href="#1-12-4-使用-Configuration-注解" class="headerlink" title="1.12.4. 使用 @Configuration 注解"></a>1.12.4. 使用 <code>@Configuration</code> 注解</h4><p><code>@Configuration</code>是一个类级别的注解,表明该类将作为bean定义的元数据配置. <code>@Configuration</code>类会将有<code>@Bean</code>注解的公开方法声明为bean, .在 <code>@Configuration</code>类上调用<code>@Bean</code>方法也可以用于定义bean间依赖关系, 有关一般介绍，请参阅 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-basic-concepts">基本概念: <code>@Bean</code> 和 <code>@Configuration</code></a></p><h5 id="注入内部bean依赖"><a href="#注入内部bean依赖" class="headerlink" title="注入内部bean依赖"></a>注入内部bean依赖</h5><p>当Bean彼此有依赖关系时,表示依赖关系就像调用另一个bean方法一样简单.如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">BeanOne</span> <span class="hljs-title function_">beanOne</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>(<span class="hljs-title function_">beanTwo</span>());    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">BeanTwo</span> <span class="hljs-title function_">beanTwo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanTwo</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在前面的示例中，<code>beanOne</code>通过构造函数注入接收对<code>beanTwo</code>的引用。</p><p>这种声明bean间依赖关系的方法只有在 <code>@Configuration</code> 类中声明<code>@Bean</code>方法时才有效。 您不能使用普通的<code>@Component</code>类声明bean间依赖关系。</p><h5 id="查找方法注入-1"><a href="#查找方法注入-1" class="headerlink" title="查找方法注入"></a>查找方法注入</h5><p>如前所述，<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-method-injection">查找方法注入</a>是一项很少使用的高级功能。 在单例范围的bean依赖于原型范围的bean的情况下，它很有用。 Java提供了很友好的API来实现这种模式。以下示例显示了如何使用查找方法注入：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> abstract</span> class CommandManager &#123;   <span class="hljs-keyword"> public</span> Object process(Object commandState) &#123;        // grab a<span class="hljs-built_in"> new </span>instance of the appropriate Command interface        Command command = createCommand();        // set the state on the (hopefully brand new) Command<span class="hljs-built_in"> instance </span>       command.setState(commandState);       <span class="hljs-built_in"> return </span>command.execute();    &#125;<br>    // okay... but where is the implementation of this method?   <span class="hljs-keyword"> protected</span><span class="hljs-keyword"> abstract</span> Command createCommand();&#125;<br></code></pre></td></tr></table></figure><p>通过使用Java配置，您可以创建 <code>CommandManager</code>的子类，其中抽象的 <code>createCommand()</code> 方法被覆盖，以便查找新的（原型）对象。 以下示例显示了如何执行此操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-title class_">AsyncCommand</span> <span class="hljs-title function_">asyncCommand</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">AsyncCommand</span> command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCommand</span>();    <span class="hljs-comment">// inject dependencies here as required    return command;&#125;</span><br><span class="hljs-meta">@Beanpublic</span> <span class="hljs-title class_">CommandManager</span> <span class="hljs-title function_">commandManager</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// return new anonymous implementation of CommandManager with command() overridden    // to return a new prototype Command object    return new CommandManager() &#123;        protected Command createCommand() &#123;            return asyncCommand();        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="有关基于Java的配置如何在内部工作的更多信息"><a href="#有关基于Java的配置如何在内部工作的更多信息" class="headerlink" title="有关基于Java的配置如何在内部工作的更多信息"></a>有关基于Java的配置如何在内部工作的更多信息</h5><p>请考虑以下示例，该示例显示了被调用两次的<code>@Bean</code>注解方法:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ClientService</span> <span class="hljs-title function_">clientService1</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">ClientServiceImpl</span> clientService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientServiceImpl</span>();        clientService.<span class="hljs-title function_">setClientDao</span>(<span class="hljs-title function_">clientDao</span>());        <span class="hljs-keyword">return</span> clientService;    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ClientService</span> <span class="hljs-title function_">clientService2</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">ClientServiceImpl</span> clientService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientServiceImpl</span>();        clientService.<span class="hljs-title function_">setClientDao</span>(<span class="hljs-title function_">clientDao</span>());        <span class="hljs-keyword">return</span> clientService;    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ClientDao</span> <span class="hljs-title function_">clientDao</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientDaoImpl</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p><code>clientDao()</code>在<code>clientService1()</code>中调用一次，在<code>clientService2()</code>中调用一次。由于此方法创建了<code>ClientDaoImpl</code>的新实例并将其返回，因此通常希望有两个实例（每个服务一个）。 这肯定会有问题：在Spring中，实例化的bean默认具有<code>singleton</code>范围。这就是它的神奇之处:所有<code>@Configuration</code>类在启动时都使用 <code>CGLIB</code>进行子类化。 在子类中，子方法在调用父方法并创建新实例之前，首先检查容器是否有任何缓存（作用域）bean。</p><p>这种行为可以根据bean的作用域而变化,我们这里只是讨论单例.</p><p>从Spring 3.2开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code>下重新打包并直接包含在spring-core JAR中。</p><p>由于CGLIB在启动时动态添加功能，因此存在一些限制。 特别是，配置类不能是 final的。 但是，从4.3开始，配置类允许使用任何构造函数，包括使用<code>@Autowired</code>或单个非默认构造函数声明进行默认注入。</p><p>如果想避免因CGLIB带来的限制,请考虑声明非<code>@Configuration</code>类的<code>@Bean</code>方法，例如在纯的<code>@Component</code>类 .这样在<code>@Bean</code>方法之间的交叉方法调用将不会被拦截,此时必须在构造函数或方法级别上进行依赖注入。</p><h4 id="1-12-5-编写基于Java的配置"><a href="#1-12-5-编写基于Java的配置" class="headerlink" title="1.12.5. 编写基于Java的配置"></a>1.12.5. 编写基于Java的配置</h4><p>Spring的基于Java的配置功能允许您撰写注解，这可以降低配置的复杂性。</p><h5 id="使用-Import-注解"><a href="#使用-Import-注解" class="headerlink" title="使用@Import 注解"></a>使用<code>@Import</code> 注解</h5><p>就像在Spring XML文件中使用<code>&lt;import/&gt;</code>元素来帮助模块化配置一样，<code>@Import</code> 注解允许从另一个配置类加载<code>@Bean</code>定义，如下例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigA</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();    &#125;&#125;<br><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(<span class="hljs-title class_">ConfigA</span>.<span class="hljs-property">class</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigB</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> B <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>现在，在实例化上下文时，不需要同时指定<code>ConfigA.class</code>和 <code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code>，如下例所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;    ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(ConfigB.<span class="hljs-keyword">class</span>);<br>    <span class="hljs-comment">// now both beans A and B will be available...    A a = ctx.getBean(A.class);    B b = ctx.getBean(B.class);&#125;</span><br></code></pre></td></tr></table></figure><p>这种方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的<code>@Configuration</code>类。</p><p>从Spring Framework 4.2开始，<code>@Import</code>还支持引用常规组件类，类似于<code>AnnotationConfigApplicationContext.register</code>方法。 如果要避免组件扫描，这一点特别有用，可以使用一些配置类作为明确定义所有组件的入口点。</p><h6 id="在导入的-Bean定义上注入依赖项"><a href="#在导入的-Bean定义上注入依赖项" class="headerlink" title="在导入的@Bean定义上注入依赖项"></a>在导入的<code>@Bean</code>定义上注入依赖项</h6><p>上面的例子可以运行,,但是太简单了。在大多数实际情况下，bean将在配置类之间相互依赖.在使用XML时,这本身不是问题,因为没有涉及到编译器. 可以简单地声明 <code>ref=&quot;someBean&quot;</code>,并且相信Spring将在容器初始化期间可以很好地处理它。当然，当使用<code>@Configuration</code>类时，Java编译器会有一些限制 ，即需符合Java的语法。</p><p>幸运的是，解决这个问题很简单。正如我们<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-java-dependencies">已经讨论过</a>的，<code>@Bean</code>方法可以有任意数量的参数来描述bean的依赖关系。 考虑以下更多真实场景，其中包含几个 <code>@Configuration</code>类，每个类都取决于其他类中声明的bean：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params">AccountRepository accountRepository</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>(accountRepository);    &#125;&#125;<br><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepositoryConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-title function_">accountRepository</span>(<span class="hljs-params">DataSource dataSource</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcAccountRepository</span>(dataSource);    &#125;&#125;<br><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(&#123;<span class="hljs-title class_">ServiceConfig</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">RepositoryConfig</span>.<span class="hljs-property">class</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemTestConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// return new DataSource    &#125;&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;    <span class="hljs-title class_">ApplicationContext</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<span class="hljs-title class_">SystemTestConfig</span>.<span class="hljs-property">class</span>);    <span class="hljs-comment">// everything wires up across configuration classes...    TransferService transferService = ctx.getBean(TransferService.class);    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);&#125;</span><br></code></pre></td></tr></table></figure><p>还有另一种方法可以达到相同的效果。请记住，<code>@Configuration</code>类最终只是容器中的另一个bean： 这意味着它们可以利用<code>@Autowired</code> 和 <code>@Value</code> 注入以及与任何其他bean相同的其他功能。</p><p>确保以这种方式注入的依赖项只是最简单的。<code>@Configuration</code>类在上下文初始化期间很早就被处理，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。 尽可能采用基于参数的注入，如前面的示例所示。</p><p>另外，要特别注意通过<code>@Bean</code>的<code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code>定义。 这些通常应该声明为静态<code>@Bean</code>方法，而不是触发其包含配置类的实例化。否则，<code>@Autowired</code> 和 <code>@Value</code>不能在配置类本身上工作，因为它过早地被创建为bean实例。</p><p>以下示例显示了如何将一个bean自动连接到另一个bean:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">AccountRepository</span> accountRepository;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>(accountRepository);    &#125;&#125;<br><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepositoryConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">DataSource</span> dataSource;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">RepositoryConfig</span>(<span class="hljs-title class_">DataSource</span> dataSource) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span> = dataSource;    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-title function_">accountRepository</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcAccountRepository</span>(dataSource);    &#125;&#125;<br><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(&#123;<span class="hljs-title class_">ServiceConfig</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">RepositoryConfig</span>.<span class="hljs-property">class</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemTestConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// return new DataSource    &#125;&#125;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;    <span class="hljs-title class_">ApplicationContext</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<span class="hljs-title class_">SystemTestConfig</span>.<span class="hljs-property">class</span>);    <span class="hljs-comment">// everything wires up across configuration classes...    TransferService transferService = ctx.getBean(TransferService.class);    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);&#125;</span><br></code></pre></td></tr></table></figure><p>仅在Spring Framework 4.3中支持<code>@Configuration</code>类中的构造函数注入。 另请注意，如果目标bean仅定义了一个构造函数，则无需指定<code>@Autowired</code>。 在前面的示例中，<code>RepositoryConfig</code>构造函数中不需要<code>@Autowired</code>。</p><p>完全导入bean便于查找</p><p>在上面的场景中,<code>@Autowired</code>可以很好的工作,使设计更具模块化,但是自动注入哪个bean依然有些模糊不清.例如, 作为一个开发者查看<code>ServiceConfig</code>类时,你怎么知道<code>@Autowired AccountRepository</code>在哪定义的呢?代码中并未明确指出, 还好, <a href="https://spring.io/tools/sts">Spring Tool Suite</a>提供的工具可以呈现图表，显示所有内容的连线方式，这可能就是您所需要的。 此外，您的Java IDE可以轻松找到<code>AccountRepository</code>类型的所有声明和用法，并快速显示返回该类型的<code>@Bean</code>方法的位置。</p><p>万一需求不允许这种模糊的装配,并且您希望从IDE中从一个<code>@Configuration</code>类直接导航到另一个<code>@Configuration</code>类，请考虑自动装配配置类本身。 以下示例显示了如何执行此操作：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <span class="hljs-variable">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RepositoryConfig</span> repositoryConfig;<br>    <span class="hljs-variable">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> transferService() &#123;        <span class="hljs-regexp">//</span> navigate <span class="hljs-string">&#x27;through&#x27;</span> the config <span class="hljs-keyword">class</span> to the <span class="hljs-variable">@Bean</span> method!        <span class="hljs-keyword">return</span> new <span class="hljs-title class_">TransferServiceImpl</span>(repositoryConfig.accountRepository());    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在前面的情况中，定义<code>AccountRepository</code> 是完全明确的。但是，<code>ServiceConfig</code>现在与<code>RepositoryConfig</code>紧密耦合。这是一种权衡的方法。 通过使用基于接口的或基于类的抽象<code>@Configuration</code> 类，可以在某种程度上减轻这种紧密耦合。请考虑以下示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceConfig</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RepositoryConfig</span> repositoryConfig;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>(repositoryConfig.<span class="hljs-title function_">accountRepository</span>());    &#125;&#125;<br><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RepositoryConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-title class_">AccountRepository</span> <span class="hljs-title function_">accountRepository</span>();&#125;<br><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultRepositoryConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RepositoryConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-title function_">accountRepository</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcAccountRepository</span>(...);    &#125;&#125;<br><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(&#123;<span class="hljs-title class_">ServiceConfig</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">DefaultRepositoryConfig</span>.<span class="hljs-property">class</span>&#125;)  <span class="hljs-comment">// import the concrete config!public class SystemTestConfig &#123;</span><br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// return DataSource    &#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;    <span class="hljs-title class_">ApplicationContext</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<span class="hljs-title class_">SystemTestConfig</span>.<span class="hljs-property">class</span>);    <span class="hljs-title class_">TransferService</span> transferService = ctx.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">TransferService</span>.<span class="hljs-property">class</span>);    transferService.<span class="hljs-title function_">transfer</span>(<span class="hljs-number">100.00</span>, <span class="hljs-string">&quot;A123&quot;</span>, <span class="hljs-string">&quot;C456&quot;</span>);&#125;<br></code></pre></td></tr></table></figure><p>现在，<code>ServiceConfig</code>与具体的<code>DefaultRepositoryConfig</code>松散耦合，内置的IDE工具仍然很有用：您可以很容易获取<code>RepositoryConfig</code>实现类的继承体系。 以这种方式,操作<code>@Configuration</code>类及其依赖关系与操作基于接口的代码的过程没有什么区别</p><p>如果要影响某些bean的启动创建顺序，可以考虑将其中一些声明为<code>@Lazy</code> （用于在首次访问时创建而不是在启动时）或<code>@DependsOn</code>某些其他bean（确保在创建之前创建特定的其他bean（当前的bean，超出后者的直接依赖性所暗示的））。</p><h5 id="有条件地包含-Configuration类或-Bean方法"><a href="#有条件地包含-Configuration类或-Bean方法" class="headerlink" title="有条件地包含@Configuration类或@Bean方法"></a>有条件地包含<code>@Configuration</code>类或<code>@Bean</code>方法</h5><p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单独的 <code>@Bean</code> 方法通常很有用。 一个常见的例子是， 只有在Spring环境中启用了特定的配置文件时才使用<code>@Profile</code> 注解来激活bean（有关详细信息，请参阅Bean<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-definition-profiles">定义配置文件</a>）。</p><p><code>@Profile</code>注解实际上是通过使用更灵活的注解<code>@Conditional</code>实现的。<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>注解表示特定的<code>org.springframework.context.annotation.Condition</code>实现。 它表明<code>@Bean</code>被注册之前会先”询问”<code>@Conditional</code>注解。</p><p><code>Condition</code>接口的实现提供了一个返回<code>true</code> 或 <code>false</code>的<code>matches(…)</code>方法。例如，以下清单显示了用于 <code>@Profile</code>的实际<code>Condition</code>实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">matches</span>(<span class="hljs-params">ConditionContext context, AnnotatedTypeMetadata metadata</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (context.<span class="hljs-title function_">getEnvironment</span>() != <span class="hljs-literal">null</span>) &#123;<br><br>        <span class="hljs-comment">// Read the @Profile annotation attributes</span><br><br>        <span class="hljs-title class_">MultiValueMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; attrs = metadata.<span class="hljs-title function_">getAllAnnotationAttributes</span>(<span class="hljs-title class_">Profile</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">getName</span>());<br><br>        <span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Object</span> value : attrs.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;value&quot;</span>)) &#123;<br><br>                <span class="hljs-keyword">if</span> (context.<span class="hljs-title function_">getEnvironment</span>().<span class="hljs-title function_">acceptsProfiles</span>(((<span class="hljs-title class_">String</span>[]) value))) &#123;<br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>                &#125;<br><br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>javadoc。</p><h5 id="结合Java和XML配置"><a href="#结合Java和XML配置" class="headerlink" title="结合Java和XML配置"></a>结合Java和XML配置</h5><p>Spring的<code>@Configuration</code>类支持但不一定成为Spring XML的100％完全替代品。 某些工具（如Spring XML命名空间）仍然是配置容器的理想方法。在XML方便或必要的情况下，您可以选择：通过使用例如<code>ClassPathXmlApplicationContext</code>以“以XML为中心”的方式实例化容器， 或者通过使用<code>AnnotationConfigApplicationContext</code>以“以Java为中心”的方式实例化它。<code>@ImportResource</code>注解，根据需要导入XML。</p><h6 id="以XML为中心使用-Configuration类"><a href="#以XML为中心使用-Configuration类" class="headerlink" title="以XML为中心使用@Configuration类"></a>以XML为中心使用<code>@Configuration</code>类</h6><p>更受人喜爱的方法是从包含<code>@Configuration</code>类的XML启动容器.例如，在使用Spring的现有系统中,大量使用的是Spring XML配置,所以很容易根据需要创建<code>@Configuration</code>类 ,并将他们到包含XML文件中。我们将介绍在这种“以XML为中心”的情况下使用<code>@Configuration</code>类的选项。</p><p>将<code>@Configuration</code>类声明为普通的Spring<code>&lt;bean/&gt;</code> 元素</p><p>请记住,<code>@Configuration</code>类最终也只是容器中的bean定义。在本系列示例中，我们创建一个名为AppConfig的<code>@Configuration</code>类，并将其作为<code>&lt;bean/&gt;</code>定义包含在<code>system-test-config.xml</code>中。 由于 <code>&lt;context:annotation-config/&gt;</code>已打开，容器会识别<code>@Configuration</code> 注解并正确处理<code>AppConfig</code>中声明的<code>@Bean</code> 方法。</p><p>以下示例显示了Java中的普通配置类:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">DataSource</span> dataSource;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-title function_">accountRepository</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcAccountRepository</span>(dataSource);    &#125;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TransferService</span> <span class="hljs-title function_">transferService</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferService</span>(<span class="hljs-title function_">accountRepository</span>());    &#125;&#125;<br></code></pre></td></tr></table></figure><p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.url&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.username&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.password&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>以下示例显示了可能的<code>jdbc.properties</code>文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">jdbc.url=jdbc:hsqldb:hsql:<span class="hljs-comment">//localhost/xdb</span><br><br>jdbc.username=sa<br><br>jdbc.password=<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;classpath:/com/acme/system-test-config.xml&quot;</span>);<br><br>    <span class="hljs-type">TransferService</span> <span class="hljs-variable">transferService</span> <span class="hljs-operator">=</span> ctx.getBean(TransferService.class);<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>system-test-config.xml</code>文件中， <code>AppConfig</code> <code>&lt;bean/&gt;</code>不声明<code>id</code>元素。虽然这样做是可以的，但是没有必要，因为没有其他bean引用它，并且不太可能通过名称从容器中明确地获取它。 类似地，<code>DataSource</code> bean只是按类型自动装配，因此不严格要求显式的bean<code>id</code>。</p><p>使用<a href="context:component-scan/">context:component-scan&#x2F;</a> 来获取<code>@Configuration</code> 类</p><p>因为<code>@Configuration</code>是<code>@Component</code>注解的元注解,所以<code>@Configuration</code>注解的类也可以被自动扫描。使用与上面相同的场景，可以重新定义<code>system-test-config.xml</code> 以使用组件扫描。 请注意，在这种情况下，我们不需要显式声明 <code>&lt;context:annotation-config/&gt;</code>,，因为<code>&lt;context:component-scan/&gt;</code> 启用相同的功能。</p><p>以下示例显示了已修改的<code>system-test-config.xml</code>文件:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.acme&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.url&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.username&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.password&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h6 id="基于-Configuration混合XML的-ImportResource"><a href="#基于-Configuration混合XML的-ImportResource" class="headerlink" title="基于@Configuration混合XML的@ImportResource"></a>基于<code>@Configuration</code>混合XML的<code>@ImportResource</code></h6><p>在 <code>@Configuration</code>类为配置容器的主要方式的应用程序中,也需要使用一些XML配置。在这些情况下,只需使用<code>@ImportResource</code> ,并只定义所需的XML。这样做可以实现“以Java为中心”的方法来配置容器并尽可能少的使用XML。 以下示例（包括配置类，定义bean的XML文件，属性文件和主类）显示了如何使用<code>@ImportResource</code> 注解来实现根据需要使用XML的“以Java为中心”的配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ImportResource</span>(<span class="hljs-string">&quot;classpath:/com/acme/properties-config.xml&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> url;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> username;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>)    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> password;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DriverManagerDataSource</span>(url, username, password);    &#125;&#125;<br>properties-config.<span class="hljs-property">xml</span>&lt;beans&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span>&lt;/beans&gt;<br>jdbc.<span class="hljs-property">properties</span><br><br>jdbc.<span class="hljs-property">url</span>=<span class="hljs-attr">jdbc</span>:<span class="hljs-attr">hsqldb</span>:<span class="hljs-attr">hsql</span>:<span class="hljs-comment">//localhost/xdb</span><br><br>jdbc.<span class="hljs-property">username</span>=sa<br><br>jdbc.<span class="hljs-property">password</span>=<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><br>    <span class="hljs-title class_">ApplicationContext</span> ctx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(<span class="hljs-title class_">AppConfig</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-title class_">TransferService</span> transferService = ctx.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">TransferService</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-13-抽象环境"><a href="#1-13-抽象环境" class="headerlink" title="1.13. 抽象环境"></a>1.13. 抽象环境</h3><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a>接口是集成在容器中的抽象，它模拟了应用程序环境的两个关键方面：<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-definition-profiles">profiles</a> 和 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-property-source-abstraction">properties</a>。</p><p>profile配置是一个被命名的,bean定义的逻辑组,这些bean只有在给定的profile配置激活时才会注册到容器.无论是以XML还是通过注解定义,Bean都可以分配给配置文件 。<code>Environment</code>对象在profile中的角色是判断哪一个profile应该在当前激活和哪一个profile应该在默认情况下激活。</p><p>属性在几乎所有应用程序中都发挥着重要作用，可能源自各种源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Map对象等。 与属性相关的<code>Environment</code>对象的作用是为用户提供方便的服务接口，用于配置属性源和从中解析属性。</p><h4 id="1-13-1-Bean定义Profiles"><a href="#1-13-1-Bean定义Profiles" class="headerlink" title="1.13.1. Bean定义Profiles"></a>1.13.1. Bean定义Profiles</h4><p>bean定义profiles是核心容器内的一种机制，该机制能在不同环境中注册不同的bean。“环境”这个词对不同的用户来说意味着不同的东西，这个功能可以帮助解决许多用例，包括：</p><ul><li>在QA或生产环境中，针对开发中的内存数据源而不是从JNDI查找相同的数据源。</li><li>开发期使用监控组件，当部署以后则关闭监控组件，使应用更高效</li><li>为用户各自注册自定义bean实现</li></ul><p>考虑<code>DataSource</code>的实际应用程序中的第一个用例。 在测试环境中，配置可能类似于以下内容：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Bean</span><br><br>public DataSource dataSource() &#123;<br><br>    return new <span class="hljs-built_in">EmbeddedDatabaseBuilder</span>()<br><br>        <span class="hljs-selector-class">.setType</span>(EmbeddedDatabaseType.HSQL)<br><br>        <span class="hljs-selector-class">.addScript</span>(&quot;my-schema.sql&quot;)<br><br>        <span class="hljs-selector-class">.addScript</span>(&quot;my-test-data.sql&quot;)<br><br>        <span class="hljs-selector-class">.build</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在考虑如何将此应用程序部署到QA或生产环境中，假设应用程序的数据源已注册到生产应用程序服务器的JNDI目录。 我们的<code>dataSource</code> bean现在看起来如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(destroyMethod=&quot;&quot;)</span><br><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>    <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring 用户已经设计了许多方法来完成这项工作，通常依赖于系统环境变量和包含<code>$&#123;placeholder&#125;</code>标记的XML<code>&lt;import/&gt;</code>语句的组合， 这些标记根据值解析为正确的配置文件路径一个环境变量。 Bean 定义 profiles 是核心容器功能，可为此问题提供解决方案。</p><p>概括一下上面的场景，环境决定bean定义,最后发现,我们需要在某些上下文环境中使用某些bean,在其他环境中则不用这些bean.或者说, 在场景A中注册一组bean定义,而在场景B中注册另外一组。先看看如何通过修改配置来完成此需求：</p><h5 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用 @Profile"></a>使用 <code>@Profile</code></h5><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>注解用于当一个或多个配置文件激活的时候,用来指定组件是否有资格注册。使用前面的示例，我们可以重写<code>dataSource</code>配置，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Profile(<span class="hljs-string">&quot;development&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StandaloneDataConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> DataSource dataSource() &#123;        <span class="hljs-keyword">return</span> new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)            .addScript(<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>)            .build();    &#125;&#125;<br><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Profile(<span class="hljs-string">&quot;production&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JndiDataConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(destroyMethod=<span class="hljs-string">&quot;&quot;</span>)</span>    <span class="hljs-keyword">public</span> DataSource dataSource() throws Exception &#123;        Context ctx = new InitialContext();        <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如前所述，使用<code>@Bean</code>方法，您通常选择使用Spring的<code>JndiTemplate</code>&#x2F;<code>JndiLocatorDelegate</code>帮助程序或前面显示的 直接JNDI <code>InitialContext</code>用法但不使用<code>JndiObjectFactoryBean</code>变量来使用编程JNDI查找，这会强制您将返回类型声明为 <code>FactoryBean</code>类型。 As mentioned earlier, with <code>@Bean</code> methods, you typically choose to use programmatic JNDI lookups, by using either Spring’s <code>JndiTemplate</code>&#x2F;<code>JndiLocatorDelegate</code> helpers or the straight JNDI <code>InitialContext</code> usage shown earlier but not the <code>JndiObjectFactoryBean</code> variant, which would force you to declare the return type as the <code>FactoryBean</code> type.</p><p>profile字符串可以包含简单的profile名称（例如，<code>production</code>）或profile表达式。 profile表达式允许表达更复杂的概要逻辑（例如，<code>production &amp; us-east</code>）。 profile表达式支持以下运算符：</p><ul><li><code>!</code>: A logical “not” of the profile</li><li><code>&amp;</code>: A logical “and” of the profiles</li><li><code>|</code>: A logical “or” of the profiles</li></ul><p>你不能不使用括号而混合 <code>&amp;</code> 和 <code>|</code> 。 例如，<code>production &amp; us-east | eu-central</code>不是一个有效的表达。 它必须表示为 <code>production &amp; (us-east | eu-central)</code>.。</p><p>您可以将<code>@Profile</code>用作<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-meta-annotations">元注解</a>，以创建自定义组合注解。 以下示例定义了一个自定义<code>@Production</code>注解，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的替代品：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<br><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br><span class="hljs-variable">@Profile</span>(<span class="hljs-string">&quot;production&quot;</span>)<br><br>public <span class="hljs-variable">@interface</span> Production &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>@Configuration</code>类标有 <code>@Profile</code>,类中所有<code>@Bean</code>和<code>@Import</code>注解相关的类都将被忽略,除非该profile被激活。 如果一个<code>@Component</code>或<code>@Configuration</code>类被标记为<code>@Profile(&#123;&quot;p1&quot;, &quot;p2&quot;&#125;)</code>。那么除非profile ‘p1’ or ‘p2’ 已被激活。 否则该类将不会注册&#x2F;处理。如果给定的配置文件以NOT运算符(<code>!</code>)为前缀，如果配置文件为not active，则注册的元素将被注册。 例如，给定<code>@Profile(&#123;&quot;p1&quot;, &quot;!p2&quot;&#125;)</code>，如果配置文件“p1”处于活动状态或配置文件“p2”未激活，则会进行注册。</p><p><code>@Profile</code>也能注解方法，用于配置一个配置类中的指定bean。如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(<span class="hljs-string">&quot;dataSource&quot;</span>)</span>    <span class="hljs-meta">@Profile(<span class="hljs-string">&quot;development&quot;</span>)</span> (<span class="hljs-number">1</span>)    <span class="hljs-keyword">public</span> DataSource standaloneDataSource() &#123;        <span class="hljs-keyword">return</span> new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)            .addScript(<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>)            .build();    &#125;<br>    <span class="hljs-meta">@Bean(<span class="hljs-string">&quot;dataSource&quot;</span>)</span>    <span class="hljs-meta">@Profile(<span class="hljs-string">&quot;production&quot;</span>)</span> (<span class="hljs-number">2</span>)    <span class="hljs-keyword">public</span> DataSource jndiDataSource() throws Exception &#123;        Context ctx = new InitialContext();        <span class="hljs-keyword">return</span> (DataSource) ctx.lookup(<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>);    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>1</strong>、<code>standaloneDataSource</code> 方法仅在 <code>development</code> 环境可用.</p><p><strong>2</strong>、<code>jndiDataSource</code>方法仅在 <code>production</code> 环境可用.</p><p>在<code>@Bean</code> 方法上还添加有<code>@Profile</code>注解,可能会应用在特殊情况。在相同Java方法名称的重载<code>@Bean</code>方法(类似于构造函数重载）的情况下， 需要在所有重载方法上一致声明<code>@Profile</code>条件，如果条件不一致，则只有重载方法中第一个声明的条件才重要。因此，<code>@Profile</code>不能用于选择具有特定参数签名的重载方法， 所有工厂方法对相同的bean在Spring构造器中的解析算法在创建时是相同的。</p><p>如果想定义具有不同配置文件条件的备用bean，请使用不同的Java方法名称，通过<code>@Bean</code>名称属性指向相同的bean名称。如上例所示。 如果参数签名都是相同的（例如，所有的变体都是无参的工厂方法），这是安排有效Java类放在首要位置的唯一方法（因为只有一个 特定名称和参数签名的方法）。</p><h5 id="XML-bean定义profiles"><a href="#XML-bean定义profiles" class="headerlink" title="XML bean定义profiles"></a>XML bean定义profiles</h5><p>XML中的<code>&lt;beans&gt;</code> 元素有一个<code>profile</code> 属性,我们之前的示例配置可以在两个XML文件中重写，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;development&quot;</span>    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span>    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jee&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以不用分开2个文件，在同一个XML中配置2个<code>&lt;beans/&gt;</code>，<code>&lt;beans/&gt;</code>元素也有profile属性。如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span>    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jee&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- other bean definitions --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:embedded-database</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">jdbc:script</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbc:embedded-database</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>spring-bean.xsd</code> 强制允许将profile元素定义在文件的最后面，这有助于在XML文件中提供灵活的方式而又不引起混乱。</p><p>对应XML不支持前面描述的profile表达式。 但是，有可能通过使用<code>!</code> 来否定一个profile表达式。 也可以通过嵌套profiles来应用“and”，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    <span class="hljs-attr">xmlns:jdbc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jdbc&quot;</span>    <span class="hljs-attr">xmlns:jee</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/jee&quot;</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- other bean definitions --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;us-east&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">jee:jndi-lookup</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">jndi-name</span>=<span class="hljs-string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在前面的示例中，如果<code>production</code> 和<code>us-east</code> profiles都处于活动状态，则会暴露<code>dataSource</code> bean。</p><h5 id="启用profile"><a href="#启用profile" class="headerlink" title="启用profile"></a>启用profile</h5><p>现在已经更新了配置,但仍然需要指定要激活哪个配置文件, 如果我们现在开始我们的示例应用程序， 我们会看到抛出<code>NoSuchBeanDefinitionException</code>，因为容器找不到名为<code>dataSource</code>的Spring bean。</p><p>激活配置文件可以通过多种方式完成，但最直接的方法是以编程方式对可通过<code>ApplicationContext</code>提供的<code>Environment</code> API进行操作。 以下示例显示了如何执行此操作：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">AnnotationConfigApplicationContext ctx = <span class="hljs-built_in">new</span> AnnotationConfigApplicationContext();<br><br>ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);<br><br>ctx.register(SomeConfig.<span class="hljs-keyword">class</span>, StandaloneDataConfig.<span class="hljs-keyword">class</span>, JndiDataConfig.<span class="hljs-keyword">class</span>);<br><br>ctx.<span class="hljs-keyword">refresh</span>();<br></code></pre></td></tr></table></figure><p>此外,配置文件也可以通过<code>spring.profiles.active</code>属性声明式性地激活,可以通过系统环境变量，JVM系统属性，<code>web.xml</code>中的Servlet上下文参数指定， 甚至作为JNDI中的一个条目设置（<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-property-source-abstraction"><code>PropertySource</code> 抽象</a>）。在集成测试中，可以通过 <code>spring-test</code>模块中的<code>@ActiveProfiles</code>注解来声明活动配置文件(参见使用<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/test/testing.mdl#testcontext-ctx-management-env-profiles">环境配置文件的上下文配置</a>)</p><p>配置文件不是“二选一”的。开发者可以一次激活多个配置文件。使用编程方式，您可以为<code>setActiveProfiles()</code>方法提供多个配置文件名称，该方法接受 <code>String…</code>varargs。 以下示例激活多个配置文件：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">ctx.getEnvironment().<span class="hljs-built_in">set</span>ActiveProfiles(<span class="hljs-string">&quot;profile1&quot;</span>, <span class="hljs-string">&quot;profile2&quot;</span>);<br></code></pre></td></tr></table></figure><p>声明性地，<code>spring.profiles.active</code>可以接受以逗号分隔的profile名列表，如以下示例所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-Dspring.profiles.active</span>=<span class="hljs-string">&quot;profile1,profile2&quot;</span><br></code></pre></td></tr></table></figure><h5 id="默认-Profile"><a href="#默认-Profile" class="headerlink" title="默认 Profile"></a>默认 Profile</h5><p>default配置文件表示默认开启的profile配置。考虑以下配置:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@Profile</span>(<span class="hljs-string">&quot;default&quot;</span>)public class DefaultDataConfig &#123;<br>    <span class="hljs-variable">@Bean</span>    public DataSource <span class="hljs-built_in">dataSource</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">EmbeddedDatabaseBuilder</span>()            <span class="hljs-selector-class">.setType</span>(EmbeddedDatabaseType.HSQL)            <span class="hljs-selector-class">.addScript</span>(<span class="hljs-string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)            <span class="hljs-selector-class">.build</span>();    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果没有配置文件激活，上面的<code>dataSource</code>就会被创建。这提供了一种默认的方式，如果有任何一个配置文件启用，default配置就不会生效。</p><p>默认配置文件的名字(default）可以通过<code>Environment</code>的<code>setDefaultProfiles()</code>方法或者<code>spring.profiles.default</code>属性修改。</p><h4 id="1-13-2-PropertySource-抽象"><a href="#1-13-2-PropertySource-抽象" class="headerlink" title="1.13.2. PropertySource 抽象"></a>1.13.2. <code>PropertySource</code> 抽象</h4><p>Spring的<code>Environment</code>抽象提供用于一系列的propertysources属性配置文件的搜索操作.请考虑以下列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericApplicationContext</span>();<br><br><span class="hljs-type">Environment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> ctx.getEnvironment();<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">containsMyProperty</span> <span class="hljs-operator">=</span> env.containsProperty(<span class="hljs-string">&quot;my-property&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);<br></code></pre></td></tr></table></figure><p>在上面的代码段中,一个高级别的方法用于访问Spring是否为当前环境定义了<code>my-property</code> 属性。为了回答这个问题，<code>Environment</code>对象对一组PropertySource对象进行搜索。 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>是对任何键值对的简单抽象，Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>配置有两个<code>PropertySource</code>对象 ，一个表示JVM系统属性(<code>System.getProperties()</code>),一个表示系统环境变量(<code>System.getenv()</code>)。</p><p>这些默认property源位于<code>StandardEnvironment</code>中,用于独立应用程序。<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>用默认的property配置源填充。 默认配置源包括Servlet配置和Servlet上下文参数，它可以选择启用<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a>。有关详细信息，请参阅它的javadocs</p><p>具体地说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对 <code>env.containsProperty(&quot;my-property&quot;)</code>的调用将返回true。</p><p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量，因此如果在调用<code>env.getProperty(&quot;my-property&quot;)</code>期间碰巧在两个位置都设置了<code>my-property</code>属性， 系统属性值返回优先于环境变量。 请注意，属性值未合并，而是由前面的条目完全覆盖。</p><p>对于常见的 <code>StandardServletEnvironment</code>，完整层次结构如下，最高优先级条目位于顶部：</p><ol><li>ServletConfig参数（如果适用 - 例如，在DispatcherServlet上下文的情况下）</li><li>ServletContext参数（web.xml context-param条目）</li><li>JNDI环境变量（<code>java:comp/env/</code>entries）</li><li>JVM系统属性（<code>-D</code>命令行参数）</li><li>JVM系统环境（操作系统环境变量）</li></ol><p>最重要的是,整个机制都是可配置的。也许开发者需要一个自定义的properties源，并将该源整合到这个检索层级中。为此，请实现并实例化您自己的<code>PropertySource</code>，并将其添加到当前<code>Environment</code>的<code>PropertySource</code>集合中。 以下示例显示了如何执行此操作：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ConfigurableApplicationContext ctx <span class="hljs-operator">=</span> new GenericApplicationContext()<span class="hljs-comment">;</span><br><br>MutablePropertySources sources <span class="hljs-operator">=</span> ctx.getEnvironment().getPropertySources()<span class="hljs-comment">;</span><br><br>sources.addFirst(new MyPropertySource())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中， <code>MyPropertySource</code>在搜索中添加了最高优先级。如果它包含<code>my-property</code>属性，则会检测并返回该属性， 优先于其他 <code>PropertySource</code>中的任何<code>my-property</code>属性。 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API公开了许多方法，允许你显式操作property属性源。</p><h4 id="1-13-3-使用-PropertySource"><a href="#1-13-3-使用-PropertySource" class="headerlink" title="1.13.3. 使用 @PropertySource"></a>1.13.3. 使用 <code>@PropertySource</code></h4><p><a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> 注解提供了便捷的方式，用于增加<code>PropertySource</code>到Spring的 <code>Environment</code>中。</p><p>给定一个名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code>， 以下<code>@Configuration</code>类使用<code>@PropertySource</code>，以便调用<code>testBean.getName()</code> 返回<code>myTestBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    Environment env;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> TestBean <span class="hljs-title function_">testBean</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">TestBean</span> <span class="hljs-variable">testBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBean</span>();        testBean.setName(env.getProperty(<span class="hljs-string">&quot;testbean.name&quot;</span>));        <span class="hljs-keyword">return</span> testBean;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>任何的存在于<code>@PropertySource</code>中的<code>$&#123;…&#125;</code>占位符，将会被解析为定义在环境中的属性配置文件中的属性值。 如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource(<span class="hljs-string">&quot;classpath:/com/<span class="hljs-subst">$&#123;my.placeholder:default/path&#125;</span>/app.properties&quot;</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>    Environment env;<br>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> TestBean testBean() &#123;        TestBean testBean = new TestBean();        testBean.setName(env.getProperty(<span class="hljs-string">&quot;testbean.name&quot;</span>));        <span class="hljs-keyword">return</span> testBean;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>假设<code>my.placeholder</code>存在于已注册的其中一个属性源中（例如，系统属性或环境变量），则占位符将解析为相应的值。 如果不是，则<code>default/path</code>用作默认值。 如果未指定默认值且无法解析属性，则抛出<code>IllegalArgumentException</code>。</p><p>根据Java 8惯例，<code>@PropertySource</code>注解是可重复的。 但是，所有这些<code>@PropertySource</code>注解都需要在同一级别声明，可以直接在配置类上声明， 也可以在同一自定义注解中作为元注解声明。 不建议混合直接注解和元注解，因为直接注解有效地覆盖了元注解。</p><h4 id="1-13-4-在声明中的占位符"><a href="#1-13-4-在声明中的占位符" class="headerlink" title="1.13.4. 在声明中的占位符"></a>1.13.4. 在声明中的占位符</h4><p>之前，元素中占位符的值只能针对JVM系统属性或环境变量进行解析。现在已经打破了这种情况。因为环境抽象集成在整个容器中，所以很容易通过它来对占位符进行解析. 这意味着开发者可以以任何喜欢的方式来配置这个解析过程，可以改变是优先查找系统properties或者是有限查找环境变量，或者删除它们；增加自定义property源，使之成为更合适的配置</p><p>具体而言，只要在<code>Environment</code>中可用，无论<code>customer</code>属性在何处定义，以下语句都可以工作：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/bank/service/$</span></span></span><span class="hljs-template-variable">&#123;customer&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">-config.xml&quot;</span>/&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-14-注册LoadTimeWeaver"><a href="#1-14-注册LoadTimeWeaver" class="headerlink" title="1.14. 注册LoadTimeWeaver"></a>1.14. 注册<code>LoadTimeWeaver</code></h3><p><code>LoadTimeWeaver</code>被Spring用来在将类加载到Java虚拟机(JVM)中时动态地转换类</p><p>若要开启加载时织入,要在<code>@Configuration</code>类中增加<code>@EnableLoadTimeWeaving</code>注解，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><br><span class="hljs-variable">@EnableLoadTimeWeaving</span><br><br>public class AppConfig &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>或者，对于XML配置，您可以使用<code>context:load-time-weaver</code> 元素:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;beans&gt;</span><br><br>    <span class="hljs-section">&lt;context:load-time-weaver/&gt;</span><br><br><span class="hljs-section">&lt;/beans&gt;</span><br></code></pre></td></tr></table></figure><p>一旦配置为 <code>ApplicationContext</code>,该 <code>ApplicationContext</code>中的任何bean都可以实现<code>LoadTimeWeaverAware</code>,从而接收对load-time weaver实例的引用。 这特别适用于<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/dataaccess/data-access.md#orm-jpa">Spring的JPA支持</a>。其中JPA类转换可能需要加载时织入。 有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html"><code>LocalContainerEntityManagerFactoryBean</code></a>.。 有关AspectJ加载时编织的更多信息，请参阅<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#aop-aj-ltw">Spring Framework中使用AspectJ的加载时织入</a>。</p><h3 id="1-15-ApplicationContext的附加功能"><a href="#1-15-ApplicationContext的附加功能" class="headerlink" title="1.15.ApplicationContext的附加功能"></a>1.15.<code>ApplicationContext</code>的附加功能</h3><p>正如 <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans">前面章节</a>中讨论的，<code>org.springframework.beans.factory</code>包提供了管理和操作bean的基本功能，包括以编程方式。 <code>org.springframework.context</code>包添加了<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>接口，该接口扩展了<code>BeanFactory</code>接口，此外还扩展了其他接口，以更面向应用程序框架的方式提供其他功能。 许多人以完全声明的方式使用<code>ApplicationContext</code>， 甚至不以编程方式创建它，而是依赖于诸如<code>ContextLoader</code>之类的支持类来自动实例化<code>ApplicationContext</code>，作为Java EE Web应用程序的正常启动过程的一部分。</p><p>为了以更加面向框架的方式增强<code>BeanFactory</code>的功能,上下文包还提供了以下功能。</p><ul><li>通过<code>MessageSource</code>接口访问i18n风格的消息。</li><li>通过<code>ResourceLoader</code>接口访问URL和文件等资源。</li><li>事件发布，即通过使用<code>ApplicationEventPublisher</code>接口实现<code>ApplicationListener</code>接口的bean。</li><li>通过<code>HierarchicalBeanFactory</code>接口，加载多级contexts，允许关注某一层级context，比如应用的Web层。</li></ul><h4 id="1-15-1-使用MessageSource实现国际化"><a href="#1-15-1-使用MessageSource实现国际化" class="headerlink" title="1.15.1. 使用MessageSource实现国际化"></a>1.15.1. 使用<code>MessageSource</code>实现国际化</h4><p><code>ApplicationContext</code> 接口扩展了一个名为<code>MessageSource</code>的接口，因此提供了国际化(“i18n”)功能。 Spring还提供了<code>HierarchicalMessageSource</code>接口，该接口可以分层次地解析消息。 这些接口共同提供了Spring影响消息解析的基础。 这些接口上定义的方法包括：</p><ul><li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>: 用于从<code>MessageSource</code>检索消息的基本方法。 如果未找到指定区域设置的消息，则使用默认消息。 传入的任何参数都使用标准库提供的<code>MessageFormat</code>功能成为替换值。</li><li><code>String getMessage(String code, Object[] args, Locale loc)</code>: 基本上与前一个方法相同，但有一个区别：不能指定默认消息。 如果找不到该消息，则抛出<code>NoSuchMessageException</code> 。</li><li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>: 前面方法中使用的所有属性也包装在名为 <code>MessageSourceResolvable</code>的类中，您可以将此方法用于此类。</li></ul><p>当一个<code>ApplicationContext</code>被加载时,它会自动搜索在上下文中定义的一个<code>MessageSource</code>,bean必须包含名称<code>messageSource</code>,如果找到这样的bean 则将对前面方法的所有调用委派给消息源。如果没有找到消息源，<code>ApplicationContext</code>会尝试找到一个包含同名bean的父对象。如果有，它使用那个bean作为<code>MessageSource</code>。 如果<code>ApplicationContext</code>找不到消息的任何源，则会实例化空的<code>DelegatingMessageSource</code>，以便能够接受对上面定义的方法的调用。</p><p>Spring提供了两个MessageSource实现， <code>ResourceBundleMessageSource</code>和<code>StaticMessageSource</code>，为了做嵌套消息两者都实现了<code>HierarchicalMessageSource</code>。 <code>StaticMessageSource</code>很少使用，但提供了以编程方式向源添加消息。 以下示例显示了<code>ResourceBundleMessageSource</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageSource&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basenames&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>format<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>exceptions<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>windows<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该示例假定您在类路径中定义了三个资源包，<code>format</code>, <code>exceptions</code> and <code>windows</code>。任何解析消息的请求都将以JDK标准方式处理, 通过<code>ResourceBundle</code>解析消息。出于示例的目的，假设上述两个资源包文件的内容如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"># <span class="hljs-keyword">in</span> format.propertiesmessage=Alligators rock!<br># <span class="hljs-keyword">in</span> exceptions.propertiesargument.<span class="hljs-keyword">required</span>=The &#123;<span class="hljs-number">0</span>&#125; argument <span class="hljs-keyword">is</span> <span class="hljs-keyword">required</span>.<br></code></pre></td></tr></table></figure><p>下一个示例显示了执行<code>MessageSource</code> 功能的程序。 请记住，所有<code>ApplicationContext</code>实现也都是<code>MessageSource</code> 实现，因此可以强制转换为<code>MessageSource</code> 接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><br>    <span class="hljs-title class_">MessageSource</span> resources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><br>    <span class="hljs-title class_">String</span> message = resources.<span class="hljs-title function_">getMessage</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Default&quot;</span>, <span class="hljs-literal">null</span>);<br><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(message);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序产生的结果如下:</p><p>Alligators rock!</p><p>总而言之，<code>MessageSource</code>在名为<code>beans.xml</code>的文件中定义，该文件存在于类路径的根目录中。<code>messageSource</code>bean定义通过其basenames属性引用许多资源包。 在列表中传递给<code>basenames</code>属性的三个文件作为类路径根目录下的文件存在，分别称为<code>format.properties</code>, <code>exceptions.properties</code>和<code>windows.properties</code>。</p><p>下一个示例显示传递给消息查询的参数，这些参数将被转换为字符串并插入查找消息中的占位符。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span>    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;exceptions&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span>    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.Example&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;messageSource&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br>public class Example &#123;<br>    private MessageSource messages;<br>    public void setMessages(MessageSource messages) &#123;        this.messages = messages;    &#125;<br>    public void execute() &#123;        String message = this.messages.getMessage(<span class="hljs-string">&quot;argument.required&quot;</span>,            new Object [] &#123;<span class="hljs-string">&quot;userDao&quot;</span>&#125;, <span class="hljs-string">&quot;Required&quot;</span>, null);        System.out.println(message);    &#125;&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>execute()</code>方法得到的结果如下:</p><p>The userDao argument is required.</p><p>关于国际化(“i18n”)，Spring的各种 <code>MessageSource</code>实现遵循与标准JDK <code>ResourceBundle</code>相同的区域设置解析和回退规则。 简而言之，继续前面定义的示例<code>messageSource</code>，如果要根据British(<code>en-GB</code>)语言环境解析消息，则应分别创建名为<code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code>和<code>windows_en_GB.properties</code>的文件。</p><p>通常，区域设置解析由应用程序的环境配置管理。在以下示例中，手动指定解析（英国）消息的区域设置：</p><p># in exceptions_en_GB.properties argument.required&#x3D;Ebagum lad, the {0} argument is required, I say, required.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">final <span class="hljs-built_in">String</span>[] args</span>) &#123;<br><br>    <span class="hljs-title class_">MessageSource</span> resources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><br>    <span class="hljs-title class_">String</span> message = resources.<span class="hljs-title function_">getMessage</span>(<span class="hljs-string">&quot;argument.required&quot;</span>,<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span> [] &#123;<span class="hljs-string">&quot;userDao&quot;</span>&#125;, <span class="hljs-string">&quot;Required&quot;</span>, <span class="hljs-title class_">Locale</span>.<span class="hljs-property">UK</span>);<br><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(message);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述程序产生的结果如下:</p><p>Ebagum lad, the ‘userDao’ argument is required, I say, required.</p><p>您还可以使用<code>MessageSourceAware</code>接口获取对已定义的任何<code>MessageSource</code>的引用。 在创建和配置bean时，应用程序上下文的<code>MessageSource</code>会注入实现<code>MessageSourceAware</code>接口的<code>ApplicationContext</code>中定义的任何bean。</p><p>作为<code>ResourceBundleMessageSource</code>的替代，Spring提供了一个<code>ReloadableResourceBundleMessageSource</code>类。 此变体支持相同的bundle文件格式，但比基于标准JDK的<code>ResourceBundleMessageSource</code>实现更灵活。特别是，它允许从任何Spring资源位置（不仅从类路径）读取文件，并支持bundle属性文件的热重新加载（同时在其间有效地缓存它们）。 有关详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html"><code>ReloadableResourceBundleMessageSource</code></a> javadoc。</p><h4 id="1-15-2-标准和自定义事件"><a href="#1-15-2-标准和自定义事件" class="headerlink" title="1.15.2. 标准和自定义事件"></a>1.15.2. 标准和自定义事件</h4><p><code>ApplicationContext</code>中的事件处理是通过<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口提供的。如果将实现<code>ApplicationListener</code>接口的bean部署到上下文中，则每次将<code>ApplicationEvent</code>发布到<code>ApplicationContext</code>时，都会通知该bean。 从本质上讲，这是标准的Observer设计模式。</p><p>从Spring 4.2开始，事件架构已经得到显着改进，并提供了一个<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-functionality-events-annotation">基于注解的模型</a>使其有发布任意事件的能力（即，不一定从<code>ApplicationEvent</code>扩展的对象） 。当发布这样的对象时，我们将它包装在一个事件中。</p><p>下表描述了Spring提供的标准事件：:</p><p>Table 7. Built-in Events</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>ContextRefreshedEvent</code></td><td>初始化或刷新<code>ApplicationContext</code>时发布（例如，通过使用<code>ConfigurableApplicationContext</code> 接口上的<code>refresh()</code> 方法）。 这里，“initialized”意味着加载所有bean，检测并激活bean的后置处理器，预先实例化单例，并且可以使用<code>ApplicationContext</code>对象。 只要上下文尚未关闭，只要所选的<code>ApplicationContext</code>实际支持这种“热”刷新，就可以多次触发刷新。 例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code> 不支持。</td></tr><tr><td><code>ContextStartedEvent</code></td><td>通过使用<code>ConfigurableApplicationContext</code>接口上的<code>start()</code>方法启动<code>ApplicationContext</code> 时发布。 通常，此信号用于在显式停止后重新启动Bean，但它也可用于启动尚未为自动启动配置的组件（例如，在初始化时尚未启动的组件）。</td></tr><tr><td><code>ContextStoppedEvent</code></td><td>通过使用<code>ConfigurableApplicationContext</code>接口上的<code>close()</code> 方法停止<code>ApplicationContext</code>时发布。 这里，“已停止”表示所有生命周期bean都会收到明确的停止信号。 可以通过<code>start()</code>调用重新启动已停止的上下文。</td></tr><tr><td><code>ContextClosedEvent</code></td><td>通过使用<code>ConfigurableApplicationContext</code>接口上的<code>close()</code>方法关闭<code>ApplicationContext</code>时发布。 这里， “关闭” 意味着所有单例bean都被销毁。 封闭的环境达到其寿命终结。 它无法刷新或重新启动。</td></tr><tr><td><code>RequestHandledEvent</code></td><td>一个特定于Web的事件，告诉所有bean已经为HTTP请求提供服务。 请求完成后发布此事件。 此事件仅适用于使用Spring的DispatcherServlet的Web应用程序。</td></tr></tbody></table><p>您还可以创建和发布自己的自定义事件。 以下示例显示了一个扩展Spring的<code>ApplicationEvent</code>基类的简单类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlackListEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> address;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> content;<br>    public <span class="hljs-type">BlackListEvent</span>(<span class="hljs-type">Object</span> source, <span class="hljs-type">String</span> address, <span class="hljs-type">String</span> content) &#123;        <span class="hljs-keyword">super</span>(source);        <span class="hljs-keyword">this</span>.address = address;        <span class="hljs-keyword">this</span>.content = content;    &#125;<br>    <span class="hljs-comment">// accessor and other methods...&#125;</span><br></code></pre></td></tr></table></figure><p>要发布自定义<code>ApplicationEvent</code>，请在<code>ApplicationEventPublisher</code>上调用<code>publishEvent()</code>方法。 通常，这是通过创建一个实现 <code>ApplicationEventPublisherAware</code>并将其注册为Spring bean的类来完成的。 以下示例显示了这样一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventPublisherAware</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; blackList;    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApplicationEventPublisher</span> publisher;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setBlackList</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; blackList</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">blackList</span> = blackList;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span>(<span class="hljs-params">ApplicationEventPublisher publisher</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">publisher</span> = publisher;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendEmail</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> address, <span class="hljs-built_in">String</span> content</span>) &#123;        <span class="hljs-keyword">if</span> (blackList.<span class="hljs-title function_">contains</span>(address)) &#123;            publisher.<span class="hljs-title function_">publishEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackListEvent</span>(<span class="hljs-variable language_">this</span>, address, content));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// send email...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>在配置时，Spring容器检测到<code>EmailService</code>实现<code>ApplicationEventPublisherAware</code>并自动调用<code>setApplicationEventPublisher()</code>。 实际上，传入的参数是Spring容器本身。 您正在通过其<code>ApplicationEventPublisher</code>接口与应用程序上下文进行交互。</p><p>要接收自定义 <code>ApplicationEvent</code>，您可以创建一个实现<code>ApplicationListener</code>的类并将其注册为Spring bean。 以下示例显示了这样一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListNotifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;<span class="hljs-title class_">BlackListEvent</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> notificationAddress;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setNotificationAddress</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> notificationAddress</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">notificationAddress</span> = notificationAddress;    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onApplicationEvent</span>(<span class="hljs-params">BlackListEvent event</span>) &#123;        <span class="hljs-comment">// notify appropriate parties via notificationAddress...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>请注意，<code>ApplicationListener</code>通常使用自定义事件的类型进行参数化（前面示例中为<code>BlackListEvent</code>）。这意味着<code>onApplicationEvent()</code>方法可以保持类型安全，从而避免任何向下转换的需要。 您可以根据需要注册任意数量的事件侦听器，但请注意，默认情况下，事件侦听器会同步接收事件。这意味着<code>publishEvent()</code>方法将阻塞，直到所有侦听器都已完成对事件的处理。 这种同步和单线程方法的一个优点是，当侦听器接收到事件时，如果事务上下文可用，它将在发布者的事务上下文内运行。如果需要另一个事件发布策略，请参阅Spring的<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a>接口的javadoc。</p><p>以下示例显示了用于注册和配置上述每个类的bean定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emailService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.EmailService&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blackList&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>[email protected]<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>[email protected]<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>[email protected]<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blackListNotifier&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example.BlackListNotifier&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;notificationAddress&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;[email protected]&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总而言之，当调用<code>emailService</code> bean的<code>sendEmail()</code>方法时，如果有任何应列入黑名单的电子邮件消息，则会发布<code>BlackListEvent</code>类型的自定义事件。 <code>blackListNotifier</code> bean注册为<code>ApplicationListener</code> 并接收<code>BlackListEvent</code> ，此时它可以通知相关方。</p><p>Spring的事件机制是为在同一应用程序上下文中的Spring bean之间的简单通信而设计的。但是，对于更复杂的企业集成需求，单独维护的<a href="https://projects.spring.io/spring-integration/">Spring Integration</a> 项目提供了完整的支持并可用于构建轻量级，<a href="http://www.enterpriseintegrationpatterns.com/">pattern-oriented</a>(面向模式），依赖Spring编程模型的事件驱动架构。</p><h5 id="基于注解的事件监听器"><a href="#基于注解的事件监听器" class="headerlink" title="基于注解的事件监听器"></a>基于注解的事件监听器</h5><p>从Spring 4.2开始，您可以使用<code>EventListener</code>注解在托管bean的任何公共方法上注册事件监听器。 <code>BlackListNotifier</code>可以重写如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackListNotifier</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> notificationAddress;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setNotificationAddress</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> notificationAddress</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">notificationAddress</span> = notificationAddress;    &#125;<br>    <span class="hljs-meta">@EventListener</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processBlackListEvent</span>(<span class="hljs-params">BlackListEvent event</span>) &#123;        <span class="hljs-comment">// notify appropriate parties via notificationAddress...    &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>方法签名再次声明它侦听的事件类型，但这次使用灵活的名称并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析通用参数，也可以通过泛型缩小事件类型。</p><p>如果您的方法应该监听多个事件，或者您想要根据任何参数进行定义，那么也可以在注解本身上指定事件类型。 以下示例显示了如何执行此操作：:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@EventListener(&#123;ContextStartedEvent.<span class="hljs-keyword">class</span>, ContextRefreshedEvent.<span class="hljs-keyword">class</span>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleContextStart</span>()</span> &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>还可以通过使用定义<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#expressions"><code>SpEL</code> 表达式</a>的注解的<code>condition</code>属性来添加额外的运行时过滤，该表达式应匹配以实际调用特定事件的方法。</p><p>以下示例显示了仅当事件的<code>content</code>属性等于<code>my-event</code>时才能重写我们的通知程序以进行调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@EventListener</span>(condition = <span class="hljs-string">&quot;#blEvent.content == &#x27;my-event&#x27;&quot;</span>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processBlackListEvent</span>(<span class="hljs-params">BlackListEvent blEvent</span>) &#123;<br><br>    <span class="hljs-comment">// notify appropriate parties via notificationAddress...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>每个<code>SpEL</code>表达式都针对专用上下文进行评估。 下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p><p>Table 8. 事件SpEL可用的元数据</p><table><thead><tr><th>名字</th><th>位置</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>Event</td><td>root</td><td>实际<code>ApplicationEvent</code></td><td><code>#root.event</code></td></tr><tr><td>Arguments array</td><td>root object</td><td>用于调用目标的参数（作为数组）</td><td><code>#root.args[0]</code></td></tr><tr><td><em>Argument name</em></td><td>evaluation context</td><td>任何方法参数的名称。 如果由于某种原因，名称不可用（例如，因为没有调试信息），参数名称也可以在#a <code>#a&lt;#arg&gt;</code>下获得，其中<code>#arg</code>代表参数索引（从0开始）。</td><td><code>#blEvent</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias)</td></tr></tbody></table><p>请注意，即使您的方法签名实际引用已发布的任意对象，<code>#root.event</code>也允许您访问基础事件。</p><p>如果需要发布一个事件作为处理另一个事件的结果，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@EventListener</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">ListUpdateEvent</span> <span class="hljs-title function_">handleBlackListEvent</span>(<span class="hljs-params">BlackListEvent event</span>) &#123;<br><br>    <span class="hljs-comment">// notify appropriate parties via notificationAddress and</span><br><br>    <span class="hljs-comment">// then publish a ListUpdateEvent...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#context-functionality-events-async">异步侦听器</a>不支持此功能。</p><p>这将通过上述方法处理每个<code>BlackListEvent</code>并发布一个新的<code>ListUpdateEvent</code>，如果需要发布多个事件，则可以返回事件 <code>集合</code>。</p><h5 id="异步的监听器"><a href="#异步的监听器" class="headerlink" title="异步的监听器"></a>异步的监听器</h5><p>如果希望特定侦听器异步处理事件，则可以重用<a href="https://github.com/DocsHome/spring-docs/blob/master/pages/integration/integration.md#scheduling-annotation-support-async">常规 <code>@Async</code>支持</a>。 以下示例显示了如何执行此操作：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EventListener</span><br><br><span class="hljs-variable">@Async</span><br><br>public void <span class="hljs-built_in">processBlackListEvent</span>(BlackListEvent event) &#123;<br><br>    <span class="hljs-comment">// BlackListEvent is processed in a separate thread</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用异步事件时请注意以下限制:</p><ul><li>如果事件侦听器抛出<code>Exception</code>，则不会将其传播给调用者。有关更多详细信息，请参阅 <code>AsyncUncaughtExceptionHandler</code>。</li><li>此类事件监听器无法发送回复。 如果您需要作为处理结果发送另一个事件，请注入<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html"><code>ApplicationEventPublisher</code></a>以手动发送事件。</li></ul><h5 id="监听器的排序"><a href="#监听器的排序" class="headerlink" title="监听器的排序"></a>监听器的排序</h5><p>如果需要在另一个侦听器之前调用一个侦听器，则可以将<code>@Order</code>注解添加到方法声明中，如以下示例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EventListener</span><br><br><span class="hljs-variable">@Order</span>(<span class="hljs-number">42</span>)<br><br>public void <span class="hljs-built_in">processBlackListEvent</span>(BlackListEvent event) &#123;<br><br>    <span class="hljs-comment">// notify appropriate parties via notificationAddress...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="泛型的事件"><a href="#泛型的事件" class="headerlink" title="泛型的事件"></a>泛型的事件</h5><p>您还可以使用泛型来进一步定义事件的结构。 考虑使用<code>EntityCreatedEvent&lt;T&gt;</code>，其中<code>T</code>是创建的实际实体的类型。 例如，您可以创建以下侦听器定义以仅接收<code>Person</code>的<code>EntityCreatedEvent</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@EventListener</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onPersonCreated</span>(<span class="hljs-params">EntityCreatedEvent&lt;Person&gt; event</span>) &#123;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>由于泛型擦除，只有此事件符合事件监听器所过滤的通用参数条件那么才会触发相应的处理事件(有点类似于<code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; &#123; … &#125;</code>）</p><p>在某些情况下，如果所有事件遵循相同的结构(如上述事件的情况），这可能变得相当乏味。在这种情况下，开发者可以实现<code>ResolvableTypeProvider</code>来引导框架超出所提供的运行时环境范围。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntityCreatedEvent&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> <span class="hljs-title">implements</span> <span class="hljs-title">ResolvableTypeProvider</span> </span>&#123;<br>    public <span class="hljs-type">EntityCreatedEvent</span>(<span class="hljs-type">T</span> entity) &#123;        <span class="hljs-keyword">super</span>(entity);    &#125;<br>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">ResolvableType</span> getResolvableType() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">ResolvableType</span>.forClassWithGenerics(getClass(), <span class="hljs-type">ResolvableType</span>.forInstance(getSource()));    &#125;&#125;<br></code></pre></td></tr></table></figure><p>这不仅适用于<code>ApplicationEvent</code> ，也适用于作为事件发送的任意对象。</p><h4 id="1-15-3-通过便捷的方式访问底层资源"><a href="#1-15-3-通过便捷的方式访问底层资源" class="headerlink" title="1.15.3.通过便捷的方式访问底层资源"></a>1.15.3.通过便捷的方式访问底层资源</h4><p>为了最佳地使用和理解应用程序上下文，您应该熟悉Spring的资源抽象，如参考资料中所述<a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#resources">资源</a>。</p><p>应用程序上下文是<code>ResourceLoader</code>，可用于加载<code>Resource</code>对象。 <code>Resource</code>本质上是JDK<code>java.net.URL</code>类的功能更丰富的版本。实际上Resource的实现类中大多含有<code>java.net.URL</code>的实例。 <code>Resource</code>几乎能从任何地方透明的获取底层资源，可以是classpath类路径、文件系统、标准的URL资源及变种URL资源。如果资源定位字串是简单的路径， 没有任何特殊前缀，就适合于实际应用上下文类型。</p><p>可以配置一个bean部署到应用上下文中，用以实现特殊的回调接口，<code>ResourceLoaderAware</code>它会在初始化期间自动回调。应用程序上下文本身作为<code>ResourceLoader</code>传入。可以公开<code>Resource</code>的type属性，这样就可以访问静态资源 静态资源可以像其他properties那样被注入<code>Resource</code>。可以使用简单的字串路径指定资源，这需要依赖于特殊的JavaBean <code>PropertyEditor</code>（由上下文自动注册），当bean部署时候它将转换资源中的字串为实际的资源对象。</p><p>提供给<code>ApplicationContext</code>构造函数的一个或多个位置路径实际上是资源字符串，并且以简单形式对特定上下文实现进行适当处理。 <code>ClassPathXmlApplicationContext</code>将一个简单的定位路径视为类路径位置。开发者还可以使用带有特殊前缀的定位路径，这样就可以强制从classpath或者URL定义加载路径， 而不用考虑实际的上下文类型。</p><h4 id="1-15-4-快速对Web应用的ApplicationContext实例化"><a href="#1-15-4-快速对Web应用的ApplicationContext实例化" class="headerlink" title="1.15.4. 快速对Web应用的ApplicationContext实例化"></a>1.15.4. 快速对Web应用的ApplicationContext实例化</h4><p>开发者可以通过使用<code>ContextLoader</code>来声明性地创建<code>ApplicationContext</code>实例，当然也可以通过使用<code>ApplicationContext</code>的实现来编程实现<code>ApplicationContext</code>。</p><p>您可以使用<code>ContextLoaderListener</code>注册<code>ApplicationContext</code> ，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><p>侦听器检查<code>contextConfigLocation</code>参数。 如果参数不存在，则侦听器将<code>/WEB-INF/applicationContext.xml</code>用作默认值。 当参数确实存在时，侦听器使用预定义的分隔符（逗号，分号和空格）分隔String，并将值用作搜索应用程序上下文的位置。 还支持Ant样式的路径模式。 示例是<code>/WEB-INF/*Context.xml</code>（对于所有名称以<code>Context.xml</code>结尾且位于<code>WEB-INF</code> 目录中的文件）和<code>/WEB-INF/**/*Context.xml</code>（对于所有这样的文件） <code>WEB-INF</code>的任何子目录中的文件。</p><h4 id="1-15-5-使用Java-EE-RAR文件部署Spring的ApplicationContext"><a href="#1-15-5-使用Java-EE-RAR文件部署Spring的ApplicationContext" class="headerlink" title="1.15.5. 使用Java EE RAR文件部署Spring的ApplicationContext"></a>1.15.5. 使用Java EE RAR文件部署Spring的<code>ApplicationContext</code></h4><p>可以将Spring <code>ApplicationContext</code>部署为RAR文件，将上下文及其所有必需的bean类和库JAR封装在Java EE RAR部署单元中，这相当于引导一个独立的<code>ApplicationContext</code>。 只是托管在Java EE环境中，能够访问Java EE服务器设施。在部署无头WAR文件(实际上，没有任何HTTP入口点，仅用于在Java EE环境中引导Spring <code>ApplicationContext</code>的WAR文件）的情况下RAR部署是更自然的替代方案</p><p>RAR部署非常适合不需要HTTP入口点但仅由消息端点和调度作业组成的应用程序上下文。在这种情况下，Bean可以使用应用程序服务器资源， 例如JTA事务管理器和JNDI绑定的JDBC <code>DataSource</code>和JMS <code>ConnectionFactory</code>实例，并且还可以通过Spring的标准事务管理和JNDI和JMX支持设施向平台的JMX服务器注册。 应用程序组件还可以通过Spring的<code>TaskExecutor</code>抽象实现与应用程序服务器的JCA <code>WorkManager</code> 交互</p><p>有关RAR部署中涉及的配置详细信息，请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>类的javadoc</p><p>对于将Spring ApplicationContext简单部署为Java EE RAR文件：</p><ol><li>将所有应用程序类打包到一个RAR文件（这是一个具有不同文件扩展名的标准JAR文件）。将所有必需的库JAR添加到RAR存档的根目录中。 。添加<code>META-INF/ra.xml</code>部署描述符 （如<a href="https://docs.spring.io/spring-framework/docs/5.1.3.BUILD-SNAPSHOT/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>的javadoc所示） 和相应的Spring XML bean定义文件（通常是 META-INF&#x2F;applicationContext.xml）。</li><li>将生成的RAR文件放入应用程序服务器的部署目录中。</li></ol><p>这种RAR部署单元通常是独立的。它们不会将组件暴露给外部世界，甚至不会暴露给同一应用程序的其他模块。 与基于RAR的<code>ApplicationContext</code>的交互通常通过与其他模块共享的JMS目标进行。 例如，基于RAR的<code>ApplicationContext</code>还可以调度一些作业或对文件系统（等等）中的新文件作出反应。 如果它需要允许来自外部的同步访问，它可以（例如）导出RMI端点，这可以由同一台机器上的其他应用程序模块使用。</p><h3 id="1-16-BeanFactory"><a href="#1-16-BeanFactory" class="headerlink" title="1.16.BeanFactory"></a>1.16.<code>BeanFactory</code></h3><p><code>BeanFactory</code> API为Spring的IoC功能提供了基础。 它的特定契约主要用于与Spring的其他部分和相关的第三方框架集成其<code>DefaultListableBeanFactory</code>实现是更高级别<code>GenericApplicationContext</code>容器中的密钥委托。</p><p><code>BeanFactory</code>和相关接口（例如<code>BeanFactoryAware</code>, <code>InitializingBean</code>，<code>DisposableBean</code>）是其他框架组件的重要集成点。 通过不需要任何注解或甚至反射，它们允许容器与其组件之间的非常有效的交互。 应用程序级bean可以使用相同的回调接口，但通常更喜欢通过注解或通过编程配置进行声明性依赖注入。</p><p>请注意，核心<code>BeanFactory</code> API级别及其 <code>DefaultListableBeanFactory</code>实现不会对配置格式或要使用的任何组件注解做出假设。 所有这些风格都通过扩展（例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>）进行，并作为核心元数据表示在共享<code>BeanDefinition</code>对象上运行。 这是使Spring的容器如此灵活和可扩展的本质。</p><h4 id="1-16-1-选择BeanFactory还是ApplicationContext"><a href="#1-16-1-选择BeanFactory还是ApplicationContext" class="headerlink" title="1.16.1. 选择BeanFactory还是ApplicationContext?"></a>1.16.1. 选择<code>BeanFactory</code>还是<code>ApplicationContext</code>?</h4><p>本节介绍<code>BeanFactory</code>和<code>ApplicationContext</code>容器级别之间的差异以及影响。</p><p>您应该使用<code>ApplicationContext</code>，除非您有充分的理由不这样做，使用<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常见实现。 这些是Spring用于所有常见目的的核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册bean定义和带注解的类，以及（从5.0开始）注册功能bean定义。</p><p>因为<code>ApplicationContext</code>包括<code>BeanFactory</code>的所有功能，和<code>BeanFactory</code>相比更值得推荐，除了一些特定的场景，例如在资源受限的设备上运行的内嵌的应用。 在<code>ApplicationContext</code>（例如<code>GenericApplicationContext</code>实现）中，按照约定（即通过bean名称或bean类型 - 特别是后处理器）检测到几种bean， 而普通的<code>DefaultListableBeanFactory</code>对任何特殊bean都是不可知的。</p><p>对于许多扩展容器功能，例如注解处理和AOP代理， <a href="https://sca.aliyun.com/learn/spring/core/ioc/?spm=5176.29160081.0.0.74aa3d07VSkV2g#beans-factory-extension-bpp"><code>BeanPostProcessor</code>扩展点是必不可少的。如果仅使用普通的<code>DefaultListableBeanFactory</code>，则默认情况下不会检测到并激活此类后置处理器。 这种情况可能令人困惑，因为您的bean配置实际上没有任何问题。 相反，在这种情况下，容器需要至少得多一些额外的处理。</a></p><p>下表列出了<code>BeanFactory</code>和<code>ApplicationContext</code>接口和实现提供的功能。</p><p>Table 9.特性矩阵</p><table><thead><tr><th>Feature</th><th><code>BeanFactory</code></th><th><code>ApplicationContext</code></th></tr></thead><tbody><tr><td>Bean Bean实例化&#x2F;装配</td><td>Yes</td><td>Yes</td></tr><tr><td>集成的生命周期管理</td><td>No</td><td>Yes</td></tr><tr><td>自动注册 <code>BeanPostProcessor</code></td><td>No</td><td>Yes</td></tr><tr><td>自动注册 <code>BeanFactoryPostProcessor</code></td><td>No</td><td>Yes</td></tr><tr><td>便利的 <code>MessageSource</code> 访问 (国际化)</td><td>No</td><td>Yes</td></tr><tr><td>内置<code>ApplicationEvent</code> 发布机制</td><td>No</td><td>Yes</td></tr></tbody></table><p>要使用 <code>DefaultListableBeanFactory</code>显式注册bean的后置处理器，您需要以编程方式调用 <code>addBeanPostProcessor</code>，如以下示例所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">DefaultListableBeanFactory <span class="hljs-keyword">factory</span> = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<span class="hljs-comment">// populate the factory with bean definitions</span><br><span class="hljs-comment">// now register any needed BeanPostProcessor instancesfactory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());factory.addBeanPostProcessor(new MyBeanPostProcessor());</span><br><span class="hljs-comment">// now start using the factory</span><br></code></pre></td></tr></table></figure><p>要将<code>BeanFactoryPostProcessor</code> 应用于普通的<code>DefaultListableBeanFactory</code>，需要调用其<code>postProcessBeanFactory</code>方法，如以下示例所示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">DefaultListableBeanFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">DefaultListableBeanFactory</span>();XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> <span class="hljs-type">XmlBeanDefinitionReader</span>(factory);reader.loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-type">FileSystemResource</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>));<br><span class="hljs-comment">// bring in some property values from a Properties filePropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();cfg.setLocation(new FileSystemResource(&quot;jdbc.properties&quot;));</span><br><span class="hljs-comment">// now actually do the replacementcfg.postProcessBeanFactory(factory);</span><br></code></pre></td></tr></table></figure><p>在这两种情况下，显示注册步骤都不方便，这就是为什么各种<code>ApplicationContext</code>变体优先于Spring支持的应用程序中的普通<code>DefaultListableBeanFactory</code>， 尤其是在典型企业设置中依赖<code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code>实例来扩展容器功能时。</p><p><code>AnnotationConfigApplicationContext</code>具有注册的所有常见注解后置处理器，并且可以通过配置注解（例如<code>@EnableTransactionManagement</code>）在封面下引入其他处理器。 在Spring的基于注解的配置模型的抽象级别，bean的后置处理器的概念变成仅仅是内部容器细节。</p><blockquote><p>Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch</p></blockquote><blockquote><p>Copyright © 2002 - 2024 VMware, Inc. All Rights Reserved.</p></blockquote><blockquote><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022.11月C语言复习题.docx</title>
    <link href="/post/22ca3782-bd81-46b5-ba49-ef6d6b47f61a/"/>
    <url>/post/22ca3782-bd81-46b5-ba49-ef6d6b47f61a/</url>
    
    <content type="html"><![CDATA[<h3 id="2022-11-月-C-语言复习题-docx"><a href="#2022-11-月-C-语言复习题-docx" class="headerlink" title="2022.11 月 C 语言复习题.docx"></a>2022.11 月 C 语言复习题.docx</h3><p><code>hexo template generate by typora plugin templater</code></p><ol><li>用 C 语言编写的代码程序（D）。<br>A.可立即执行B.是一个源程序<br>C.经过编译即可执行D.经过编译解释才能执行</li><li>将 C 语言源程序进行（B）可得到目标程序。<br>A.编辑B.编译C.连接D.执行</li><li>（a）是 C 语言提供的合法的数据类型关键字。<br>A.FloatB.UnsignedC.IntegerD.Char</li><li>   若 int k &#x3D; 7, x &#x3D; 12; 则能使值为 3 的表达式是（C）。<br>A.x%&#x3D;(k%&#x3D; 5)12%&#x3D; 2B.x%&#x3D;(k－k%5)12%&#x3D; 5<br>C.x%&#x3D; k－k%5D.(x%&#x3D; k)－(k%&#x3D; 5) 1 - 1<br>X &#x3D; x%k-k%5</li></ol><p>5.C 语言源程序文件经过 C 编译程序编译后生成的目标文件的后缀为（B）。<br>A. .c        B.  .obj     C..exe       D..bas<br>6.C 语言语句的结束符是（B）。<br>A. 回车符    B. 分号          C. 逗号      D. 句号<br>7.以下程序的功能是给 r 输入数据后计算半径为 r 的圆面积 s。程序在编译时出错，出错的原因是（D）。<br>#include &lt;stdio.h&gt;<br>int main()<br>&#x2F;* Beginning <em>&#x2F;<br>{  int r; float s;   &#x2F;&#x2F;float 代表浮点类型，即小数，其对应的格式为%f<br>   scanf(“%d”,&amp;r);<br>   s &#x3D; p <em>r</em> r;<br>   printf(“s &#x3D;%f\n”, s);<br>   return 0;<br>}<br>A.注释语句书写位置错误<br>B.存放圆半径的变量 r 不应该定义为整型<br>C.输出语句中格式描述符非法<br>D.计算圆面积的赋值语句中使用了未定义的变量<br>8.在 C 语言中, 要求参加运算的数必须是整数的运算符是(A)。<br>A.%       B.&#x2F;        C.!           D.</em><br>9.若已定义 x 和 y 为 double 类型, 则表达式 “x &#x3D; 1, y &#x3D; x+3&#x2F;2” 的值是(D)。<br>A.1       B.2      C.2.0          D.2.5<br>10.下列变量中合法的是(C)。<br>A.        B.3a6b       C._6a7b         D.$ABC<br>11.以下不正确的叙述是(D)。<br>A.在 C 程序中所用的变量必须先定义后使用<br>B.程序中, APH 和 aph 是两个不同的变量<br>C.若 a 和 b 类型相同, 在执行了赋值语句 a &#x3D; b; 后 b 中的值将放入 a 中, b 中的值不变<br>D.当输入数值数据时, 对于整型变量只能输入整型值; 对于实型变量只能输入实型值<br>12.若 x &#x3D; 2, y &#x3D; 3 则 x||y 的结果是(B)。<br>A.0          B.1            C.2          D.3<br>13.C 语言的 if 语句嵌套时, if 与 else 的配对关系是(D)。<br>A. 每个 else 总是与它上面的 if 配对<br>B. 每个 else 总是与最外层的 if 配对<br>C. 每个 else 与 if 的配对是任意的<br>D. 每个 else 总是与它上面的最近的并且尚未与其他 else 匹配的 if 配对<br>14.C 语言的 switch 语句中 case 后(B)。<br>A.只能为常量                                    B.只能为常量或常量表达式<br>C.可为常量或表达式或有确定值的变量及表达式     D.可为任何量或表达式<br>15.有以下程序段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p;<br><span class="hljs-keyword">do</span><br>&#123;  scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p);<br>n++;<br>&#125;<span class="hljs-keyword">while</span>(p!= <span class="hljs-number">12345</span>&amp;&amp;n &lt; <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>此处 do-while 循环的结束条件是(D)。<br>A.p 的值不等于 12345 并且 n 的值小于 3<br>B.p 的值等于 12345 并且 n 的值大于等于 3<br>C.p 的值不等于 12345 或者 n 的值小于 3<br>D.p 的值等于 12345 或者 n 的值大于等于 3<br>16.若 i 为整型变量, 则以下循环执行次数是(D)。<br>for(i &#x3D; 2; i &#x3D;&#x3D; 0;)  printf(“%d”, i–);<br>A.无限次     B. 0 次     C. 1 次     D. 2 次<br>17.下面有关 for 循环的正确描述是(D)。<br>A.for 循环只能用于循环次数已经确定的情况<br>B.for 循环是先执行循环循环体语句, 后判断表达式<br>C.在 for 循环中, 不能用 break 语句跳出循环体<br>D.for 循环的循环体语句中, 可以包含多条语句, 但必须用花括号括起来<br>18.若有说明: int a [10]; 则对 a 数组元素的正确引用是(D)。<br>A. a [10]        B. a [3,5]      C.a(5)       D.a [10-10]<br>19.若二维数组 a 有 m 列, 则在 a [i][j] 前的元素个数为(A)。<br>令 m &#x3D; 4 , i &#x3D; 2, j &#x3D; 2<br>A [2][2] 前 有 21 20 13 12 11 10 03 02 01 00  j*m+i<br>A. j <em>m+I        B.i</em> m+j        C.i <em>m+j-1    D.i</em> m+j+1<br>20.若有说明: int a [ ][3] &#x3D;{1,2,3,4,5,6,7}; 则 a 数组第一维的大小是(B)。<br>A. 2            B.3            C.4          D.无确定值<br>21. 以下不正确的定义语句是(B)。<br>A.double x [5] &#x3D;{2.0,4.0,6.0,8.0,10.0};    B. int y [5] &#x3D;{0,1,3,5,7,9};<br>C.char c1 [ ] &#x3D;{‘1’,’2’,’3’,’4’,’5’};      D. char c2 [ ] &#x3D;{‘\x10’,’\xa’,’\x8’};<br>22.已知 int p(); p 是(C)。<br>A.int 型变量                                  B.函数 p 的调用<br>C.一个函数声明, 该函数的返回值是 int 型的值     D.强制类型转换表达式中的变量<br>23. C 语言中的函数(D)。<br>A.可以嵌套定义                     B.不可以嵌套调用<br>C.可以嵌套调用, 但不能调用自己      D.嵌套调用和调用自己均可<br>24.关于 return 语句, 下列正确的说法是(A)。<br>A. 可以在同一函数中出现多次   B.在主函数中不能出现<br>C. 必须在每个函数中出现       D.只能在除主函数之外的函数中出现一次</p><p>1.C 语言本身不提供输入输出语句, 输入和输出操作是由函数来实现的。（V）<br>2.一个 C 程序可以包含若干个函数。（V）<br>3．C 程序的注释部分可以出现在程序的任何位置，它对程序的编译和运行不起任何作用。但是可以增加程序的可读性。（V）<br>4．C 程序的注释不能是中文文字信息。（X）<br>5.while 和 do…while 循环不论什么条件下它们的结果都是相同的。(X)<br>6.三种循环(while 语句、 for 语句、 do-while 语句)都可以用来处理同一个问题, 一般它们可以相互代替。(V)<br>7.循环嵌套执行时, 先由内层循环进入外层循环。(X)<br>8.break 语句只能用于循环语句中。(X)<br>9.循环结构中的 continue 语句是使整个循环终止执行。(X)<br>10.C 语言的 if 语句嵌套时, if 与 else 的匹配关系是每个 else 与 if 的匹配是任意的。（X）<br>11.main 函数必须写在一个 C 程序的最前面。（  X  ）<br>12.一个 C 程序可以包含若干的函数。（   V ）<br>13.C 程序的注释部分可以出现在程序的任何位置，它对程序的编译和运行不起任何作用。但是可以增加程序的可读性。（  V ）<br>14.C 程序的注释不能是中文文字信息。（  X ）<br>15.在 C 程序中对用到的所有数据都必须指定其数据类型。（ V  ）<br>16.对几个变量在定义时赋初值可以写成：int a &#x3D; b &#x3D; c &#x3D; 3; （  X ）<br>17.自增运算符(++)或自减运算符(–)只能用于变量，不能用于常量或表达式。（ V ）<br>18.在 C 程序的表达式中，为了明确表达式的运算次序，常使用括号 “（）”。（  V ）</p><p>1.若从键盘输入 58，则以下程序输出的结果是           。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <span class="hljs-type">int</span> a;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br> <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">50</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br> <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">40</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br> <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">30</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><p>58<br>2.程序的功能是使一个字符串按逆序存放，请填空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span><br>&#123;<br>    <span class="hljs-type">char</span> str [] =&#123;<span class="hljs-string">&quot;abcdefghijl&quot;</span>&#125;, m;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, j = <span class="hljs-built_in">strlen</span>(str); i &lt;   j        ; i++, j--)<br>    &#123;m = str [i];<br>     str [i] =  str [j<span class="hljs-number">-1</span>]           ;<br>     str [j<span class="hljs-number">-1</span>] = m;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>&#125;<span class="hljs-comment">//交换字符串的第 i 个字符与倒数第 I 个字符</span><br></code></pre></td></tr></table></figure><p>4.若有以下程序<br>i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">nt <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span>(y-x)*x; <br>&#125;<br>main()<br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>, c = <span class="hljs-number">5</span>, d;<br>    d = f(f(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), f(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, d);<br>&#125;<br>F(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)=(<span class="hljs-number">4</span><span class="hljs-number">-3</span>)*<span class="hljs-number">3</span> = <span class="hljs-number">3</span><br>    F(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)=(<span class="hljs-number">5</span><span class="hljs-number">-3</span>)*<span class="hljs-number">3</span> = <span class="hljs-number">6</span><br>    F(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)=(<span class="hljs-number">6</span><span class="hljs-number">-3</span>)*<span class="hljs-number">3</span> = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>执行后输出结果是       9<br>5.下列程序的输出结果是(   1,0           )。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;  <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">switch</span> (x)<br>  &#123; <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: b++; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: a++; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//a = 1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: a++; b++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, a, b);<br>&#125; <br><span class="hljs-number">6.</span>以下程序的运行结果是(   <span class="hljs-number">12457810</span>  )。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;  <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span>(n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">10</span>; n++)<br>&#123;<br><span class="hljs-keyword">if</span>(n%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.下列程序的运行结果是(    1       )。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <span class="hljs-type">int</span> i, j, m = <span class="hljs-number">55</span>;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">3</span>; j &lt;= i; j++) <br>m = m%j;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, m);<br><br>i = <span class="hljs-number">1</span>; j = <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span><br>i = <span class="hljs-number">2</span>; j = <span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span><br>i = <span class="hljs-number">3</span>; j = <span class="hljs-number">3</span> = <span class="hljs-number">3</span>; m = <span class="hljs-number">55</span>%<span class="hljs-number">3</span> = <span class="hljs-number">1</span><br>i = <span class="hljs-number">4</span>; <span class="hljs-keyword">break</span><br>m = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>8.程序运行后的输出结果是(     D          )。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <span class="hljs-type">char</span> a [ ] =&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br> <span class="hljs-type">int</span> i, j;<br> i = <span class="hljs-keyword">sizeof</span>(a)<span class="hljs-number">9</span>; j = <span class="hljs-built_in">strlen</span>(a)<span class="hljs-number">8</span>;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, i, j); &#125;<br></code></pre></td></tr></table></figure><p>A) 9,9<br>B) 8,9<br>C) 1,8<br>D) 9,8<br>9.以下程序的运行结果是(       10,20       )。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>func(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp; &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123; <br>    <span class="hljs-type">int</span> x, y;<br>    x = <span class="hljs-number">10</span>; y = <span class="hljs-number">20</span>;<br>    func(x, y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d\n&quot;</span>, x, y); &#125;<br></code></pre></td></tr></table></figure><p>四、编程题：</p><p>1.编写程序实现，根据输入的年号和月份，输出该月的天数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> year;<br><span class="hljs-type">int</span> month;<br><span class="hljs-type">int</span> day;<br><span class="hljs-built_in">scanf</span>(“请输入年份 year =%d”,&amp;year);<br><span class="hljs-built_in">scanf</span>(“请输入月份 month =%d”,&amp;month);<br><span class="hljs-keyword">if</span>(month &gt;= <span class="hljs-number">1</span>&amp;&amp;month &lt;= <span class="hljs-number">12</span>)&#123;<br>    <span class="hljs-keyword">switch</span>(month)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: day = <span class="hljs-number">31</span>; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">if</span>(year%<span class="hljs-number">4</span> ==<span class="hljs-number">0</span>||year%<span class="hljs-number">100</span>== <span class="hljs-number">0</span>)&#123;day = <span class="hljs-number">29</span>&#125;<span class="hljs-keyword">else</span>&#123;day = <span class="hljs-number">28</span>&#125;; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: day = <span class="hljs-number">30</span>; <span class="hljs-keyword">break</span>;<br>    &#125;<br>    Print(“%d 年%d 月有%d 天”, year, month, day);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">printf</span>(“月份错误,<span class="hljs-number">1</span> &lt;= month &lt;= <span class="hljs-number">12</span>”);<br>&#125;<br><span class="hljs-number">2.</span>求 <span class="hljs-number">100</span>～<span class="hljs-number">200</span> 间的全部素数<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">100</span>; n &lt;= <span class="hljs-number">200</span>; n++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i == n)&#123;<br>                print(“%d”, n);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.编写程序实现：一个班 10 名学生，每名学生选修了三门课程，每名学生每门课程有一个成绩，求每门课程 10 名学生平均成绩.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>Typedf <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-type">int</span> num;<br><span class="hljs-type">float</span> score [<span class="hljs-number">3</span>];<br>&#125; student;<br><br>Void <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>student Students [<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br><span class="hljs-built_in">scanf</span>(“请输入第%d 名学生的第%d 门课程分数”,(i+<span class="hljs-number">1</span>),(j+<span class="hljs-number">1</span>), Students [i]-&gt; score [j]);<br>&#125;<br>&#125; <br>Float avg [<span class="hljs-number">3</span>];<br>Float sum [<span class="hljs-number">3</span>];<br>For(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>For(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>sum [j] += Students [i]-&gt; score [j];<br>&#125;<br>&#125;<br>Printf(“每门课程的平均分数依次是:\n”)<br>For(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>avg [i] = sum [i]/<span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(“第%d 门课程平均分为 %f 分\n”, i+<span class="hljs-number">1</span>, avg [i]);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学校课程</category>
      
      <category>复习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="/post/0293a069-f8d9-4fcd-a321-127459fe4d7d/"/>
    <url>/post/0293a069-f8d9-4fcd-a321-127459fe4d7d/</url>
    
    <content type="html"><![CDATA[<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p><code>hexo template generate by typora plugin templater</code></p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><h5 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>            <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> integers;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) postorderTraversal(root.left);<br>            <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) postorderTraversal(root.right);<br>            integers.add(root.val);<br>            <span class="hljs-keyword">return</span> integers;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>724. 寻找数组的中心下标</title>
    <link href="/post/f7b981ec-6bba-4292-9a59-8cb044181eda/"/>
    <url>/post/f7b981ec-6bba-4292-9a59-8cb044181eda/</url>
    
    <content type="html"><![CDATA[<h3 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h3><p><code>hexo template generate by typora plugin templater</code></p><p>**Description **</p><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是<span class="hljs-number"> 3 </span>。<br>左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 11 </span>，<br>右侧数之和 sum = nums[4] + nums[5] =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 11 </span>，二者相等。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1, 2, 3]</span><br><span class="hljs-string">输出：-1</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">数组中不存在满足此条件的中心下标。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2, 1, -1]<br>输出：0<br>解释：<br>中心下标是<span class="hljs-number"> 0 </span>。<br>左侧数之和 sum =<span class="hljs-number"> 0 </span>，（下标<span class="hljs-number"> 0 </span>左侧不存在元素），<br>右侧数之和 sum = nums[1] + nums[2] =<span class="hljs-number"> 1 </span>+ -1 =<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>注意：</strong> 本题与主站 1991 题相同：<a href="https://leetcode-cn.com/problems/find-the-middle-index-in-array/">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>找到一个位置 , 使得 左右之和相同</p><p>即满足关系 <strong>左侧和 &#x3D; 总和 - nums[i] - 左侧和</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * sum + nums[i] == total) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/find-pivot-index/solutions/579264/xun-zhao-shu-zu-de-zhong-xin-suo-yin-by-gzjle/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">//1.维护两个变量，分别表示当前位置的前后缀和</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//2.第一个位置的后缀和为[1, n-1]元素和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        suffix += nums[i];<br>    &#125;<br>    <span class="hljs-comment">//如果0位置就是中心下标，直接返回</span><br>    <span class="hljs-keyword">if</span>(prefix == suffix) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//3.每次更新当前位置的前后缀和</span><br>    <span class="hljs-comment">//当前位置前缀和：每次加上i-1的数 当前位置后缀和，每次扣除i位置数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        prefix += nums[i - <span class="hljs-number">1</span>];<br>        suffix -= nums[i];<br>        <span class="hljs-keyword">if</span>(prefix == suffix) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio对象存储</title>
    <link href="/post/5ba1c0a2-54bf-4057-b728-bd1ab9191349/"/>
    <url>/post/5ba1c0a2-54bf-4057-b728-bd1ab9191349/</url>
    
    <content type="html"><![CDATA[<h3 id="Minio对象存储"><a href="#Minio对象存储" class="headerlink" title="Minio对象存储"></a>Minio对象存储</h3><p><code>hexo template generate by typora plugin templater</code></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>Docker 快速安装 minio</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">sudo mkdir -p /mnt/minio/data<br><br>sudo docker run \<br>   -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> \<br>   -p <span class="hljs-number">9001</span>:<span class="hljs-number">9001</span> \<br>   --name minio_instance \<br>   -v /mnt/minio/data:/data \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_USER=minio&quot;</span> \<br>   -e <span class="hljs-string">&quot;MINIO_ROOT_PASSWORD=CYhZ632Fa1DnclQXzvmp&quot;</span> \<br>   quay.io/minio/minio server /data --console-address <span class="hljs-string">&quot;:9001&quot;</span><br></code></pre></td></tr></table></figure><p><img src="image-20240707235948167.png" alt="image-20240707235948167"></p><h2 id="MinIO-root-用户"><a href="#MinIO-root-用户" class="headerlink" title="MinIO root 用户"></a><a href="https://www.minio.org.cn/docs/minio/container/administration/identity-access-management/minio-user-management.html#id9">MinIO <code>root</code> 用户</a></h2><p>MinIO部署中有一个名为 <code>root</code> 的用户，该用户可以访问部署上的所有 操作和资源，无论配置了哪种 <a href="https://www.minio.org.cn/docs/minio/container/administration/identity-access-management.html#minio-authentication-and-identity-management">身份管理器（identity manager）</a>。当一个MinIO服务器首次启动时， 它会通过检查以下环境变量的值来设置 <code>root</code> 用户的凭据：</p><ul><li><code>MINIO_ROOT_USER</code></li><li><code>MINIO_ROOT_PASSWORD</code></li></ul><p>要轮换根用户凭据，需要更新部署中所有MinIO服务器上 的一个或两个环境变量。为根凭据指定 <em>长、 唯一且随机</em> 的字符串。 在存储访问密钥和秘密密钥时， 应采取所有可能的预防措施，以确保只有那些已知且受信任且 <em>需要</em> 超级用户访问权限的个人才能检索到 <code>root</code> 凭据。</p><ul><li>MinIO <em>强烈建议</em> 不要在任何环境（开发、测试或生产） 中使用 <code>root</code> 用户进行常规客户端访问。</li><li>MinIO <em>强烈建议</em> 创建用户，以便每个客户端都能访问 到执行其分配的工作负载所需的最小动作和 资源集。</li></ul><p>如果这些变量未设置，<code>minio</code> 将默认使用 <code>minioadmin</code> 作为 访问密钥，以及 <code>minioadmin</code> 作为秘密密钥。 MinIO <em>强烈建议</em> 不要在任何部署环境中 使用默认凭据。</p><h1 id="创建桶"><a href="#创建桶" class="headerlink" title="创建桶"></a>创建桶</h1><p><img src="image-20240708000100406.png" alt="image-20240708000100406"></p><p><img src="image-20240708001654973.png" alt="image-20240708001654973"></p><p>桶默认可以有三种<strong>Access Policy</strong>策略：</p><ul><li><p><strong>public</strong> : 不经过任何认证可以直接访问资源</p></li><li><p><strong>private</strong>  : 桶设置为<strong>private</strong>后，未经授权不能进行任何操作，所有<strong>Access Rules</strong>失效</p></li><li><p><strong>custom</strong> : 这种<strong>Access Policy</strong>策略是通过如下自定义<strong>Access Rules</strong>出现的</p><ul><li><p><strong>readonly</strong> : 可以设置资源不经过授权，只能读取</p></li><li><p><strong>writeonly</strong> : 资源不经过授权，只能写入</p></li><li><p><strong>readwrite</strong> 资源不经过授权，可读可写</p></li></ul></li></ul><p><img src="image-20240708002956819.png" alt="image-20240708002956819"></p><p>手动上传一些测试文件到 <code>minio-example-bucket/images</code> </p><p>设置桶策略为 <strong>public</strong> 时 , 访问资源  <strong>logo.jpg</strong></p><p>路径为 <code>API地址/桶/路径/文件</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http:<span class="hljs-comment">//192.168.0.104:9000/minio-example-bucket/images/logo.jpg</span><br></code></pre></td></tr></table></figure><p>访问成功</p><p><img src="image-20240708003312049.png" alt="image-20240708003312049"></p><p>修改成 <strong>private</strong>后再次访问</p><p><img src="image-20240708003356384.png" alt="image-20240708003356384"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
      <tag>对象存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>收藏夹</title>
    <link href="/post/b828993e-4e2e-44ac-8d7f-b449d09b28d7/"/>
    <url>/post/b828993e-4e2e-44ac-8d7f-b449d09b28d7/</url>
    
    <content type="html"><![CDATA[<h3 id="收藏夹"><a href="#收藏夹" class="headerlink" title="收藏夹"></a>收藏夹</h3><p><code>hexo template generate by typora plugin templater</code></p><h1 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h1><ul><li>收藏夹栏网页工具Edge插件<a href="https://microsoftedge.microsoft.com/addons/detail/adguard-%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%99%A8/pdffkfellgipmhklpdmokmckkkfcopbh?hl=zh-CN">AdGuard 广告拦截器 - Microsoft Edge Addons</a><a href="https://microsoftedge.microsoft.com/addons/detail/%E7%AF%A1%E6%94%B9%E7%8C%B4/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">篡改猴 - Microsoft Edge Addons</a><a href="https://microsoftedge.microsoft.com/addons/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/idghocbbahafpfhjnfhpbfbmpegphmmp?hl=zh-CN">沙拉查词-聚合词典划词翻译 - Microsoft Edge Addons</a><a href="https://microsoftedge.microsoft.com/addons/detail/dark-reader/ifoakfbpdcdoeenechcleahebpibofpc?hl=zh-CN">Dark Reader - Microsoft Edge Addons</a><a href="https://chat2.jinshutuan.com/#/chat/1702545336821">AIchatOS</a><a href="https://up.woozooo.com/mydisk.php">蓝奏云</a><a href="http://24mail.chacuo.net/">临时邮箱</a><a href="https://htmlrev.com/">Free HTML Templates on HTMLrev</a><a href="https://tools.liumingye.cn/">刘明野的工具箱</a><a href="https://wannengrun.net/zh/">万能命令</a><a href="https://dict.youdao.com/">网易有道</a><a href="https://mail.qq.com/cgi-bin/frame_html?sid=HGTR89w-rXEKE0ci&r=d96cd9437067b2597aef84cf9f0eab0c&lang=zh">QQ邮箱</a><a href="https://qwerty.liumingye.cn/">Qwerty Learner</a><a href="https://chat18.aichatos.xyz/#/chat/1703125037985">AIchatOS</a><a href="https://portal.he3app.com/home/category">My categories - He3</a><a href="https://www.laoyujianli.com/">写简历从未如此简单 - 老鱼简历</a><a href="https://www.jyshare.com/front-end/854/">正则表达式在线测试 | 菜鸟工具</a><a href="https://tool.lu/">在线工具 - 你的工具箱</a>图片工具<a href="https://bigjpg.com/zh">AI图片无损放大</a>[PNG转ICO转换器](<a href="https://pngtoicon.com/cn#:~:text=%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BA%BF%E5%B0%86PNG%E8%BD%AC%E6%8D%A2%E4%B8%BAICO">https://pngtoicon.com/cn#:~:text=如何在线将PNG转换为ICO</a> 1 要开始转换，请将一个或多个PNG图像上传到转换器区域。,2 接下来，使用转换设置，然后单击“转换”按钮。 3 转换完成后，您可以单独或在单个存档中下载ICO图像。)<a href="https://photokit.com/editor/?lang=zh">图片编辑器</a><a href="https://watermark.liumingye.cn/">短视频去水印</a><a href="https://imagetostl.com/cn/convert/file/png/to/svg">免费将 PNG 转换为 SVG - ImageToStl</a><a href="https://products.aspose.app/svg/zh/conversion/png-to-svg">PNG 到 SVG 转换器 | 在线免费将 PNG 转换为 SVG！</a><a href="https://www.aconvert.com/cn/image/png-to-svg/">PNG转SVG - 在线转换图像文件</a>加密工具<a href="https://www.cmd5.com/default.aspx">md5在线解密破解,md5解密加密</a><a href="https://openui.fly.dev/ai/f1BV6D01DxmRws93J2Ul9">Chat Application UI</a><a href="https://cyberchef.org/">CyberChef</a><a href="https://cdkm.com/cn/ppt-to-doc">PPT转WORD - 免费在线将PPT文件转换成WORD</a><a href="https://mylivewallpapers.com/page/4/">MyLiveWallpapers.com - Best Live Wallpaper For Your Desktop PC and Mobile Phone</a><a href="https://pan.baidu.com/s/1u7PNExeoEsYGh5pAnSyocg?from=init&pwd=9987#list/path=%2F">3、黑马程序员Java微服务项目《黑马头条》_免费高速下载|百度网盘-分享无限制</a>学校<a href="https://www.sasu.edu.cn/">四川文理学院欢迎您！</a><a href="http://jwc.sasu.edu.cn/web/web/web/index">欢迎进入四川文理学院教学综合管理系统</a><a href="https://hszg.sasu.edu.cn/index.htm">巴山红-大学生思想政治教育特色资源库</a><a href="https://www.zhihuishu.com/">智慧树网</a><a href="https://i.mooc.chaoxing.com/space/index">学习通</a>娱乐<a href="https://music.163.com/">网易云音乐</a><a href="https://y.qq.com/">QQ音乐</a><a href="https://www.kugou.com/">酷狗音乐</a><a href="https://tools.liumingye.cn/music/#/">MyFreeMP3</a><a href="http://www.wpsseo.cn/">全民解析网</a><a href="https://www.douyin.com/">抖音</a><a href="https://v.qq.com/">腾讯视频</a><a href="https://youku.com/">优酷</a><a href="https://www.iqiyi.com/">爱奇艺</a><a href="https://zhutix.com/">致美化</a><a href="https://player.cmov.cn/?url=">全民解析计费 - 高清播放器</a>动漫<a href="https://v.qq.com/x/cover/324olz7ilvo2j5f/y0048yce1wk.html">吞噬星空第107话_动漫_高清完整版视频在线观看_腾讯视频</a><a href="http://pic.netbian.com/">4K壁纸_4K手机壁纸_4K高清壁纸大全_电脑壁纸_4K,5K,6K,7K,8K壁纸图片素材_彼岸图网</a>学习<a href="https://yiyan.baidu.com/">文心一言</a>社区<a href="https://www.csdn.net/">CSDN</a><a href="https://gitee.com/">Gitee</a><a href="https://github.com/">GitHub</a><a href="https://juejin.cn/">稀土掘金</a><a href="https://leetcode.cn/">LeetCode</a><a href="https://www.nowcoder.com/">牛客网</a><a href="https://www.osrc.com/">OSRC-Open Source Runtime Community</a>开发文档后端<a href="https://sa-token.cc/index.html">Sa-Token</a><a href="https://www.justauth.cn/">JustAuth</a><a href="https://www.springcloud.cc/spring-security.html#oauth2login-sample-initial-setup">Spring Security 中文文档 参考手册 中文版</a><a href="https://doc.qzxdp.cn/spring/spring-boot.html#web.servlet">Spring Boot中文文档</a><a href="https://mybatis.org/spring/zh/index.html">Mybatis-Spring</a><a href="https://baomidou.com/">MyBatis-Plus</a><a href="https://mybatis.net.cn/index.html">MyBatis中文网</a><a href="https://webmagic.io/docs/zh/">WebMagic Documents</a><a href="https://www.yuque.com/zilvbenxiangziyou/fue6m0">蜗牛java重点精讲</a><a href="https://www.easy-es.cn/">Easy-Es</a><a href="https://mybatis-flex.com/">MyBatis-Flex - MyBatis-Flex 官方网站</a><a href="https://multipass.run/install">Multipass 编排虚拟 Ubuntu 实例</a>前端<a href="https://www.w3school.com.cn/">w3school 在线教程</a><a href="http://www.layui-vue.com/zh-CN/components/icon">Layui - Vue 前端 UI 框架</a><a href="https://element-plus.org/zh-CN/#/zh-CN">一个 Vue 3 UI 框架 | Element Plus</a><a href="https://router.vuejs.org/zh/">Vue Router | Vue.js 的官方路由</a><a href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js</a><a href="https://uniapp.dcloud.net.cn/quickstart.html#">uni-app快速上手 | uni-app官网</a><a href="https://ts.nodejs.cn/">TypeScript 中文网</a><a href="https://echarts.apache.org/handbook/zh/get-started/">Apache ECharts</a><a href="https://developer.harmonyos.com/">HarmonyOS应用开发官网 - 华为HarmonyOS打造全场景新服务</a><a href="https://www.mdui.org/zh-cn/">mdui - Material Design 3 (Material You) 开源前端组件库，使用 Web Components 实现</a><a href="https://layui.dev/">Layui - 极简模块化前端 UI 组件库(官方文档)</a><a href="https://www.tampermonkey.net/documentation.php#api:GM_deleteValue">文档 | Tampermonkey</a><a href="https://element.eleme.io/">Element - The world’s most popular Vue UI framework</a><a href="https://v2.cn.vuejs.org/">Vue.js</a><a href="https://www.wangeditor.com/">wangEditor</a><a href="https://www.wangeditor.com/v5/content.html#ajax-%E5%BC%82%E6%AD%A5%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AE%B9">内容处理 | wangEditor</a><a href="https://varlet.gitee.io/varlet-ui/#/zh-CN/link">面向 Vue3 的 Material 风格移动端组件库</a><a href="https://primevue.org/uikit/">UI Kit - PrimeVue</a>后端扩展oauth<a href="https://gitee.com/api/v5/oauth_doc#/">Gitee OAuth 文档</a><a href="https://docs.github.com/zh">GitHub Docs</a><a href="https://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0">准备工作_OAuth2.0 — QQ互联WIKI</a><a href="http://localhost:8080/api/auth/oauth2/code/gitee?code=002633296b0f1b5f38aa0e918ac119cad4cf1b218532b28ab705ad910a4019ce">localhost:8080&#x2F;api&#x2F;auth&#x2F;oauth2&#x2F;code&#x2F;gitee?code&#x3D;002633296b0f1b5f38aa0e918ac119cad4cf1b218532b28ab705ad910a4019ce</a><a href="https://app.open.qq.com/p/developer/team_manage/info">开发者信息展示页</a><a href="https://connect.qq.com/manage.html#/">QQ互联管理中心</a><a href="https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html">5 分钟内开始使用标准方言 - Thymeleaf</a><a href="https://javen205.gitee.io/ijpay/">IJPay</a><a href="https://easyexcel.opensource.alibaba.com/">EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel</a><a href="https://sparkjava.com/documentation">Spark Framework</a><a href="https://www.linuxcool.com/">Linux命令大全(手册) – 真正好用的Linux命令在线查询网站</a><a href="https://www.thymeleaf.org/doc/tutorials/3.1/usingthymeleaf.html">教程：使用 Thymeleaf</a><a href="http://easy-trans.fhs-opensource.top/components/faq.html">Easy-Trans | Easy-Trans</a><a href="https://x-file-storage.xuyanwu.cn/#/">XFileStorage</a>QQ机器人QQ官方机器人(api太卡了)<a href="https://bot.q.qq.com/wiki/develop/pythonsdk/#sdk-%E5%AE%89%E8%A3%85">Python SDK 接入指南 | QQ机器人文档</a><a href="https://bot.q.qq.com/wiki/#%E7%AE%80%E4%BB%8B">QQ 机器人 | QQ机器人文档</a><a href="https://github.com/tencent-connect/botpy">GitHub - tencent-connect&#x2F;botpy: QQ频道机器人PythonSDK</a>mirai<a href="https://docs.mirai.mamoe.net/">Mirai QQ机器人</a><a href="https://github.com/mamoe/mirai">GitHub - mamoe&#x2F;mirai: 高效率 QQ 机器人支持库</a>go-cqhttp<a href="https://docs.go-cqhttp.org/">go-cqhttp 帮助中心</a><a href="https://github.com/Mrs4s/go-cqhttp">GitHub - Mrs4s&#x2F;go-cqhttp: cqhttp的golang实现，轻量、原生跨平台.</a>其他<a href="http://blog.fondme.cn/apidoc/jdk-1.8-google/">Overview (Java Platform SE 8 )</a><a href="https://www.w3xue.com/manual/">在线速查手册 - W3xue</a><a href="https://developers.weixin.qq.com/doc/">基础 | 微信开放文档</a><a href="https://q.qq.com/#/">QQ 开放平台</a><a href="https://developer.open-douyin.com/console?type=5">控制台 - 抖音开放平台</a><a href="https://www.runoob.com/">菜鸟教程 - 学的不仅是技术，更是梦想！</a>开发工具<a href="https://devhints.io/">开发者速查表</a><a href="https://uiverse.io/all">3727 UI elements: CSS &amp; Tailwind</a><a href="https://www.free-api.com/">接口大全-免费API,收集所有免费的API</a><a href="https://www.89ip.cn/">免费代理IP_免费HTTP代理IP_SOCKS5代理服务器_优质IP代理_89免费代理IP</a><a href="https://shijianchuo.net/md5/">在线MD5加密</a><a href="https://chat2.jinshutuan.com/#/chat/1702529636770">AIchatOS</a><a href="https://api.gumengya.com/Docs/#/Doc/news">API - 故梦</a><a href="https://uiverse.io/">Explore 3000+ Free UI Elements: CSS &amp; Tailwind</a><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a><a href="https://svgwave.in/">Svg Wave - A free &amp; beautiful gradient SVG wave Generator.</a><a href="https://www.ventoy.net/cn/index.html">Ventoy</a><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>操作系统<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a><a href="https://next.itellyou.cn/Original/">原版软件</a><a href="https://wiki.archlinuxcn.org/zh-hans/">Arch Linux 中文维基</a><a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a><a href="https://www.deepin.org/index/zh">deepin - 基于Linux的开源国产操作系统</a><a href="https://kubuntu.org/">Kubuntu | Friendly Computing</a>博客Maven<a href="https://blog.csdn.net/weixin_44985115/article/details/115253160?ops_request_misc=%7B%22request_id%22:%22170279043216800182182372%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279043216800182182372&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115253160-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=maven&spm=1018.2226.3001.4187">史上最全安装Maven教程</a><a href="https://blog.csdn.net/Q176782/article/details/126628947">Maven打包插件介绍</a><a href="https://blog.csdn.net/weixin_47201411/article/details/125803485">解决maven项目打包运行时出现“没有主清单属性”问题_maven打包没有主清单属性-CSDN博客</a><a href="https://blog.csdn.net/CSDN13822805069/article/details/122858429">JavaWeb项目相关的依赖(Maven仓库)_javaweb项目需要的依赖-CSDN博客</a>JavaEESpring<a href="https://blog.csdn.net/weixin_39709134/article/details/131854218">基于Java+SpringBoot+vue前后端分离在线文档管理系统设计实现_vue文档管理系统-CSDN博客</a><a href="https://blog.csdn.net/qq_41367934/article/details/120268860">Java之spring新手教程(包教包会)_java spring-CSDN博客</a><a href="https://blog.csdn.net/Object_de_Father/article/details/111737733">SpringAOP是啥，怎么用？_什么是springaop-CSDN博客</a><a href="https://blog.csdn.net/fmwind/article/details/81235401">Spring Boot配置接口 WebMvcConfigurer_实现webmvcconfigurer-CSDN博客</a><a href="https://blog.csdn.net/weixin_52850476/article/details/124847728">SSM 整合详细步骤与配置（纯注解）_ssm整合-CSDN博客</a><a href="https://blog.csdn.net/zhangpower1993/article/details/89016503">SpringBoot—WebMvcConfigurer详解-CSDN博客</a><a href="https://blog.csdn.net/weixin_44207403/article/details/106736102">Spring-全面详解（学习总结）_spring全面详解-CSDN博客</a><a href="https://blog.csdn.net/qq_44823283/article/details/125448132">ssm框架中注解总结_ssm框架注解-CSDN博客</a><a href="https://blog.csdn.net/guorui_java/article/details/107347754">Spring常用注解（绝对经典）_spring注解-CSDN博客</a><a href="https://blog.csdn.net/Weixiaohuai/article/details/120853683?ops_request_misc=%7B%22request_id%22:%22170265578916800182118455%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170265578916800182118455&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120853683-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=@autowired%E5%92%8C@resource%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187">Spring中@Autowired和@Resource的区别_spring resource和autowired-CSDN博客</a><a href="https://blog.csdn.net/xu12387/article/details/88818278?ops_request_misc=%7B%22request_id%22:%22170272983116800184119479%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170272983116800184119479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88818278-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=SpringBoot%E4%BD%BF%E7%94%A8Websocket&spm=1018.2226.3001.4187">springboot（十一）WebSocket实现前后端消息推送_java使用webstocket实现前后端互发消息-CSDN博客</a><a href="https://blog.csdn.net/qq_36942720/article/details/135223537?ops_request_misc=%7B%22request_id%22:%22170661795816800185893998%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170661795816800185893998&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-135223537-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=springboot3%E9%9B%86%E6%88%90swagger3&spm=1018.2226.3001.4187">SpringBoot3 整合Swagger_springboot3集成swagger-CSDN博客</a><a href="https://blog.csdn.net/shijizhe1/article/details/130495081?ops_request_misc=&request_id=&biz_id=102&utm_term=SpringDoc%E9%85%8D%E7%BD%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130495081.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">基于SpringBoot3从零配置SpringDoc_springdoc 配置-CSDN博客</a><a href="https://blog.csdn.net/glenshappy/article/details/127526427?ops_request_misc=%7B%22request_id%22:%22171073909316800186583736%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171073909316800186583736&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127526427-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF&spm=1018.2226.3001.4187">spring事务失效的各种场景（13种）_事务失效的几种场景-CSDN博客</a><a href="https://blog.csdn.net/dayuiicghaid/article/details/125260092?ops_request_misc=%7B%22request_id%22:%22171073934416800184193163%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171073934416800184193163&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125260092-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">Spring的7种事务传播机制_spring事务传播机制-CSDN博客</a>SpirngSecurity<a href="https://blog.csdn.net/q66562636/article/details/124914906">SpringSecurity动态鉴权流程解析_springsecurity鉴权-CSDN博客</a><a href="https://blog.csdn.net/weixin_50569789/article/details/123766739?ops_request_misc=%7B%22request_id%22:%22170340687316800180682901%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170340687316800180682901&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123766739-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=springsecurity&spm=1018.2226.3001.4187">SpringSecurity框架【详解】-CSDN博客</a><a href="https://blog.csdn.net/weixin_50569789/article/details/123766739">SpringSecurity框架【详解】-CSDN博客</a><a href="https://blog.csdn.net/heshengfu1211/article/details/123725104">手把手带你在集成SpringSecurity的SpringBoot应用中添加短信验证码登录认证功能_springsecurity账号密码登录或 短信验证码登录-CSDN博客</a><a href="https://blog.csdn.net/heshengfu1211/article/details/123621872">一文梳理SpringSecurity中的登录认证流程_public void com.boco.sdp.auth.handler.authenticati-CSDN博客</a>[Spring Security 6.x 系列（5）—— Servlet 认证体系结构介绍_springsecurity 6.1-CSDN博客](<a href="https://blog.csdn.net/ctwy291314/article/details/134615099?ops_request_misc=%7B%22request_id%22:%22170392388416800185894522%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170392388416800185894522&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-134615099-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=SpringSecurity6">https://blog.csdn.net/ctwy291314/article/details/134615099?ops_request_misc=%7B%22request%5Fid%22%3A%22170392388416800185894522%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170392388416800185894522&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-134615099-null-null.142^v99^pc_search_result_base8&amp;utm_term=SpringSecurity6</a> 获取 providermanager&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://blog.csdn.net/yorickjun/article/details/116645852?ops_request_misc=%7B%22request_id%22:%22170403015016800226518424%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170403015016800226518424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-116645852-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=SpringSecurity%E4%BD%BF%E7%94%A8OAuth%E8%BF%9B%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%88%E6%9D%83&spm=1018.2226.3001.4187">SpringSecurity结合OAuth2实现第三方授权-CSDN博客</a><a href="https://docs.spring.io/spring-security/reference/migration-7/configuration.html#_use_the_lambda_dsl">Configuration Migrations :: Spring Security</a><a href="https://blog.csdn.net/weixin_41866717/article/details/128889475?ops_request_misc=%7B%22request_id%22:%22170434988216800213097969%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170434988216800213097969&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-128889475-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=AuthorizationRequestRepository&spm=1018.2226.3001.4187">Spring Security 源码解读：OAuth2.0 Login Client_spring oauth2.0 login-CSDN博客</a>[新版SpringSecurity配置（SpringBoot＞2.7&amp;SpringSecurity＞5.7）_spring security5.7 配置-CSDN博客](<a href="https://blog.csdn.net/zhongjianboy/article/details/130721399?ops_request_misc=%7B%22request_id%22:%22170454049716777224459308%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170454049716777224459308&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-130721399-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=%E6%96%B0%E7%89%88">https://blog.csdn.net/zhongjianboy/article/details/130721399?ops_request_misc=%7B%22request%5Fid%22%3A%22170454049716777224459308%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170454049716777224459308&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-130721399-null-null.142^v99^pc_search_result_base8&amp;utm_term=新版</a> AuthenticationManager&amp;spm&#x3D;1018.2226.3001.4187)[SpringSecurity系列&#x2F;spring_security_04&#x2F;Spring Security 整合JWT（四）.md · zhengqingya&#x2F;java-workspace - Gitee.com](<a href="https://gitee.com/zhengqingya/java-workspace/blob/master/SpringSecurity%E7%B3%BB%E5%88%97/spring_security_04/Spring">https://gitee.com/zhengqingya/java-workspace/blob/master/SpringSecurity系列/spring_security_04/Spring</a> Security 整合JWT（四）.md#3security访问鉴权中认证用户信息)Mybatis &amp; Mysql数据库<a href="https://blog.csdn.net/progammer10086/article/details/131123422?ops_request_misc=%7B%22request_id%22:%22171080925916800226586423%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171080925916800226586423&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131123422-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=mybatisplus%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90%E8%BF%87%E6%BB%A4&spm=1018.2226.3001.4187">MyBatis Plus 拦截器实现数据权限控制(完整版)_mybatisplus数据权限过滤-CSDN博客</a><a href="https://blog.csdn.net/qq_43437874/article/details/118330067?ops_request_misc=&request_id=&biz_id=102&utm_term=mybatisplus%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-118330067.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">Mybatis-Plus入门系列(18) -基于注解的动态数据权限实现方案_setoperationlist-CSDN博客</a><a href="https://blog.csdn.net/ZGL_cyy/article/details/110668927">Mybatis使用注解方式配置_mybatis 配置类-CSDN博客</a><a href="https://blog.csdn.net/qq_41057885/article/details/125824289">@MapKey用法说明-CSDN博客</a><a href="https://blog.csdn.net/chenbo19867758/article/details/80022354">数据库数值类型对应Integer还是int_integer对应数据库什么类型-CSDN博客</a><a href="https://blog.csdn.net/weixin_44207403/article/details/106565877">mysql全面详解_mysql -h$ip -p$port -u$user -p-CSDN博客</a><a href="https://ximeneschen.blog.csdn.net/article/details/126085063">mybatis中@Results,@ResultMap注解使用-CSDN博客</a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877">MySQL 有这一篇就够（呕心狂敲37k字，只为博君一点赞！！！）_mysql 有这一篇就够(呕心狂敲37k字,只为博君一点赞!!!)-CSDN博客</a><a href="https://blog.csdn.net/zzzgd_666/article/details/100709605?ops_request_misc=%7B%22request_id%22:%22170308102016800182713615%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170308102016800182713615&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-100709605-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=%E9%87%87%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187">使用二进制位来控制权限,表设计_二进制权限-CSDN博客</a>[Mysql存储json格式数据需要掌握的-CSDN博客](<a href="https://blog.csdn.net/weixin_43888891/article/details/130225150?ops_request_misc=%7B%22request_id%22:%22170876648416800213052264%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170876648416800213052264&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130225150-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=mysql">https://blog.csdn.net/weixin_43888891/article/details/130225150?ops_request_misc=%7B%22request%5Fid%22%3A%22170876648416800213052264%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170876648416800213052264&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130225150-null-null.142^v99^pc_search_result_base1&amp;utm_term=mysql</a> 使用JSON一张表存系统所有数据&amp;spm&#x3D;1018.2226.3001.4187)[MYSQL JSON 函数_mysql json函数-CSDN博客](<a href="https://blog.csdn.net/qq_28204635/article/details/125554612?ops_request_misc=%7B%22request_id%22:%22171073176516800184180673%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171073176516800184180673&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125554612-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=mysql">https://blog.csdn.net/qq_28204635/article/details/125554612?ops_request_misc=%7B%22request%5Fid%22%3A%22171073176516800184180673%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171073176516800184180673&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125554612-null-null.142^v99^pc_search_result_base1&amp;utm_term=mysql</a> json函数&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://blog.csdn.net/qq_41071754/article/details/130173193?ops_request_misc=%7B%22request_id%22:%22171080985216800227460728%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171080985216800227460728&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130173193-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=mybatisplus%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6&spm=1018.2226.3001.4187">【MyBatis Plus】004 – MyBatis Plus高级（AR、MP插件、自定义全局操作、自动填充、逻辑删除、枚举、代码生成器）_mybatisplus自定义插件-CSDN博客</a><a href="https://blog.csdn.net/qq_45732538/article/details/132540943?ops_request_misc=%7B%22request_id%22:%22171082757416800186580596%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171082757416800186580596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-132540943-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=ruoyi%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90&spm=1018.2226.3001.4187">ruoyi–数据权限_若依数据权限-CSDN博客</a><a href="https://blog.csdn.net/qq_32077121/article/details/135754286?ops_request_misc=%7B%22request_id%22:%22171602962216800215047119%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171602962216800215047119&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135754286-null-null.142%5Ev100%5Epc_search_result_base3&utm_term=mysql%E7%9A%84data%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BF%81%E7%A7%BB&spm=1018.2226.3001.4187">mysql数据迁移之data目录复制方法_mysql data文件移植-CSDN博客</a>JSP<a href="https://blog.csdn.net/a_helloword/article/details/80193810">JSTL核心标签超详细_jstl核心标签库-CSDN博客</a><a href="https://blog.csdn.net/IT_WEH_coder/article/details/126620622">基于MVC三层架构的图书管理系统（JavaWeb+Maven项目）_基于mvc框架的图书管理系统-CSDN博客</a><a href="https://blog.csdn.net/weixin_29002595/article/details/114113009">java web controller_Java web 编程规范 之 controller规范-CSDN博客</a><a href="https://blog.csdn.net/weixin_41995541/article/details/119716580">Java学习之JavaWeb篇_java web-CSDN博客</a><a href="https://blog.csdn.net/liuduke1/article/details/108302474">通过内网穿透让别人访问自己的JavaWeb项目_让别人访问到我的web项目-CSDN博客</a>Redis<a href="https://blog.csdn.net/weixin_43811057/article/details/120382906?ops_request_misc=&request_id=&biz_id=102&utm_term=springBoot%E4%B8%AD%E4%BD%BF%E7%94%A8Redis&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-120382906.142%5Ev99%5Epc_search_result_base8&spm=1018.2226.3001.4187">springBoot整合redis使用介绍（详细案例）_redis springboot-CSDN博客</a><a href="https://www.runoob.com/redis/redis-keys.html">Redis 键(key) | 菜鸟教程</a><a href="https://blog.csdn.net/zl1zl2zl3/article/details/110987968?ops_request_misc=%7B%22request_id%22:%22170663375516800215083900%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170663375516800215083900&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-110987968-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=Cacheable&spm=1018.2226.3001.4187">SpringBoot 缓存之 @Cacheable 详细介绍-CSDN博客</a><a href="https://blog.csdn.net/qq_56098414/article/details/124770709?ops_request_misc=%7B%22request_id%22:%22170663458516800222856260%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170663458516800222856260&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-124770709-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=@cacheable%E4%B8%8D%E7%94%9F%E6%95%88&spm=1018.2226.3001.4187">@Cacheable未生效的原因_cacheable注解不生效-CSDN博客</a>实用业务<a href="https://blog.csdn.net/wu1317581750/article/details/89355622?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BB%91%E5%AE%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E8%A1%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-89355622.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">如何设计 user 表？加入第三方登录呢？_user identifer 表-CSDN博客</a><a href="https://blog.csdn.net/weixin_65549694/article/details/125055243?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%A4%B1%E5%8E%BB%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-125055243.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">雪花算法生成id，js处理过程中精度损失_解决官方雪花算法长度过长导致js精度丢失问题-CSDN博客</a><a href="https://blog.csdn.net/L___K__/article/details/132535554?ops_request_misc=%7B%22request_id%22:%22170687047716800180663150%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170687047716800180663150&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-132535554-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97&spm=1018.2226.3001.4187">Jackson序列化和反序列化枚举类型_jackson 枚举 反序列化-CSDN博客</a>[一文搞懂Mybatis Plus通用枚举功能使用_mybatisplus 枚举-CSDN博客](<a href="https://blog.csdn.net/qq_37132495/article/details/121433185?ops_request_misc=&request_id=&biz_id=102&utm_term=mybatisplus">https://blog.csdn.net/qq_37132495/article/details/121433185?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mybatisplus</a> 枚举&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb<del>default-5-121433185.142^v99^pc_search_result_base1&amp;spm&#x3D;1018.2226.3001.4187)[springmvc&#x2F;springboot 序列化枚举类&#x2F;枚举转json、转json忽略字段、fastjon&#x2F;jackson指定字段名称&#x2F;自定义字段名称_枚举类转json-CSDN博客](<a href="https://blog.csdn.net/wangjun5159/article/details/122012182?ops_request_misc=%7B%22request_id%22:%22170687120016800180636269%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170687120016800180636269&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2">https://blog.csdn.net/wangjun5159/article/details/122012182?ops_request_misc=%7B%22request%5Fid%22%3A%22170687120016800180636269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170687120016800180636269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2</a></del>all<del>sobaiduend</del>default-1-122012182-null-null.142^v99^pc_search_result_base1&amp;utm_term&#x3D;fastjson序列化枚举&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://blog.csdn.net/fzlhz/article/details/130488405">SpringBoot 采用JsonSerializer和Aop 实现可控制的数据脱敏-CSDN博客</a><a href="https://blog.csdn.net/weixin_41347419/article/details/132811499?ops_request_misc=%7B%22request_id%22:%22171034484416800226538701%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171034484416800226538701&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-132811499-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+JsonSerializer&spm=1018.2226.3001.4187">Jackson 自定义注解扩展实战-CSDN博客</a><a href="https://blog.csdn.net/weixin_43888891/article/details/130438841">Mybatis读取和存储json类型的数据_mybatis json-CSDN博客</a><a href="https://blog.csdn.net/weixin_42633131/article/details/82873731?ops_request_misc=%7B%22request_id%22:%22171204787016800182169692%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171204787016800182169692&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82873731-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=lucene&spm=1018.2226.3001.4187">Lucene介绍与使用-CSDN博客</a><a href="https://blog.csdn.net/m0_37694106/article/details/103997854?ops_request_misc=%7B%22request_id%22:%22171206307016800192263070%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171206307016800192263070&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-103997854-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=lucene%E5%AE%9E%E6%88%98&spm=1018.2226.3001.4187">Lucene入门+实战_lucene实战-CSDN博客</a>[最详细的Lucene实现全文检索_lucene全文检索的实现-CSDN博客](<a href="https://blog.csdn.net/wxc1207/article/details/104968781#2">https://blog.csdn.net/wxc1207/article/details/104968781#2</a>. Lucene介绍)<a href="https://github.com/houbb/sensitive-word?tab=readme-ov-file">houbb&#x2F;sensitive-word: 👮‍♂️The sensitive word tool for java.(敏感词&#x2F;违禁词&#x2F;违法词&#x2F;脏词。基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。请勿发布涉及政治、广告、营销、翻墙、违反国家法律法规等内容。高性能敏感词检测过滤组件，附带繁体简体互换，支持全角半角互换，汉字转拼音，模糊搜索等功能。)</a><a href="https://blog.csdn.net/Ares___/article/details/122102581?ops_request_misc=%7B%22request_id%22:%22170956614116800188551806%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170956614116800188551806&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-122102581-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=vo%E5%8C%85,dto%E5%8C%85%E8%BF%98%E6%9C%89entity%E5%8C%85%E5%BA%94%E8%AF%A5%E5%88%86%E5%88%AB%E6%94%BE%E5%9C%A8%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%E5%90%88%E9%80%82&spm=1018.2226.3001.4187">快速理解 POJO，VO，DO，DTO，Entity_pojo中的vo包-CSDN博客</a><a href="https://blog.csdn.net/qq_42146402/article/details/127133435">【Java全栈学习路线】最全的Java学习路线及知识清单，Java自学方向指引_csdnjava路线-CSDN博客</a>JavaSEswing&amp;&amp;awt<a href="https://blog.csdn.net/weixin_41571493/article/details/81415327">JavaFX极简入门（利用FXML文件）到精通-CSDN博客</a><a href="https://blog.csdn.net/weixin_42436686/article/details/114007170">swing ui主题_仿IntelliJ Darcula的Swing主题FlatLaf使用方法-CSDN博客</a><a href="https://blog.csdn.net/Rwenkai/article/details/103750099">Graphics类使用的解释与思考_getgraphics()-CSDN博客</a><a href="https://blog.csdn.net/weixin_44893902/article/details/107021644">使用 Eclipse 可视化插件 windowbuilder 进行Java GUI开发（插件安装的两种方法）_eclipse jframe插件-CSDN博客</a><a href="https://blog.csdn.net/dkbnull/article/details/48368913">Eclipse开发环境下Java可视化界面编程-CSDN博客</a><a href="https://blog.csdn.net/xietansheng/article/details/72814492">Java Swing 图形界面开发（目录）_swing 目录页效果-CSDN博客</a><a href="https://blog.csdn.net/weixin_43901038/article/details/105527424">java–图形绘绘制_java 绘制彩图和线图-CSDN博客</a><a href="https://blog.csdn.net/weixin_51201930/article/details/122618959">Java Swing界面设计UI（全）_swing ui-CSDN博客</a><a href="https://blog.csdn.net/myweishanli/article/details/39005139">简述 Java 图形用户界面设计 (Swing)_(1)简述java中图形界面设计过程-CSDN博客</a>JDBC<a href="https://blog.csdn.net/weixin_45195665/article/details/108627965">JDBC从入门到熟练使用——功能类详解、增删改查(CRUD)、sql注入、事务、连接池-CSDN博客</a><a href="https://blog.csdn.net/qq_44890539/article/details/106102018">数据库连接池（常用的德鲁伊）_连接池的流是不关闭的吗-CSDN博客</a>反射<a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java基础之—反射（非常重要）-CSDN博客</a>IO流<a href="https://blog.csdn.net/mu_wind/article/details/108674284">【Java基础-3】吃透Java IO：字节流、字符流、缓冲流_缓冲流是字节流吗-CSDN博客</a><a href="https://blog.csdn.net/qq_44543508/article/details/102831084">史上最骚最全最详细的IO流教程，小白都能看懂！_start_input_stream-CSDN博客</a><a href="https://blog.csdn.net/guorui_java/article/details/120643691">Java学习路线总结（思维导图篇）-CSDN博客</a><a href="https://blog.csdn.net/keep12moving/article/details/92666633">什么是javabean及其用法-CSDN博客</a><a href="https://blog.csdn.net/William0318/article/details/102775217">史上最全正则表达式语法，文末附常用表达式！_正则表达式 语法-CSDN博客</a><a href="https://xiaoqijava.blog.csdn.net/article/details/125382015">Java学习路线图-CSDN博客</a><a href="https://blog.csdn.net/m0_37989980/article/details/123391450">Java常用工具类 : StringUtils、CollectionUtils、ArrayUtils、Lists、Maps等_collectionutils map-CSDN博客</a><a href="https://blog.csdn.net/weixin_54963748/article/details/122792274">Java获取图片的RGB值（数字图像处理）_java生成rgb图片-CSDN博客</a><a href="https://blog.csdn.net/weixin_44427181/article/details/124868953">毕业设计不要再做 XX 管理系统了_xx管理系统-CSDN博客</a><a href="https://blog.csdn.net/weixin_44556968/article/details/106568259">Eclipse 从安装、配置、使用、到常见问题以及常用快捷键_eclipse安装时出现的每一个选项是什么-CSDN博客</a>[Java从入门到熟悉的48道练习题<a href="https://blog.csdn.net/m0_47224070/article/details/107349992">完结]_java练习题-CSDN博客</a><a href="https://blog.csdn.net/m0_47224070/article/details/106289745">最实用eclipse常用快捷键_eclipse快速至于末尾-CSDN博客</a>闲谈<a href="https://blog.csdn.net/qq_28168421/article/details/108633288">Github标星超200K，这10个流行的可视化面板你知道几个-CSDN博客</a>爬虫<a href="https://blog.csdn.net/GodTao111/article/details/125260189">java爬虫技术之Selenium爬虫_java selenium 爬虫-CSDN博客</a><a href="https://blog.csdn.net/weixin_43582101/article/details/125905855">sg、xb分析_抖音webmssdk.es5.js-CSDN博客</a><a href="https://blog.csdn.net/u012756235/article/details/123590369">Selenium入门用法详解【Java爬虫】_selenium-java-CSDN博客</a><a href="https://my.oschina.net/flashsword/blog/147334">使用Selenium来抓取动态加载的页面 - 黄亿华的个人空间 - OSCHINA - 中文开源技术交流社区</a><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/?form=MA13LH">Microsoft Edge WebDriver | Microsoft Edge Developer 浏览器驱动</a><a href="https://blog.csdn.net/CYK_byte/article/details/128991985?ops_request_misc=%7B%22request_id%22:%22170978705316800225546993%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170978705316800225546993&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-128991985-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=Seleniumapi&spm=1018.2226.3001.4187">Selenium常用API详解，从入门到进阶（全套）_selenium api-CSDN博客</a><a href="https://www.wetools.com/js-compress">JavaScript 代码压缩工具 - 在线工具-wetools.com微工具</a><a href="https://www.wetools.com/">在线工具大全 | JS加解密 | Base64加解密 | JSON格式化-wetools微工具 - 在线工具-wetools.com微工具</a>数据结构<a href="https://blog.csdn.net/weixin_45682058/article/details/121326496">二叉树：后序遍历非递归算法_二叉树后序遍历非递归-CSDN博客</a><a href="https://blog.csdn.net/jc_hook/article/details/113267537">求子集(递归解法）_递归求子集-CSDN博客</a>Linux<a href="https://blog.csdn.net/qiaoyurensheng/article/details/127872664">windows to go 和 linux to go 制作教程-CSDN博客</a><a href="https://blog.csdn.net/qq_51714354/article/details/116357105">arch linux安装和dwm窗口管理器安装_linux dwm-CSDN博客</a><a href="https://blog.csdn.net/nineya_com/article/details/128244009">Ubuntu 22.04 桌面美化之Mac Big Sur风格_ubuntu美化mac-CSDN博客</a><a href="https://blog.csdn.net/oschina_40530576/article/details/108825394">ubuntu18.04 + windows10双系统使用rEFInd引导(安装rEFInd-minimal主题)_refind主题-CSDN博客</a><a href="https://blog.csdn.net/XM_89/article/details/120403647">【虚拟机】Arch Linux 安装教程(UEFI+GPT)_虚拟机viratualbox安装archlinux教程-CSDN博客</a><a href="https://blog.csdn.net/Linuxprobe18/article/details/127161096">在 Arch Linux 和其他发行版中使用终端连接到 WiFi_archlinux如何连接wifi-CSDN博客</a><a href="https://blog.csdn.net/weixin_39517241/article/details/116944600">linux双系统 引导修复,Linux与windows双系统GRUB引导修复-CSDN博客</a><a href="https://blog.csdn.net/tkzky001/article/details/109110092">dpkg和apt_银河麒麟中dpkg找不到命令-CSDN博客</a><a href="https://cunyu1943.blog.csdn.net/article/details/106248806">玩转 Manjora，原来大神都是这么用 Linux！_manjora linux简介-CSDN博客</a><a href="https://lpwmm.blog.csdn.net/article/details/119056455">在已安装Ventoy的移动设备上安装Linux与配置引导_ventoy linux 安装-CSDN博客</a>解决Bug[No converter for <a href="https://blog.csdn.net/qq_51401283/article/details/126184469">class com.duan.domain.User] with preset Content-Type ‘null‘-CSDN博客</a><a href="https://blog.csdn.net/qq_52889967/article/details/113393225">使用exe4j将java程序打包成可执行文件(.exe)且可以在没有JDK和jre的电脑中运行_exe4j 管理员-CSDN博客</a><a href="https://blog.csdn.net/qq_42701414/article/details/104810570">IDEA 点击右上浏览器访问时直接访问jsp源文件IDEA 点击右上浏览器访问时直接访问jsp源文件_idea点击后直接显示jsp文件-CSDN博客</a><a href="https://justdoit.blog.csdn.net/article/details/89290195">整理一些完全免费开放的API接口_开放性api-CSDN博客</a><a href="https://blog.csdn.net/qq_35999017/article/details/123922952">selenium启动谷歌浏览器的参数设置_enable-automation-CSDN博客</a><a href="https://blog.csdn.net/qq_55069056/article/details/118105044">Tomcat 10中Servlet无法正常使用的解决办法_tomcat 10 ser-CSDN博客</a><a href="https://blog.csdn.net/qq_42898112/article/details/125687691">解决jsp里面写java代码 HTTP 状态 500 - 无法为 JSP 编译类 System.out cannot be resolved to a type_无法为jsp编译类-CSDN博客</a>[openJDK17官方镜像报Error loading shared library libfreetype.so_openjdk17docker镜像-CSDN博客](<a href="https://blog.csdn.net/shengfakun1234/article/details/136565950?ops_request_misc=&request_id=&biz_id=102&utm_term=Error">https://blog.csdn.net/shengfakun1234/article/details/136565950?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Error</a> loading shared library l&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb<del>default-0-136565950.142^v100^pc_search_result_base1&amp;spm&#x3D;1018.2226.3001.4187)C语言<a href="https://blog.csdn.net/m0_63312733/article/details/122145605">C语言初阶——手把手教零基础&#x2F;新手入门（万字心得笔记）_c语言入门自学零基础-CSDN博客</a>Python<a href="https://blog.csdn.net/qq_34160248/article/details/128509402">整理了上千个 Python 工具库，涵盖24个大方向-CSDN博客</a><a href="https://blog.csdn.net/weixin_47163937/article/details/115818021">【建议收藏】三月份开始，二十二个爬虫项目，无套路，附上源码 全部拿走_3月爬虫-CSDN博客</a><a href="https://blog.csdn.net/newlw/article/details/125231235">基于Python的校园学生一卡通管理系统_ttps:&#x2F;&#x2F;download.csdn.net&#x2F;download&#x2F;sheziqiong&#x2F;85609-CSDN博客</a>IDEA[使用 Idea 的 Diagram 功能查看 UML 类图_idea 显示类图-CSDN博客](<a href="https://blog.csdn.net/ttzommed/article/details/114905865?ops_request_misc=%7B%22request_id%22:%22170254113316800211539733%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170254113316800211539733&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2">https://blog.csdn.net/ttzommed/article/details/114905865?ops_request_misc=%7B%22request%5Fid%22%3A%22170254113316800211539733%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170254113316800211539733&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2</a></del>all<del>sobaiduend</del>default-1-114905865-null-null.142^v96^pc_search_result_base8&amp;utm_term&#x3D;IDEA怎么打开类图&amp;spm&#x3D;1018.2226.3001.4187)前端<a href="https://blog.csdn.net/lunahaijiao/article/details/123625379?ops_request_misc=%7B%22request_id%22:%22170279255416800182770520%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279255416800182770520&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123625379-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=TS%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">「1.9W字总结」一份通俗易懂的 TS 教程，入门 + 实战！-CSDN博客</a><a href="https://blog.csdn.net/weixin_47511959/article/details/118152956">CSS——CSS基础（一篇就够用）_css一篇-CSDN博客</a><a href="https://blog.csdn.net/weixin_47511959/article/details/118178073">CSS3总结（核心）_css3 总结-CSDN博客</a><a href="https://blog.csdn.net/qq_56973906/article/details/126774381?ops_request_misc=%7B%22request_id%22:%22170279174016800180639697%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279174016800180639697&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126774381-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=vue%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&spm=1018.2226.3001.4187">Vue-依赖注入（provide-inject）_vue inject-CSDN博客</a><a href="https://blog.csdn.net/weixin_47124112/article/details/126730114?ops_request_misc=%7B%22request_id%22:%22170279146716800188596694%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279146716800188596694&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-126730114-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=vue-router&spm=1018.2226.3001.4187">vue-router 路由超详细教程_vue router-CSDN博客</a>[Vue中watch的详解_vue watch-CSDN博客](<a href="https://blog.csdn.net/weixin_45112114/article/details/125672584?ops_request_misc=%7B%22request_id%22:%22170279200516777224418911%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279200516777224418911&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125672584-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=vue">https://blog.csdn.net/weixin_45112114/article/details/125672584?ops_request_misc=%7B%22request%5Fid%22%3A%22170279200516777224418911%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170279200516777224418911&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125672584-null-null.142^v96^pc_search_result_base8&amp;utm_term=vue</a> watch&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://blog.csdn.net/yifei1234567/article/details/123801171">二、【Vue3】——ref和reactive的使用、区别_vue3ref和reactive区别-CSDN博客</a><a href="https://blog.csdn.net/yifei1234567/article/details/123975970">六、【Vue3】——Vue3生命周期有哪些不同_vue3生命周期的变化-CSDN博客</a><a href="https://blog.csdn.net/yifei1234567/article/details/123992972?ops_request_misc=%7B%22request_id%22:%22170279213616800215079099%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170279213616800215079099&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123992972-null-null.142%5Ev96%5Epc_search_result_base8&utm_term=vue%E7%BB%84%E5%90%88%E5%BC%8Fapi%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">八、【Vue3】——组合式API（Composition API）_组合式api的功能代码一般都放在什么位置-CSDN博客</a>[Vue Router 路由（路由守卫）—route_6. vue-router 守卫?-CSDN博客](<a href="https://blog.csdn.net/yiyueqinghui/article/details/107291509?ops_request_misc=&request_id=&biz_id=102&utm_term=vue-router">https://blog.csdn.net/yiyueqinghui/article/details/107291509?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vue-router</a> 路由守卫&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb<del>default-1-107291509.142^v96^pc_search_result_base8&amp;spm&#x3D;1018.2226.3001.4187)[vue路由切换之淡入淡出_elmentplus页面切换过度效果-CSDN博客](<a href="https://blog.csdn.net/qq_39197547/article/details/81911396?ops_request_misc=%7B%22request_id%22:%22170326018716800213081146%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170326018716800213081146&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2">https://blog.csdn.net/qq_39197547/article/details/81911396?ops_request_misc=%7B%22request%5Fid%22%3A%22170326018716800213081146%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170326018716800213081146&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2</a></del>all<del>first_rank_ecpm_v1</del>rank_v31_ecpm-3-81911396-null-null.142^v96^pc_search_result_base8&amp;utm_term&#x3D;elementplus 路由过渡&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://vue3js.cn/">Vue one peice</a><a href="http://120.79.202.7/">RuoYi 若依官方网站 |后台管理系统|权限管理系统|快速开发框架|企业管理系统|开源框架|微服务框架|前后端分离框架|开源后台系统|RuoYi|RuoYi-Vue|RuoYi-Cloud|RuoYi框架|RuoYi开源|RuoYi视频|若依视频|RuoYi开发文档|若依开发文档|Java开源框架|Java|SpringBoot|SrpingBoot2.0|SrpingCloud|Alibaba|MyBatis|Shiro|OAuth2.0|Thymeleaf|BootStrap|Vue|Element-UI||www.ruoyi.vip</a><a href="https://blog.csdn.net/qinglingLS/article/details/88866438">全栈工程师学习路线（自用）_全栈学习路线-CSDN博客</a>Vue<a href="https://juejin.cn/post/7228990409909108793">Vue3.3 + Vite+ Element-Plus + TypeScript 从0到1搭建企业级后台管理系统（前后端开源） - 掘金</a><a href="edge://newtab/">oo</a><a href="https://juejin.cn/post/6844903476661583880">手摸手，带你用vue撸后台 系列一（基础篇） - 掘金</a><a href="http://localhost:5173/#/home">Vite App</a><a href="http://localhost:8080/hello">hello.html</a><a href="https://blog.csdn.net/lhblmd/article/details/125547525?ops_request_misc=%7B%22request_id%22:%22170862261416800180640925%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170862261416800180640925&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-125547525-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187">状态管理 Pinia-CSDN博客</a><a href="http://127.0.0.1:8080/#/page/4.html">Home</a><a href="https://blog.csdn.net/weixin_43877799/article/details/121536943">js Promise与async&#x2F;await用法详解_js promise away-CSDN博客</a><a href="https://blog.csdn.net/m0_64892344/article/details/131723052?ops_request_misc=%7B%22request_id%22:%22170869066016777224489020%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170869066016777224489020&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-131723052-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=pinina%E6%8C%81%E4%B9%85%E5%8C%96%E6%8F%92%E4%BB%B6&spm=1018.2226.3001.4187">Pinia数据持久化插件_pinia的持久化插件-CSDN博客</a><a href="https://blog.csdn.net/weixin_44860226/article/details/127101707?ops_request_misc=%7B%22request_id%22:%22170869532216800213014190%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170869532216800213014190&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127101707-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=npm%E6%8C%89%E7%85%A7%E4%BE%9D%E8%B5%96%E9%80%9F%E5%BA%A6%E6%85%A2&spm=1018.2226.3001.4187">npm与包及npm包下载速度慢问题的解决_npm下载-CSDN博客</a><a href="https://blog.csdn.net/G_ing/article/details/128192480?ops_request_misc=%7B%22request_id%22:%22170869639516800227495235%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170869639516800227495235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-128192480-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=pinina%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8&spm=1018.2226.3001.4187">快速搞懂Pinia及数据持久化存储(详细教程)_pinia持久化-CSDN博客</a><a href="https://blog.csdn.net/G_ing/article/details/128242848?spm=1001.2014.3001.5502">Pinia实现数据持久化存储_pinia数据持久存储-CSDN博客</a><a href="https://www.douyin.com/user/MS4wLjABAAAAg31Bd6DkzftOlOyPm4k3mJPQXykir-N50cxhZngfbjgKNDkD3D2vlmt5rdxUXgU_?is_search=0&list_name=follow&modal_id=7287424783573093691&nt=0">vue3的抖音 - 抖音 pinia 持久话存储 插件</a><a href="https://blog.csdn.net/dongzi_yu/article/details/126786022?ops_request_misc=&request_id=&biz_id=102&utm_term=fetch%E5%8F%91%E9%80%81post%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-126786022.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">js fetch请求使用_js fetch post-CSDN博客</a><a href="https://blog.csdn.net/qq_59747594/article/details/130303158?ops_request_misc=%7B%22request_id%22:%22170887831016800222880693%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170887831016800222880693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-130303158-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=vue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE&spm=1018.2226.3001.4187">Vue如何实现权限管理（动态路由addRoutes）_vue动态路由导航菜单权限管理-CSDN博客</a>[TS报错大全_一个模块不能具有多个默认导出-CSDN博客](<a href="https://blog.csdn.net/sjajjajusja/article/details/126829562?ops_request_misc=%7B%22request_id%22:%22170912246516800215020782%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170912246516800215020782&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-126829562-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=import">https://blog.csdn.net/sjajjajusja/article/details/126829562?ops_request_misc=%7B%22request%5Fid%22%3A%22170912246516800215020782%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170912246516800215020782&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-126829562-null-null.142^v99^pc_search_result_base1&amp;utm_term=import</a> TS1109%3A Expression expected.&amp;spm&#x3D;1018.2226.3001.4187)<a href="https://pinia.web3doc.top/">Home | Pinia 中文文档</a><a href="https://www.yuque.com/zilvbenxiangziyou/fue6m0/ghe3hre1ya0qum1b">Spring基础 - Spring核心之控制反转(IOC)</a>Windows<a href="https://blog.csdn.net/weixin_45300266/article/details/122359920?ops_request_misc=%7B%22request_id%22:%22171134436816800222831444%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171134436816800222831444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122359920-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=windows%E6%B3%A8%E5%86%8C%E8%A1%A8&spm=1018.2226.3001.4187">Windows 注册表(Registry) 学习_window注册表-CSDN博客</a><a href="https://sxyz.blog/about/">About</a><a href="https://blog.csdn.net/m0_61503020/article/details/125456520?ops_request_misc=%7B%22request_id%22:%22171434564016800225530559%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171434564016800225530559&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125456520-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=docker&spm=1018.2226.3001.4187">运维</a>运维<a href="https://blog.csdn.net/qq_38505969/article/details/114305742?ops_request_misc=&request_id=&biz_id=102&utm_term=docker-compose&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-114305742.142%5Ev100%5Epc_search_result_base1&spm=1018.2226.3001.4187">使用docker-compose高效部署常见应用_docker compose-CSDN博客</a><a href="https://blog.csdn.net/kingsoft88123456/article/details/125548280?ops_request_misc=%7B%22request_id%22:%22171715632316800185891258%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171715632316800185891258&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-125548280-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEwsl&spm=1018.2226.3001.4187">WSL安装及配置_配置wsl-CSDN博客</a>[用docker-compose编排ELK_elk docker 编排-CSDN博客](<a href="https://blog.csdn.net/liu1430016196/article/details/126406938?ops_request_misc=%7B%22request_id%22:%22171824878116800197011549%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171824878116800197011549&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126406938-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=Kibann">https://blog.csdn.net/liu1430016196/article/details/126406938?ops_request_misc=%7B%22request%5Fid%22%3A%22171824878116800197011549%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171824878116800197011549&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126406938-null-null.142^v100^pc_search_result_base9&amp;utm_term=Kibann</a> docker &amp;spm&#x3D;1018.2226.3001.4187)<a href="https://blog.csdn.net/bryanwang_3099/article/details/114649881?ops_request_misc=%7B%22request_id%22:%22172011324116800222820027%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=172011324116800222820027&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-114649881-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee&spm=1018.2226.3001.4187">Hexo 部署到 Gitee_hexo部署gitee-CSDN博客</a>开源前端框架<a href="http://admin.layui-vue.com/#/error/404">layui-vue-admin</a><a href="https://gitee.com/lyt-top/vue-next-admin?_from=gitee_search#https://lyt-top.gitee.io/vue-next-admin-preview/#/login">vue-next-admin: 🎉🎉🔥基于vue3.x 、Typescript、vite、Element plus等，适配手机、平板、pc 的后台开源免费模板库（vue2.x请切换vue-prev-admin分支）</a><a href="https://gitee.com/pear-admin/Pear-Admin-Layui?_from=gitee_search#https://gitee.com/link?target=http%3A%2F%2Fwww.pearadmin.com%2Fdoc">Pear Admin Layui: 🌈 Pear Admin 是 一 款 开 箱 即 用 的 前 端 开 发 模 板</a><a href="https://vue.ruoyi.vip/system/menu">若依管理系统</a><a href="https://uiverse.io/elements">4235 UI elements: CSS &amp; Tailwind</a>开源项目<a href="https://gitee.com/Doocs/md?_from=gitee_search">md: ✍ 一款高度简洁的微信 Markdown 编辑器：支持 Markdown 所有基础语法、色盘取色、一键复制并粘贴到公众号后台、多图上传、一键下载文档、自定义 CSS 样式、一键重置等特性</a><a href="https://gitee.com/halo-dev/halo">halo: 强大易用的开源建站工具。</a><a href="https://gitee.com/y_project/RuoYi-Vue">RuoYi-Vue: 🎉 基于SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统，同时提供了 Vue3 的版本</a><a href="https://gitee.com/flashsword20/webmagic?_from=gitee_search">webmagic: webmagic 是一个无须配置、便于二次开发的爬虫框架，它提供简单灵活的API，只需少量代码即可实现一个爬虫。</a><a href="https://github.com/Naccl/NBlog">Naccl&#x2F;NBlog: 🍓 Spring Boot + Vue 前后端分离博客系统 https://naccl.top</a><a href="https://gitee.com/fastdfs100/fastdfs">FastDFS: FastDFS是一款轻量级的开源分布式文件系统，功能包括：文件存储、文件同步、文件上传、文件下载等，解决了文件大容量存储和高性能访问问题。特别适合以文件为载体的在线服务，如图片、视频、文档服务等等。FastDFS相关文章请搜索微信公众号：fastdfs</a><a href="https://dromara.org/zh/projects/">项目</a><a href="https://github.com/Meekdai/Gmeek">Meekdai&#x2F;Gmeek: Gmeek is a Blog All in Github</a><a href="https://hexo.io/zh-cn/">Hexo</a><a href="https://hexo.io/plugins/">Plugins | Hexo</a><a href="https://github.com/obgnail/typora_plugin?tab=readme-ov-file">obgnail&#x2F;typora_plugin: Typora plugin. Feature enhancement tool | Typora 插件，功能增强工具</a><a href="http://localhost:4000/post/c83e1014-1e8b-401b-8369-ec9a1a9a42c3/">Hexo 与 Typora 最佳组合 - Hexo</a>User<a href="https://homura.live/links/">友链 | Homura’s Blog</a><a href="https://www.bilibili.com/">哔哩哔哩</a>垃圾<a href="https://zhuanlan.zhihu.com/p/686846115">英文简历模板（通用10篇） - 知乎</a><a href="https://ctool.dev/tool.html#/tool/bcrypt?category=encryption">Ctool</a>Local<a href="http://localhost:8080/">8080@localhost</a><a href="http://localhost:5173/">5173@localhost</a><a href="http://192.168.0.104:9999/">1Panel@beelink:9999</a><a href="http://192.168.0.104:9998/#/">CasaOS@beelink:9998</a><a href="http://192.168.0.104:8848/nacos/">Nacos@beelink:8848</a><a href="http://192.168.0.104:9997/">halo@beelink:9997</a><a href="http://192.168.0.104:9001/">MinIO@beelink:9001</a><a href="http://192.168.0.104:8858/#/dashboard">Sentinel Dashboard@beelink:8858</a><a href="http://192.168.0.104:44444/">YesPlayMusic@beelink:44444</a><a href="http://192.168.0.104:40157/#/">文件快递柜-FileCodeBox@beelink:40157</a><a href="http://192.168.0.104:9600/">RabbitMQ@Beelink:9600</a>AI<a href="https://xinghuo.xfyun.cn/">讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞</a><a href="https://chat18.aichatos.xyz/#/chat/1708411710252">AIchatOS</a><a href="https://yiyan.baidu.com/">文心一言</a><a href="https://kimi.moonshot.cn/?utm_campaign=TR_wl2nZci6&utm_content=&utm_medium=B%E7%AB%99&utm_source=CH_E9CmoK5c&utm_term=">Kimi.ai - 帮你看更大的世界</a><a href="https://tongyi.aliyun.com/qianwen?sessionId=a8b5f7a9ac0b4693858ee222207dd7eb">通义</a></li><li><a href="https://www.cnblogs.com/zs0322/p/12289403.html">纯手写！！转移系统用户资料和更改AppData路径的方法 不接受反驳！ - Java_ZS滴水穿石 - 博客园</a></li><li><a href="https://zxmls520.github.io/zxmls/#/">莫老师的附件表</a></li><li><a href="https://blog.csdn.net/GenuineMonster/article/details/83685479">Grub2主题修改和美化——–Linux&amp;Windows-CSDN博客</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo主题安装</title>
    <link href="/post/fgke1014-1e8b-5gjn-8369-ec9a1a9a42c3/"/>
    <url>/post/fgke1014-1e8b-5gjn-8369-ec9a1a9a42c3/</url>
    
    <content type="html"><![CDATA[<p><code>千里之行，始于足下。</code></p><p><strong>hexo 安装参考</strong> <a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a></p><p><strong>hexo 主题安装</strong> <a href="https://hexo.io/themes/">Themes | Hexo</a></p><p>前往主题网站 , 搜索主题 <code>fluid</code> , 可以预览 和前往 github 安装</p><p><img src="image-20240707152913095.png" alt="image-20240707152913095"></p><p>直接克隆这个主题到themes目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><p><img src="image-20240707153426510.png" alt="image-20240707153426510"></p><p>修改<code>Hexo/_config</code>主题配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><p><img src="image-20240707153713218.png" alt="image-20240707153713218"></p><p>将 <code>Hexo/themes/fluid/_config</code>.yml 配置文件复制一份到 hexo 根目录 并命名为 <code>_config.fluid.yml</code></p><p><img src="image-20240707153550259.png" alt="image-20240707153550259"></p><p>这个 <code>_config.fluid.yml</code> 是用户对主题的配置, 优先级高于 默认主题 <code>_config</code> </p><p>这个主题配置中有很多可配置项 , 请自行配置 </p><p>预览结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp; hexo g &amp; hexo s<br></code></pre></td></tr></table></figure><p><img src="image-20240707154309268.png" alt="image-20240707154309268"></p><p><img src="image-20240707154325052.png" alt="image-20240707154325052"></p><p>我的配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># Hexo Theme Fluid</span><br><span class="hljs-comment"># Author: Fluid-dev</span><br><span class="hljs-comment"># Github: https://github.com/fluid-dev/hexo-theme-fluid</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 配置指南: https://hexo.fluid-dev.com/docs/guide/</span><br><span class="hljs-comment"># 你可以从指南中获得更详细的说明</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Guide: https://hexo.fluid-dev.com/docs/en/guide/</span><br><span class="hljs-comment"># You can get more detailed help from the guide</span><br><span class="hljs-comment">#---------------------------</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 全局</span><br><span class="hljs-comment"># Global</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># 用于浏览器标签的图标</span><br><span class="hljs-comment"># Icon for browser tab</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/fluid.png</span><br><br><span class="hljs-comment"># 用于苹果设备的图标</span><br><span class="hljs-comment"># Icon for Apple touch</span><br><span class="hljs-attr">apple_touch_icon:</span> <span class="hljs-string">/img/fluid.png</span><br><br><span class="hljs-comment"># 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名</span><br><span class="hljs-comment"># Title separator in browser tab, eg: article - site</span><br><span class="hljs-attr">tab_title_separator:</span> <span class="hljs-string">&quot; - &quot;</span><br><br><span class="hljs-comment"># 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）</span><br><span class="hljs-comment"># Force all links to be HTTPS (applicable to HTTP mixed error)</span><br><span class="hljs-attr">force_https:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 代码块的增强配置</span><br><span class="hljs-comment"># Enhancements to code blocks</span><br><span class="hljs-attr">code:</span><br>  <span class="hljs-comment"># 是否开启复制代码的按钮</span><br>  <span class="hljs-comment"># Enable copy code button</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 代码语言</span><br>  <span class="hljs-comment"># Code language</span><br>  <span class="hljs-attr">language:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">default:</span> <span class="hljs-string">&quot;TEXT&quot;</span><br><br>  <span class="hljs-comment"># 代码高亮</span><br>  <span class="hljs-comment"># Code highlight</span><br>  <span class="hljs-attr">highlight:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 代码块是否显示行号</span><br>    <span class="hljs-comment"># If true, the code block display line numbers</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 实现高亮的库，对应下面的设置</span><br>    <span class="hljs-comment"># Highlight library</span><br>    <span class="hljs-comment"># Options: highlightjs | prismjs</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-comment"># 在链接中挑选 style 填入</span><br>      <span class="hljs-comment"># Select a style in the link</span><br>      <span class="hljs-comment"># See: https://highlightjs.org/static/demo/</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;github gist&quot;</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span><br><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-comment"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><br>      <span class="hljs-comment"># Select the style button on the right side of the link page, you can also set the CSS link</span><br>      <span class="hljs-comment"># See: https://prismjs.com/</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;tomorrow night&quot;</span><br><br>      <span class="hljs-comment"># 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><br>      <span class="hljs-comment"># If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 一些好玩的功能</span><br><span class="hljs-comment"># Some fun features</span><br><span class="hljs-attr">fun_features:</span><br>  <span class="hljs-comment"># 为 subtitle 添加打字机效果</span><br>  <span class="hljs-comment"># Typing animation for subtitle</span><br>  <span class="hljs-attr">typing:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 打印速度，数字越大越慢</span><br>    <span class="hljs-comment"># Typing speed, the larger the number, the slower</span><br>    <span class="hljs-attr">typeSpeed:</span> <span class="hljs-number">70</span><br><br>    <span class="hljs-comment"># 游标字符</span><br>    <span class="hljs-comment"># Cursor character</span><br>    <span class="hljs-attr">cursorChar:</span> <span class="hljs-string">&quot;_&quot;</span><br><br>    <span class="hljs-comment"># 是否循环播放效果</span><br>    <span class="hljs-comment"># If true, loop animation</span><br>    <span class="hljs-attr">loop:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 在指定页面开启，不填则在所有页面开启</span><br>    <span class="hljs-comment"># Enable in specified page, all pages by default</span><br>    <span class="hljs-comment"># Options: home | post | tag | category | about | links | page | 404</span><br>    <span class="hljs-attr">scope:</span> []<br><br>  <span class="hljs-comment"># 为文章内容中的标题添加锚图标</span><br>  <span class="hljs-comment"># Add an anchor icon to the title on the post page</span><br>  <span class="hljs-attr">anchorjs:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">element:</span> <span class="hljs-string">h1,h2,h3,h4,h5,h6</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br>    <span class="hljs-comment"># Options: hover | always | touch</span><br>    <span class="hljs-attr">visible:</span> <span class="hljs-string">hover</span><br>    <span class="hljs-comment"># Options: § | # | ❡</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-comment"># 加载进度条</span><br>  <span class="hljs-comment"># Progress bar when loading</span><br>  <span class="hljs-attr">progressbar:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">height_px:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#29d&quot;</span><br>    <span class="hljs-comment"># See: https://github.com/rstacruz/nprogress</span><br>    <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">showSpinner:</span> <span class="hljs-literal">false</span>, <span class="hljs-attr">trickleSpeed:</span> <span class="hljs-number">100</span> &#125;<br><br><span class="hljs-comment"># 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换</span><br><span class="hljs-comment"># Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor&#x27;s browser will store his switch option</span><br><span class="hljs-attr">dark_mode:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式</span><br>  <span class="hljs-comment"># Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time</span><br>  <span class="hljs-comment"># Options: auto | light | dark</span><br>  <span class="hljs-attr">default:</span> <span class="hljs-string">auto</span><br><br><span class="hljs-comment"># 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发</span><br><span class="hljs-comment"># Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below</span><br><span class="hljs-comment"># See: https://www.webdesignrankings.com/resources/lolcolors/</span><br><span class="hljs-attr">color:</span><br>  <span class="hljs-comment"># body 背景色</span><br>  <span class="hljs-comment"># Color of body background</span><br>  <span class="hljs-attr">body_bg_color:</span> <span class="hljs-string">&quot;#eee&quot;</span><br>  <span class="hljs-comment"># 暗色模式下的 body 背景色，下同</span><br>  <span class="hljs-comment"># Color in dark mode, the same below</span><br>  <span class="hljs-attr">body_bg_color_dark:</span> <span class="hljs-string">&quot;#181c27&quot;</span><br><br>  <span class="hljs-comment"># 顶部菜单背景色</span><br>  <span class="hljs-comment"># Color of navigation bar background</span><br>  <span class="hljs-attr">navbar_bg_color:</span> <span class="hljs-string">&quot;#2f4154&quot;</span><br>  <span class="hljs-attr">navbar_bg_color_dark:</span> <span class="hljs-string">&quot;#1f3144&quot;</span><br><br>  <span class="hljs-comment"># 顶部菜单字体色</span><br>  <span class="hljs-comment"># Color of navigation bar text</span><br>  <span class="hljs-attr">navbar_text_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">navbar_text_color_dark:</span> <span class="hljs-string">&quot;#d0d0d0&quot;</span><br><br>  <span class="hljs-comment"># 副标题字体色</span><br>  <span class="hljs-comment"># Color of navigation bar text</span><br>  <span class="hljs-attr">subtitle_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">subtitle_color_dark:</span> <span class="hljs-string">&quot;#d0d0d0&quot;</span><br><br>  <span class="hljs-comment"># 全局字体色</span><br>  <span class="hljs-comment"># Color of global text</span><br>  <span class="hljs-attr">text_color:</span> <span class="hljs-string">&quot;#3c4858&quot;</span><br>  <span class="hljs-attr">text_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 全局次级字体色（摘要、简介等位置）</span><br>  <span class="hljs-comment"># Color of global secondary text (excerpt, introduction, etc.)</span><br>  <span class="hljs-attr">sec_text_color:</span> <span class="hljs-string">&quot;#718096&quot;</span><br>  <span class="hljs-attr">sec_text_color_dark:</span> <span class="hljs-string">&quot;#a7a9ad&quot;</span><br><br>  <span class="hljs-comment"># 主面板背景色</span><br>  <span class="hljs-comment"># Color of main board</span><br>  <span class="hljs-attr">board_color:</span> <span class="hljs-string">&quot;#fff&quot;</span><br>  <span class="hljs-attr">board_color_dark:</span> <span class="hljs-string">&quot;#252d38&quot;</span><br><br>  <span class="hljs-comment"># 文章正文字体色</span><br>  <span class="hljs-comment"># Color of post text</span><br>  <span class="hljs-attr">post_text_color:</span> <span class="hljs-string">&quot;#2c3e50&quot;</span><br>  <span class="hljs-attr">post_text_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 文章正文字体色（h1 h2 h3...）</span><br>  <span class="hljs-comment"># Color of Article heading (h1 h2 h3...)</span><br>  <span class="hljs-attr">post_heading_color:</span> <span class="hljs-string">&quot;#1a202c&quot;</span><br>  <span class="hljs-attr">post_heading_color_dark:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br><br>  <span class="hljs-comment"># 文章超链接字体色</span><br>  <span class="hljs-comment"># Color of post link</span><br>  <span class="hljs-attr">post_link_color:</span> <span class="hljs-string">&quot;#0366d6&quot;</span><br>  <span class="hljs-attr">post_link_color_dark:</span> <span class="hljs-string">&quot;#1589e9&quot;</span><br><br>  <span class="hljs-comment"># 超链接悬浮时字体色</span><br>  <span class="hljs-comment"># Color of link when hovering</span><br>  <span class="hljs-attr">link_hover_color:</span> <span class="hljs-string">&quot;#30a9de&quot;</span><br>  <span class="hljs-attr">link_hover_color_dark:</span> <span class="hljs-string">&quot;#30a9de&quot;</span><br><br>  <span class="hljs-comment"># 超链接悬浮背景色</span><br>  <span class="hljs-comment"># Color of link background when hovering</span><br>  <span class="hljs-attr">link_hover_bg_color:</span> <span class="hljs-string">&quot;#f8f9fa&quot;</span><br>  <span class="hljs-attr">link_hover_bg_color_dark:</span> <span class="hljs-string">&quot;#364151&quot;</span><br><br>  <span class="hljs-comment"># 分隔线和表格边线的颜色</span><br>  <span class="hljs-comment"># Color of horizontal rule and table border</span><br>  <span class="hljs-attr">line_color:</span> <span class="hljs-string">&quot;#eaecef&quot;</span><br>  <span class="hljs-attr">line_color_dark:</span> <span class="hljs-string">&quot;#435266&quot;</span><br><br>  <span class="hljs-comment"># 滚动条颜色</span><br>  <span class="hljs-comment"># Color of scrollbar</span><br>  <span class="hljs-attr">scrollbar_color:</span> <span class="hljs-string">&quot;#c4c6c9&quot;</span><br>  <span class="hljs-attr">scrollbar_color_dark:</span> <span class="hljs-string">&quot;#687582&quot;</span><br>  <span class="hljs-comment"># 滚动条悬浮颜色</span><br>  <span class="hljs-comment"># Color of scrollbar when hovering</span><br>  <span class="hljs-attr">scrollbar_hover_color:</span> <span class="hljs-string">&quot;#a6a6a6&quot;</span><br>  <span class="hljs-attr">scrollbar_hover_color_dark:</span> <span class="hljs-string">&quot;#9da8b3&quot;</span><br><br>  <span class="hljs-comment"># 按钮背景色</span><br>  <span class="hljs-comment"># Color of button</span><br>  <span class="hljs-attr">button_bg_color:</span> <span class="hljs-string">&quot;transparent&quot;</span><br>  <span class="hljs-attr">button_bg_color_dark:</span> <span class="hljs-string">&quot;transparent&quot;</span><br>  <span class="hljs-comment"># 按钮悬浮背景色</span><br>  <span class="hljs-comment"># Color of button when hovering</span><br>  <span class="hljs-attr">button_hover_bg_color:</span> <span class="hljs-string">&quot;#f2f3f5&quot;</span><br>  <span class="hljs-attr">button_hover_bg_color_dark:</span> <span class="hljs-string">&quot;#46647e&quot;</span><br><br><span class="hljs-comment"># 主题字体配置</span><br><span class="hljs-comment"># Font</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">16px</span><br>  <span class="hljs-attr">font_family:</span><br>  <span class="hljs-attr">letter_spacing:</span> <span class="hljs-number">0.</span><span class="hljs-string">02em</span><br>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-number">85</span><span class="hljs-string">%</span><br><br><span class="hljs-comment"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span><br><span class="hljs-comment"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span><br><span class="hljs-attr">custom_js:</span><br><br><span class="hljs-comment"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span><br><span class="hljs-comment"># The usage is the same as custom_js</span><br><span class="hljs-attr">custom_css:</span><br><br><span class="hljs-comment"># 网页访问统计</span><br><span class="hljs-comment"># Analysis of website visitors</span><br><span class="hljs-attr">web_analytics:</span>  <span class="hljs-comment"># 网页访问统计</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># 遵循访客浏览器&quot;请勿追踪&quot;的设置，如果开启则不统计其访问</span><br>  <span class="hljs-comment"># Follow the &quot;Do Not Track&quot; setting of the visitor&#x27;s browser</span><br>  <span class="hljs-comment"># See: https://www.w3.org/TR/tracking-dnt/</span><br>  <span class="hljs-attr">follow_dnt:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串</span><br>  <span class="hljs-comment"># Baidu analytics, get the string behind `hm.js?`</span><br>  <span class="hljs-comment"># See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376</span><br>  <span class="hljs-attr">baidu:</span><br><br>  <span class="hljs-comment"># Google Analytics 4 的媒体资源 ID</span><br>  <span class="hljs-comment"># Google Analytics 4 MEASUREMENT_ID</span><br>  <span class="hljs-comment"># See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article</span><br>  <span class="hljs-attr">google:</span><br>    <span class="hljs-attr">measurement_id:</span><br><br>  <span class="hljs-comment"># 腾讯统计的 H5 App ID，开启高级功能才有cid</span><br>  <span class="hljs-comment"># Tencent analytics, set APP ID</span><br>  <span class="hljs-comment"># See: https://mta.qq.com/h5/manage/ctr_app_manage</span><br>  <span class="hljs-attr">tencent:</span><br>    <span class="hljs-attr">sid:</span><br>    <span class="hljs-attr">cid:</span><br><br>  <span class="hljs-comment"># 51.la 站点统计 ID</span><br>  <span class="hljs-comment"># 51.la analytics</span><br>  <span class="hljs-comment"># See: https://www.51.la/user/site/index</span><br>  <span class="hljs-attr">woyaola:</span>  <span class="hljs-comment"># 51.la 站点统计 ID，参见</span><br><br>  <span class="hljs-comment"># 友盟/cnzz 站点统计 web_id</span><br>  <span class="hljs-comment"># cnzz analytics</span><br>  <span class="hljs-comment"># See: https://web.umeng.com/main.php?c=site&amp;a=show</span><br>  <span class="hljs-attr">cnzz:</span><br><br>  <span class="hljs-comment"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>  <span class="hljs-comment"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span><br>  <span class="hljs-attr">leancloud:</span><br>    <span class="hljs-attr">app_id:</span><br>    <span class="hljs-attr">app_key:</span><br>    <span class="hljs-comment"># REST API 服务器地址，国际版不填</span><br>    <span class="hljs-comment"># Only the Chinese mainland users need to set</span><br>    <span class="hljs-attr">server_url:</span><br>    <span class="hljs-comment"># 统计页面时获取路径的属性</span><br>    <span class="hljs-comment"># Get the attribute of the page path during statistics</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>    <span class="hljs-comment"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class="hljs-comment"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class="hljs-attr">ignore_local:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载</span><br><span class="hljs-comment"># Lazy loading of images and comment plugin on the page</span><br><span class="hljs-attr">lazyload:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 加载时的占位图片</span><br>  <span class="hljs-comment"># The placeholder image when loading</span><br>  <span class="hljs-attr">loading_img:</span> <span class="hljs-string">/img/loading.gif</span><br><br>  <span class="hljs-comment"># 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`</span><br>  <span class="hljs-comment"># If true, only enable lazyload on the post page. For custom pages, you can set &#x27;lazyload: true&#x27; in front-matter</span><br>  <span class="hljs-attr">onlypost:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节</span><br>  <span class="hljs-comment"># The factor of viewport height that triggers loading</span><br>  <span class="hljs-attr">offset_factor:</span> <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/</span><br><span class="hljs-comment"># Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/</span><br><span class="hljs-attr">iconfont:</span> <span class="hljs-string">//at.alicdn.com/t/font_1736178_lbnruvf0jn.css</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 页头</span><br><span class="hljs-comment"># Header</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># 导航栏的相关配置</span><br><span class="hljs-comment"># Navigation bar</span><br><span class="hljs-attr">navbar:</span><br>  <span class="hljs-comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class="hljs-comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;Hexo&quot;</span><br><br>  <span class="hljs-comment"># 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效</span><br>  <span class="hljs-comment"># Navigation bar frosted glass special animation. It is an experimental feature</span><br>  <span class="hljs-attr">ground_glass:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 模糊像素，只能为数字，数字越大模糊度越高</span><br>    <span class="hljs-comment"># Number of blurred pixel. the larger the number, the higher the blur</span><br>    <span class="hljs-attr">px:</span> <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体</span><br>    <span class="hljs-comment"># Ratio of opacity, 1.0 is completely opaque</span><br>    <span class="hljs-comment"># available: 0 - 1.0</span><br>    <span class="hljs-attr">alpha:</span> <span class="hljs-number">0.7</span><br><br>  <span class="hljs-comment"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br>  <span class="hljs-comment"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br>  <span class="hljs-attr">menu:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;archive&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/archives/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/categories/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/tags/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;about&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/about/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;links&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;/links/&quot;</span>, <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-link-fill&quot;</span> &#125;<br><br><span class="hljs-comment"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件</span><br><span class="hljs-comment"># Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files</span><br><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 搜索索引文件的路径，可以是相对路径或外站的绝对路径</span><br>  <span class="hljs-comment"># Path for search index file, it can be a relative path or an absolute path</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/local-search.xml</span><br><br>  <span class="hljs-comment"># 文件生成在本地的位置，必须是相对路径</span><br>  <span class="hljs-comment"># The location where the index file is generated locally, it must be a relative location</span><br>  <span class="hljs-attr">generate_path:</span> <span class="hljs-string">/local-search.xml</span><br><br>  <span class="hljs-comment"># 搜索的范围</span><br>  <span class="hljs-comment"># Search field</span><br>  <span class="hljs-comment"># Options: post | page | all</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">all</span><br><br>  <span class="hljs-comment"># 搜索是否扫描正文</span><br>  <span class="hljs-comment"># If true, search will scan the post content</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 首屏图片的相关配置</span><br><span class="hljs-comment"># Config of the big image on the first screen</span><br><span class="hljs-attr">banner:</span><br>  <span class="hljs-comment"># 视差滚动，图片与板块会随着屏幕滚动产生视差效果</span><br>  <span class="hljs-comment"># Scrolling parallax</span><br>  <span class="hljs-attr">parallax:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0</span><br>  <span class="hljs-comment"># Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0</span><br>  <span class="hljs-attr">width_height_ratio:</span> <span class="hljs-number">1.0</span><br><br><span class="hljs-comment"># 向下滚动的箭头</span><br><span class="hljs-comment"># Scroll down arrow</span><br><span class="hljs-attr">scroll_down_arrow:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 头图高度不小于指定比例，才显示箭头</span><br>  <span class="hljs-comment"># Only the height of the banner image is greater than the ratio, the arrow is displayed</span><br>  <span class="hljs-comment"># Available: 0 - 100</span><br>  <span class="hljs-attr">banner_height_limit:</span> <span class="hljs-number">80</span><br><br>  <span class="hljs-comment"># 翻页后自动滚动</span><br>  <span class="hljs-comment"># Auto scroll after page turning</span><br>  <span class="hljs-attr">scroll_after_turning_page:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 向顶部滚动的箭头</span><br><span class="hljs-comment"># Scroll top arrow</span><br><span class="hljs-attr">scroll_top_arrow:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># Open Graph metadata</span><br><span class="hljs-comment"># See: https://hexo.io/docs/helpers.html#open-graph</span><br><span class="hljs-attr">open_graph:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">twitter_card:</span> <span class="hljs-string">summary_large_image</span><br>  <span class="hljs-attr">twitter_id:</span><br>  <span class="hljs-attr">twitter_site:</span><br>  <span class="hljs-attr">google_plus:</span><br>  <span class="hljs-attr">fb_admins:</span><br>  <span class="hljs-attr">fb_app_id:</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 页脚</span><br><span class="hljs-comment"># Footer</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题</span><br>  <span class="hljs-comment"># HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><br><span class="hljs-string">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><br><span class="hljs-string">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><br><span class="hljs-string">  &lt;div style=&quot;font-size: 0.85rem&quot;&gt;</span><br><span class="hljs-string">      &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="hljs-string">      &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="hljs-string">      &lt;script src=&quot;/js/duration.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  &#x27;</span><br><br>  <span class="hljs-comment"># 展示网站的 PV、UV 统计数</span><br>  <span class="hljs-comment"># Display website PV and UV statistics</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br>    <span class="hljs-comment"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span><br>    <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br><br>  <span class="hljs-comment"># 国内大陆服务器的备案信息</span><br>  <span class="hljs-comment"># For Chinese mainland website policy, other areas keep disable</span><br>  <span class="hljs-attr">beian:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># ICP证号</span><br>    <span class="hljs-attr">icp_text:</span> <span class="hljs-string">京ICP证123456号</span><br>    <span class="hljs-comment"># 公安备案号，不填则只显示ICP</span><br>    <span class="hljs-attr">police_text:</span> <span class="hljs-string">京公网安备12345678号</span><br>    <span class="hljs-comment"># 公安备案的编号，用于URL跳转查询</span><br>    <span class="hljs-attr">police_code:</span> <span class="hljs-number">12345678</span><br>    <span class="hljs-comment"># 公安备案的图片. 为空时不显示备案图片</span><br>    <span class="hljs-attr">police_icon:</span> <span class="hljs-string">/img/police_beian.png</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 首页</span><br><span class="hljs-comment"># Home Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">index:</span><br>  <span class="hljs-comment"># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同</span><br>  <span class="hljs-comment"># Path of Banner image, can be a relative path or an absolute path, the same on other pages</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-home.webp</span><br><br>  <span class="hljs-comment"># 头图高度，屏幕百分比</span><br>  <span class="hljs-comment"># Height ratio of banner image</span><br>  <span class="hljs-comment"># Available: 0 - 100</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">100</span><br><br>  <span class="hljs-comment"># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明</span><br>  <span class="hljs-comment"># Opacity of the banner mask, 1.0 is completely opaque</span><br>  <span class="hljs-comment"># Available: 0 - 1.0</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 首页副标题的独立设置</span><br>  <span class="hljs-comment"># Independent config of home page subtitle</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 为空则按 hexo config.subtitle 显示</span><br>    <span class="hljs-comment"># If empty, text based on `subtitle` in hexo config</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;An elegant Material-Design theme for Hexo&quot;</span><br><br>    <span class="hljs-comment"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>    <span class="hljs-comment"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>    <span class="hljs-attr">api:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>      <span class="hljs-comment"># 请求地址</span><br>      <span class="hljs-comment"># Request url</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span><br><br>      <span class="hljs-comment"># 请求方法</span><br>      <span class="hljs-comment"># Request method</span><br>      <span class="hljs-comment"># Available: GET | POST | PUT</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;GET&quot;</span><br><br>      <span class="hljs-comment"># 请求头</span><br>      <span class="hljs-comment"># Request headers</span><br>      <span class="hljs-attr">headers:</span> &#123;&#125;<br><br>      <span class="hljs-comment"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span><br>      <span class="hljs-comment"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span><br>      <span class="hljs-attr">keys:</span> [<span class="hljs-string">&quot;hitokoto&quot;</span>]<br><br>  <span class="hljs-comment"># 自动截取文章摘要</span><br>  <span class="hljs-comment"># Auto extract post</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 打开文章的标签方式</span><br>  <span class="hljs-comment"># The browser tag to open the post</span><br>  <span class="hljs-comment"># Available: _blank | _self</span><br>  <span class="hljs-attr">post_url_target:</span> <span class="hljs-string">_self</span><br><br>  <span class="hljs-comment"># 是否显示文章信息（时间、分类、标签）</span><br>  <span class="hljs-comment"># Meta information of post</span><br>  <span class="hljs-attr">post_meta:</span><br>    <span class="hljs-attr">date:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章通过 sticky 排序后，在首页文章标题前显示图标</span><br>  <span class="hljs-comment"># If the posts are sorted by `sticky`, an icon is displayed in front of the post title</span><br>  <span class="hljs-attr">post_sticky:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;iconfont icon-top&quot;</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 文章页</span><br><span class="hljs-comment"># Post Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-article.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">70</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片</span><br>  <span class="hljs-comment"># Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed</span><br>  <span class="hljs-attr">default_index_img:</span><br><br>  <span class="hljs-comment"># 文章标题下方的元信息</span><br>  <span class="hljs-comment"># Meta information below title</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-comment"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>    <span class="hljs-comment"># Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>    <span class="hljs-comment"># Post date, based on `date` field in front-matter, if not set, based on create date of .md file</span><br>    <span class="hljs-attr">date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>      <span class="hljs-comment"># ISO-8601 date format</span><br>      <span class="hljs-comment"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL a&quot;</span><br><br>    <span class="hljs-comment"># 字数统计</span><br>    <span class="hljs-comment"># Word count</span><br>    <span class="hljs-attr">wordcount:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 估计阅读全文需要的时长</span><br>    <span class="hljs-comment"># Estimated reading time</span><br>    <span class="hljs-attr">min2read:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节</span><br>      <span class="hljs-comment"># Average word length (chars count in word), ZH ≈ 2, EN ≈ 5</span><br>      <span class="hljs-attr">awl:</span> <span class="hljs-number">2</span><br>      <span class="hljs-comment"># 每分钟阅读字数，如果大部分是技术文章可适度调低</span><br>      <span class="hljs-comment"># Words per minute</span><br>      <span class="hljs-attr">wpm:</span> <span class="hljs-number">60</span><br><br>    <span class="hljs-comment"># 浏览量计数</span><br>    <span class="hljs-comment"># Number of visits</span><br>    <span class="hljs-attr">views:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-comment"># 统计数据来源</span><br>      <span class="hljs-comment"># Data Source</span><br>      <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;busuanzi&quot;</span><br><br>  <span class="hljs-comment"># 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）</span><br>  <span class="hljs-comment"># Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)</span><br>  <span class="hljs-attr">updated:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 格式参照 ISO-8601 日期格式化</span><br>    <span class="hljs-comment"># ISO-8601 date format</span><br>    <span class="hljs-comment"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>    <span class="hljs-attr">date_format:</span> <span class="hljs-string">&quot;LL a&quot;</span><br><br>    <span class="hljs-comment"># 是否使用相对时间表示，比如：&quot;3 天前&quot;</span><br>    <span class="hljs-comment"># If true, it will be a relative time, such as: &quot;3 days ago&quot;</span><br>    <span class="hljs-attr">relative:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 提示标签类型</span><br>    <span class="hljs-comment"># Note class</span><br>    <span class="hljs-comment"># Options: default | primary | info | success | warning | danger | light</span><br>    <span class="hljs-attr">note_class:</span> <span class="hljs-string">info</span><br><br>  <span class="hljs-comment"># 侧边栏展示当前分类下的文章</span><br>  <span class="hljs-comment"># Sidebar of category</span><br>  <span class="hljs-attr">category_bar:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class="hljs-comment"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br><br>    <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>    <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;title&quot;</span><br><br>    <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class="hljs-attr">post_limit:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 侧边栏展示文章目录</span><br>  <span class="hljs-comment"># Table of contents (TOC) in the sidebar</span><br>  <span class="hljs-attr">toc:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 置于板块的左侧或右侧</span><br>    <span class="hljs-comment"># place in the board</span><br>    <span class="hljs-comment"># Options: left | right</span><br>    <span class="hljs-attr">placement:</span> <span class="hljs-string">right</span><br><br>    <span class="hljs-comment"># 目录会选择这些节点作为标题</span><br>    <span class="hljs-comment"># TOC will select these nodes as headings</span><br>    <span class="hljs-attr">headingSelector:</span> <span class="hljs-string">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class="hljs-comment"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class="hljs-attr">collapseDepth:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class="hljs-comment"># Copyright, will be displayed at the end of each post</span><br>  <span class="hljs-attr">copyright:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># CreativeCommons license</span><br>    <span class="hljs-comment"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class="hljs-attr">license:</span> <span class="hljs-string">&#x27;BY&#x27;</span><br><br>    <span class="hljs-comment"># 显示作者</span><br>    <span class="hljs-attr">author:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 显示发布日期</span><br>    <span class="hljs-comment"># Show post date</span><br>    <span class="hljs-attr">post_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>    <span class="hljs-comment"># 显示更新日期</span><br>    <span class="hljs-comment"># Show update date</span><br>    <span class="hljs-attr">update_date:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;LL&quot;</span><br><br>  <span class="hljs-comment"># 文章底部上一篇下一篇功能</span><br>  <span class="hljs-comment"># Link to previous/next post</span><br>  <span class="hljs-attr">prev_next:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片标题</span><br>  <span class="hljs-comment"># Image caption</span><br>  <span class="hljs-attr">image_caption:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 文章图片可点击放大</span><br>  <span class="hljs-comment"># Zoom feature of images</span><br>  <span class="hljs-attr">image_zoom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;, &#x27;&#x27;]</span><br>    <span class="hljs-comment"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\d&#123;3,4&#125;\\/\\d&#123;3,4&#125;\\/&#x27;,&#x27;&#x27;]</span><br>    <span class="hljs-attr">img_url_replace:</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><br>  <span class="hljs-comment"># 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突</span><br>  <span class="hljs-comment"># Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict</span><br>  <span class="hljs-attr">footnote:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 脚注的节标题，也可以在 front-matter 中通过 `foot<span class="hljs-doctag">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` 这种形式修改单独页面的 header</span><br>    <span class="hljs-comment"># The section title of the footnote, you can also modify the header of a single page in the form of `foot<span class="hljs-doctag">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` in front-matter</span><br>    <span class="hljs-attr">header:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-comment"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br>  <span class="hljs-comment"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>    <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># Options: mathjax | katex</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br>  <span class="hljs-comment"># 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图</span><br>  <span class="hljs-comment"># Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid</span><br>  <span class="hljs-attr">mermaid:</span><br>    <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`</span><br>    <span class="hljs-comment"># If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class="hljs-comment"># If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># See: http://mermaid-js.github.io/mermaid/</span><br>    <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">theme:</span> <span class="hljs-string">&#x27;default&#x27;</span> &#125;<br><br>  <span class="hljs-comment"># 评论插件</span><br>  <span class="hljs-comment"># Comment plugin</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 评论插件</span><br><span class="hljs-comment"># Comment plugins</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数</span><br><span class="hljs-comment"># Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`</span><br><span class="hljs-comment">#---------------------------</span><br><br><span class="hljs-comment"># Utterances</span><br><span class="hljs-comment"># 基于 GitHub Issues</span><br><span class="hljs-comment"># Based on GitHub Issues</span><br><span class="hljs-comment"># See: https://utteranc.es</span><br><span class="hljs-attr">utterances:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">issue_term:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">label:</span> <span class="hljs-string">utterances</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">github-light</span><br>  <span class="hljs-attr">theme_dark:</span> <span class="hljs-string">github-dark</span><br><br><span class="hljs-comment"># Disqus</span><br><span class="hljs-comment"># 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs</span><br><span class="hljs-comment"># Based on third-party service</span><br><span class="hljs-comment"># See: https://disqus.com</span><br><span class="hljs-attr">disqus:</span><br>  <span class="hljs-attr">shortname:</span><br>  <span class="hljs-comment"># 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用</span><br>  <span class="hljs-comment"># The following are Disqusjs configurations, please ignore if DisqusJS is not required</span><br>  <span class="hljs-comment"># See: https://github.com/SukkaW/DisqusJS</span><br>  <span class="hljs-attr">disqusjs:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">apikey:</span><br><br><span class="hljs-comment"># Gitalk</span><br><span class="hljs-comment"># 基于 GitHub Issues</span><br><span class="hljs-comment"># Based on GitHub Issues</span><br><span class="hljs-comment"># See: https://github.com/gitalk/gitalk#options</span><br><span class="hljs-attr">gitalk:</span><br>  <span class="hljs-attr">clientID:</span><br>  <span class="hljs-attr">clientSecret:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">owner:</span><br>  <span class="hljs-attr">admin:</span> [<span class="hljs-string">&#x27;name&#x27;</span>]<br>  <span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br>  <span class="hljs-attr">labels:</span> [<span class="hljs-string">&#x27;Gitalk&#x27;</span>]<br>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">pagerDirection:</span> <span class="hljs-string">last</span><br>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">createIssueManually:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 默认 proxy 可能会失效，解决方法请见下方链接</span><br>  <span class="hljs-comment"># The default proxy may be invalid, refer to the links for solutions</span><br>  <span class="hljs-comment"># https://github.com/gitalk/gitalk/issues/429</span><br>  <span class="hljs-comment"># https://github.com/Zibri/cloudflare-cors-anywhere</span><br>  <span class="hljs-attr">proxy:</span> <span class="hljs-string">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span><br><br><span class="hljs-comment"># Valine</span><br><span class="hljs-comment"># 基于 LeanCloud</span><br><span class="hljs-comment"># Based on LeanCloud</span><br><span class="hljs-comment"># See: https://valine.js.org/</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span><br>  <span class="hljs-attr">appKey:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">placeholder:</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;retro&#x27;</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredFields:</span> []<br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">highlight:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">serverURLs:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">emojiCDN:</span><br>  <span class="hljs-attr">emojiMaps:</span><br>  <span class="hljs-attr">enableQQ:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Waline</span><br><span class="hljs-comment"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class="hljs-comment"># Derived from Valine, with self-hosted service and new features</span><br><span class="hljs-comment"># See: https://waline.js.org/</span><br><span class="hljs-attr">waline:</span><br>  <span class="hljs-attr">serverURL:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredMeta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>]<br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">emoji:</span> [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class="hljs-attr">dark:</span> <span class="hljs-string">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class="hljs-attr">wordLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 畅言 Changyan</span><br><span class="hljs-comment"># 基于第三方的服务</span><br><span class="hljs-comment"># Based on third-party service, insufficient support for regions outside China</span><br><span class="hljs-comment"># http://changyan.kuaizhan.com</span><br><span class="hljs-attr">changyan:</span><br>  <span class="hljs-attr">appid:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">appkey:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># 来必力 Livere</span><br><span class="hljs-comment"># 基于第三方的服务</span><br><span class="hljs-comment"># Based on third-party service</span><br><span class="hljs-comment"># See: https://www.livere.com</span><br><span class="hljs-attr">livere:</span><br>  <span class="hljs-attr">uid:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># Remark42</span><br><span class="hljs-comment"># 需要自托管服务端</span><br><span class="hljs-comment"># Based on self-hosted service</span><br><span class="hljs-comment"># See: https://remark42.com</span><br><span class="hljs-attr">remark42:</span><br>  <span class="hljs-attr">host:</span><br>  <span class="hljs-attr">site_id:</span><br>  <span class="hljs-attr">max_shown_comments:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">locale:</span> <span class="hljs-string">zh</span><br>  <span class="hljs-attr">components:</span> [<span class="hljs-string">&#x27;embed&#x27;</span>]<br><br><span class="hljs-comment"># Twikoo</span><br><span class="hljs-comment"># 支持腾讯云、Vercel、Railway 等多种平台部署</span><br><span class="hljs-comment"># Based on Tencent CloudBase</span><br><span class="hljs-comment"># See: https://twikoo.js.org</span><br><span class="hljs-attr">twikoo:</span><br>  <span class="hljs-attr">envId:</span><br>  <span class="hljs-attr">region:</span> <span class="hljs-string">ap-shanghai</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br><br><span class="hljs-comment"># Cusdis</span><br><span class="hljs-comment"># 基于第三方服务或自托管服务</span><br><span class="hljs-comment"># Based on third-party or self-hosted service</span><br><span class="hljs-comment"># See https://cusdis.com</span><br><span class="hljs-attr">cusdis:</span><br>  <span class="hljs-attr">host:</span><br>  <span class="hljs-attr">app_id:</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-comment"># Giscus</span><br><span class="hljs-comment"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class="hljs-comment"># Based on GitHub Discussions, similar to Utterances</span><br><span class="hljs-comment"># See: https://giscus.app/</span><br><span class="hljs-attr">giscus:</span><br>  <span class="hljs-attr">repo:</span><br>  <span class="hljs-attr">repo-id:</span><br>  <span class="hljs-attr">category:</span><br>  <span class="hljs-attr">category-id:</span><br>  <span class="hljs-attr">theme-light:</span> <span class="hljs-string">light</span><br>  <span class="hljs-attr">theme-dark:</span> <span class="hljs-string">dark</span><br>  <span class="hljs-attr">mapping:</span> <span class="hljs-string">pathname</span><br>  <span class="hljs-attr">reactions-enabled:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">emit-metadata:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">input-position:</span> <span class="hljs-string">top</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh-CN</span><br><br><span class="hljs-comment"># Discuss</span><br><span class="hljs-comment"># 多平台、多数据库、自托管、免费开源评论系统</span><br><span class="hljs-comment"># Self-hosted, small size, multi-platform, multi-database, free and open source commenting system</span><br><span class="hljs-comment"># See: https://discuss.js.org</span><br><span class="hljs-attr">discuss:</span><br>  <span class="hljs-attr">serverURLs:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 归档页</span><br><span class="hljs-comment"># Archive Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">archive:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-archives.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 分类页</span><br><span class="hljs-comment"># Category Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">category:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-categories.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br>  <span class="hljs-comment"># 分类的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class="hljs-comment"># Sort field for categories, with a minus sign is reverse order</span><br>  <span class="hljs-comment"># Options: length | name</span><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">&quot;-length&quot;</span><br><br>  <span class="hljs-comment"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开</span><br>  <span class="hljs-comment"># Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories</span><br>  <span class="hljs-attr">collapse_depth:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class="hljs-comment"># Sort field for posts, with a minus sign is reverse order</span><br>  <span class="hljs-comment"># Options: date | title | or other field of front-matter</span><br>  <span class="hljs-attr">post_order_by:</span> <span class="hljs-string">&quot;-date&quot;</span><br><br>  <span class="hljs-comment"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>  <span class="hljs-comment"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>  <span class="hljs-attr">post_limit:</span> <span class="hljs-number">10</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 标签页</span><br><span class="hljs-comment"># Tag Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">tag:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-tags.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">tagcloud:</span><br>    <span class="hljs-attr">min_font:</span> <span class="hljs-number">15</span><br>    <span class="hljs-attr">max_font:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">unit:</span> <span class="hljs-string">px</span><br>    <span class="hljs-attr">start_color:</span> <span class="hljs-string">&quot;#e27faa&quot;</span><br>    <span class="hljs-attr">end_color:</span> <span class="hljs-string">&quot;#efff00&quot;</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 关于页</span><br><span class="hljs-comment"># About Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">about:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-about.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">/images/logo.jpg</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Inyxin&quot;</span><br>  <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;An elegant theme for Hexo&quot;</span><br>  <span class="hljs-comment"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class="hljs-comment"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code</span><br>  <span class="hljs-attr">icons:</span><br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-gitee-fill&quot;</span>, <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://gitee.com/inyxin/inyxin&quot;</span>, <span class="hljs-attr">tip:</span> <span class="hljs-string">&quot;Gitee&quot;</span> &#125;<br>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">class:</span> <span class="hljs-string">&quot;iconfont icon-qq-fill&quot;</span>, <span class="hljs-attr">qrcode:</span> <span class="hljs-string">&quot;/images/qrcode-qq.jpg&quot;</span>&#125;<br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 自定义页</span><br><span class="hljs-comment"># Custom Page</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 通过 hexo new page 命令创建的页面</span><br><span class="hljs-comment"># Custom Page through `hexo new page`</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">page:</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-tags.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 404页</span><br><span class="hljs-comment"># 404 Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">page404:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/default.png</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">85</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-comment"># 重定向到首页的延迟(毫秒)</span><br>  <span class="hljs-comment"># Delay in redirecting to home page (milliseconds)</span><br>  <span class="hljs-attr">redirect_delay:</span> <span class="hljs-number">5000</span><br><br><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-comment"># 友链页</span><br><span class="hljs-comment"># Links Page</span><br><span class="hljs-comment">#---------------------------</span><br><span class="hljs-attr">links:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">banner_img:</span> <span class="hljs-string">/images/page-links.webp</span><br>  <span class="hljs-attr">banner_img_height:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">banner_mask_alpha:</span> <span class="hljs-number">0.3</span><br>  <span class="hljs-comment"># 友链的成员项</span><br>  <span class="hljs-comment"># Member item of page</span><br>  <span class="hljs-attr">items:</span><br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Blog&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题博客&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://hexo.fluid-dev.com/&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Docs&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题使用指南&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://hexo.fluid-dev.com/docs/&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class="hljs-bullet">-</span> &#123;<br>      <span class="hljs-attr">title:</span> <span class="hljs-string">&quot;Fluid Repo&quot;</span>,<br>      <span class="hljs-attr">intro:</span> <span class="hljs-string">&quot;主题 GitHub 仓库&quot;</span>,<br>      <span class="hljs-attr">link:</span> <span class="hljs-string">&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot;</span>,<br>      <span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;/img/favicon.png&quot;</span><br>    &#125;<br><br>  <span class="hljs-comment"># 当成员头像加载失败时，替换为指定图片</span><br>  <span class="hljs-comment"># When the member avatar fails to load, replace the specified image</span><br>  <span class="hljs-attr">onerror_avatar:</span> <span class="hljs-string">/img/avatar.png</span><br><br>  <span class="hljs-comment"># 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字</span><br>  <span class="hljs-comment"># Custom content at the bottom of the links</span><br>  <span class="hljs-attr">custom:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;&lt;hr&gt;&lt;p&gt;在下方留言申请加入我的友链，按如下格式提供信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客名：Fluid&lt;/li&gt;&lt;li&gt;简介：Fluid 主题官方博客&lt;/li&gt;&lt;li&gt;链接：https://hexo.fluid-dev.com&lt;/li&gt;&lt;li&gt;图片：https://hexo.fluid-dev.com/img/favicon.png&lt;/li&gt;&lt;/ul&gt;&#x27;</span><br><br>  <span class="hljs-comment"># 评论插件</span><br>  <span class="hljs-comment"># Comment plugin</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
      <tag>Theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花生壳</title>
    <link href="/post/d2322c4d3105/"/>
    <url>/post/d2322c4d3105/</url>
    
    <content type="html"><![CDATA[<p><code>千里之行，始于足下。</code></p><p><a href="https://hsk.oray.com/download">花生壳客户端官方下载 - 贝锐花生壳官网 (oray.com)</a></p><p>优点: 固定IP</p><p>缺点: 限流1M , 只有2条隧道</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><img src="image-20240706164818305.png" alt="image-20240706164818305"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget <span class="hljs-string">&quot;https://dl.oray.com/hsk/linux/phddns_5.3.0_amd64.deb&quot;</span> -O phddns_5.3.0_amd64.deb<br></code></pre></td></tr></table></figure><p><a href="https://service.oray.com/question/11630.html">Linux版使用教程-贝锐官网 (oray.com)</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@beelink:~<span class="hljs-comment"># apt install ./phddns_5.3.0_amd64.deb</span><br>正在读取软件包列表... 完成<br>正在分析软件包的依赖关系树... 完成<br>正在读取状态信息... 完成<br>注意，选中 <span class="hljs-string">&#x27;phddns&#x27;</span> 而非 <span class="hljs-string">&#x27;./phddns_5.3.0_amd64.deb&#x27;</span><br>下列【新】软件包将被安装：<br>  phddns<br>升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 48 个软件包未 被升级。<br>需要下载 0 B/270 kB 的归档。<br>解压缩后会消耗 12.5 MB 的额外空间。<br>获取:1 /root/phddns_5.3.0_amd64.deb phddns amd64 5.3.0 [270 kB]<br>正在选中未选择的软件包 phddns。<br>(正在读取数据库 ... 系统当前共安装有 224640 个文件和目录。)<br>准备解压 /root/phddns_5.3.0_amd64.deb  ...<br>正在解压 phddns (5.3.0) ...<br>正在设置 phddns (5.3.0) ...<br><span class="hljs-keyword">in</span> systemv<br>Installation, please later...<br>Successful installation of Phddns Service.<br><br> +--------------------------------------------------+<br> |             Oray PeanutHull Linux 5.3.0          |<br> +--------------------------------------------------+<br> |  SN: orayf7285ff174f3   Default password: admin  |<br> +--------------------------------------------------+<br> |    Remote Management Address http://b.oray.com   |<br> +--------------------------------------------------+<br>N: 由于文件<span class="hljs-string">&#x27;/root/phddns_5.3.0_amd64.deb&#x27;</span>无法被用户<span class="hljs-string">&#x27;_apt&#x27;</span>访问，已脱离沙盒并 提权为根用户来进行下载。 - pkgAcquire::Run (13: 权限不够)<br>root@beelink:~<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@beelink:~<span class="hljs-comment"># apt remove phddns</span><br>正在读取软件包列表... 完成<br>正在分析软件包的依赖关系树... 完成<br>正在读取状态信息... 完成<br>下列软件包将被【卸载】：<br>  phddns<br>升级了 0 个软件包，新安装了 0 个软件包，要卸载 1 个软件包，有 48 个软件包未 被升级。<br>解压缩后将会空出 12.5 MB 的空间。<br>您希望继续执行吗？ [Y/n] y<br>(正在读取数据库 ... 系统当前共安装有 224651 个文件和目录。)<br>正在卸载 phddns (5.3.0) ...<br>phdaemon: 未找到进程<br>phtunnel: 未找到进程<br>phddns_mini_httpd: 未找到进程<br>Remove Phtunnel Service Success.<br>Thanks For Using Phtunnel Service.<br>root@beelink:~<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@beelink:~<span class="hljs-comment"># phddns</span><br>Phtunnel Serive called with  unknown argument<br>(phddns  |start|status|stop|restart|reset|<span class="hljs-built_in">enable</span>|<span class="hljs-built_in">disable</span>|version)<br></code></pre></td></tr></table></figure><ul><li>start 启动</li><li>stop 停止</li><li>status 状态</li><li>restart 重启</li><li>reset 重置</li><li>enable 开机自启</li><li>disable 取消开机自启</li><li>version 查看版本号</li></ul><p><strong>注意: 除phddns version命令不需要管理员权限外,其他命令均需要管理员权限</strong></p><p><img src="image-20240706165746108.png" alt="image-20240706165746108"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1、浏览器访问<a href="http://b.oray.com/">http://b.oray.com</a> ，输入花生壳Linux 5.0在安装时产生<strong>SN码与默认登录密码admin</strong>登录。</p><p><img src="image-20240706165910674.png" alt="image-20240706165910674"></p><p><img src="image-20240706165936080.png" alt="image-20240706165936080"></p><p><img src="image-20240706170003456.png" alt="image-20240706170003456"></p><p>激活成功后就可以正常使用了</p><h1 id="添加映射"><a href="#添加映射" class="headerlink" title="添加映射"></a>添加映射</h1><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>应用名称</td><td>自定义</td></tr><tr><td>应用图标</td><td>自行选择</td></tr><tr><td>映射类型</td><td>选择TCP</td></tr><tr><td>映射模板</td><td>暂不选择模板</td></tr><tr><td>外网<a href="https://domain.oray.com/">域名</a></td><td>选择用作外网访问的域名</td></tr><tr><td>外网端口</td><td>选择动态端口</td></tr><tr><td>内网主机</td><td>映射的Ubuntu系统内网IP地址</td></tr><tr><td>内网端口</td><td>映射的服务类型对应端口22</td></tr><tr><td>访问控制</td><td>设置在指定条件下才可访问映射 , 提升应用安全。针对网页类映射可支持设置访问密码</td></tr><tr><td>带宽</td><td>购买映射带宽后，可支持给映射分配额外带宽，这里保存默认</td></tr><tr><td>夜间带宽</td><td>18:00-次日8:00带宽速度提升100%，速度不低于5Mbps；带宽基数越大，夜间越快</td></tr></tbody></table><p><a href="https://console.hsk.oray.com/forward">贝锐花生壳管理 - 内网穿透 (oray.com)</a></p><p><img src="image-20240706170558042.png" alt="image-20240706170558042"></p><p><strong>内网主机</strong> : 127.0.0.1也行</p><p>访问部署在linux 80 端口上的nginx </p><p><img src="image-20240706172025539.png" alt="image-20240706172025539"></p><p>穿透成功</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>内网穿透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
      <tag>花生壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpolar-使用教程</title>
    <link href="/post/cb717c9eae02/"/>
    <url>/post/cb717c9eae02/</url>
    
    <content type="html"><![CDATA[<p><code>千里之行，始于足下。</code></p><p><a href="https://dashboard.cpolar.com/">cpolar - secure introspectable tunnels to localhost</a></p><p><strong>优点</strong>: 不限流量 , 4 条隧道</p><p><strong>缺点</strong>: CPU 占用高 , 随机 IP</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-literal">-L</span> https://www.cpolar.com/<span class="hljs-keyword">static</span>/downloads/<span class="hljs-built_in">install-release</span><span class="hljs-literal">-cpolar</span>.sh | sudo bash<br><br></code></pre></td></tr></table></figure><p><img src="image-20240706160413788.png" alt="image-20240706160413788"></p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">inyxin<span class="hljs-meta">@beelink</span>:~$ cpolar version<br>cpolar version <span class="hljs-number">3.3</span><span class="hljs-number">.12</span><br></code></pre></td></tr></table></figure><h3 id="token-认证"><a href="#token-认证" class="headerlink" title="token 认证"></a>token 认证</h3><p>登录 <a href="https://dashboard.cpolar.com/get-started">cpolar 官网后台</a>，点击左侧的验证，查看自己的认证 token，之后将 token 贴在命令行里</p><p><img src="image-20240706160658210.png" alt="image-20240706160658210"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">inyxin@beelink:~$ cpolar authtoken YWVmMDQ0NGEtMTEyZC00Yjg2LTk4ZjktZDRlOThi<br>Authtoken saved to configuration file: /usr/local/etc/cpolar/cpolar.yml<br></code></pre></td></tr></table></figure><h3 id="简单穿透测试一下"><a href="#简单穿透测试一下" class="headerlink" title="简单穿透测试一下"></a>简单穿透测试一下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">cpolar <span class="hljs-number">9998</span><br>    cpolar by <span class="hljs-meta">@bestexpresser</span>                                    (Ctrl+C to quit)                                                                            Tunnel Status       online<br>Account             <span class="hljs-title function_">inyxin</span> <span class="hljs-params">(Plan: Free)</span><br>Version             <span class="hljs-number">3.12</span>/<span class="hljs-number">3.22</span><br>Web Interface       <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">4040</span><br>Forwarding          http:<span class="hljs-comment">//31526c8c.r25.cpolar.top -&gt; http://localhost: 9998 Forwarding          https://31526c8c.r25.cpolar.top -&gt; http://localhost: 9998# Conn              0</span><br>Avg Conn Time       <span class="hljs-number">0.</span>00ms                                 <br>    <br>    <br></code></pre></td></tr></table></figure><p>穿透成功 , 只是 IP 不固定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">https:<span class="hljs-comment">//31526c8c.r25.cpolar.top/#/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>内网穿透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpolar</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo中Typero图片插入问题</title>
    <link href="/post/8fc22e81-ab43-4043-aef1-e9092fc59e87/"/>
    <url>/post/8fc22e81-ab43-4043-aef1-e9092fc59e87/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://hexo.io/zh-cn/">Hexo 官网</a></strong></p><p><strong>Question :</strong> </p><p>​hexo 处理 本地编写的带有图片的markdown时, 无法正确加载图片的路径</p><p><strong>Solution :</strong></p><ol><li><p>安装插件 <code>hexo-typora-img</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-typora-img --save<br></code></pre></td></tr></table></figure><p><img src="image-20240706153100037.png" alt="image-20240706153100037"></p></li><li><p>修改_config.yml</p><p><img src="image-20240706153226789.png" alt="image-20240706153226789"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#启用 资源文件夹</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#把链接改为与根目录的相对位址</span><br></code></pre></td></tr></table></figure></li><li><p>修改typora图片配置</p></li></ol><p><img src="image-20240706145214903.png" alt="image-20240706145214903"></p><p>这种做法 将当前目录下 与 <strong>abc.md</strong> 同名的文件夹作为 <strong>abc</strong> 的资源目录</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
      <tag>Typora</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typero v1.8.10 破解</title>
    <link href="/post/0d82c848-4ee7-4650-b0ee-ac9f4aef2ed9/"/>
    <url>/post/0d82c848-4ee7-4650-b0ee-ac9f4aef2ed9/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><a href="https://pan.baidu.com/share/init?surl=AXfxqM9KBSp7fvbpkeQ8KA&pwd=9sla"> 👉百度网盘下载 </a></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p><strong>解压密码</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">www.ittel.<span class="hljs-literal">cn</span><br></code></pre></td></tr></table></figure><p><img src="image-20240706144336808.png" alt="image-20240706144336808"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="image-20240706144510255.png" alt="image-20240706144510255"></p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="方式1-亲测可行"><a href="#方式1-亲测可行" class="headerlink" title="方式1 (亲测可行)"></a>方式1 (亲测可行)</h3><p>将 <code>ittel/winmm.dll</code> 复制到Typora安装目录下</p><p><img src="image-20240706150128143.png" alt="image-20240706150128143"></p><p> <img src="image-20240706145801712.png" alt="image-20240706145801712"></p><p>最后重启 查看许可证</p><p><img src="image-20240706150207507.png" alt="image-20240706150207507"></p><h3 id="方式2-我不行"><a href="#方式2-我不行" class="headerlink" title="方式2  (我不行)"></a>方式2  (我不行)</h3><p>How to use?</p><ol><li><p>运行 typora-setup-x64-1.7.0-dev-cracked.exe 安装Typora</p></li><li><p>运行 LicenseGen.exe 获得激活码</p><p><img src="image-20240706144737512.png" alt="image-20240706144737512"></p></li><li><p>输入你的邮箱和得到的激活码</p><p><img src="image-20240706144851917.png" alt="image-20240706144851917"></p></li><li><p>完美激活！</p></li></ol><p>这里也提供几个可以用的激活码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">VMLM7G</span>-<span class="hljs-number">2</span>A45QN-DBM3UZ-GSC7U3<br><span class="hljs-attribute">NXYAC8</span>-NQLVG3-<span class="hljs-number">4</span>ZMB4Z-W4APQA<br><span class="hljs-attribute">7UMJ6D</span>-BWHGKL-KD7ZN9-DNFA3E<br><span class="hljs-attribute">6TFNEN</span>-EFC3MK-QC5VC7-XHWY6A<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Quick Start</title>
    <link href="/post/a6c23c07bd1b/"/>
    <url>/post/a6c23c07bd1b/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学期末复习题</title>
    <link href="/post/9ae56c810397/"/>
    <url>/post/9ae56c810397/</url>
    
    <content type="html"><![CDATA[<p><strong>单项选择题：</strong></p><p>1．计算机的最小存储单位是   A    。</p><p>  A． 位  B． 字节   C． 字  D． 双字 </p><p>2．关于计算机图形学研究内容，不正确的说法是    D 。</p><p>  A． 几何模型构造及图形生成技术       B． 图形的操作与处理方法  </p><p>C． 图形信息的存储、检索与交换技术   D． 人机交互及用户串联技术</p><ol start="3"><li>C&#x2F;C++ Windows 应用程序的入口函数名称是    B   。</li></ol><p>A． main    B． WinMain    C． mian     D． winMain</p><ol start="4"><li>本学期的计算机图形学课程选用的编程语言是   A   。</li></ol><p>A． C&#x2F;C++      B． Java     C． C#      D． Python</p><ol start="5"><li>以下属于本课程选用的编程语言的特点是   B    。</li></ol><p>A． 不支持多继承    B．执行效率高    </p><p>C． 需要解释执行    D． 不适合编写系统软件</p><ol start="6"><li>在Win32 Application平台上绘制图形的类型是   A   。</li></ol><p>A． HDC      B．DCC      C．PDC       D．CDD</p><ol start="7"><li>本学期本课程介绍的绘制直线段的算法共有    D  种。</li></ol><p>A． 1      B． 2      C． 3       D． 4</p><p>8．平面直角坐标系的第一象限有两点A（x0,y0）、B（x1,y1），其中x0、y0、x1、y1均是正整数，则用逐点比较法绘制直线段AB共需执行   A  次画点命令。</p><p>A. | x1-x0| + | y1-y0| + 1    B. | x1-x0| + | y1-y0| </p><p>C. | x1-x0| + | y1-y0| - 1     D. 无法确定</p><p>9．若用逐点比较法在平面直角坐标系的第一象限内绘制直线段，则需要该线段的斜率K的绝对值   A   。</p><p>A. ≥0  B. ≥1  C. 没有要求  D. 无法确定</p><p>10．在平面直角坐标系的第一象限内绘制直线段，下列  D   算法对线段的斜率K没有限制。</p><p>A. 逐点比较  B. DDA  C. 中点 D. Bresenham</p><p>11．不属于Bresenham算法绘制直线段效率高的原因是    D   。</p><p>A. 斜率K不大于1  B. 减少了绘制次数  C. 避免了浮点数运用算 D. 不可进行移位运算</p><p>12．采用Bresenham算法绘制从点A（10,10）到点B（20,15）的直线段，共需执行 A     次画点命令。</p><p>A. 11  B. 15  C. 10  D. 12</p><p>13．计算机图形学中表达一条曲线的方程一般有    C   种形式。</p><p>A. 一  B. 二  C. 三 D. 无穷</p><p>14．解算三次样条插值函数需要额外补充    B   个条件。</p><p>   A. 1  B. 2  C. 3 D. 0</p><p>15．下列不属于曲线插值方法的是  D     。</p><p>A.多项式插值 B.分段多项式插值 C.样条函数插值 D.最小二乘插值</p><p>16．最小二乘法曲线拟合的原理是：使型值点的坐标值与曲线上对应点的坐标值的偏差的平方和达到     B  。</p><p>A.最大  B.最小  C.给定的取值范围 D.以上说法均不正确</p><p>17．区域内部点的判断方法可以是：射线法、检验夹角之和</p><p>18．    B   不属于简单种子填充算法的特点。</p><p>A.操作过程简单  B.需进行深度递归  C.算法的效率低 D.仅需少量的内存空间</p><p>19．二维图形的几何变换共有   B   种基本变换形式。</p><p>A． 2     B． 3     C． 5      D． 4</p><p>20．对于任意一条直线段，它相对于一个已定义的窗口位置关系最多有   D   种情况。</p><p>A． 2     B． 3     C． 5      D． 4</p><p>21．编码裁剪法中，每个区域用一个    D  位代码来表示。</p><p>A． 2     B． 3     C． 5      D． 4</p><p>22．编码裁剪法中，每个点的编码从高到低位依次分别代表   A   。</p><p>A．上下右左     B．右左上下    C．上下左右     D．下上左右</p><p>23．编码裁剪法中，每位的编码只有    A  状态。</p><p>A． 1    B． 3     C． 2      D． 4</p><p>24．编码裁剪法中，若线段两端点编码均为零，则两点    A  。</p><p>A．在窗口外    B．在窗口内    C． 不可见      D． 不能确定</p><p>25．要判断两端点所构成的线段与窗口对应关系，可用两个端点编码进行  C   运算。</p><p>A．逻辑“非”    B．逻辑“或”    C．逻辑“与”      D．逻辑“异或”</p><p>26．若线段两端点的编码的逻辑   C  不为0，则这两个端点必然位于某条边界的同侧，故必在窗口外，应不可见。</p><p>A．非    B． 或    C． 与       D． 异或</p><p>27．多边形的逐边裁剪算法中需要设置   C   个顶点表。</p><p>A． 1    B． 3     C． 2      D． 4</p><p>28．计算机图形学中，一般有   B   种表示三维图形的方法。</p><p>A． 1    B． 3     C． 2      D． 4 (线框模型、表面模型、实体模型)</p><p>29．在三维空间里，给定(n＋l)×(m+1)个空间点,可生成   D   次Bezier曲面。</p><p>A． (n＋l)×(m+1)    B． n ×(m+1)     C．(n＋l)×m      D． n×m</p><p>30．在三维空间中，,生成双三次Bezier曲面，需要    B  个控制顶点。</p><p>A． 9    B． 16     C．25      D． 20</p><p>31．以下不属于正轴测投影的是   D   。</p><p>A． 正等测    B． 正二测    C．正三测      D．正四测</p><ol start="32"><li>透视投影是透视变换与   A   的组合。</li></ol><p>A．平行投影变换    B． 正二测    C．正三测      D．正四测</p><ol start="33"><li>影响真实感图形因素有   D   。</li></ol><p>A．物体本身形状及物体表面特征  B．照射物体光源及物体与光源相对位置</p><p>C. 物体周围环境        D. 以上都是</p><ol start="34"><li>光照在物体表面上通常有   C    种情况。</li></ol><p>A． 1      B． 2      C． 3       D． 4</p><ol start="35"><li>Lambert光照模型主要考虑漫反射光和   A   的影响。</li></ol><p>A. 环境光      B． 镜面光     C． 透射光       D． 高光</p><ol start="36"><li>Phong光照模型有  C    种类型的光的影响。</li></ol><p>A． 1      B． 2      C． 3       D． 4</p><p>37．下列有关投影的叙述语句中,正确的论述为    D  。</p><p>A. 透视投影与平行投影相比，能真实地反映物体的精确的尺寸和形状</p><p>B. 平行投影的投影中心到投影面的距离是无限的</p><p>C. 透视投影变换中，一组平行于投影面的线的投影产生一个灭点</p><p>D. 灭点可以看作是有限远处的一个点在投影面上的投影</p><p>38．以下    D  不是贝塞尔曲线的特点。</p><p> A.贝塞尔曲线只要给出数据点就可构造曲线</p><p> B.贝塞尔曲线次数严格依赖于确定该段曲线的数据点个数</p><p> C.贝塞尔曲线不完全通过数据点</p><p>D.贝塞尔曲线处处可以调整</p><p>39．三维图形是相对于    A   作旋转变换。</p><p>A. 点   B. 直线    C. 平面   D. 曲线</p><p>40．三维空间XYZ中的图形绕x轴的逆时针旋转可看成是图形在  B   绕原点O的二维旋转变换。 </p><p>A．XOY平面  B．YOZ 平面  C．ZOX 平面  D．都不是</p><p>41．已知平面裁剪矩形域的左下角点(50,60)及右上角点(200，200)，利用编码裁剪算法对某线段的端点(56,115)进行编码，其编码是   D  。</p><p>A．1100  B．0000   C．0101  D．1001</p><p>42．在进行扫描线多边形区域填充时，若位于扫描线异侧的两相邻边与扫描线相交于同一点，则该点应视为    C  个交点。</p><p>  A．舍弃  B．1  C．2  D．3</p><p>43．下面哪一项是Bezier曲线的特性    A   。</p><p>A．局部可调性     B．凹凸性    C．对称性    D．中点性</p><p>44．在透视投影中，主灭点的个数最多是   C    。</p><p>A． 1      B． 2     C． 3      D． 0 </p><p>45．下列有关简单光反射模型的描述语句中，正确的是   C  。 </p><p>A．简单光反射模型，又称为Phong模型，它模拟物体表面对光的透射作用</p><p>B．在简单光反射模型中，假定光源是点光源，且仅关注物体表面对光的镜面反射作用 </p><p>C．简单光反射模型主要考虑物体表面对直射光照的漫反射作用</p><p>D．在简单光反射模型中，对物体间的光反射作用，只用一个环境光变量做近似处理</p><p>46．正等轴测图的三个投影轴间的夹角是   D   度。</p><p>A．30     B．60      C．90     D．120</p><p>47．一般情况下，三次B样条曲线需要   B  个控制顶点。 </p><p>A． 5       B． 4      C． 6       D． 3</p><ol start="48"><li>下列设备中，   B    是图形输出设备。</li></ol><p>A． 数字化仪      B． 绘图仪      C．扫描仪       D．键盘</p><ol start="49"><li>直线DDA算法中，当斜率|m|&gt;1时，x方向的增量△x和y方向的增量△y分别</li></ol><p>是   C  。</p><p>A. ±m和±1   B. ±1和±1&#x2F;m   C. ±1和±m   D. ±1&#x2F;m和±1</p><ol start="50"><li>计算机图形学中，CAD是指计算机  B   。</li></ol><p>A. 辅助制造   B. 辅助设计   C. 辅助教学   D. 辅助探测</p><p>51．计算机的基本存储单位是   D   。</p><p>  A． 位  B． 双字   C． 字  D．字节</p><p>52．关于计算机图形学的特点，不正确的说法是    C   。</p><p>A． 计算机产生的图形有规律、光滑 </p><p>B． 计算机产生的图形纯净美观、无噪声干扰</p><p>C．通过计算机产生的图形不能描绘纯粹是想像的主观世界中的各种对象。 </p><p>D．交互式产生的图形可修改性强，且速度快、差错少。</p><ol start="53"><li>关于C&#x2F;C++中的类的说法不正确的是  A     。</li></ol><p>A． 定义类的关键字是struct       B． 类的成员通常具有访问属性</p><p>C． 定义类的对象需要构造函数      D． 类具有封装特性</p><ol start="54"><li>最小二乘法是实际测量值和真实值之差（误差）的平方和达到     B 。</li></ol><p>A． 最大     B． 最小     C． 零       D． 无穷大</p><ol start="55"><li>以下属于本课程选用的编程语言的特点是    A   。</li></ol><p>A． 支持多继承      B． 执行效率低      </p><p>C． 需要解释执行    D． 不适合编写系统软件</p><ol start="56"><li>本学期在MFC平台上绘制图形时通常在   C   类进行实现。</li></ol><p>A． 应用程序类      B．对话框类      C．视图类       D．文档类</p><ol start="57"><li>对于同一条线段而言，Bresenham方法较DDA绘制法的效率   A   。</li></ol><p>A．高     B． 低     C． 相同      D． 没有可比性  </p><p>58．下列有关几何变换的叙述语句中，正确的论述是  C    。</p><p>A．几何变换就是把一个图形从一个位置移到别的位置</p><p>B．几何变换后图形连线次序发生改变</p><p>C．一个正方体经几何变换后可能会变成长方体</p><p>D．几何变换过程中不能让图形产生变形</p><p>59．三维空间XYZ中的图形绕Y轴的正向旋转可以被看作是在 A   绕原点O的二维旋转变换。 </p><p>A．XOY平面  B．YOZ 平面  C．ZOX 平面  D．都不是</p><p>60． 用编码裁剪算法裁剪二维线段时，若直线段两端点M、N的编码分别为1001和1011，则对该线段采用的处理方法是   C    。</p><p>A． 直接保留   B． 直接放弃  C． 对MN在求交分割  D．不能判断</p><p>61．在进行扫描线多边形区域填充时，若位于扫描线同侧的两相邻边与扫描线相交于同一点，则该点应视为   A 个交点。</p><p>  A． 1   B． 2   C． 3   D． 舍弃</p><p>62．下面哪一项不是Bezier曲线的特性   A    。</p><p>A．对称性    B．凸包性    C．局部性可调    D．几何不变性</p><p>63．在透视投影中，投影面仅与两个坐标轴相交,此透视被称为   B   点透视。</p><p>A．1   B．2    C．3   D．4 </p><p>64．下列不属于三视图范围的是      C  。</p><p>A．俯视图       B．主视图      C．正轴测图    D．侧视图</p><p>65．二次B样条曲线具有     B  导数的连续性。 </p><p>A．0阶      B．一阶      C．二阶       D．三阶</p><p>66．MFC应用程序的入口函数名是   C    。 </p><p>A．main      B．mian      C．WinMain       D．winmain</p><p>67．下列有关B样条曲线性质的说明语句中，正确的论述为   B   。</p><p>A． 一条直线与n个顶点控制的B样条曲线可有n个或更多个交点</p><p>B． B样条曲线可构造直线段和切线等特殊情况</p><p>C． 当移动B样条曲线一个顶点时，必定会对整条B样条曲线产生影响</p><p>D． B样条曲线的形状与坐标系的选择无关</p><p>68．下列关于数据的逻辑结构的叙述中，正确的是   A   。</p><p>A．数据的逻辑结构是数据间关系的描述</p><p>B．数据的逻辑结构反映了数据在计算机中的存储方式</p><p>C．数据的逻辑结构分为顺序结构和链式结构</p><p>D．数据的逻辑结构分为静态结构和动态结构</p><p>69．下列有关简单光反射模型的描述中，错误的论述为   D   。</p><p>A．漫反射光是由于表面粗糙不平引起的</p><p>B．环境光是光在物体和环境之间多次反射后最终达到平衡时的一种光</p><p>C．镜面反射光产生的高光区域只反映光源的颜色</p><p>D．该模型中必须考虑透射光</p><p>70．解算平面上5个点所确定的4段自然三次样条函数共需要   C   个附加条件。</p><p>A．1       B．2       C．3       D．4</p><p><strong>判断题：</strong></p><p>( F ) 1. 计算机生成图形时，只能用矢量法而没有其它别的方法。</p><p>( T ) 2. 简单种子填充算法中，选择的种子点必须位于待填充的区域内。 </p><p>( T ) 3. 图形学中可以用线段来近似逼近平面上的曲线。</p><p>( F  ) 4. 两空间向量v1(2，3，4)与v2(4，6，8)可唯一地确定一个平面。</p><p>(  F ) 5.由RGB颜色模型所定义的量所需存储空间是15位。</p><p>( F ) 6. 活动边表AET是多边形所有边记录链表。 </p><p>( T ) 7. 用齐次坐标表示法可以非常方便地处理平移变换。</p><p>(  T  ) 8. 一般情况下，透视投影的投影中心到投影面之间的距离是有限的。   </p><p>（ T  ）9. 由于物体表面凹凸不平而向四周均匀反射的光叫漫射光。 </p><p>（  T ）10.可以通过适当的变换将三点透视转换为一点透视。 </p><p>（  T ）11.计算机生成的直线在显示时往往呈现锯齿状，这种现象叫走样。   </p><p>（ F  ）12.在构建B样条曲线时，绝不允许出现重结点，否则将出错。</p><p>（  T  ）13.平面点P的齐次坐标为(16,6,2)，其对应的实际坐标为（8,3）。</p><p>（ T ）14.移动一个控制点时，可以调整B样条曲线的局部形状。</p><p>（ T ）15.平面上两个点是否位于某直线的同侧可用向量的叉乘进行判断。</p><p>（  F ）16.绘图仪绘制线段是笔在X,Y方向移动，画线时单方向的一次移动距离称为步矩，设备的步矩越小，绘出的图形越精确。</p><p>（  F ）17.自由曲线是一条无法用标准代数方程来描述的曲线。</p><p>曲线插值方法可使用使用高次多项式，因为次数越高，曲线越精确。</p><p>（ T ）18.三次样条曲线要求通过所有指定的数据点，但曲线的形状依赖于边界条件.</p><p>（  T ）19.曲线的形状由特征多边形的顶点Pi（i＝0，l，……，n）唯一确定，与坐标系的选取无关。这就是几何不变性，Bezier曲线的几何作图法就是一个很好的例证。</p><p>（ T ）20.区域填充就是将区域内的像素置成新的颜色值或图案。</p><p>（ T ）21.平面上的区域通常由一个封闭的轮廓来定义，处于一个封闭轮廓线内的所有像素点即构成一个区域。</p><p>（ T ）22.多边形区域填充就是将区域内的像素置成新的颜色值或图案。</p><p>（  T ）23.任何一个封闭曲线都可以用多边形来逼近。</p><p>（  T ）24.对于一个给定的多边形区域而言，显示平面上每个像素点内外特性是互相关联的，即相邻像素间具有相关属性。</p><p>（  T ）25.活动边表AET是一个只与当前扫描线相交的边记录链表。随着扫描线从一条到另一条的转换，AET表的内容也应随之变动。</p><p>（  T ）26.几何变换的规则可以用函数来表示。</p><p>（  T ）27.一般而言，复杂的图形变换都可以基本交换的适当组合来实现。</p><p>（  T ）28.对图形作几何变换，其实质是对点的几何变换。</p><p>（ T ）29.齐次坐标的应用，扩大了变换矩阵功能，只要对矩阵中有关元素赋以不同的 值，即可达到预期变换目的。</p><p>（  T ）30.组合变换顺序不能颠倒，顺序不同，则变换结果不同。</p><p>（  T ）31.裁剪就是将指定窗口作为图形边界，从一幅大的画面中抽取所需的具体信息，以显示某一局部画面或视图。</p><p>（ T ）32.裁剪实质上是从数据集合中抽取信息的过程。</p><p>（  T ）33.视图区（视图Viewport），是在屏幕上定义的一个小于或等于屏幕区域一个矩形块。</p><p>（  T ）34.窗口—视图变换是比例变换和平移变换的组合变换。</p><p>（ F ）35.中点分割裁剪法也叫最远（或近）的可见点算法。</p><p>（  T ）36.线段裁剪确良的多边形裁剪的基础。</p><p>（ T ）37.裁剪多边形要解决两个问题。其一是一个完整的封闭多边形经裁剪后一般不再是封闭的，需要用窗口边界适当部分来封闭它。其二是矩形窗口的四个角点在裁剪中是否要与其它交点连线。</p><p>（ T ）38.计算机图形学中，可以用曲线网格来近似地表示自由曲面。</p><p>（ T ）39.在产生一张自由曲面时，可以利用一系列的纵横交错且相互平行的样条曲线来构造。</p><p>（ T ）40.在空间解析几何中，三维空间内一张任意曲面片用两个参数曲面矢量方程或参数方程表示。</p><p>（  T ）41.在三维空间里，给定(n＋l)×(m+1)个空间点,可生成n×m次参数曲面。</p><p>（ F ）42.双二次Bezier曲面由四条抛物线段包围而，中间的一个顶点的变化对边界曲线不产生影响，这意味着在周边八点不变的情况下，适当选择中心顶点的位置可以控制曲面凹凸，这种控制方式是极其直观的，而且极其简易。</p><p>（ T ）43.双三次Bezier曲面中间的四个顶点的变化对边界曲线不产生影响，但影响曲面片的形状。</p><p>（  T ）44.NURBS曲面拥有非常良好的性质，目前已经成为曲面造型中最为广泛应用的技术。</p><p>（  T ）45.三维图形几何变换后仍然是三维图形。</p><p>（  T ）46. 三维图形旋转变换前后立体的大小和形状不发生变化，只是空间位置相对原位置发生了变化。</p><p>（ T ）47.通常图形输出设备（显示器、绘图仪等）都是二维的，用这些二维设备来输出三维图形，就得把三维坐标系下图形上各点的坐标转化为某一平面坐标系下的二维坐标。</p><p>（  T ）48.把三维物体用二维图形表示的过程称为三维投影变换。</p><p>（  T ）49.斜轴测投影是先将立体沿两个方向产生错切，再向投影面作正投影而得到。</p><p>（ T ）50.透视图是一种将三维物体用二维平面来表达的立体图。</p><p>（ T ）51. 将立体上各点与视点相连所得到的投影线分别与投影面相交，其交点就是立体上相应点的透视投影，再将其依次相连，即获得具有真实立体感的透视图。</p><p>（ F ）52.透视变换是将空间中的物体透视成空间中的另一物体，然后再把这一物体形投影到一个平面上，从而得到透视投影图。</p><p>（  F ）53.透视投影是透视变换与平行投影变换的组合。</p><p>（ T ）54.当视点位于Y轴上时,Y轴上的无限远点［0 1 0 0］进行透视变换后成为有限远点［0 l／q 0 1］。由此可以证明，原来平行于X轴和Z轴直线变换后仍平行于对应坐标轴，但原与Y轴平行直线，透视变换后不再与Y轴平行，而是汇交于Y轴上一点（0，1／q，0） ，该点称为透视的灭点。</p><p>（ T ）55.三点透视: 投影面α与X、Y、Z轴均有交点。三点透视可转换为一点透视进行计算。</p><p>（  T ）56.透视投影符合人类的生理机制，即离视点近的物体大，离视点远的物体小，远到极点即为消失，成为灭点。</p><p>（ T ）57.一个物体离观察点越远，那么它越有可能被其他物体所遮挡。</p><p>（ T ）58.物体空间算法有比较高的精度，生成的图形即使放大一定倍数后仍有令人满意的观感，因此在比较精密的对象显示方面有较多的应用。</p><p>（ T ）59.图像空间的算法在精度上不及前者，它最多到屏幕分辨率时就无法再提高精度，但计算效率较高，因为在图像空间中各种相关性可以得到充分应用，所以也有许多方法是在图像空间中实现的。</p><p>（ T ）60.背面消除算法不是一个完整的隐面消除方法，但它是隐面消除算法中的关键部分。</p><p>（ T ）61.凸多面体是指连接形体上不属于同一表面的任意两点的线段完全位于形体的内部的形体。</p><p>（ T ）62.若点A、B、C三个点中的任意两点所构成的两个向量的叉乘为0，则三点共线。</p><p>（ F ）63.根据三角形面积的坐标表示法所得到的面积的符号可判别顶点的排列顺序，若符号为正是逆序排列，为负则为顺序排列。</p><p>（ T ）64.场景坐标系通常是右手坐标系。</p><p>（ F ）65.观察坐标系通常是左手坐标系。</p><p>（ T ）66.镜面反射光与物体颜色无关，即镜面反射光产生的高光区域只反映光源的颜色。</p><p>（ T ）67.阴影是指景物中没有被光源直接照射的暗区。</p><p>（ T ）68. 纹理：物体表面的细节，分颜色纹理和几何纹理。</p><p>（ T ）69. 颜色纹理：指光滑表面上附加花纹和图案</p><p>（ T ）70. 几何纹理：景物表面微观上呈现的起伏不平；</p><p>(  T ) 71. 一般而言，矢量图所需要的存储空间要比位图小得多。</p><p>(  T ) 72. 若生成的曲线必须通过给定的每个型值点，这种生成曲线的方法叫插值法。</p><p>(  T ) 73. 用射线与多边形边界的交点个数可判数一个点是否是该多边形的内点。</p><p>(  T ) 74. 一般情况下,两个空间三维向量v1与v2的叉积是一个新的向量。</p><p>(  T ) 75. 在视点坐标系中，视点是原点O(0，0，0)，投影面经过点V(0，1，1)，则与OV垂直的投影面方程是y+z-1&#x3D;0。</p><p>( T ) 76. 齐次坐标表示法可以在计算机中表示无穷远点。</p><p>( T ) 77. 可以用梯形法来计算机平面多边形的面积。</p><p>( F ) 78. 在进行扫描线多边形区域填充时，通常需要构建边结点，边结点的数据结构一般有包含该边斜率信息在内的4个域。</p><p>( T ) 79. 由于物体表面的粗糙因素造成入射光向周围均匀反射的光叫环境光。</p><p>( F ) 80.给定平面上4个不同点可以生成一段4次贝塞尔曲线。</p><p>( T ) 81. Windows经经常用句柄（Handle）来标识对象。 </p><p>( T ) 82.基于单文档的MFC应用程序会自动生成包括应用程序类在内的基本类。</p><p>( T ) 83.C++中类的析构函数可完成一些清理性的任务。</p><p>( T ) 84.Z_Buffer算法是一种消隐算法。 </p><p>(  T ) 85.复杂变换通常可以用一系列的基本变换的组合来实现。</p><p>(  T ) 86. 颜色纹理用纹理映射来处理，几何纹理用扰动函数来描述。</p><p>(  T ) 87.图形显示器是由一个个排列有序的像素所构成，画一条直线实际上</p><p>是根据一系列计算出来并与该线靠近的像素而绘制。</p><p>Phong光照明模型中，反射光是由哪几部分组成的？</p><p>答：环境光（Ambient Light）：环境光模拟了场景中所有物体都会接收到的间接光照，即使它们没有被直接的光源照射。这种光照通常用来提供场景的基本亮度，使得物体即使在阴影中也能被看到。</p><p>漫反射光（Diffuse Light）：漫反射光模拟了光线照射到粗糙表面时向各个方向散射的现象。这种光照取决于物体表面的材质属性（如漫反射系数）和光线与表面法线之间的角度。漫反射光照使得物体表面看起来均匀受光，并且颜色取决于物体材质的颜色。</p><p>镜面反射光（Specular Light）：镜面反射光模拟了光线照射到光滑表面时反射的现象。这种光照产生高光（specular highlights），其强度和位置取决于光源、观察者、物体表面法线以及表面材质的镜面反射系数。镜面反射光照使得物体表面看起来有光泽，并且高光的亮度随着观察角度的变化而变化。</p><p>问题：什么是正轴测投影变换？</p><p>答案：正轴测投影变换是一种将三维物体投影到二维平面上的方法，它保持了物体各个轴之间的比例关系。在正轴测投影中，投影线（光线）与投影面（通常是二维平面）垂直，且投影线与物体的三个主要坐标轴（通常是x、y、z轴）成相同的夹角。这种投影方法通常用于工程制图和计算机图形学中，因为它可以提供一个物体的三维视图，同时保持各个方向的比例一致。</p><p>正轴测投影可以进一步分为几种类型，包括：</p><ol><li><p>正等测投影（Isometric Projection）：在正等测投影中，三个轴之间的夹角都是120度，且每个轴的长度在投影中都被缩短到原始长度的√2&#x2F;2倍（大约是原始长度的70.7%）。这种投影保持了三个轴之间的比例关系，使得物体在二维视图上看起来是等比例的。</p></li><li><p>正二测投影（Dimetric Projection）：在正二测投影中，两个轴之间的夹角是120度，而第三个轴与这两个轴的夹角不同。这种投影保持了两个轴之间的比例关系，但第三个轴的比例可能不同。</p></li><li><p>正三测投影（Trimetric Projection）：在正三测投影中，三个轴之间的夹角都不相同，且每个轴的长度在投影中都被缩短到不同的比例。这种投影不保持任何轴之间的比例关系，因此物体的形状在二维视图上可能看起来有些扭曲。</p></li></ol><p>正轴测投影变换在工程制图中非常有用，因为它可以提供一个清晰的、易于理解的物体三维视图，同时避免了透视投影中由于距离造成的尺寸变化。在计算机图形学中，正轴测投影也用于创建技术图和概念设计图，因为它可以提供一种直观的方式来展示物体的三维结构。</p><p>问题：背面消除算法的基本步骤。</p><p>答案：</p><p>1.确定多边形的法线： 对于每个多边形，计算其法线向量。法线向量是垂直于多边形平面的向量，可以通过取多边形上两个非共线边的叉积来得到。</p><p>2.计算观察者到多边形的向量： 确定观察者的位置（通常为摄像机位置），并计算从观察者位置到多边形中心的向量。</p><p>3.计算法线与观察者向量的点积： 将多边形的法线向量与观察者到多边形中心的向量进行点积运算。点积的结果是一个标量，表示两个向量的夹角的余弦值。</p><p>4.判断多边形的可见性：</p><p>如果点积结果大于0，则表示法线向量与观察者向量之间的夹角小于90度，即多边形面向观察者，因此是可见的。</p><p>如果点积结果小于或等于0，则表示法线向量与观察者向量之间的夹角大于或等于90度，即多边形背向观察者，因此是不可见的。</p><p>5.消除背面多边形： 对于那些被判定为不可见的多边形，跳过它们的渲染过程，不进行进一步的绘制操作。</p><p>6.渲染可见多边形： 对于那些被判定为可见的多边形，继续进行渲染过程，包括光照计算、纹理映射等。</p><p>请写出扫描线多边形区域填充的算法过程。</p><p>答案：<strong>预处理多边形，构建活动边表（<strong><strong>AET</strong></strong>），扫描线遍历，处理活动边表，更新活动边表，重复步骤<strong><strong>3-5</strong></strong>，结束</strong></p><p>三次贝塞尔曲线段的有关计算</p><p>答：</p><p>二维、三维几何变换</p><p>答：</p><p>二维几何变换：</p><p>平移变换：将图形沿着x轴和y轴移动一定的距离</p><p>旋转变换：围绕原点或任意点旋转图形</p><p>缩放变换：放大或缩小图形。</p><p>剪切变换：沿x轴或y轴方向倾斜图形</p><p>反射变换：沿x轴或y轴翻转图形</p><p>三位几何变换：</p><p>平移变换：将图形沿着x轴、y轴和z轴移动。</p><p>旋转变换：将图形沿着x轴、y轴和z轴移动。</p><p>缩放变换：放大或缩小图形</p><p>剪切变换：将图形沿着x轴、y轴和z轴移动。</p><p>反射变换：沿x轴、y轴或z轴翻转图形。</p><p>DDA、逐点比较法画直线段</p><p>答：</p><p>DDA步骤：</p><p><img src="clip_image002-1719382350883-1.png" alt="屏幕截图 2024-06-13 115224"></p><p>逐点比较法;</p><p><img src="clip_image004-1719382350883-2.png" alt="屏幕截图 2024-06-13 115634"></p><p><strong>已知平面四点依次是P0(0,0)，P1(1,1)，P2(2,1)，P3(3,0)。用其作为特征多边形P0P1P2P3来构造一条三次贝塞尔曲线段，请写出该曲线的参数化表达式，并分别计算参数为1、2&#x2F;3时曲线上点的值。</strong></p><p><strong>答：表达式：<img src="clip_image005-1719382350884-5.png" alt="屏幕截图 2024-06-13 120039"></strong></p><p><strong>计算<img src="clip_image007-1719382350884-3.png" alt="屏幕截图 2024-06-13 120154"></strong></p><p><strong>简述Gouraud双线性插值算法的基本步骤。</strong></p><p><strong>答：</strong>1.顶点着色：首先，为多边形的每个顶点分配颜色值。</p><p>2.计算边上的颜色梯度：对于多边形的每条边，计算两个顶点之间的颜色梯度，即颜色变化率。</p><p>3.线性插值：沿着每条边，根据参数 𝑡（通常是从0到1的值，表示从一个顶点到另一个顶点的位置），使用线性插值计算边上的每个点的颜色。</p><p>4.填充多边形：使用扫描线算法填充多边形内部。对于扫描线上的每个点，根据该点所在的水平位置，使用相邻边的颜色插值结果来计算该点的颜色。</p><p><strong>如下图所示三角形ABC，将其关于A点顺时针旋转2700，写出其变换矩阵和变换后图形各点的坐标。</strong></p><p><img src="clip_image009-1719382350884-4.png" alt="img"></p><p><strong>简述计算机图形的分类及其特点</strong><strong>:</strong></p><p>计算机图形主要分为两大类：基于线条信息的图形和真实感图形。</p><p>基于线条信息的图形：</p><p>特点：这类图形主要使用线条来表示物体的轮廓和结构，例如工程图、等高线地图、曲面的线框图等。</p><p>应用：常用于工程设计和地理信息系统等领域，强调物体的结构和几何形状。</p><p>真实感图形：</p><p>特点：这类图形通过模拟光线在物体表面的反射、折射、散射等现象，来创建具有真实感的图像。它们通常包含明暗、纹理、阴影等细节。</p><p>应用：广泛应用于电影、游戏、虚拟现实等领域，用于创建逼真的视觉效果。</p><p>计算机图形的这两类各有特点，基于线条信息的图形强调结构和轮廓，而真实感图形则注重图像的真实性和细节。</p><p>问题：请写出多边形区域填充的算法过程:</p><p>1.<strong>多边形表示</strong>：</p><p>使用顶点列表来表示多边形，每个顶点包含其坐标（x, y）。</p><p>2.<strong>排序顶点</strong>：</p><p>将多边形的顶点按照y坐标进行排序，如果y坐标相同，则按照x坐标排序。</p><p>3.<strong>扫描线处理</strong>：</p><p>从y坐标最小的顶点开始，沿着y轴向上扫描。</p><p>对于每条扫描线，找到与该扫描线相交的所有多边形边。</p><p>这些边将扫描线分成若干个区间，每个区间对应多边形内部的一个水平线段。</p><p>4.<strong>边表（ET）和活动边表（AET）</strong>：</p><p>创建边表（Edge Table, ET），用于存储每条扫描线与多边形边相交的信息。</p><p>创建活动边表（Active Edge Table, AET），用于存储当前扫描线上的所有活动边。</p><p>5.<strong>处理交点</strong>：</p><p>对于每条扫描线，将所有与扫描线相交的边的交点按x坐标排序。</p><p>将交点添加到AET中，并更新ET中的边信息。</p><p>6.<strong>填充像素</strong>：</p><p>对于AET中的每一对相邻交点，填充它们之间的所有像素点。</p><p>如果多边形是闭合的，则不需要考虑交点的奇偶性；如果不是闭合的，则只填充交点为奇数个的区间。</p><p>7.<strong>更新AET</strong>：</p><p>在填充完一个区间后，更新AET，移除已经离开扫描线的边，并添加新的进入扫描线的边。</p><p>8.<strong>重复步骤</strong>：</p><p>重复步骤3到7，直到处理完所有扫描线。</p><p>9.<strong>结束</strong>：</p><p>当所有扫描线都处理完毕后，多边形填充完成。</p><p><strong>在如下图所示的坐标系中，有一空间点A绕直线L旋转θ角后到点B，试分析利用基本的平移及旋转矩阵解算B点位置的步骤。</strong></p><p><img src="image-20240705232433572.png" alt="image-20240705232433572"></p><p><img src="image-20240705232446420.png" alt="image-20240705232446420"></p><p>写出逐点比较法画线算法的原理,并编写从点（20，10）到点（60，20）的C程序。</p><p>写出DDA画直线算法的原理，并写出实现该算法的C程序</p><p><img src="clip_image015-1719382350884-8.png" alt="屏幕截图 2024-06-13 171637"><img src="clip_image017-1719382350884-9.png" alt="屏幕截图 2024-06-13 171714"></p><p>写出扫描线种子填充算法的步骤</p><p>答：</p><p>1.初始化种子点：首先，选择一个种子点作为填充过程的起点。这个种子位于需要填充的区域内部。</p><p>2.填充种子点所在的扫描线：从种子点开始，向左和向右填充种子点所在的扫描线上的像素，直到遇到边界像素。</p><p>3.记录填充区域的边界：在填充过程中，记录下填充区域的左边界和右边界，这些边界是填充过程中遇到的第一个非填充像素。</p><p>4.检查相邻的扫描线：对于当前扫描线上的填充区域，检查与它相邻的上一个扫描线和下一个扫描线。在相邻的扫描线上，从记录的左边界开始向右搜索，直到遇到边界像素或已填充的像素。</p><p>5.找到新的种子点：如果在相邻的扫描线上找到了未填充的像素，那么这个像素将成为新的种子点。将这个种子点压入一个栈中，用于后续的填充过程。</p><p>6.重复填充过程：重复步骤4和步骤5，直到栈为空，即所有的种子点都已经处理完毕。</p><p>7.结束填充：当栈为空时，填充过程结束。</p><p>试推导在笛卡尔坐标系中，空间点A（x,y,z）绕Z轴旋转θ角的旋转矩阵.</p><p>什么是正轴测投影变换？试推导正轴测投影变换的变换矩阵</p><p>写出贝塞尔曲面的定义及其矩阵表示形式</p><p>简述三维投影变换分类</p><p>写出Z_Buffer算法的基本步骤.</p><p>Phong光照明模型中，反射光是由哪几部分组成的？写出Phong模型的表达形式.</p><p>组成：</p><ol><li>环境光反射（Ambient Reflection）：这是由环境光引起的均匀照明，它模拟了光线在场景中多次反射后形成的柔和光线。环境光反射不依赖于光源的位置和方向。</li><li>漫反射（Diffuse Reflection）：这是由光源直接照射在物体表面后，由于表面粗糙不平而向各个方向散射的光线。漫反射光的强度与光源的位置和方向有关，但与观察者的位置无关。</li></ol><p>3.镜面反射（Specular Reflection）：这是由光源直接照射在物体表面后，由于表面光滑而向特定方向反射的光线。镜面反射光的强度与光源的位置、观察者的位置以及物体表面的光滑程度有关。</p><p>表达形式：<img src="clip_image019-1719382350884-10.png" alt="屏幕截图 2024-06-13 172531"></p>]]></content>
    
    
    <categories>
      
      <category>学校课程</category>
      
      <category>复习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计复习题</title>
    <link href="/post/0194fff0752e/"/>
    <url>/post/0194fff0752e/</url>
    
    <content type="html"><![CDATA[<h3 id="第1章-算法概述"><a href="#第1章-算法概述" class="headerlink" title="第1章 算法概述"></a>第1章 算法概述</h3><h4 id="算法的概念及性质"><a href="#算法的概念及性质" class="headerlink" title="算法的概念及性质"></a>算法的概念及性质</h4><p>算法是解决问题的一系列清晰指令的有限序列，具有输入、输出和明确定义的操作步骤。算法应具备正确性、可行性、确定性和有穷性等性质。</p><h4 id="程序的概念"><a href="#程序的概念" class="headerlink" title="程序的概念"></a>程序的概念</h4><p>程序是由编程语言编写的一组指令，用于实现特定功能或解决特定问题的计算机软件。</p><h4 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h4><ul><li><strong>调度问题</strong>：如作业调度、任务分配等问题。</li><li><strong>排序算法</strong>：如冒泡排序、快速排序、归并排序等。</li></ul><h4 id="P类问题、NP类问题概念"><a href="#P类问题、NP类问题概念" class="headerlink" title="P类问题、NP类问题概念"></a>P类问题、NP类问题概念</h4><ul><li><strong>P类问题</strong>：指在多项式时间内可解决的问题。</li><li><strong>NP类问题</strong>：指可以在多项式时间内验证解的问题。NP问题不一定可以在多项式时间内求解。</li></ul><h4 id="算法复杂性的概念"><a href="#算法复杂性的概念" class="headerlink" title="算法复杂性的概念"></a>算法复杂性的概念</h4><p>算法复杂性描述了算法在解决问题时所需的计算资源。主要包括时间复杂性和空间复杂性两个方面。</p><h4 id="时间复杂性的分析"><a href="#时间复杂性的分析" class="headerlink" title="时间复杂性的分析"></a>时间复杂性的分析</h4><p>时间复杂性是指算法运行所需时间的度量，通常用大O记号来表示。常见的时间复杂度包括O(1)、O(log n)、O(n)、O(n log n)、O(n^2)等。</p><h4 id="常见的算法复杂度的大O阶"><a href="#常见的算法复杂度的大O阶" class="headerlink" title="常见的算法复杂度的大O阶"></a>常见的算法复杂度的大O阶</h4><ul><li>**O(1)**：常数时间复杂度，如哈希表的插入和查找操作。</li><li>**O(log n)**：对数时间复杂度，如二分查找。</li><li>**O(n)**：线性时间复杂度，如简单查找。</li><li>**O(n log n)**：如快速排序、归并排序等。</li><li>**O(n^2)**：平方时间复杂度，如冒泡排序、插入排序等。</li><li><h2 id="O-1-O-logn-O-n-O-nlogn-O-n-2-O-2-n-O-n"><a href="#O-1-O-logn-O-n-O-nlogn-O-n-2-O-2-n-O-n" class="headerlink" title="O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)"></a><strong><code>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)</code></strong></h2></li></ul><h4 id="h函数的渐进表达式计算"><a href="#h函数的渐进表达式计算" class="headerlink" title="h函数的渐进表达式计算"></a>h函数的渐进表达式计算</h4><p>函数的渐进表达式用来描述函数在自变量趋向于无穷大时的增长趋势。常见的有O大O、Ω大Omega、Θ大Theta等。</p><p>希望这些回答能帮到你！如有其他问题，请继续提问。</p><h3 id="第2章-递归与分治"><a href="#第2章-递归与分治" class="headerlink" title="第2章 递归与分治"></a>第2章 递归与分治</h3><h4 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h4><p>递归是指一个函数在定义中调用自身的过程。递归函数通常包括两部分：基本情况（递归的结束条件）和递归情况（调用自身以解决更小的子问题）。</p><h4 id="递归方程求解"><a href="#递归方程求解" class="headerlink" title="递归方程求解"></a>递归方程求解</h4><p>递归方程用来描述递归算法的时间复杂度。通常通过递推关系式来表示，可以使用递归树或主定理来求解复杂度。</p><h4 id="经典递归实例"><a href="#经典递归实例" class="headerlink" title="经典递归实例"></a>经典递归实例</h4><ul><li><strong>求和</strong>：例如计算1到n的和。</li><li><strong>求阶乘</strong>：如计算n的阶乘，即n!。</li><li><strong>Fibonacci数列</strong>：例如计算第n个斐波那契数。</li><li><strong>整数划分问题</strong>：例如将整数n划分成若干个整数的和。</li><li><strong>汉诺塔问题</strong>：经典的递归问题，将圆盘从一根柱子移动到另一根柱子，要求小圆盘必须在大圆盘上方。</li></ul><h4 id="递归的特点及优缺点"><a href="#递归的特点及优缺点" class="headerlink" title="递归的特点及优缺点"></a>递归的特点及优缺点</h4><p><strong>特点：</strong></p><ul><li>简洁、直观，能够简化问题的表达和解决。</li><li>适用于问题的分而治之，能够自然地描述一些具有递归结构的问题。</li></ul><p><strong>优点：</strong></p><ul><li>简化复杂问题，使问题更易理解和实现。</li><li>有助于实现分治策略，使问题的分解和解决更加自然和高效。</li></ul><p><strong>缺点：</strong></p><ul><li>可能会导致堆栈溢出的问题，尤其是在递归层数很深时。</li><li>可能存在重复计算，效率较低。</li></ul><h4 id="分治法的基本思想"><a href="#分治法的基本思想" class="headerlink" title="分治法的基本思想"></a>分治法的基本思想</h4><p>分治法将原问题分解成若干个规模较小但结构与原问题相似的子问题，递归地求解这些子问题，然后合并子问题的解来得到原问题的解。</p><h4 id="分治法实例"><a href="#分治法实例" class="headerlink" title="分治法实例"></a>分治法实例</h4><ul><li><strong>二分搜索算法</strong>：在有序数组中查找特定元素。</li><li><strong>合并排序（Merge Sort）</strong>：将数组分成两半，分别排序后再合并。</li><li><strong>快速排序（Quick Sort）</strong>：选取一个基准元素，将数组分为比基准元素小和比基准元素大的两部分，然后递归地对这两部分进行排序。</li></ul><h2 id="第3章-动态规划"><a href="#第3章-动态规划" class="headerlink" title="第3章 动态规划"></a>第3章 动态规划</h2><h3 id="动态规划总体思想"><a href="#动态规划总体思想" class="headerlink" title="动态规划总体思想"></a>动态规划总体思想</h3><p>动态规划（Dynamic Programming，简称DP）是一种通过将复杂问题拆分为更简单的子问题，并存储其子问题的解，以避免重复计算，从而提高效率的算法设计方法。它通常用于解决具有重叠子问题和最优子结构性质的问题。</p><ol><li><strong>重叠子问题（Overlapping Subproblems）</strong>：原问题可以分解为多个子问题，这些子问题会重复出现。</li><li><strong>最优子结构（Optimal Substructure）</strong>：原问题的最优解可以通过其子问题的最优解构造得到。</li></ol><h3 id="动态规划基本步骤"><a href="#动态规划基本步骤" class="headerlink" title="动态规划基本步骤"></a>动态规划基本步骤</h3><ol><li><strong>定义子问题</strong>：明确要解决的子问题是什么，把一个大问题分解成若干个相同类型的小问题。</li><li><strong>确定状态（State）</strong>：用一个数组或表格来表示每个子问题的解。</li><li><strong>设置边界条件（Initialization）</strong>：初始化最简单的子问题的解。</li><li><strong>状态转移方程（Recurrence Relation）</strong>：找到子问题和原问题之间的递推关系。</li><li><strong>计算结果</strong>：根据状态转移方程，迭代计算每个子问题的解，最终得到原问题的解。</li></ol><h3 id="动态规划基本要素"><a href="#动态规划基本要素" class="headerlink" title="动态规划基本要素"></a>动态规划基本要素</h3><ol><li><strong>状态定义</strong>：描述一个子问题的解，例如 <code>dp[i]</code> 表示前 i 个元素的某种状态。</li><li><strong>状态转移方程</strong>：描述如何从一个状态转移到另一个状态，例如 <code>dp[i] = dp[i-1] + something</code>。</li><li><strong>初始状态和边界条件</strong>：为递推提供基础，例如 <code>dp[0] = 0</code> 或其他初始值。</li><li><strong>计算顺序</strong>：根据状态转移方程的依赖关系，通常是从小到大的顺序计算。</li></ol><h3 id="动态规划实例"><a href="#动态规划实例" class="headerlink" title="动态规划实例"></a>动态规划实例</h3><h4 id="1-最长公共子序列（Longest-Common-Subsequence-LCS）"><a href="#1-最长公共子序列（Longest-Common-Subsequence-LCS）" class="headerlink" title="1. 最长公共子序列（Longest Common Subsequence, LCS）"></a>1. 最长公共子序列（Longest Common Subsequence, LCS）</h4><p><strong>问题描述</strong>：给定两个字符串，找到它们的最长公共子序列的长度。</p><p><strong>状态定义</strong>：<code>dp[i][j]</code> 表示字符串 A 的前 i 个字符和字符串 B 的前 j 个字符的最长公共子序列的长度。</p><p><strong>状态转移方程</strong>：</p><ul><li>如果 <code>A[i-1] == B[j-1]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code></li><li>否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li></ul><p><strong>初始化</strong>：<code>dp[0][j] = 0</code> 和 <code>dp[i][0] = 0</code>，因为任何字符串和空字符串的最长公共子序列长度都是 0。</p><h4 id="2-最大子段和问题（Maximum-Subarray-Sum）"><a href="#2-最大子段和问题（Maximum-Subarray-Sum）" class="headerlink" title="2. 最大子段和问题（Maximum Subarray Sum）"></a>2. 最大子段和问题（Maximum Subarray Sum）</h4><p><strong>问题描述</strong>：给定一个整数数组，找到具有最大和的连续子数组，并返回其最大和。</p><p><strong>状态定义</strong>：<code>dp[i]</code> 表示以第 i 个元素结尾的最大子数组和。</p><p><strong>状态转移方程</strong>：</p><ul><li><code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code></li></ul><p><strong>初始化</strong>：<code>dp[0] = nums[0]</code>，因为只有一个元素时，最大子数组和就是该元素本身。</p><h4 id="3-0-1-背包问题（0-1-Knapsack-Problem）"><a href="#3-0-1-背包问题（0-1-Knapsack-Problem）" class="headerlink" title="3. 0-1 背包问题（0-1 Knapsack Problem）"></a>3. 0-1 背包问题（0-1 Knapsack Problem）</h4><p><strong>问题描述</strong>：给定一个容量为 W 的背包和一组物品，每个物品有重量和价值，求解如何选择物品使得总价值最大且总重量不超过背包容量。</p><p><strong>状态定义</strong>：<code>dp[i][w]</code> 表示前 i 个物品在总重量不超过 w 时的最大价值。</p><p><strong>状态转移方程</strong>：</p><ul><li>如果不选第 i 个物品：<code>dp[i][w] = dp[i-1][w]</code></li><li>如果选第 i 个物品：<code>dp[i][w] = dp[i-1][w-weight[i]] + value[i]</code></li><li>综合起来：<code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])</code></li></ul><p><strong>初始化</strong>：<code>dp[0][w] = 0</code> 对所有 w，因为没有物品时，价值为 0。</p><p>这些实例展示了动态规划在不同领域中的应用，通过定义状态、确定转移方程以及初始化，可以有效地解决许多复杂问题。</p><h3 id="第4章-贪心算法"><a href="#第4章-贪心算法" class="headerlink" title="第4章 贪心算法"></a>第4章 贪心算法</h3><h4 id="贪心算法的概念"><a href="#贪心算法的概念" class="headerlink" title="贪心算法的概念"></a>贪心算法的概念</h4><p>贪心算法（Greedy Algorithm）是一种在每一步选择中都采取在当前状态下最好或最优的选择，以期望通过局部最优解达到全局最优解的算法设计方法。贪心算法不一定能保证求得全局最优解，但对于某些特定问题，它可以提供高效且正确的解。</p><h4 id="用贪心算法求解的问题需具备的两个基本要素"><a href="#用贪心算法求解的问题需具备的两个基本要素" class="headerlink" title="用贪心算法求解的问题需具备的两个基本要素"></a>用贪心算法求解的问题需具备的两个基本要素</h4><ol><li><strong>贪心选择性质（Greedy Choice Property）</strong>：在当前步骤中，选择局部最优解不会影响到后续的选择能够构成全局最优解。这意味着可以通过局部最优策略来构建全局最优解。</li><li><strong>最优子结构性质（Optimal Substructure）</strong>：一个问题的全局最优解包含其子问题的全局最优解。也就是说，问题的最优解可以由其子问题的最优解递归地构建出来。</li></ol><h4 id="贪心算法与动态规划算法的差异"><a href="#贪心算法与动态规划算法的差异" class="headerlink" title="贪心算法与动态规划算法的差异"></a>贪心算法与动态规划算法的差异</h4><ul><li><strong>选择标准</strong>：<ul><li><strong>贪心算法</strong>：在每一步选择中做出局部最优的选择，不回溯、不考虑后续可能的选择。</li><li><strong>动态规划</strong>：考虑所有可能的选择，通过比较不同选择的结果来确保全局最优解。</li></ul></li><li><strong>适用问题类型</strong>：<ul><li><strong>贪心算法</strong>：通常适用于具有贪心选择性质和最优子结构性质的问题。</li><li><strong>动态规划</strong>：适用于更广泛的问题类型，特别是那些具有重叠子问题和最优子结构性质的问题。</li></ul></li><li><strong>计算复杂度</strong>：<ul><li><strong>贪心算法</strong>：通常较简单且高效，适用于大多数实际情况。</li><li><strong>动态规划</strong>：可能需要存储子问题的解，空间和时间复杂度一般较高。</li></ul></li></ul><h4 id="贪心算法实例"><a href="#贪心算法实例" class="headerlink" title="贪心算法实例"></a>贪心算法实例</h4><h5 id="1-活动安排问题（Activity-Selection-Problem）"><a href="#1-活动安排问题（Activity-Selection-Problem）" class="headerlink" title="1. 活动安排问题（Activity Selection Problem）"></a>1. 活动安排问题（Activity Selection Problem）</h5><p><strong>问题描述</strong>：给定一组活动，每个活动有一个开始时间和结束时间。要求选择尽可能多的互不重叠的活动。</p><p><strong>贪心策略</strong>：每次选择结束时间最早且与已选活动不冲突的活动。</p><p><strong>算法描述</strong>：</p><ol><li>按照活动的结束时间从小到大排序。</li><li>选择第一个活动。</li><li>从剩余活动中选择开始时间不早于上一个选择的活动结束时间的活动。</li><li>重复步骤3直到没有可选活动。</li></ol><h5 id="2-部分背包问题（Fractional-Knapsack-Problem）"><a href="#2-部分背包问题（Fractional-Knapsack-Problem）" class="headerlink" title="2. 部分背包问题（Fractional Knapsack Problem）"></a>2. 部分背包问题（Fractional Knapsack Problem）</h5><p><strong>问题描述</strong>：给定一组物品，每个物品有重量和价值，在允许部分取物的情况下，选择装入容量为 W 的背包，使得总价值最大。</p><p><strong>贪心策略</strong>：按照单位重量的价值（value&#x2F;weight）从大到小选择物品，尽可能多地装入背包。</p><p><strong>算法描述</strong>：</p><ol><li>计算每个物品的单位重量价值，并按其从大到小排序。</li><li>依次选择物品，直到背包装满或无法再装入更多物品。</li></ol><h5 id="3-最优装载问题（Optimal-Load-Problem）"><a href="#3-最优装载问题（Optimal-Load-Problem）" class="headerlink" title="3. 最优装载问题（Optimal Load Problem）"></a>3. 最优装载问题（Optimal Load Problem）</h5><p><strong>问题描述</strong>：在一个货运航班中，如何装载货物使得总重量不超过最大承载重量且装载的货物总价值最大。</p><p><strong>贪心策略</strong>：按照单位重量的价值（value&#x2F;weight）从大到小选择货物，尽可能多地装入航班。</p><h5 id="4-哈夫曼编码（Huffman-Coding）"><a href="#4-哈夫曼编码（Huffman-Coding）" class="headerlink" title="4. 哈夫曼编码（Huffman Coding）"></a>4. 哈夫曼编码（Huffman Coding）</h5><p><strong>问题描述</strong>：给定一组字符及其对应的频率，构建一个二进制前缀码（哈夫曼码）使得编码后的字符总长度最短。</p><p><strong>贪心策略</strong>：每次选择频率最小的两个节点合并，直到所有节点合并成一棵树。</p><p><strong>算法描述</strong>：</p><ol><li>将所有字符构建成叶子节点，并按照频率构建一个优先队列。</li><li>每次从队列中取出频率最小的两个节点，合并成一个新节点，并将新节点的频率设为两个节点频率之和。</li><li>将新节点重新放入队列。</li><li>重复步骤2和3，直到队列中只剩一个节点，这个节点即为哈夫曼树的根。</li></ol><h5 id="5-最小生成树（Minimum-Spanning-Tree-MST）"><a href="#5-最小生成树（Minimum-Spanning-Tree-MST）" class="headerlink" title="5. 最小生成树（Minimum Spanning Tree, MST）"></a>5. 最小生成树（Minimum Spanning Tree, MST）</h5><p><strong>问题描述</strong>：给定一个带权无向图，找到一个树，使得树包含所有节点且边的权值和最小。</p><p><strong>常用贪心算法</strong>：Kruskal算法和Prim算法。</p><p><strong>Kruskal算法</strong>：</p><ol><li>将所有边按权重从小到大排序。</li><li>初始化一个森林（每个顶点各自为树）。</li><li>依次选择权重最小的边，若该边连接的两个顶点属于不同的树，则将其加入生成树，并合并这两个顶点所在的树。</li><li>重复步骤3，直到生成树包含所有顶点。</li></ol><p><strong>Prim算法</strong>：</p><ol><li>从任意一个顶点开始，将其标记为已访问。</li><li>在已访问顶点和未访问顶点之间选择权重最小的边，将该边和其连接的未访问顶点加入生成树。</li><li>重复步骤2，直到生成树包含所有顶点。</li></ol><h5 id="6-多机调度问题（Job-Scheduling-Problem）"><a href="#6-多机调度问题（Job-Scheduling-Problem）" class="headerlink" title="6. 多机调度问题（Job Scheduling Problem）"></a>6. 多机调度问题（Job Scheduling Problem）</h5><p><strong>问题描述</strong>：给定一组作业和多个机器，安排作业到机器上，使得所有作业完成的总时间最短。</p><p><strong>贪心策略</strong>：每次选择最短作业时间或将作业分配到当前负载最轻的机器上。</p><p><strong>算法描述</strong>：</p><ol><li>按作业时间从短到长排序。</li><li>依次将作业分配到当前负载最轻的机器上。</li></ol><p>贪心算法通过简洁有效的策略解决了许多实际问题，但并非适用于所有情况。在使用贪心算法时，需要确保问题具备贪心选择性质和最优子结构性质。</p><h1 id="试卷结构"><a href="#试卷结构" class="headerlink" title="试卷结构"></a><strong>试卷结构</strong></h1><p>试卷共4页，5大题，满分 100分， 120 分钟完卷。</p><h4 id="一、单项选择题：-每小题2分，共30分"><a href="#一、单项选择题：-每小题2分，共30分" class="headerlink" title="一、单项选择题：(每小题2分，共30分)"></a>一、<strong>单项选择题：</strong>(每小题2分，共30分)</h4><p>在下列每小题的四个备选答案中选出一个正确的答案，并将其字母标号填入下面的表格中，填入题干的括号内无效。</p><h4 id="二、判断题：-每小题1分，共10分）"><a href="#二、判断题：-每小题1分，共10分）" class="headerlink" title="二、判断题：(每小题1分，共10分）"></a>二、<strong>判断题：</strong>(每小题1分，共10分）</h4><p>以下描述正确的打“√”，错误的打“×”，并将答案填在下面的表格中。</p><h4 id="三、计算题：-每小题10分，共30分"><a href="#三、计算题：-每小题10分，共30分" class="headerlink" title="三、计算题：(每小题10分，共30分)"></a><strong>三、计算题：</strong>(每小题10分，共30分)</h4><p>函数的渐进表达式计算（递归方程求解）、解空间树（子集树或排列树）、哈夫曼编码（构造哈夫曼树及编码）</p><h4 id="四、简答题：-每小题5分，共10分"><a href="#四、简答题：-每小题5分，共10分" class="headerlink" title="四、简答题：(每小题5分，共10分)"></a>四、<strong>简答题：</strong>(每小题5分，共10分)</h4><h5 id="动态规划总体思想、基本步骤、基本要素"><a href="#动态规划总体思想、基本步骤、基本要素" class="headerlink" title="动态规划总体思想、基本步骤、基本要素"></a>动态规划总体思想、基本步骤、基本要素</h5><ul><li><p>动态规划通过将原问题分解为相对简单的子问题来解决复杂问题，通过存储子问题的解，避免重复计算，从而提高效率。其关键在于将问题分解为子问题，并确定子问题之间的递推关系，以便逐步求解原问题。</p><h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><p>（1）</p><p>（2）递归地定义最优值。 </p><p>（3）以自底向上的方式或自顶向下的记忆化方法（备忘录法）计算出最优值。 </p><p>（4）根据计算最优值时得到的信息，构造一个最优解。 </p><h3 id="基本要素："><a href="#基本要素：" class="headerlink" title="基本要素："></a>基本要素：</h3><ul><li>最优子结构</li><li>状态转移方程</li><li>边界条件</li><li>状态存储</li><li>状态压缩</li></ul></li></ul><h5 id="回溯法的概念及基本思想、应用步骤及剪枝函数"><a href="#回溯法的概念及基本思想、应用步骤及剪枝函数" class="headerlink" title="回溯法的概念及基本思想、应用步骤及剪枝函数"></a>回溯法的概念及基本思想、应用步骤及剪枝函数</h5><p>概念：回溯法（Backtracking）是一种通过试探所有可能的解来求解问题的算法</p><p>基本思想：逐步构建问题的解决方案，并在搜索过程中进行选择和回退，直到找到解或确定问题无解为止</p><p>应用步骤：</p><ul><li>定义问题1</li><li>选择状态表示</li><li>编写回溯函数<ul><li>递归参数</li><li>递归终止条件</li><li>递归主体</li></ul></li><li>执行回溯搜索</li></ul><h5 id="分支限界法与回溯法的比较"><a href="#分支限界法与回溯法的比较" class="headerlink" title="分支限界法与回溯法的比较"></a>分支限界法与回溯法的比较</h5><p><strong>分支限界法与回溯法的相同点是：</strong>都是一种在问题的解空间树T中搜索问题解的算法。</p><p><strong>不同点：</strong>（1）求解目标不同； </p><p>（2）搜索方式不同； </p><p>（3）对扩展结点的扩展方式不同； </p><p>（4）存储空间的要求不同。</p><h4 id="分支限界法的基本思想、分支限界法的两种实现方式"><a href="#分支限界法的基本思想、分支限界法的两种实现方式" class="headerlink" title="分支限界法的基本思想、分支限界法的两种实现方式"></a>分支限界法的基本思想、分支限界法的两种实现方式</h4><p>基本思想：分支限界法通常以广度优先或者以最小耗费优先的方式搜索问题的解空间树</p><p>两种实现方式：</p><p>队列式分支限界法（队列式分支限界法将活结点表组织成一个队列，并按照队列先进先出的原则选取下一个结点为当前扩展结点）</p><p>优先队列式分支限界法（优先队列式的分支限界法将活结点表组织成一个优先队列，并按照优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前的扩展结点）</p><h3 id="五、算法设计题：-每小题10分，共20分"><a href="#五、算法设计题：-每小题10分，共20分" class="headerlink" title="五、算法设计题：(每小题10分，共20分)"></a><strong>五、算法设计题：</strong>(每小题10分，共20分)</h3><p>最大子段和、二分搜索算法</p><h6 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>        maxSum = Math.max(maxSum, dp[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br>解释：<br>dp[i] 数组用来存储以第 i 个元素结尾的最大子段和。<br>maxSum 变量用来记录 dp 数组中的最大值，即为最终的结果。<br>时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是数组 nums 的长度。<br>这种动态规划算法在实现上简单直观，并且能够有效地解决最大子段和问题。<br></code></pre></td></tr></table></figure><h6 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h6><p><img src="clip_image002-1718613963237-2.png" alt="img">                                                                 </p>]]></content>
    
    
    <categories>
      
      <category>学校课程</category>
      
      <category>复习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于AOP实现简单日志记录</title>
    <link href="/post/9697fbcc0d23/"/>
    <url>/post/9697fbcc0d23/</url>
    
    <content type="html"><![CDATA[<h3 id="基于AOP实现简单日志记录"><a href="#基于AOP实现简单日志记录" class="headerlink" title="基于AOP实现简单日志记录"></a>基于AOP实现简单日志记录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> org.example.springaoplog.log;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StopWatch;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日志切面</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 14237</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br>    <span class="hljs-meta">@Pointcut</span> ( <span class="hljs-string">&quot;@annotation(org.example.springaoplog.log.Log)&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Resource</span><br>    HttpServletRequest request;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Around</span> ( <span class="hljs-string">&quot;pointcut()&quot;</span>)<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> ((MethodSignature) pjp.getSignature());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(Log.class);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">StopWatch</span> <span class="hljs-variable">stopWatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        stopWatch.start();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">final</span> Object proceed;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            proceed = pjp.proceed();<br>            result = mapper.writeValueAsString(proceed);<span class="hljs-comment">//返回结果</span><br>            <span class="hljs-keyword">return</span> proceed;<br>        &#125; <span class="hljs-keyword">catch</span>(Throwable e) &#123;<br>            errorMsg = e.getLocalizedMessage();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stopWatch.stop();<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">SysLog</span> <span class="hljs-variable">sysLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLog</span>()<br>                    .setId(<span class="hljs-literal">null</span>)<br>                    .setRequestMethod(request.getMethod())<br>                    .setName(annotation.value())<br>                    .setType(annotation.type().getValue())<br>                    .setOperator(<span class="hljs-string">&quot;sessionId: &quot;</span> + request.getSession().getId())<br>                    .setOperatingTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())<br>                    .setIp(request.getRemoteHost())<br>                    .setUrl(request.getRequestURL().toString())<br>                    .setMethod(signature.toString())<br>                    .setArgs(mapper.writeValueAsString(pjp.getArgs()))<br>                    .setMillisecond(stopWatch.getTotalTimeMillis())<br>                    .setResult(result)<br>                    .setError(errorMsg);<br>            <span class="hljs-comment">//记录日志</span><br>            recordLog(sysLog);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录日志</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> log 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordLog</span><span class="hljs-params">(SysLog log)</span> &#123;<br>        <span class="hljs-comment">//保存到数据库</span><br>        System.err.println(log);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springaoplog.log;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><br><span class="hljs-meta">@Retention</span> ( RetentionPolicy.RUNTIME)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> LogType &#125;</span><br><span class="hljs-comment">     */</span><br>    LogType <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LogType.DEFAULT;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@link</span> String &#125;</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springaoplog.log;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Getter;<br><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">LogType</span> &#123;<br>    DEFAULT(<span class="hljs-string">&quot;默认&quot;</span>),<br>    SYSTEM(<span class="hljs-string">&quot;系统日志&quot;</span>),<br>    BUSINESS(<span class="hljs-string">&quot;业务日志&quot;</span>),<br>    OPERATE(<span class="hljs-string">&quot;操作日志&quot;</span>),<br>    TEST(<span class="hljs-string">&quot;测试日志&quot;</span>);<br>    <span class="hljs-keyword">final</span> String value;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.springaoplog.log;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.experimental.Accessors;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 系统日志</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> inyxin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors</span> ( chain = <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysLog</span> &#123;<br>    <span class="hljs-comment">/** 日志ID */</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">/** 日志名字 */</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">/** 日志类型 */</span><br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-comment">/** 请求路径 */</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-comment">/** 请求方式 */</span><br>    <span class="hljs-keyword">private</span> String requestMethod;<br>    <span class="hljs-comment">/** 操作者 */</span><br>    <span class="hljs-keyword">private</span> String operator;<br>    <span class="hljs-comment">/** 方法 */</span><br>    <span class="hljs-keyword">private</span> String method;<br>    <span class="hljs-comment">/** 参数 */</span><br>    <span class="hljs-keyword">private</span> String args;<br>    <span class="hljs-comment">/** 远程IP */</span><br>    <span class="hljs-keyword">private</span> String ip;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date operatingTime;<br>    <span class="hljs-comment">/** 异常信息 */</span><br>    <span class="hljs-keyword">private</span> String error;<br>    <span class="hljs-comment">/** 结果 */</span><br>    <span class="hljs-keyword">private</span> String result;<br>    <span class="hljs-comment">/** 方法执行时间 毫秒 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> millisecond;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2013-2018 the original author or authors.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment"> * you may not use this file except in compliance with the License.</span><br><span class="hljs-comment"> * You may obtain a copy of the License at</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment"> * See the License for the specific language governing permissions and</span><br><span class="hljs-comment"> * limitations under the License.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> org.example.springaoplog.demos.web;<br><br><span class="hljs-keyword">import</span> org.example.springaoplog.log.Log;<br><span class="hljs-keyword">import</span> org.example.springaoplog.log.LogType;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> &lt;a href=&quot;mailto:chenxilzx1@gmail.com&quot;&gt;theonefx&lt;/a&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicController</span> &#123;<br><br>    <span class="hljs-comment">// http://127.0.0.1:8080/hello?name=lisi</span><br>    <span class="hljs-meta">@RequestMapping</span> ( <span class="hljs-string">&quot;/hello&quot;</span>)<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@Log</span> (<br>            value = <span class="hljs-string">&quot;Hello&quot;</span>,<br>            type = LogType.TEST<br>    )<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@RequestParam</span> (</span><br><span class="hljs-params">                    name = <span class="hljs-string">&quot;name&quot;</span>,</span><br><span class="hljs-params">                    defaultValue = <span class="hljs-string">&quot;unknown user&quot;</span></span><br><span class="hljs-params">            )</span> String name) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">// http://127.0.0.1:8080/errortest</span><br>    <span class="hljs-meta">@RequestMapping</span> ( <span class="hljs-string">&quot;/errortest&quot;</span>)<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@Log</span> (<br>            value = <span class="hljs-string">&quot;异常测试&quot;</span>,<br>            type = LogType.TEST<br>    )<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">errortest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;12321&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// http://127.0.0.1:8080/user</span><br>    <span class="hljs-meta">@RequestMapping</span> ( <span class="hljs-string">&quot;/user&quot;</span>)<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@Log</span> ( value = <span class="hljs-string">&quot;查询用户&quot;</span>)<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">user</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;theonefx&quot;</span>);<br>        user.setAge(<span class="hljs-number">666</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br><br>    <span class="hljs-comment">// http://127.0.0.1:8080/save_user?name=newName&amp;age=11</span><br>    <span class="hljs-meta">@RequestMapping</span> ( <span class="hljs-string">&quot;/save_user&quot;</span>)<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@Log</span> (<br>            value = <span class="hljs-string">&quot;保存用户&quot;</span>,<br>            type = LogType.OPERATE<br>    )<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">saveUser</span><span class="hljs-params">(User u)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user will save: name=&quot;</span> + u.getName() + <span class="hljs-string">&quot;, age=&quot;</span> + u.getAge();<br>    &#125;<br><br>    <span class="hljs-comment">// http://127.0.0.1:8080/html</span><br>    <span class="hljs-meta">@RequestMapping</span> ( <span class="hljs-string">&quot;/html&quot;</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">html</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index.html&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseUser</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@RequestParam</span> (</span><br><span class="hljs-params">                    name = <span class="hljs-string">&quot;name&quot;</span>,</span><br><span class="hljs-params">                    defaultValue = <span class="hljs-string">&quot;unknown user&quot;</span></span><br><span class="hljs-params">            )</span> String name<br>            ,<br>            <span class="hljs-meta">@RequestParam</span> (<br>                    name = <span class="hljs-string">&quot;age&quot;</span>,<br>                    defaultValue = <span class="hljs-string">&quot;12&quot;</span><br>            ) Integer age, User user) &#123;<br>        user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        user.setAge(<span class="hljs-number">18</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SysLog(id=<span class="hljs-literal">null</span>, name=查询用户, type=默认, url=http:<span class="hljs-comment">//127.0.0.1:8080/user, requestMethod=GET, operator=sessionId: 2F552A00DA410EEE3047B4AEE36927B1, method=User org.example.springaoplog.demos.web.BasicController.user(), args=[], ip=127.0.0.1, operatingTime=Fri Jun 14 10:02:11 CST 2024, error=, result=&#123;&quot;name&quot;:&quot;theonefx&quot;,&quot;age&quot;:666&#125;, millisecond=7)</span><br>SysLog(id=<span class="hljs-literal">null</span>, name=查询用户, type=默认, url=http:<span class="hljs-comment">//10.120.1.193:8080/user, requestMethod=GET, operator=sessionId: 39EA319EFCC022E1973A1C9DA452DAE2, method=User org.example.springaoplog.demos.web.BasicController.user(), args=[], ip=10.120.1.193, operatingTime=Fri Jun 14 10:06:46 CST 2024, error=, result=&#123;&quot;name&quot;:&quot;theonefx&quot;,&quot;age&quot;:666&#125;, millisecond=0)</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOP</tag>
      
      <tag>Log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapStruct 对象转换框架</title>
    <link href="/post/ca7c951ed4e8/"/>
    <url>/post/ca7c951ed4e8/</url>
    
    <content type="html"><![CDATA[<h1 id="MapStruct-对象转换框架"><a href="#MapStruct-对象转换框架" class="headerlink" title="MapStruct 对象转换框架"></a>MapStruct 对象转换框架</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">        <span class="hljs-tag">&lt;<span class="hljs-name">mapstruct.version</span>&gt;</span>1.4.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">mapstruct.version</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理与 <code>lomback</code> 类似&#96; , 都是通过自动生成代码;</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><h5 id="定义映射接口"><a href="#定义映射接口" class="headerlink" title="定义映射接口"></a>定义映射接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GoodsInfoMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无状态且线程安全</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">GoodsInfoMapper</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(GoodsInfoMapper.class);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GoodsInfoPO</span> <span class="hljs-variable">goodsInfoPO</span> <span class="hljs-operator">=</span> GoodsInfoMapper.INSTANCE.goodsInfoDtoToPo(goodsInfoDTO);<br></code></pre></td></tr></table></figure><h3 id="在-Spring-中使用"><a href="#在-Spring-中使用" class="headerlink" title="在 Spring 中使用"></a>在 Spring 中使用</h3><h5 id="定义映射接口-1"><a href="#定义映射接口-1" class="headerlink" title="定义映射接口"></a>定义映射接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper(componentModel = &quot;spring&quot;)</span> <span class="hljs-comment">// 设置为 spring</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GoodsInfoMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无状态且线程安全</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">GoodsInfoMapper</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(GoodsInfoMapper.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>有了 <code>@Mapper(componentModel = &quot;spring)</code> 这个后.生成的实现类上会自动加上  <code>@Component</code> 注解</p><h4 id="Mapping"><a href="#Mapping" class="headerlink" title="@Mapping"></a>@Mapping</h4><p><code>@Mapping</code> 注解是 MapStruct 框架中的一个关键注解，用于定义两个 bean 之间的字段映射关系。它可以应用在 Mapper 接口的方法上，指定源（source）字段到目标（target）字段的映射关系。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CarMapper</span> &#123;<br><br>    <span class="hljs-meta">@Mapping(source = &quot;make&quot;, target = &quot;manufacturer&quot;)</span><br>    CarDto <span class="hljs-title function_">carToCarDto</span><span class="hljs-params">(Car car)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>@Mapping(source = &quot;make&quot;, target = &quot;manufacturer&quot;)</code> 表示将 <code>Car</code> 对象的 <code>make</code> 字段映射到 <code>CarDto</code> 对象的 <code>manufacturer</code> 字段上。</p><h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><ul><li><p><strong>source</strong>：源对象的字段名。</p></li><li><p><strong>target</strong>：目标对象的字段名。</p></li><li><p><strong>qualifiedByName</strong>：通过一个命名转换器来转换字段值。</p></li><li><p><strong>defaultValue</strong>：指定目标字段的默认值。</p></li><li><p><strong>ignore</strong>：忽略某个字段，不进行映射。</p></li><li><p><strong>expression</strong>：使用 SpEL 表达式定义映射规则。</p><p><code>This attribute can not be used together with source(), defaultValue(), defaultExpression() or expression().</code></p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><strong>简单映射</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapping(source = &quot;name&quot;, target = &quot;fullName&quot;)</span><br>PersonDto <span class="hljs-title function_">personToPersonDto</span><span class="hljs-params">(Person person)</span>;<br></code></pre></td></tr></table></figure><p>这个示例将 <code>Person</code> 对象的 <code>name</code> 字段映射到 <code>PersonDto</code> 对象的 <code>fullName</code> 字段。</p><ol><li><strong>使用转换器</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jaVA"><span class="hljs-meta">@Mapping(source = &quot;birthDate&quot;, target = &quot;birthDate&quot;, dateFormat = &quot;dd-MM-yyyy&quot;)</span><br>PersonDto <span class="hljs-title function_">personToPersonDto</span><span class="hljs-params">(Person person)</span>;<br></code></pre></td></tr></table></figure><p>这个示例中，<code>dateFormat</code> 属性指定了日期格式，MapStruct 会自动将 <code>Person</code> 对象的 <code>birthDate</code> 字段按照指定的格式转换为 <code>PersonDto</code> 对象的 <code>birthDate</code> 字段。</p><ol><li><strong>忽略字段</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Mapping(target = &quot;id&quot;, ignore = true)</span><br>PersonDto <span class="hljs-title function_">personToPersonDto</span><span class="hljs-params">(Person person)</span>;<br></code></pre></td></tr></table></figure><p>这个示例中，<code>ignore = true</code> 表示忽略 <code>PersonDto</code> 对象的 <code>id</code> 字段，不进行映射。</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ul><li><strong>多字段映射</strong>：可以同时映射多个字段，通过多个 <code>@Mapping</code> 注解实现。</li><li><strong>复杂类型映射</strong>：支持复杂对象类型，如集合、嵌套对象等。</li><li><strong>条件映射</strong>：通过 SpEL 表达式在 <code>@Mapping</code> 的 <code>expression</code> 属性中定义条件，根据条件动态进行映射。</li></ul><p><code>@Mapping</code> 注解使得 MapStruct 在生成映射代码时具有灵活性和可配置性，能够应对多种复杂的映射需求。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/post/e667cd738d13/"/>
    <url>/post/e667cd738d13/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br>        --name es \<br>        -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \<br>        -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>        -v es-data:/usr/share/elasticsearch/data \<br>        -v es-plugins:/usr/share/elasticsearch/plugins \<br>        -v es-logs:/usr/share/elasticsearch/logs \<br>        --privileged \ --network es-net \<br>        -p 9200:9200 \<br>        -p 9300:9300 \<br>elasticsearch:7.12.1<br></code></pre></td></tr></table></figure><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">1panel-network:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">es-volumes:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">elasticsearch:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">es</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:7.12.1</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> <span class="hljs-comment"># 非集群模块</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9300:9300&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;es-volumes:/usr/share/elasticsearch&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">1panel-network</span><br>  <span class="hljs-attr">kibana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.12.1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kibana</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ELASTICSEARCH_HOSTS=http://es:9200</span> <span class="hljs-comment">#设置访问elasticsearch的地址</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">5601</span><span class="hljs-string">:5601</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">1panel-network</span><br></code></pre></td></tr></table></figure><h2 id="安装中文分词"><a href="#安装中文分词" class="headerlink" title="安装中文分词"></a>安装中文分词</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@beelink</span><span class="hljs-symbol">:/var/lib/docker/volumes/es-volumes/_data</span><span class="hljs-comment"># bin/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/7.12.1</span><br></code></pre></td></tr></table></figure><h3 id="部署地址"><a href="#部署地址" class="headerlink" title="部署地址:"></a>部署地址:</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ES : http:<span class="hljs-regexp">//</span><span class="hljs-number">172.19</span>.<span class="hljs-number">143.22</span>:<span class="hljs-number">9200</span>/<br>Kibanna http:<span class="hljs-regexp">//</span><span class="hljs-number">172.19</span>.<span class="hljs-number">143.22</span>:<span class="hljs-number">5601</span><span class="hljs-regexp">/app/</span>dev_tools<span class="hljs-comment">#/console</span><br></code></pre></td></tr></table></figure><p><a href="http://172.19.143.22:9200/">ES</a></p><p><a href="http://172.19.143.22:5601/app/dev_tools#/console">KibanaDev Tools - Elastic </a></p><h2 id="IK-分词器插件安装"><a href="#IK-分词器插件安装" class="headerlink" title="IK 分词器插件安装"></a>IK 分词器插件安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://github.com/infinilabs/analysis-ik/tags?after=v7.12.1">IK 分词器插件 Tags · infinilabs&#x2F;analysis-ik (github.com)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">将对于版本的插件 如 <span class="hljs-number">7.12</span><span class="hljs-number">.1</span> 版本的ik <span class="hljs-built_in">zip</span>解压 放在 es 的plugins目录下<br></code></pre></td></tr></table></figure><h3 id="分词测试"><a href="#分词测试" class="headerlink" title="分词测试"></a>分词测试</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_analyze<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ik_smart&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;这个到秦始皇就是非好像是被那种高层吧高层想消灭他，然后就用那个他的软肋，就因为它已经变成掌控了掌控他有个软肋是他婆娘。复生者，对，但是掌控可以影响啊在宾馆里面是吧？嗯，对，但是。会影响他的那个秦始皇然后反正之后就相当于是自爆我靠晕了自己，把自己给灭了。用腿狼。不用推导与他人。自己是秦始皇，然后他本来是是天外的那种修行者然后到地球来寻找突破之法然后地球灵气不够，他传不回去了，然后反正秦始皇那些秦始皇就是它几千年后他被人挖了起来，走了。&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="索引库"><a href="#索引库" class="headerlink" title="索引库"></a>索引库</h2><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><ul><li>type <ul><li>字符串 : <code>text</code>(可分词)   <code>keyword</code>(精确值 , 不可分词, 如 IP, 地址, 品牌)</li><li>数值 : <code>long integer short byte  double float number</code></li><li>布尔 : <code>boolean</code></li><li>日期 : <code>date</code></li><li>对象 : <code>object</code></li></ul></li><li>index : 是否创建索引 , 默认值 <code>true</code></li><li>analyzer : 使用哪种分词器</li><li>properties : 该字段的子字段</li></ul><h3 id="索引库-的-CRUD"><a href="#索引库-的-CRUD" class="headerlink" title="索引库 的 CRUD"></a>索引库 的 CRUD</h3><ul><li><p>创建索引库</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /inyxin<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;details&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>查询索引库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /索引库<br></code></pre></td></tr></table></figure></li><li><p>修改索引库 <code>只支持新增字段 </code> </p><p>如果字段已经存在 , 则会报错</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引库/</span>_mapping<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /inyxin/_mapping<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;true&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>删除索引库</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">DELETE</span> /索引库<br></code></pre></td></tr></table></figure></li></ul><h2 id="文档的-CRUD"><a href="#文档的-CRUD" class="headerlink" title="文档的 CRUD"></a>文档的 CRUD</h2><ul><li><p>新增</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引库/</span>_doc/文档ID<br>&#123;<br>文档数据<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /inyxin/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;20&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;确实是描述&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;四川·达州&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;details&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;四川文理学院·南坝校区&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>添加成功后响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span>  索引库名<br>  <span class="hljs-attr">&quot;_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span>文档名<br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span>文档ID<br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;result&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;created&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_shards&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;total&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;successful&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p>读取</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /索引库/_doc/文档ID<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /inyxin/_doc/1<br></code></pre></td></tr></table></figure><p>查询结果</p><p><code>_source</code> : 原始文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;_doc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_version&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;found&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;_source&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inyxin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;20&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;确实是描述&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;city&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;四川·达州&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;details&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;四川文理学院·南坝校区&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>修改</p><ul><li><p><code> 全量修改 (覆盖修改)</code> </p><p>若文档 ID 已存在 , 则会先删除旧的文档, 在进行新增 ,</p><p>否则 就是添加一个新的文档</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引库/</span>_doc/文档ID  同新增<br>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>增量修改 (局部修改)</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">UPDATE  /索引库/_update/文档ID<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;YINIXN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">21</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>删除</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/索引库/</span>_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h1><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">GET</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
      <tag>搜索引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux启动脚本</title>
    <link href="/post/fe20cd40b669/"/>
    <url>/post/fe20cd40b669/</url>
    
    <content type="html"><![CDATA[<h2 id="实现用户登录后执行特定启动脚本"><a href="#实现用户登录后执行特定启动脚本" class="headerlink" title="实现用户登录后执行特定启动脚本"></a>实现用户登录后执行特定启动脚本</h2><h3 id="1-使用-bash-profile-或-bashrc"><a href="#1-使用-bash-profile-或-bashrc" class="headerlink" title="1. 使用 .bash_profile 或 .bashrc"></a>1. 使用 <code>.bash_profile</code> 或 <code>.bashrc</code></h3><p>如果使用的是 Bash shell，可以将启动脚本添加到用户主目录下的 <code>.bash_profile</code> 或 <code>.bashrc</code> 文件中。</p><h4 id="bash-profile"><a href="#bash-profile" class="headerlink" title=".bash_profile"></a>.bash_profile</h4><p><code>.bash_profile</code> 在用户登录时运行一次。适用于登录 shell。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">bashCopy Code# 编辑用户主目录下的 .bash_profile 文件<br>nano ~/.bash_profile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存并退出</span><br></code></pre></td></tr></table></figure><h4 id="bashrc"><a href="#bashrc" class="headerlink" title=".bashrc"></a>.bashrc</h4><p><code>.bashrc</code> 在每次打开一个新的 shell 时运行。适用于非登录 shell。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">bashCopy Code# 编辑用户主目录下的 .bashrc 文件<br>nano ~/.bashrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存并退出</span><br></code></pre></td></tr></table></figure><h3 id="2-使用-profile"><a href="#2-使用-profile" class="headerlink" title="2. 使用 .profile"></a>2. 使用 <code>.profile</code></h3><p>某些 Linux 发行版和 shell（如 Dash）使用 <code>.profile</code> 文件。该文件在用户登录时运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bashCopy Code<span class="hljs-comment"># 编辑用户主目录下的 .profile 文件</span><br>nano ~/.profile<br><br><span class="hljs-comment"># 在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><br><span class="hljs-comment"># 保存并退出</span><br></code></pre></td></tr></table></figure><h3 id="3-使用-etc-profile-和-etc-profile-d"><a href="#3-使用-etc-profile-和-etc-profile-d" class="headerlink" title="3. 使用 /etc/profile 和 /etc/profile.d"></a>3. 使用 <code>/etc/profile</code> 和 <code>/etc/profile.d</code></h3><p>对于全系统范围内的配置，可以编辑 <code>/etc/profile</code> 文件，或在 <code>/etc/profile.d</code> 目录下创建一个新的脚本。</p><h4 id="etc-profile"><a href="#etc-profile" class="headerlink" title="&#x2F;etc&#x2F;profile"></a>&#x2F;etc&#x2F;profile</h4><p>在所有用户登录时运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bashCopy Code<span class="hljs-comment"># 编辑 /etc/profile 文件（需要root权限）</span><br>sudo nano /etc/profile<br><br><span class="hljs-comment"># 在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><br><span class="hljs-comment"># 保存并退出</span><br></code></pre></td></tr></table></figure><h4 id="etc-profile-d"><a href="#etc-profile-d" class="headerlink" title="&#x2F;etc&#x2F;profile.d"></a>&#x2F;etc&#x2F;profile.d</h4><p>在 <code>/etc/profile.d</code> 目录下创建一个新的脚本文件（必须以 <code>.sh</code> 结尾）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bashCopy Code<span class="hljs-comment"># 创建一个新的脚本文件（需要root权限）</span><br>sudo nano /etc/profile.d/myscript.sh<br><br><span class="hljs-comment"># 添加要执行的内容</span><br>/path/to/your/script.sh<br><br><span class="hljs-comment"># 保存并退出</span><br></code></pre></td></tr></table></figure><h3 id="4-使用-xinitrc-或-xsession"><a href="#4-使用-xinitrc-或-xsession" class="headerlink" title="4. 使用 .xinitrc 或 .xsession"></a>4. 使用 <code>.xinitrc</code> 或 <code>.xsession</code></h3><p>如果使用图形界面并希望在 X 会话启动时运行脚本，可以使用 <code>.xinitrc</code> 或 <code>.xsession</code> 文件。</p><h4 id="xinitrc"><a href="#xinitrc" class="headerlink" title=".xinitrc"></a>.xinitrc</h4><p>适用于使用 <code>startx</code> 启动 X 会话的用户。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bashCopy Code<span class="hljs-comment"># 编辑用户主目录下的 .xinitrc 文件</span><br>nano ~/.xinitrc<br><br><span class="hljs-comment"># 在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><br><span class="hljs-comment"># 保存并退出</span><br></code></pre></td></tr></table></figure><h4 id="xsession"><a href="#xsession" class="headerlink" title=".xsession"></a>.xsession</h4><p>适用于使用显示管理器（如 GDM、LightDM）启动 X 会话的用户。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">bashCopy Code<span class="hljs-comment"># 编辑用户主目录下的 .xsession 文件</span><br>nano ~/.xsession<br><br><span class="hljs-comment"># 在文件末尾添加要执行的脚本</span><br>/path/to/your/script.sh<br><br><span class="hljs-comment"># 保存并退出</span><br></code></pre></td></tr></table></figure><p>选择合适的方法取决于具体需求和系统环境。通常情况下，对于单个用户和命令行环境，修改 <code>.bash_profile</code> 或 <code>.bashrc</code> 是最常用的方法。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>default</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/post/8a8dcb035543/"/>
    <url>/post/8a8dcb035543/</url>
    
    <content type="html"><![CDATA[<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><ul><li><p><code>docker version</code> 显示 docekr 的详细信息</p></li><li><p><code>docker info</code> 显示 docker 的系统信息</p></li><li><p><code>docker --help</code> docker 的命令帮助手册</p></li><li><p><code>docker search &#123;关键字&#125;</code> 搜索镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker search nginx <span class="hljs-comment">#搜索nginx镜像</span><br>docker search openjdk <span class="hljs-comment">#搜索openjdk镜像</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker pull &#123;镜像名[标签]&#125;</code> 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull nginx <span class="hljs-comment">#拉取 nginx镜像</span><br>docker pull openjdk:latest <span class="hljs-comment">#拉取 openjdk镜像</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker images</code> 查看已经下载的镜像</p></li><li><p><code>docker rmi &#123;镜像名或镜像ID&#125;</code> 删除镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi nginx <span class="hljs-comment"># 删除镜像名为nginx的镜像</span><br>docker rmi e235nd <span class="hljs-comment"># 根据镜像ID删除</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker tag &#123;原来的镜像名[:标签]&#125; &#123;新的镜像名[:标签]&#125;</code> 复制镜像并修改名称</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]<br><span class="hljs-comment">#SOURCE_IMAGE 是要标记的现有镜像的名称或 ID。</span><br><span class="hljs-comment">#TARGET_IMAGE 是为现有镜像指定的新标签的名称。</span><br><span class="hljs-comment">#TAG 是可选的标签，用于指定版本或其他特定标识符。</span><br>例如:<br>docker tag nginx inyxin/nginx:beta  <br></code></pre></td></tr></table></figure></li><li><p><code>docker load -i &#123;镜像的tar&#125;</code>  导入镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i /root/docker-centos-httpd.tar<br></code></pre></td></tr></table></figure></li><li><p><code>docker save -o &#123;镜像的tar&#125; &#123;镜像名&#125;</code>  导出镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o xxx.tar 镜像名<br>docker save -o my_image.tar my_image <br></code></pre></td></tr></table></figure></li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li><p><code>docker run [参数] &#123;镜像&#125; [COMMAND] [ARG...]</code> <strong>启动容器 (重点)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#语法</span><br>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br><span class="hljs-comment">#[OPTIONS]</span><br>-d, --detach：在后台运行容器。<br>--name：为容器指定一个名称。<br>-p, --publish：将容器端口映射到宿主机端口。<br>-v, --volume：挂载宿主机目录到容器内部。<br>-e, --<span class="hljs-built_in">env</span>：设置环境变量。<br>--network：连接容器到指定的网络。<br>--restart：在容器退出时指定重启策略。<br>--<span class="hljs-built_in">rm</span>：容器退出时自动删除。<br>-it：交互式操作，通常与 -i（标准输入）和 -t（终端）一起使用。<br><span class="hljs-comment"># [COMMAND] [ARG...]</span><br><span class="hljs-comment">#可以覆盖默认的命令和参数。例如，你可以执行以下命令来覆盖默认的命令：</span><br>docker run my_image <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, Docker!&quot;</span><br><span class="hljs-comment">#在这个例子中，echo &quot;Hello, Docker!&quot; 将覆盖镜像中定义的默认命令，容器将输出 Hello, Docker! 而不是 Hello, World!。</span><br></code></pre></td></tr></table></figure></li><li><p><code>docker build [OPTIONS]</code> 创建镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build [OPTIONS]<br><span class="hljs-comment">#[OPTIONS]</span><br>-f : 指定dockerfile文件路径 , 默认就是当前目录的 Dockerfile 文件<br>-t : 构建后的镜像名以及标签<br><span class="hljs-comment">#[EXAMPLE]</span><br>docker build -t inyxin/openjdk:1.8 <br></code></pre></td></tr></table></figure></li><li><p><code>docker logs &#123;容器ID&#125;</code>  查看容器日志</p></li><li><p><code>docker rename &#123;旧名字&#125; &#123;新名字&#125;</code> 容器重命名</p></li><li><p><code>docker ps [-a]</code>  查看正在运行的容器 [ -a 查看全部容器 ] </p></li><li><p><code>docekr kill &#123;容器名 或 容器ID&#125;</code> 杀死一个容器</p></li><li><p><code>docker rm &#123;容器名 或 容器ID&#125;</code> 删除容器</p></li></ul><p>[^{容器名 或 容器 ID}]: 以下简称 {容器ID}</p><ul><li><p><code>docker history &#123;容器ID&#125;</code>  查看 docker 镜像的变更历史</p></li><li><p><code>docker start &#123;容器ID&#125;</code> 启动一个容器</p></li><li><p><code>docker restart &#123;容器ID&#125;</code>  重启容器</p></li><li><p><code>docker stop</code> 停止容器</p></li><li><p><code>doceker image inspect &#123;容器ID&#125;</code>  查看容器内源数据</p></li><li><p><code>docker cp &#123;容器ID&#125;:路径 主机路径</code> 从容器内拷贝文件到主机</p></li><li><p><code>docker exec -it &#123;容器名ID&#125; /bin/bash</code> 进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it 1Panel-minio-UuPy /bin/bash<br></code></pre></td></tr></table></figure></li><li><p><code>docker commit -m=&quot;提交的描述信息&quot;  -a=&quot;作者&quot;  &#123;容器id&#125;  &#123;目标镜像名:[TAG]&#125;</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br>--name inyxin-minio \ <br>-v <span class="hljs-string">&quot;/opt/1panel/apps/minio/minio/data:/data&quot;</span> \ <br>-v <span class="hljs-string">&quot;/opt/1panel/apps/minio/minio/certs:/root/.minio/certs&quot;</span> \<br>-p <span class="hljs-string">&quot;9001:9001&quot;</span> \ <br>-p <span class="hljs-string">&quot;9000:9000&quot;</span> \<br>--restart always \ <br>-e MINIO_ROOT_PASSWORD=<span class="hljs-string">&quot;1423716216@qq.com&quot;</span> \ <br>-e MINIO_ROOT_USER=<span class="hljs-string">&quot;1423716216@qq.com&quot;</span> \<br>-e MINIO_SERVER_URL=<span class="hljs-string">&quot;http://127.0.0.1:9000&quot;</span> \<br>-e MINIO_BROWSER=on \<br>-e MINIO_BROWSER_LOGIN_ANIMATION=on \<br>-e MINIO_BROWSER_REDIRECT_URL=<span class="hljs-string">&quot;http://127.0.0.1:9001&quot;</span> \<br>-e MINIO_BROWSER_SESSION_DURATION=12h \<br>-e PATH=/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin \<br>-e container=oci \<br>-e MINIO_ACCESS_KEY_FILE=access_key \<br>-e MINIO_SECRET_KEY_FILE=secret_key \<br>-e MINIO_ROOT_USER_FILE=access_key \<br>-e MINIO_ROOT_PASSWORD_FILE=secret_key \<br>-e MINIO_KMS_SECRET_KEY_FILE=kms_master_key \<br>-e MINIO_UPDATE_MINISIGN_PUBKEY=RWTx5Zr1tiHQLwG9keckT0c45M3AGeHD6IvimQHpyRywVWGbP1aVSGav \<br>-e MINIO_CONFIG_ENV_FILE=config.env \<br>minio/minio <br><br></code></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 指定基础镜像，例如 node:14。这是 Dockerfile 的第一条指令，定义了新镜像是基于哪个已有镜像创建的。</span><br>FROM &lt;base_image&gt;<br><br><span class="hljs-comment"># 设置作者信息 (可选)</span><br>LABEL maintainer=<span class="hljs-string">&quot;&lt;your_name&gt; &lt;your_email&gt;&quot;</span><br><br><span class="hljs-comment"># 设置工作目录。所有后续的 COPY, ADD, RUN 等指令都将在这个目录下执行。例如 WORKDIR /usr/src/app</span><br>WORKDIR /usr/src/app<br><br><span class="hljs-comment"># 复制文件到镜像中</span><br>COPY &lt;<span class="hljs-built_in">source</span>&gt; &lt;destination&gt;<br><br><span class="hljs-comment"># 下载并安装依赖包</span><br>RUN &lt;<span class="hljs-built_in">command</span>&gt;<br><br><span class="hljs-comment"># 设置环境变量 (可选)</span><br>ENV &lt;key&gt;=&lt;value&gt;<br><br><span class="hljs-comment"># 暴露端口 (可选)</span><br>EXPOSE &lt;port&gt;<br><br><span class="hljs-comment"># 运行容器启动时的命令 ,与 CMD 类似，但 ENTRYPOINT 不会被 docker run 提供的参数覆盖。例如：</span><br>ENTRYPOINT [<span class="hljs-string">&quot;&lt;command&gt;&quot;</span>]<br><br><span class="hljs-comment"># 指定默认参数 (可选) 指定容器启动时要执行的命令。例如，CMD [&quot;npm&quot;, &quot;start&quot;]。注意，CMD 只会有一个生效，如果存在多个 CMD 指令，只有最后一个会被执行。</span><br>CMD [<span class="hljs-string">&quot;&lt;args&gt;&quot;</span>]<br></code></pre></td></tr></table></figure><p>通过 &#96;docker build -t {镜像: 标签} 即可构建</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">volume</span> <span class="hljs-string">COMMAND</span><br><br><span class="hljs-string">Manage</span> <span class="hljs-string">volumes</span><br><br><span class="hljs-attr">Commands:</span><br>  <span class="hljs-string">create</span>      <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">volume</span><br>  <span class="hljs-string">inspect</span>     <span class="hljs-string">Display</span> <span class="hljs-string">detailed</span> <span class="hljs-string">information</span> <span class="hljs-string">on</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">volumes</span><br>  <span class="hljs-string">ls</span>          <span class="hljs-string">List</span> <span class="hljs-string">volumes</span><br>  <span class="hljs-string">prune</span>       <span class="hljs-string">Remove</span> <span class="hljs-string">unused</span> <span class="hljs-string">local</span> <span class="hljs-string">volumes</span><br>  <span class="hljs-string">rm</span>          <span class="hljs-string">Remove</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">volumes</span><br></code></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">network</span> <span class="hljs-string">COMMAND</span><br><br><span class="hljs-string">Manage</span> <span class="hljs-string">networks</span><br><br><span class="hljs-attr">Commands:</span><br>  <span class="hljs-string">connect</span>     <span class="hljs-string">Connect</span> <span class="hljs-string">a</span> <span class="hljs-string">container</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">network</span><br>  <span class="hljs-string">create</span>      <span class="hljs-string">Create</span> <span class="hljs-string">a</span> <span class="hljs-string">network</span><br>  <span class="hljs-string">disconnect</span>  <span class="hljs-string">Disconnect</span> <span class="hljs-string">a</span> <span class="hljs-string">container</span> <span class="hljs-string">from</span> <span class="hljs-string">a</span> <span class="hljs-string">network</span><br>  <span class="hljs-string">inspect</span>     <span class="hljs-string">Display</span> <span class="hljs-string">detailed</span> <span class="hljs-string">information</span> <span class="hljs-string">on</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">networks</span><br>  <span class="hljs-string">ls</span>          <span class="hljs-string">List</span> <span class="hljs-string">networks</span><br>  <span class="hljs-string">prune</span>       <span class="hljs-string">Remove</span> <span class="hljs-string">all</span> <span class="hljs-string">unused</span> <span class="hljs-string">networks</span><br>  <span class="hljs-string">rm</span>          <span class="hljs-string">Remove</span> <span class="hljs-string">one</span> <span class="hljs-string">or</span> <span class="hljs-string">more</span> <span class="hljs-string">networks</span><br></code></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Usage:</span>  <span class="hljs-string">docker</span> <span class="hljs-string">compose</span> [<span class="hljs-string">OPTIONS</span>] <span class="hljs-string">COMMAND</span><br><br><span class="hljs-string">Define</span> <span class="hljs-string">and</span> <span class="hljs-string">run</span> <span class="hljs-string">multi-container</span> <span class="hljs-string">applications</span> <span class="hljs-string">with</span> <span class="hljs-string">Docker</span><br><br><span class="hljs-attr">Options:</span><br>      <span class="hljs-string">--all-resources</span>              <span class="hljs-string">Include</span> <span class="hljs-string">all</span> <span class="hljs-string">resources,</span> <span class="hljs-string">even</span> <span class="hljs-string">those</span> <span class="hljs-string">not</span> <span class="hljs-string">used</span> <span class="hljs-string">by</span> <span class="hljs-string">services</span><br>      <span class="hljs-string">--ansi</span> <span class="hljs-string">string</span>                <span class="hljs-string">Control</span> <span class="hljs-string">when</span> <span class="hljs-string">to</span> <span class="hljs-string">print</span> <span class="hljs-string">ANSI</span> <span class="hljs-string">control</span> <span class="hljs-string">characters</span> <span class="hljs-string">(&quot;never&quot;|&quot;always&quot;|&quot;auto&quot;)</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;auto&quot;</span><span class="hljs-string">)</span><br>      <span class="hljs-string">--compatibility</span>              <span class="hljs-string">Run</span> <span class="hljs-string">compose</span> <span class="hljs-string">in</span> <span class="hljs-string">backward</span> <span class="hljs-string">compatibility</span> <span class="hljs-string">mode</span><br>      <span class="hljs-string">--dry-run</span>                    <span class="hljs-string">Execute</span> <span class="hljs-string">command</span> <span class="hljs-string">in</span> <span class="hljs-string">dry</span> <span class="hljs-string">run</span> <span class="hljs-string">mode</span><br>      <span class="hljs-string">--env-file</span> <span class="hljs-string">stringArray</span>       <span class="hljs-string">Specify</span> <span class="hljs-string">an</span> <span class="hljs-string">alternate</span> <span class="hljs-string">environment</span> <span class="hljs-string">file</span><br>  <span class="hljs-string">-f,</span> <span class="hljs-string">--file</span> <span class="hljs-string">stringArray</span>           <span class="hljs-string">Compose</span> <span class="hljs-string">configuration</span> <span class="hljs-string">files</span><br>      <span class="hljs-string">--parallel</span> <span class="hljs-string">int</span>               <span class="hljs-string">Control</span> <span class="hljs-string">max</span> <span class="hljs-string">parallelism,</span> <span class="hljs-number">-1</span> <span class="hljs-string">for</span> <span class="hljs-string">unlimited</span> <span class="hljs-string">(default</span> <span class="hljs-number">-1</span><span class="hljs-string">)</span><br>      <span class="hljs-string">--profile</span> <span class="hljs-string">stringArray</span>        <span class="hljs-string">Specify</span> <span class="hljs-string">a</span> <span class="hljs-string">profile</span> <span class="hljs-string">to</span> <span class="hljs-string">enable</span><br>      <span class="hljs-string">--progress</span> <span class="hljs-string">string</span>            <span class="hljs-string">Set</span> <span class="hljs-string">type</span> <span class="hljs-string">of</span> <span class="hljs-string">progress</span> <span class="hljs-string">output</span> <span class="hljs-string">(auto,</span> <span class="hljs-string">tty,</span> <span class="hljs-string">plain,</span> <span class="hljs-string">quiet)</span> <span class="hljs-string">(default</span> <span class="hljs-string">&quot;auto&quot;</span><span class="hljs-string">)</span><br>      <span class="hljs-string">--project-directory</span> <span class="hljs-string">string</span>   <span class="hljs-string">Specify</span> <span class="hljs-string">an</span> <span class="hljs-string">alternate</span> <span class="hljs-string">working</span> <span class="hljs-string">directory</span><br>                                   <span class="hljs-string">(default:</span> <span class="hljs-string">the</span> <span class="hljs-string">path</span> <span class="hljs-string">of</span> <span class="hljs-string">the,</span> <span class="hljs-string">first</span> <span class="hljs-string">specified,</span> <span class="hljs-string">Compose</span> <span class="hljs-string">file)</span><br>  <span class="hljs-string">-p,</span> <span class="hljs-string">--project-name</span> <span class="hljs-string">string</span>        <span class="hljs-string">Project</span> <span class="hljs-string">name</span><br><br><span class="hljs-attr">Commands:</span><br>  <span class="hljs-string">attach</span>      <span class="hljs-string">Attach</span> <span class="hljs-string">local</span> <span class="hljs-string">standard</span> <span class="hljs-string">input,</span> <span class="hljs-string">output,</span> <span class="hljs-string">and</span> <span class="hljs-string">error</span> <span class="hljs-string">streams</span> <span class="hljs-string">to</span> <span class="hljs-string">a</span> <span class="hljs-string">service&#x27;s</span> <span class="hljs-string">running</span> <span class="hljs-string">container</span><br>  <span class="hljs-string">build</span>       <span class="hljs-string">Build</span> <span class="hljs-string">or</span> <span class="hljs-string">rebuild</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">config</span>      <span class="hljs-string">Parse,</span> <span class="hljs-string">resolve</span> <span class="hljs-string">and</span> <span class="hljs-string">render</span> <span class="hljs-string">compose</span> <span class="hljs-string">file</span> <span class="hljs-string">in</span> <span class="hljs-string">canonical</span> <span class="hljs-string">format</span><br>  <span class="hljs-string">cp</span>          <span class="hljs-string">Copy</span> <span class="hljs-string">files/folders</span> <span class="hljs-string">between</span> <span class="hljs-string">a</span> <span class="hljs-string">service</span> <span class="hljs-string">container</span> <span class="hljs-string">and</span> <span class="hljs-string">the</span> <span class="hljs-string">local</span> <span class="hljs-string">filesystem</span><br>  <span class="hljs-string">create</span>      <span class="hljs-string">Creates</span> <span class="hljs-string">containers</span> <span class="hljs-string">for</span> <span class="hljs-string">a</span> <span class="hljs-string">service</span><br>  <span class="hljs-string">down</span>        <span class="hljs-string">Stop</span> <span class="hljs-string">and</span> <span class="hljs-string">remove</span> <span class="hljs-string">containers,</span> <span class="hljs-string">networks</span><br>  <span class="hljs-string">events</span>      <span class="hljs-string">Receive</span> <span class="hljs-string">real</span> <span class="hljs-string">time</span> <span class="hljs-string">events</span> <span class="hljs-string">from</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">exec</span>        <span class="hljs-string">Execute</span> <span class="hljs-string">a</span> <span class="hljs-string">command</span> <span class="hljs-string">in</span> <span class="hljs-string">a</span> <span class="hljs-string">running</span> <span class="hljs-string">container</span><br>  <span class="hljs-string">images</span>      <span class="hljs-string">List</span> <span class="hljs-string">images</span> <span class="hljs-string">used</span> <span class="hljs-string">by</span> <span class="hljs-string">the</span> <span class="hljs-string">created</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">kill</span>        <span class="hljs-string">Force</span> <span class="hljs-string">stop</span> <span class="hljs-string">service</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">logs</span>        <span class="hljs-string">View</span> <span class="hljs-string">output</span> <span class="hljs-string">from</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">ls</span>          <span class="hljs-string">List</span> <span class="hljs-string">running</span> <span class="hljs-string">compose</span> <span class="hljs-string">projects</span><br>  <span class="hljs-string">pause</span>       <span class="hljs-string">Pause</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">port</span>        <span class="hljs-string">Print</span> <span class="hljs-string">the</span> <span class="hljs-string">public</span> <span class="hljs-string">port</span> <span class="hljs-string">for</span> <span class="hljs-string">a</span> <span class="hljs-string">port</span> <span class="hljs-string">binding</span><br>  <span class="hljs-string">ps</span>          <span class="hljs-string">List</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">pull</span>        <span class="hljs-string">Pull</span> <span class="hljs-string">service</span> <span class="hljs-string">images</span><br>  <span class="hljs-string">push</span>        <span class="hljs-string">Push</span> <span class="hljs-string">service</span> <span class="hljs-string">images</span><br>  <span class="hljs-string">restart</span>     <span class="hljs-string">Restart</span> <span class="hljs-string">service</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">rm</span>          <span class="hljs-string">Removes</span> <span class="hljs-string">stopped</span> <span class="hljs-string">service</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">run</span>         <span class="hljs-string">Run</span> <span class="hljs-string">a</span> <span class="hljs-string">one-off</span> <span class="hljs-string">command</span> <span class="hljs-string">on</span> <span class="hljs-string">a</span> <span class="hljs-string">service</span><br>  <span class="hljs-string">scale</span>       <span class="hljs-string">Scale</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">start</span>       <span class="hljs-string">Start</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">stats</span>       <span class="hljs-string">Display</span> <span class="hljs-string">a</span> <span class="hljs-string">live</span> <span class="hljs-string">stream</span> <span class="hljs-string">of</span> <span class="hljs-string">container(s)</span> <span class="hljs-string">resource</span> <span class="hljs-string">usage</span> <span class="hljs-string">statistics</span><br>  <span class="hljs-string">stop</span>        <span class="hljs-string">Stop</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">top</span>         <span class="hljs-string">Display</span> <span class="hljs-string">the</span> <span class="hljs-string">running</span> <span class="hljs-string">processes</span><br>  <span class="hljs-string">unpause</span>     <span class="hljs-string">Unpause</span> <span class="hljs-string">services</span><br>  <span class="hljs-string">up</span>          <span class="hljs-string">Create</span> <span class="hljs-string">and</span> <span class="hljs-string">start</span> <span class="hljs-string">containers</span><br>  <span class="hljs-string">version</span>     <span class="hljs-string">Show</span> <span class="hljs-string">the</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Compose</span> <span class="hljs-string">version</span> <span class="hljs-string">information</span><br>  <span class="hljs-string">wait</span>        <span class="hljs-string">Block</span> <span class="hljs-string">until</span> <span class="hljs-string">the</span> <span class="hljs-string">first</span> <span class="hljs-string">service</span> <span class="hljs-string">container</span> <span class="hljs-string">stops</span><br>  <span class="hljs-string">watch</span>       <span class="hljs-string">Watch</span> <span class="hljs-string">build</span> <span class="hljs-string">context</span> <span class="hljs-string">for</span> <span class="hljs-string">service</span> <span class="hljs-string">and</span> <span class="hljs-string">rebuild/refresh</span> <span class="hljs-string">containers</span> <span class="hljs-string">when</span> <span class="hljs-string">files</span> <span class="hljs-string">are</span> <span class="hljs-string">updated</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自定义 Starter</title>
    <link href="/post/d9e19035cbb9/"/>
    <url>/post/d9e19035cbb9/</url>
    
    <content type="html"><![CDATA[<p>适用于将独立模块,封装成spring-boot-stater 自动配置的模块</p><h3 id="1-创建-Maven-项目"><a href="#1-创建-Maven-项目" class="headerlink" title="1. 创建 Maven 项目"></a>1. 创建 Maven 项目</h3><p>创建一个普通的 Maven 项目 <code>custom-example-starter</code>。</p><h3 id="2-导入-Spring-Boot-相关依赖"><a href="#2-导入-Spring-Boot-相关依赖" class="headerlink" title="2. 导入 Spring Boot 相关依赖"></a>2. 导入 Spring Boot 相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-声明需要配置的属性和配置名前缀"><a href="#3-声明需要配置的属性和配置名前缀" class="headerlink" title="3. 声明需要配置的属性和配置名前缀"></a>3. 声明需要配置的属性和配置名前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * admin 属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;custom.user.admin&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;admin&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;password&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-创建自定义配置类，并配置-Bean"><a href="#4-创建自定义配置类，并配置-Bean" class="headerlink" title="4. 创建自定义配置类，并配置 Bean"></a>4. 创建自定义配置类，并配置 Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(AdminProperties.class)</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.utils&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAutoConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    User <span class="hljs-title function_">admin</span><span class="hljs-params">(AdminProperties adminProperties)</span> &#123;<br>        System.err.println(<span class="hljs-string">&quot;adminProperties: &quot;</span> + adminProperties);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(adminProperties.getId());<br>        user.setUsername(adminProperties.getUsername());<br>        user.setPassword(adminProperties.getPassword());<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-导入指定的配置类"><a href="#5-导入指定的配置类" class="headerlink" title="5. 导入指定的配置类"></a>5. 导入指定的配置类</h3><p>创建文件：<code>resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>，并添加以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.utils</span>.UserAutoConfiguration<br></code></pre></td></tr></table></figure><p>SpringBoot 2.7前后配置有所差异</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">示例 <br>原spring.factories文件<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.iot</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.SaTokenConfigure</span>,\<br>com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.iot</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.SecurityProperties</span><br><br>在resource/META-INF目录下新建spring目录，并添加org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.AutoConfiguration</span>.imports文件<br>com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.iot</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.SaTokenConfigure</span><br>com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.iot</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.config</span>.SecurityProperties<br></code></pre></td></tr></table></figure><h3 id="6-在其他-Spring-Boot-项目中引用此模块直接使用-Bean"><a href="#6-在其他-Spring-Boot-项目中引用此模块直接使用-Bean" class="headerlink" title="6. 在其他 Spring Boot 项目中引用此模块直接使用 Bean"></a>6. 在其他 Spring Boot 项目中引用此模块直接使用 Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Main.class, args);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> context.getBean(User.class);<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-在-YAML-文件中修改默认值"><a href="#7-在-YAML-文件中修改默认值" class="headerlink" title="7. 在 YAML 文件中修改默认值"></a>7. 在 YAML 文件中修改默认值</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">custom:</span><br><span class="hljs-attr">user:</span><br><span class="hljs-attr">admin:</span><br><span class="hljs-attr">id:</span> <span class="hljs-number">22</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">inyxin</span><br></code></pre></td></tr></table></figure><p>通过以上步骤，你就创建了一个自定义的 Spring Boot Starter，并能在其他项目中直接使用对应的 Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电力巡检实训项目</title>
    <link href="/post/d595de9ca8b1/"/>
    <url>/post/d595de9ca8b1/</url>
    
    <content type="html"><![CDATA[<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><p>超级管理员</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">维护整个系统的正常运行,不参与任何用户的业务<br></code></pre></td></tr></table></figure></li><li><p>线路管理员</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对于线路进行管理, 巡检任务的指定, 分配, 审核以及消缺任务的指定, 分配和审核<br></code></pre></td></tr></table></figure></li><li><p>巡检员 </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">执行巡检任务并返回回执信息 <span class="hljs-comment">(巡检回执)</span><br></code></pre></td></tr></table></figure></li><li><p>消缺员</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">执行消缺任务 , 消除线路中的缺陷, 并反馈回执信息 <span class="hljs-comment">(消缺回执)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">电力巡检系统应该设计一个RBAC权限模型, 来控制角色的操作<br><span class="hljs-deletion">-用户表(user)</span><br><span class="hljs-deletion">-用户角色表(user_role)</span><br><span class="hljs-deletion">-角色表(role)</span><br><span class="hljs-deletion">-角色资源表(role_resource)  </span><br><span class="hljs-deletion">-资源表(reource)</span><br></code></pre></td></tr></table></figure><p>可以基于 <code>Spring MVC</code> 中的 <code>拦截器</code> 或者使用 <code>AOP</code> 实现简单的权限控制效果</p>]]></content>
    
    
    <categories>
      
      <category>default</category>
      
    </categories>
    
    
    <tags>
      
      <tag>default</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>friends</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">这里写关于页的正文，支持 Markdown, <span class="hljs-selector-tag">HTML</span><br></code></pre></td></tr></table></figure>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[!(function() {  /** 计时起始时间，自行修改 **/  var start = new Date("2024/07/04 00:00:00");  function update() {    var now = new Date();    now.setTime(now.getTime()+250);    days = (now - start) / 1000 / 60 / 60 / 24;    dnum = Math.floor(days);    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);    hnum = Math.floor(hours);    if(String(hnum).length === 1 ){      hnum = "0" + hnum;    }    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);    mnum = Math.floor(minutes);    if(String(mnum).length === 1 ){      mnum = "0" + mnum;    }    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);    snum = Math.round(seconds);    if(String(snum).length === 1 ){      snum = "0" + snum;    }    document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";    document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";  }  update();  setInterval(update, 1000);})();]]></content>
    
  </entry>
  
  
  
</search>
